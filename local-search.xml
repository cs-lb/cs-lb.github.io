<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>保研专业课面试题库</title>
    <link href="/2024/06/05/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E4%BF%9D%E7%A0%94%E4%B8%93%E4%B8%9A%E8%AF%BE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    <url>/2024/06/05/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E4%BF%9D%E7%A0%94%E4%B8%93%E4%B8%9A%E8%AF%BE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="保研专业课面试题库"><a href="#保研专业课面试题库" class="headerlink" title="保研专业课面试题库"></a>保研专业课面试题库</h1><p><a href="https://www.cnblogs.com/moonout/p/17286478.html">cs 保研经验贴 | 综合面试题库</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>概率论与数理统计</title>
    <link href="/2024/06/04/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    <url>/2024/06/04/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><h3 id="概率计算公式"><a href="#概率计算公式" class="headerlink" title="概率计算公式"></a>概率计算公式</h3><p><strong>1. 加法公式</strong></p><p>加法公式用于计算两个事件<strong>至少有一个发生的概率</strong> ，即事件A或事件B发生的概率。</p><p>如果事件A和事件B不是互斥的，那么需要减去它们同时发生的概率，以避免重复计算：<br>[ P(A \cup B) &#x3D; P(A) + P(B) - P(A \cap B) ]</p><p>如果事件A和事件B是<strong>互斥的（即它们不能同时发生）</strong>，那么加法公式可以表示为：<br>[ P(A \cup B) &#x3D; P(A) + P(B) ]</p><p>其中：</p><ul><li>( P(A \cup B) ) 是事件A或事件B发生的概率。</li><li>( P(A) ) 是事件A发生的概率。</li><li>( P(B) ) 是事件B发生的概率。</li><li>( P(A \cap B) ) 是事件A和事件B同时发生的概率。</li></ul><p><strong>2. 乘法公式</strong></p><p>乘法公式用于计算两个事件<strong>同时发生的概率</strong>，即事件A和事件B的联合概率。</p><p>如果事件A和事件B不是独立的，那么需要使用条件概率来计算它们的联合概率：<br>[ P(A \cap B) &#x3D; P(A) \times P(B | A) ]<br>或者<br>[ P(A \cap B) &#x3D; P(B) \times P(A | B) ]</p><p>如果事件<strong>A和B是独立的</strong>，那么它们的联合概率可以通过它们各自的概率相乘得到：<br>[ P(A \cap B) &#x3D; P(A) \times P(B) ]</p><p>其中：</p><ul><li>( P(A \cap B) ) 是事件A和事件B同时发生的概率。</li><li>( P(B | A) ) 是在事件A发生的条件下事件B发生的概率，即条件概率。</li><li>( P(A | B) ) 是在事件B发生的条件下事件A发生的概率。</li></ul><p><strong>3. 全概率公式（原因推结果）</strong></p><p>全概率公式用于计算一个事件的结果，当这个事件是由多个互斥原因引起的。如果事件A是由多个互斥的子事件B1, B2, …, Bn引起的，那么事件A发生的概率可以通过以下公式计算：<br>[ P(A) &#x3D; P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + \ldots + P(A|B_n)P(B_n) ]<br>其中：</p><ul><li>( P(A) ) 是事件A发生的概率。</li><li>( P(B_i) ) 是第i个原因发生的概率。</li><li>( P(A|B_i) ) 是在第i个原因发生的条件下，事件A发生的概率。</li></ul><p>全概率公式允许我们通过已知的各个原因的概率和它们导致结果的条件概率，来计算结果发生的概率</p><p><strong>4. 贝叶斯公式（结果推原因）</strong></p><p>贝叶斯公式是一种逆概率计算方法，它允许我们根据已知的结果来推断原因的概率。贝叶斯公式可以表示为：<br>[ P(B_i|A) &#x3D; \frac{P(A|B_i)P(B_i)}{P(A)} ]<br>其中：</p><ul><li>( P(B_i|A) ) 是在事件A发生的条件下，原因Bi发生的概率。</li><li>( P(A|B_i) ) 是在原因Bi发生的条件下，事件A发生的概率。</li><li>( P(B_i) ) 是原因Bi发生的概率。</li><li>( P(A) ) 是事件A发生的概率。</li></ul><p>贝叶斯公式的核心思想是，通过已知的事件A发生的条件概率和原因的概率，以及事件A发生的概率，来计算在事件A发生的情况下，各个原因发生的概率。</p><p>这两个公式在处理不确定性和进行决策时非常有用，特别是在我们只有部分信息的情况下。例如，在医学诊断、风险评估、机器学习中的分类问题等领域，全概率公式和贝叶斯公式都发挥着重要作用。</p><h3 id="事件独立性"><a href="#事件独立性" class="headerlink" title="事件独立性"></a>事件独立性</h3><h2 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h2><h3 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h3><p><img src="/../../img/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83.png"></p><p><strong>1. 伯努利分布（0-1分布）</strong></p><p>描述了只有两种可能结果（成功和失败，通常用1和0表示）的单次随机试验。</p><p><strong>2. 二项分布（n重 伯努利分布）</strong></p><p>描述了固定次数 𝑛的独立重复的伯努利试验中成功的次数。</p><p><strong>3. 几何分布</strong></p><p>描述了在一系列独立的伯努利试验中，得到第一次成功所需的试验次数。<br>意义：n 次伯努利试验中前 k-1 次皆失败，第 k 次成功的概率。</p><p><strong>4. 泊松分布（0-1分布）</strong></p><p>二项分布的极限。期望和方差均为λ。</p><p>参数 λ 是单位时间(或单位面积)内随机事件的平均发生次数，满足线性相加（2 倍单位时间内…服从 2λ分布）。</p><p>泊松分布适合于描述单位时间内随机事件发生的次数</p><h3 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h3><p>概率论与数理统计中的均匀分布、指数分布和正态分布是三种非常重要的连续概率分布，它们在不同的领域和情境下有着广泛的应用。</p><p><strong>均匀分布（Uniform Distribution）</strong><br>均匀分布是一种最简单的连续概率分布，其中随机变量在某个区间内取任何值的概率是相同的。如果随机变量 ( X ) 在区间 ( [a, b] ) 上服从均匀分布，其概率密度函数（PDF）为：<br>[ f(x) &#x3D; \begin{cases}<br>\frac{1}{b - a} &amp; \text{for } a \leq x \leq b, \<br>0 &amp; \text{otherwise.}<br>\end{cases} ]</p><p>均匀分布的特点：</p><ul><li>概率密度在区间 ( [a, b] ) 上是恒定的。</li><li>区间外的概率密度为0。</li><li>随机变量的期望值 ( E(X) ) 为 ( \frac{a + b}{2} )。</li><li>方差 ( \text{Var}(X) ) 为 ( \frac{(b - a)^2}{12} )。</li></ul><p><strong>指数分布（Exponential Distribution）</strong><br>指数分布是一种单参数的连续概率分布，常用于描述独立随机事件发生的时间间隔。如果随机变量 ( X ) 服从参数为 ( \lambda ) 的指数分布，其概率密度函数为：<br>[ f(x) &#x3D; \lambda e^{-\lambda x} \quad \text{for } x \geq 0 ]<br>其中 ( \lambda &gt; 0 )。</p><p>指数分布的特点：</p><ul><li>它没有记忆性，即指数分布的随机变量的持续时间不依赖于已经经过的时间。</li><li>期望值 ( E(X) ) 为 ( \frac{1}{\lambda} )。</li><li>方差 ( \text{Var}(X) ) 为 ( \frac{1}{\lambda^2} )。</li></ul><p><strong>正态分布（Normal Distribution）</strong><br>正态分布，也称为高斯分布，是连续概率分布中最重要的一种。它在自然科学和社会科学的许多领域中都有应用。如果随机变量 ( X ) 服从均值为 ( \mu )，方差为 ( \sigma^2 ) 的正态分布，其概率密度函数为：<br>[ f(x) &#x3D; \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{(x - \mu)^2}{2\sigma^2}} ]</p><p>正态分布的特点：</p><ul><li>它是对称的，并且以均值 ( \mu ) 为中心。</li><li>大部分数据集中在均值附近，数据的分布呈现钟形曲线。</li><li>期望值 ( E(X) )、中位数和众数都等于 ( \mu )。</li><li>方差 ( \text{Var}(X) ) 为 ( \sigma^2 )。</li><li>68-95-99.7 规则（经验法则）表明，在正态分布中，约68%的数据落在 ( \mu \pm \sigma ) 区间内，约95%落在 ( \mu \pm 2\sigma ) 区间内，约99.7%落在 ( \mu \pm 3\sigma ) 区间内。</li></ul><p>这三种分布各自有其独特的性质和应用场景。均匀分布常用于描述在一定范围内等可能发生的事件；指数分布适用于描述泊松过程中事件之间的时间间隔；正态分布则因其优美的数学性质和中心极限定理，在统计推断和数据分析中扮演着核心角色。</p><h2 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h2><p>大数定律是概率论和数理统计中的一个基本概念，它描述了在一定条件下，<strong>随着样本量的增加，样本均值会越来越接近总体均值的性质。</strong> 大数定律保证了在大量重复实验中，随机变量的相对频率趋近于其概率。</p><h3 id="大数定律的两种形式"><a href="#大数定律的两种形式" class="headerlink" title="大数定律的两种形式"></a>大数定律的两种形式</h3><ol><li><p><strong>切比雪夫大数定律（Chebyshev’s Law of Large Numbers）</strong><br>切比雪夫大数定律是大数定律的一个较弱的形式，它适用于具有相同期望值和有限方差的随机变量序列。它指出，对于一列独立同分布（i.i.d.）的随机变量 ( X_1, X_2, \ldots )，如果它们的期望值 ( \mu ) 和方差 ( \sigma^2 ) 都存在，则样本均值 ( \overline{X}<em>n &#x3D; \frac{1}{n} \sum</em>{i&#x3D;1}^n X_i ) 会随着 ( n ) 的增加而趋近于 ( \mu )。具体来说，对于任意正数 ( \varepsilon &gt; 0 )，有：<br>[ P\left(|\overline{X}_n - \mu| \geq \varepsilon\right) \leq \frac{\sigma^2}{n \varepsilon^2} ]</p></li><li><p><strong>中心极限定理（Central Limit Theorem, CLT）</strong><br>中心极限定理是大数定律的一个更强的形式，它说明了在适当的条件下，大量独立同分布的随机变量之和经过标准化后趋近于正态分布。无论原始随机变量本身服从何种分布，只要它们具有相同的期望值 ( \mu ) 和方差 ( \sigma^2 )，它们的样本均值的分布会随着样本量的增加而趋近于正态分布 ( N(\mu, \frac{\sigma^2}{n}) )。具体来说，对于任意 ( z ) 值，当 ( n ) 足够大时，有：<br>[ P\left(\frac{\overline{X}_n - \mu}{\sigma&#x2F;\sqrt{n}} \leq z\right) \approx \Phi(z) ]<br>其中，( \Phi(z) ) 是标准正态分布的累积分布函数。</p></li></ol><h3 id="大数定律的应用"><a href="#大数定律的应用" class="headerlink" title="大数定律的应用"></a>大数定律的应用</h3><p>大数定律在统计学、经济学、保险学、质量管理等领域有着广泛的应用。它为统计推断提供了理论基础，尤其是在估计总体参数时。例如：</p><ul><li>在抽样调查中，通过大数定律，我们可以相信，随着样本量的增加，样本均值会越来越接近总体均值。</li><li>在保险业中，大数定律用于解释为什么保险公司可以通过承保大量保单来分散风险，从而稳定赔付成本。</li><li>在质量管理中，大数定律帮助我们理解为什么生产大量产品时，产品的缺陷率会趋于稳定。</li></ul><p>大数定律不保证每个样本均值都接近总体均值，但它确实保证了随着样本量的增加，样本均值的分布会越来越集中于总体均值周围。这是统计学中非常重要的一个概念，它帮助我们理解和预测大量数据的行为。</p><h2 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h2><h3 id="贝叶斯公式是什么，有什么应用"><a href="#贝叶斯公式是什么，有什么应用" class="headerlink" title="贝叶斯公式是什么，有什么应用"></a>贝叶斯公式是什么，有什么应用</h3><p>贝叶斯公式描述了两个<strong>条件概率之间的关系</strong><br>即在已知某个事件B发生的条件下，事件A发生的概率 与 在已知事件A发生的条件下，事件B发生的概率之间的关系。（原因推结果）</p><ol><li>机器学习：在机器学习中，贝叶斯方法被用于分类、聚类和预测。贝叶斯分类器利用<strong>先验概率</strong>和<strong>似然度</strong>来计算新实例的后验概率。</li></ol><p>贝叶斯分类器是一种统计分类方法，它使用贝叶斯定理来结合先验知识（先验概率）和新观测到的数据（似然度），从而计算出新实例的后验概率，并据此做出分类决策。以下是贝叶斯分类器如何工作的详细解释：</p><p><strong>先验概率（Prior Probability）</strong><br>先验概率是指在没有考虑新证据之前，我们对某个事件发生的概率评估。在分类问题中，先验概率通常是指各类别在数据集中出现的频率。例如，如果我们正在处理垃圾邮件分类问题，先验概率可能是垃圾邮件和非垃圾邮件在训练数据集中的比例。</p><p><strong>似然度（Likelihood）</strong><br>似然度是指在某个假设下，观测数据出现的概率。在贝叶斯分类器中，似然度是指给定类别条件下，实例特征出现的概率。例如，对于一封邮件，似然度可以是邮件中包含特定单词的概率，假设这些单词只在垃圾邮件中出现。</p><p><strong>后验概率（Posterior Probability）</strong><br>后验概率是在考虑了新证据之后，对事件发生概率的重新评估。在贝叶斯分类器中，后验概率是给定实例特征条件下，该实例属于某个类别的概率。贝叶斯定理提供了一种计算后验概率的方法：</p><p>[ P(C_k|X) &#x3D; \frac{P(X|C_k) \cdot P(C_k)}{P(X)} ]</p><p>其中：</p><ul><li>( P(C_k|X) ) 是后验概率，即给定特征集 ( X ) 的条件下，实例属于类别 ( C_k ) 的概率。</li><li>( P(X|C_k) ) 是似然度，即在类别 ( C_k ) 发生的条件下，观测到特征集 ( X ) 的概率。</li><li>( P(C_k) ) 是先验概率，即类别 ( C_k ) 的初始概率。</li><li>( P(X) ) 是边缘概率，即不考虑类别标签，观测到特征集 ( X ) 的概率，它可以通过对所有类别的似然度和先验概率乘积求和得到。</li></ul><p><strong>分类决策</strong><br>贝叶斯分类器根据后验概率来做出分类决策。具体来说，对于一个新的实例，分类器会计算该实例属于每个可能类别的后验概率，然后选择具有最高后验概率的类别作为预测结果。</p><p>贝叶斯分类器的优势在于其简单性和解释性，它可以很容易地结合领域知识（通过先验概率）和数据（通过似然度）。此外，贝叶斯分类器在处理大量特征时特别有效，尤其是在特征之间存在不确定性时。</p><ol start="2"><li><p>决策理论：贝叶斯决策理论通过考虑不确定性和风险来帮助做出最优决策。</p></li><li><p>信号处理：在信号检测和滤波中，贝叶斯方法可以用来估计信号的存在概率。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2024/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2024/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">//哈希表统计数据</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; a; <span class="hljs-comment">//vector的sort来排序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            st[nums[i]] ++;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> it = st.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it != st.<span class="hljs-built_in">end</span>()) &#123;<br>            a.<span class="hljs-built_in">push_back</span>(&#123;it-&gt;second,it-&gt;first&#125;);<br>            it ++;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            res.<span class="hljs-built_in">push_back</span>(a[i].second);<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mamba Out</title>
    <link href="/2024/06/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Mamba-Out/"/>
    <url>/2024/06/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Mamba-Out/</url>
    
    <content type="html"><![CDATA[<h1 id="Mamba"><a href="#Mamba" class="headerlink" title="Mamba"></a>Mamba</h1><p><a href="https://blog.csdn.net/v_JULY_v/article/details/134923301">一文通透想颠覆Transformer的Mamba：从SSM、HiPPO、S4到Mamba</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正则化</title>
    <link href="/2024/06/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <url>/2024/06/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><h2 id="L1和L2正则化"><a href="#L1和L2正则化" class="headerlink" title="L1和L2正则化"></a>L1和L2正则化</h2><p>L1和L2正则化是机器学习和深度学习中常用的两种技术，它们用于控制模型的复杂度，防止过拟合，并提高模型的泛化能力。这两种正则化方法通过在损失函数中添加一个额外的惩罚项来实现，该惩罚项与模型参数的大小相关。下面是L1和L2正则化的详细解释：</p><h3 id="L2正则化（岭回归，Tikhonov正则化）"><a href="#L2正则化（岭回归，Tikhonov正则化）" class="headerlink" title="L2正则化（岭回归，Tikhonov正则化）"></a>L2正则化（岭回归，Tikhonov正则化）</h3><p>L2正则化，也称为欧几里得范数正则化，通过惩罚参数的平方和来工作。它的目标是使参数值尽可能小，从而限制模型的复杂度。</p><p><strong>数学表达式</strong>：<br>[ L_{2} &#x3D; \lambda \sum_{i&#x3D;1}^{n} w_i^2 ]</p><p>其中，( w_i ) 是模型参数，( \lambda ) 是正则化系数（一个超参数），控制着正则化项的强度，( n ) 是参数的总数。</p><p><strong>特点</strong>：</p><ul><li>L2正则化倾向于让参数值接近于0，但不会变成0。</li><li>它倾向于产生平滑的权重分布。</li><li>L2正则化可以被看作是高斯先验的贝叶斯推断。</li></ul><h3 id="L1正则化（Lasso回归）"><a href="#L1正则化（Lasso回归）" class="headerlink" title="L1正则化（Lasso回归）"></a>L1正则化（Lasso回归）</h3><p>L1正则化，也称为拉普拉斯范数正则化，通过惩罚参数的绝对值之和来工作。与L2正则化不同，L1正则化可以产生稀疏权重矩阵，即模型参数中的一部分会变为0。</p><p><strong>数学表达式</strong>：<br>[ L_{1} &#x3D; \lambda \sum_{i&#x3D;1}^{n} |w_i| ]</p><p>其中，( w_i ) 是模型参数，( \lambda ) 是正则化系数，( n ) 是参数的总数。</p><p><strong>特点</strong>：</p><ul><li>L1正则化倾向于产生稀疏解，即模型参数中的一些元素可以被驱动为0。</li><li>这使得L1正则化具有特征选择的能力，因为它可以自动地将不重要的特征的权重设置为0。</li><li>L1正则化可以被看作是拉普拉斯先验的贝叶斯推断。</li></ul><h3 id="正则化的选择"><a href="#正则化的选择" class="headerlink" title="正则化的选择"></a>正则化的选择</h3><ul><li><strong>L2正则化</strong>通常用于大多数深度学习模型，因为它有助于稳定训练过程，并且可以防止参数值变得过大。</li><li><strong>L1正则化</strong>适用于需要特征选择的情况，或者当模型需要稀疏性时。</li><li>在某些情况下，结合L1和L2正则化（即弹性网正则化）可以提供两者的优点。</li></ul><p>正则化是深度学习中控制模型复杂度的重要工具，通过合理选择正则化类型和调整正则化系数，可以显著提高模型的泛化能力和性能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hugging Face Transformer</title>
    <link href="/2024/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Hugging-Face-Transformer/"/>
    <url>/2024/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Hugging-Face-Transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Hugging-Face-Transformer"><a href="#Hugging-Face-Transformer" class="headerlink" title="Hugging Face Transformer"></a>Hugging Face Transformer</h1><p><a href="https://blog.csdn.net/FrenzyTechAI/article/details/131958687">Hugging Face Transformer：从原理到实战的全面指南</a></p><p><a href="https://blog.csdn.net/m0_68382801/article/details/127624858">使用网上服务器（AutoDL）训练模型</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 周赛</title>
    <link href="/2024/05/26/leetcode-%E5%91%A8%E8%B5%9B/"/>
    <url>/2024/05/26/leetcode-%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-周赛"><a href="#leetcode-周赛" class="headerlink" title="leetcode 周赛"></a>leetcode 周赛</h1><h2 id="100313-所有球里面不同颜色的数目"><a href="#100313-所有球里面不同颜色的数目" class="headerlink" title="100313. 所有球里面不同颜色的数目"></a>100313. 所有球里面不同颜色的数目</h2><p><a href="https://leetcode.cn/problems/find-the-number-of-distinct-colors-among-the-balls/description/">所有球里面不同颜色的数目</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; balls; <span class="hljs-comment">//球的序号，颜色值</span><br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; colors; <span class="hljs-comment">//颜色值，该颜色值个数</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">queryResults</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; q = queries;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//该气球已经有颜色了</span><br>            <span class="hljs-keyword">if</span>(balls[ q[i][<span class="hljs-number">0</span>] ])&#123;<br>                <span class="hljs-comment">//先将原先存在的气球和颜色从两个数组中去除</span><br>                colors[ balls[q[i][<span class="hljs-number">0</span>]] ] --;<br>                <span class="hljs-keyword">if</span>( colors[ balls[q[i][<span class="hljs-number">0</span>]] ] == <span class="hljs-number">0</span>) res --;<br>            &#125;<br>            <br>            <span class="hljs-comment">//加入新的颜色</span><br>            balls[ q[i][<span class="hljs-number">0</span>] ] = q[i][<span class="hljs-number">1</span>];<br>            colors[ q[i][<span class="hljs-number">1</span>] ] ++;<br>            <span class="hljs-keyword">if</span>(colors[ q[i][<span class="hljs-number">1</span>] ] == <span class="hljs-number">1</span>) res ++;<br><br>            ans.<span class="hljs-built_in">push_back</span>(res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="100321-优质数对的总数-II"><a href="#100321-优质数对的总数-II" class="headerlink" title="100321.优质数对的总数 II"></a>100321.优质数对的总数 II</h2><p><a href="https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description/">优质数对的总数 II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp; <span class="hljs-comment">//nums1数组中某个数的约数 ； 该约数的总个数</span><br><br>    <span class="hljs-comment">//求nums1[i]的约数和对应个数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=v/i;i++)&#123;<br>            <span class="hljs-keyword">if</span>(v % i == <span class="hljs-number">0</span>)&#123;<br>                mp[i] ++;<br>                <span class="hljs-comment">//重复的约数只记作一个（如4的约数为一个2）</span><br>                <span class="hljs-comment">//这个if一定要在上一个if里面</span><br>                <span class="hljs-keyword">if</span>(i != (v/i))&#123;<br>                    mp[v/i] ++;<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">numberOfPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>(); <span class="hljs-type">int</span> m = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-built_in">cnt</span>(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            nums2[i] *= k;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            res += mp[ nums2[i] ];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="100306-不包含相邻元素的子序列的最大和"><a href="#100306-不包含相邻元素的子序列的最大和" class="headerlink" title="100306. 不包含相邻元素的子序列的最大和"></a>100306. 不包含相邻元素的子序列的最大和</h2><p><a href="https://leetcode.cn/problems/maximum-sum-of-subsequence-with-non-adjacent-elements/description/">不包含相邻元素的子序列的最大和</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Hot 100</title>
    <link href="/2024/05/25/Leetcode-Hot-100/"/>
    <url>/2024/05/25/Leetcode-Hot-100/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Hot-100"><a href="#Leetcode-Hot-100" class="headerlink" title="Leetcode Hot 100"></a>Leetcode Hot 100</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天是2024年5月25日 凌晨 1:24 分 在寝室洗衣房写下这段话。距离9.28还有4个月。也不知道那个时候的我有没有offer了（shushu不会还是0 offer吧，做梦都想去tp，有点难，那就梦梦浙大吧，耳机里突然响起来《落空》这首歌——“我们都曾试过想以后，以后却不会来了”。。。。。。希望我的梦想不会落空。加油！！！开刷leetcode hot 100 为了我梦想，为了不留遗憾，再冲一次吧。）</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p><img src="/../img/1.png"></p><ol><li><p>算法一（哈希表）<br>核心思想：for循环，使用map依次存储数组下标和对应的数；使用map.count(target - num[i]) 查询目前map中是否已经存储了所需要的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(target - nums[i]) &gt; <span class="hljs-number">0</span>)&#123;<br>                res[<span class="hljs-number">0</span>] = i;<br>                res[<span class="hljs-number">1</span>] = mp[target - nums[i]];<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            mp[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>算法二（快慢指针）<br>核心思想：$两个指针 i,j 不断向前移动找到答案（ j &lt; i ）$</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=nums.<span class="hljs-built_in">begin</span>();i&lt;nums.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j=nums.<span class="hljs-built_in">begin</span>();j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>((*i + *j) == target)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(j-nums.<span class="hljs-built_in">begin</span>());<br>                    res.<span class="hljs-built_in">push_back</span>(i-nums.<span class="hljs-built_in">begin</span>());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p><img src="/../img/2.png"></p><p>核心思想：高精度加法</p><p>tips:</p><ol><li>注意最后一个进位也要考虑进来</li><li>构造链表<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1.</span>初始化<br>ListNode* prehead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *cur = prehead;<br><br><span class="hljs-number">2.</span>赋值<br>cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(v);<br>cur = cur-&gt;next;<br><br><span class="hljs-number">3.</span>返回构造的链表<br><span class="hljs-keyword">return</span> prehead-&gt;next;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* prehead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *cur = prehead;<br>        ListNode *p = l1;<br>        vector&lt;<span class="hljs-type">int</span>&gt; a,b;<br>        <span class="hljs-keyword">while</span>(p)&#123;<br>            a.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>            p = p-&gt;next;<br>        &#125;<br>        p = l2;<br>        <span class="hljs-keyword">while</span>(p)&#123;<br>            b.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">size</span>(),b.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        vector &lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())&#123;<br>                v += a[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())&#123;<br>                v += b[i];<br>            &#125;<br>            v += t;<br>            <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">10</span>)&#123;<br>                v -= <span class="hljs-number">10</span>; t = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                t = <span class="hljs-number">0</span>;<br>            &#125;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(v);<br>            cur = cur-&gt;next;<br><br>        &#125;<br>        <span class="hljs-comment">//注意最后一个进位也要考虑进来</span><br>        <span class="hljs-keyword">if</span>(t &gt;= <span class="hljs-number">1</span>)&#123;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t);<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prehead-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p><img src="/../img/3.png"><br>核心思想：滑动窗口 + un ordered set<br>tips:</p><ol><li>count（检查当前窗口内是否有重复元素）</li><li>erase（去掉左指针所指向元素，i++ ——&gt; 即窗口右移）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; str; <span class="hljs-comment">//无重复字符且无序</span><br>        <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义右指针</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历左指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br><br>            <span class="hljs-comment">//不断移动右指针</span><br>            <span class="hljs-keyword">while</span>(!str.<span class="hljs-built_in">count</span>(s[r]) &amp;&amp; r&lt;len)&#123;<br>                str.<span class="hljs-built_in">insert</span>(s[r]);<br>                r++;<br>            &#125;<br>            <span class="hljs-comment">//跳出了while循环代表有重复元素出现了，此时移动左指针(从set中删除当前左指针所指向元素)</span><br>            res = <span class="hljs-built_in">max</span>(res,r-i);<br>            str.<span class="hljs-built_in">erase</span>(s[i]);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><p><img src="/../img/4.png"><br>核心思想：先合并成一个单调递增的数组；然后计算新数组的中位数，算法复杂度为O(n+m); 还可以用二分优化到log(n+m);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = nums1.<span class="hljs-built_in">size</span>(); <span class="hljs-type">int</span> len2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>,m=<span class="hljs-number">0</span>; <span class="hljs-comment">//分别指示num1,num2两个数组的指针</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br>        <span class="hljs-comment">//构建一个单调递增的ans数组</span><br>        <span class="hljs-keyword">while</span>(n &lt; len1 &amp;&amp; m &lt; len2)&#123;<br>            <span class="hljs-keyword">if</span>(nums1[n] &lt; nums2[m])&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums1[n]);<br>                n++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums2[m]);<br>                m++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(n &lt; len1)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums1[n]);<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(m &lt; len2)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums2[m]);<br>            m++;<br>        &#125;<br>        <span class="hljs-type">int</span> len = ans.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">double</span> res;<br>        <span class="hljs-keyword">if</span>(len % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            res = (ans[len/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + ans[len/<span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res = ans[len/<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>核心思想：动态规划 f[i][j] , <strong>区间dp</strong> ，以[i,j]这段长度上的回文子串<br>（1） 求最长回文子串长度<br>（2） 求具体的最长回文子串 ：不断判断某个区间是否是回文子串，如果是，则更新最大长度的左右下标值，之后通过该下标序号来截取具体的子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        <span class="hljs-comment">// 初始化二维动态规划表</span><br>        <span class="hljs-type">bool</span> f[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 填充对角线为true，因为单个字符总是回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            f[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最长回文串的起始位置和长度</span><br><br>        <span class="hljs-comment">// 填充动态规划表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; ++len) &#123; <span class="hljs-comment">// 长度从2开始</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + len - <span class="hljs-number">1</span> &lt; n; ++i) &#123; <span class="hljs-comment">// i是子串的起始位置,j是右端点小于n</span><br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>; <span class="hljs-comment">// j是子串的结束位置</span><br>                <span class="hljs-comment">// 如果首尾字符相同，并且中间部分也是回文，则整个序列是回文</span><br>                <span class="hljs-keyword">if</span> (s[i] == s[j] &amp;&amp; (len &lt; <span class="hljs-number">3</span> || f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>                    f[i][j] = <span class="hljs-literal">true</span>;<br>                    maxLen = len;<br>                    start = i;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最长的回文子串</span><br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start, maxLen);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h2><p>核心思想：动态规划</p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>核心思想：双指针（最短木板原理，因此两个指针所指向的板中较短的那个指针要向中心移动）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> r = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> maxv = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            maxv = <span class="hljs-built_in">max</span>(maxv,(r-l)*<span class="hljs-built_in">min</span>(height[l],height[r]));<br>            <span class="hljs-keyword">if</span>(height[l] &lt; height[r])&#123;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxv;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>核心思想：双指针＋set去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ret;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br> <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">int</span> x = -nums[i];<br>            <span class="hljs-type">int</span> l = i+<span class="hljs-number">1</span>; <span class="hljs-type">int</span> r = len<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-keyword">if</span>(nums[l] + nums[r] + nums[i] &lt; <span class="hljs-number">0</span>)&#123;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[l] + nums[r] + nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                    r--;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    ret.<span class="hljs-built_in">insert</span>(&#123;nums[i],nums[l],nums[r]&#125;); <br>                    l++; r--;<span class="hljs-comment">//在当前已经满足条件的情况下，只移动一个指针肯定不能够继续满足条件</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(ret.<span class="hljs-built_in">begin</span>(),ret.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>核心思想：<strong>栈的先进后出</strong>（注意栈是否为空时的一些边界情况）<br><img src="/../img/20.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map &lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; mp;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        mp.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;)&#x27;</span>&#125;);<br>        mp.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-string">&#x27;&#125;&#x27;</span>&#125;);<br>        mp.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;]&#x27;</span>&#125;);<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//剪枝提前返回</span><br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//如果读入了一个右括号而此时没有左括号在栈中，则一定不满足条件</span><br>                <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || mp[st.<span class="hljs-built_in">top</span>()] != s[i])&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//如果遍历完了整个字符串之后，还符合条件的话，栈肯定为空</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p>核心思想：二分查找<br>tips:注意空数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//找开始位置</span><br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid = (l+r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target)&#123;<br>                r = mid;<br>            &#125; <br>            <span class="hljs-keyword">else</span>&#123;<br>                l = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[l] != target) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(l);<br>        &#125;<br><br>        <span class="hljs-comment">//找结束位置</span><br>        l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid = (l+r+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt;= target)&#123;<br>                l = mid;<br>            &#125; <br>            <span class="hljs-keyword">else</span>&#123;<br>                r = mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[l] != target) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(l);<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p>核心思想：<br>（1）递归+剪枝<br>（2）动态规划（d[n] &#x3D; d[n-1] + d[n-2]）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*递归＋剪枝</span><br><span class="hljs-comment">    int st[50];</span><br><span class="hljs-comment">    int dfs(int i)&#123;</span><br><span class="hljs-comment">        if(i&lt;=1)&#123;</span><br><span class="hljs-comment">            return 1;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        if(st[i]) return st[i]; //剪枝操作，如果该数已经计算过了，就直接查找不需要再递归计算</span><br><span class="hljs-comment">        else&#123;</span><br><span class="hljs-comment">            st[i] = dfs(i-1) + dfs(i-2);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return st[i];</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//dfs(n);</span><br>        <span class="hljs-type">int</span> f[<span class="hljs-number">50</span>];<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>            f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><p>核心思想：</p><ol><li>移除数组元素：<strong>数组的元素在内存地址中是连续的，</strong> 不能单独删除数组中的某个元素，只能覆盖。</li><li>通过快慢指针来实现数组元素覆盖</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(r=<span class="hljs-number">0</span>;r&lt;n;r++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[r] != <span class="hljs-number">0</span>)&#123;<br>                nums[l] = nums[r];<br>                l++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//r最后所在位置为最后一个位置的下一位（因为r要遍历到此才会跳出for循环）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r<span class="hljs-number">-1</span>;i++)&#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二分图</title>
    <link href="/2024/05/22/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2024/05/22/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！</p><p>说人话的定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。</p><p><img src="/../../img/%E4%BA%8C%E5%88%86%E5%9B%BE.png"></p><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><blockquote><p>判断给定图 是否是二分图<br>算法步骤：</p></blockquote><ol><li>循环对每个点进行染色（dfs或者bfs）</li><li>判断其相邻的点中，若未染色则将其染上和当前顶点不同的颜色。</li><li>若已经染色 且颜色跟当前点颜色一样的则说明不是二分图，如果没有则进行下一个节点的判断</li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><blockquote><p>计算二分图的最大匹配数</p><p>二分图的匹配：给定一个二分图 G ，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。</p><p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p></blockquote><p>算法思想：<br>find(x) : 左半边点x的某条边的右半边的另一个点<br>match[j] 右半边的点j所匹配的点</p><ol><li>对左半边图的节点进行循环<ul><li>循环该节点所有的边(find(x))，如果能够在右半边找到一个没有匹配过的点（match[j] &#x3D;&#x3D; 0），则进行匹配</li><li>如果找到的点已经匹配上了别的点了(match[j] !&#x3D; 0)，则看其匹配的点是否有别的备胎（find(match[j])）</li><li>有备胎则将匹配取消，让其去找备胎。</li><li>如果能够成功匹配则返回true （总匹配边数 res++）</li><li>如果无备胎，则返回false</li></ul></li></ol><p>tips:</p><ol><li>循环中找每个点对应右半边点前都要<strong>先重置st数组为false</strong></li><li>要用st数组来标记节点是否被访问过了</li></ol><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n1,n2,m;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx;<br><span class="hljs-comment">//st 标记节点是否递归找过， match[x]：和 x 编号的男生的编号</span><br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> match[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b; ne[idx] = h[a]; h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">//i指代的是下标为idx的边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-comment">//递归的剪枝操作，如果没有的话会报MLE</span><br>        <span class="hljs-keyword">if</span>(!st[j])&#123;<br>            st[j] = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记该节点已经找过了</span><br>            <span class="hljs-keyword">if</span>(!match[j] || <span class="hljs-built_in">find</span>(match[j]))&#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i))&#123;<br>            res++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树算法</title>
    <link href="/2024/05/21/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/21/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><p>从具有n个节点的连通图中选择 n-1 条边，使得所组成的树的权值最小，即为最小生成树</p><p><img src="/../../img/mintree.png"></p><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><ol><li>循环n次，找到集合（最小生成树中的节点所组成）外距离最近集合最近的点t加入集合</li><li>用 t 更新集合外其他点到<strong>集合的距离</strong>（到集合中任意一点的最小距离）</li></ol><h2 id="堆优化版Prim"><a href="#堆优化版Prim" class="headerlink" title="堆优化版Prim"></a>堆优化版Prim</h2><ol><li>使用小根堆来判断 d数组 里的最小值</li><li>记录被确认的点的数量，当队列为空后，判断点数量是否与总节点数相同来判断是否有最小生成树</li><li>无向图的初始化：边数的两倍（<code>const int M = 2e5+10</code>）; <code>add(a,b,w); add(b,a,w);</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>; <span class="hljs-comment">//无向图，边数的两倍</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx,w[M];<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    e[idx] = b; w[idx] = v;<br>    ne[idx] = h[a];<br>    h[a] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">//定义在函数里的值一定要初始化，否则不会给它设置为 0 </span><br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;); <span class="hljs-comment">//距离，节点编号</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//不属于集合 &amp;&amp; 距离集合最小的点</span><br>        <span class="hljs-comment">/*朴素版</span><br><span class="hljs-comment">        int t = -1;</span><br><span class="hljs-comment">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="hljs-comment">            if(!st[i] &amp;&amp; (t == -1 || d[i] &lt; d[t]))&#123;</span><br><span class="hljs-comment">                t = i;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//堆优化版本</span><br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-type">int</span> ver = t.second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//把点t加到集合当中去，更新权值</span><br>        st[ver] = <span class="hljs-literal">true</span>;<br>        cnt++; <span class="hljs-comment">//不存在生成树即cnt != n</span><br>        <br>        <span class="hljs-comment">// res += q.top().first; //前面已经pop 了因此不能这样写</span><br>        res += t.first;<br>        <br>        <span class="hljs-comment">//更新其他点到 集合 的距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[ver];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(st[j]) <span class="hljs-keyword">continue</span>; <br>            <span class="hljs-keyword">if</span>(w[i] &lt; d[j])&#123;<br>                d[j] = w[i];<br>                q.<span class="hljs-built_in">push</span>(&#123;d[j],j&#125;); <span class="hljs-comment">//只有在确定最小值会被更新时，再push入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt != n) <span class="hljs-keyword">return</span> INF; <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,w;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        <span class="hljs-built_in">add</span>(a,b,w); <span class="hljs-built_in">add</span>(b,a,w); <span class="hljs-comment">//无向图</span><br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">prim</span>();<br>    <span class="hljs-keyword">if</span>(ans == INF) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; ans;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>离散化</title>
    <link href="/2024/05/18/algorithm_know/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2024/05/18/algorithm_know/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>离散化就是把大而分散的一段段使用到的稀疏区间，整合映射到连续的一段较小的稠密区间里，然后就可以通过普通前缀和公式来计算连续一段的区间和，本质上就是化大为小，把稀疏离散化简为稠密连续的一段。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>双指针算法</title>
    <link href="/2024/05/18/algorithm_know/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/18/algorithm_know/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>tips:</p><ol><li>涉及到 <strong>重复</strong> 二字考虑用一个计数数组进行存储</li></ol><h2 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h2><p>思路：设立两个指针 i 和 j ; 分别指向数组两端，在不同条件下，向内部移动某个指针，直到两个指针交互。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>    <span class="hljs-keyword">if</span>()&#123;<br>        v = ...;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        v = ...;<br>        j--;<br>    &#125;<br>    res = <span class="hljs-built_in">max</span>(res,v);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>例题一: <a href="https://leetcode.cn/problems/container-with-most-water/description/">盛最多水的容器</a></p><p>例题二：<a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/">和为s的两个数字</a></p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>思想：<br>两个指针朝着同一方向前进，一个指针走得慢，一个指针走得快。</p><p>例题一：<a href="https://leetcode.cn/problems/middle-of-the-linked-list/submissions/532905013/">链表的中间结点</a></p><p>例题二：<a href="https://www.acwing.com/problem/content/description/801/">最长连续不重复子序列</a></p><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></p><p>核心思想：快慢指针，</p><ol><li><p>当窗口内的和还小于目标值时，移动右指针增大窗口内子数组的和使其大于等于目标值</p></li><li><p>当窗口内的和已经大于目标值时，移动左指针缩小窗口大小找长度最小的子数组</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1e9</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            s[i] = s[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[n] &lt; target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;r&lt;n;)&#123;<br>            <span class="hljs-keyword">if</span>( (s[r+<span class="hljs-number">1</span>] - s[l]) &gt;= target)&#123;<br>                res = <span class="hljs-built_in">min</span>(res,r+<span class="hljs-number">1</span>-l);<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                r++;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h3><p>核心思想：</p><ol><li>滑动窗口的双指针</li><li>unordered_map 哈希表存储字符和其对应个数，以此来比较是否覆盖了另一个子数组</li><li>下方解法会TLE</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; st,sw;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string t,<span class="hljs-type">int</span> m)</span></span>&#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-comment">//这里不是等于而是小于（如题意中的我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。）</span><br>            <span class="hljs-keyword">if</span>(sw[t[i]] &lt; st[t[i]])&#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(); <span class="hljs-type">int</span> m = t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            st[t[i]] ++;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">10010</span>; <span class="hljs-type">int</span> minl,minr;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;r&lt;=n;)&#123; <span class="hljs-comment">//这里r到n，是为了满足如果r最后移动到数组末尾时刚好check成功了，但无法更新的minr和minl；因此让它多循环一次</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(t,m))&#123;<br>                <span class="hljs-keyword">if</span>(r-l &lt; res)&#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                    res = r-l;<br>                    minr = r;<br>                    minl = l;<br>                &#125;<br>                sw[s[l]] --;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(r == n) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//防止数组越界</span><br>                sw[s[r]] ++;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//check函数一次都没有true过 ，则代表无结果的情况，返回空串</span><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;<br>            string s = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        string ans; <span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=minl;i&lt;minr;i++)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(s[i]);<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习中的梯度</title>
    <link href="/2024/05/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%A2%AF%E5%BA%A6/"/>
    <url>/2024/05/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%A2%AF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习中的梯度"><a href="#深度学习中的梯度" class="headerlink" title="深度学习中的梯度"></a>深度学习中的梯度</h1><h2 id="梯度反向传播"><a href="#梯度反向传播" class="headerlink" title="梯度反向传播"></a>梯度反向传播</h2><p>梯度反向传播（Backpropagation）是神经网络中用于训练模型的关键算法。在反向传播过程中，梯度会从输出层反向传递到输入层，用于更新网络中的权重。梯度反向传播涉及对网络中每一层的权重和激活函数进行微分，计算损失函数相对于每个权重的梯度。</p><p>梯度反向传播会经过多层反复相乘的原因与链式法则（Chain Rule）有关，这是微积分中用于求解复合函数导数的基本法则。在神经网络中，每个神经元的输出可以看作是输入、权重和激活函数的复合结果。因此，要计算损失相对于网络中某个权重的梯度，就需要应用链式法则，将损失对激活函数的导数与激活函数对权重的导数相乘。</p><p>以下是梯度反向传播中链式法则应用的一个简化示例：</p><p>假设一个神经网络包含多个层，每层有多个神经元，每个神经元的输出 ( y ) 可以表示为：</p><p>[ y &#x3D; f(z) ]</p><p>其中 ( z ) 是输入加权和 ( w \cdot x + b )（( w ) 是权重向量，( x ) 是输入向量，( b ) 是偏置），( f ) 是激活函数。</p><p>损失函数 ( L ) 相对于权重 ( w ) 的梯度可以表示为：</p><p>[ \frac{\partial L}{\partial w} &#x3D; \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial z} \cdot \frac{\partial z}{\partial w} ]</p><p>这里：</p><ul><li>( \frac{\partial L}{\partial y} ) 是损失相对于输出 ( y ) 的梯度。</li><li>( \frac{\partial y}{\partial z} ) 是激活函数 ( f ) 相对于 ( z ) 的导数。</li><li>( \frac{\partial z}{\partial w} ) 是 ( z ) 相对于权重 ( w ) 的导数。</li></ul><p>在反向传播过程中，首先计算输出层的梯度 ( \frac{\partial L}{\partial y} )，然后使用链式法则递归地计算前面各层的梯度。每一步都涉及到对激活函数的导数和权重的导数进行乘法运算。</p><p>当神经网络很深时，即存在很多层，这些梯度乘积会沿着网络层级反复进行。如果激活函数的导数值（如sigmoid或tanh函数在接近饱和区的导数）很小，或者权重本身较小，那么经过多次乘法后，梯度可能会变得非常小，导致梯度消失问题。相反，如果梯度值在每一步都较大，那么它们在多次乘法后可能会变得非常大，导致梯度爆炸问题。</p><p>为了解决这些问题，研究人员已经提出了多种技术，如使用ReLU激活函数（其在正区间内导数为常数，可以缓解梯度消失问题），权重初始化策略，梯度裁剪，以及改进的优化算法等。</p><h2 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h2><p>梯度消失和梯度爆炸的根源主要是因为<strong>深度神经网络结构</strong>以及**激活函数选择不当(函数的导数数值过小会导致梯度消失)**，目前优化神经网络的方法都是基于反向传播的思想，即根据损失函数计算的误差通过反向传播的方式，指导深度网络权值的更新。</p><p>在反向传播时对激活函数进行求导。如果在此部分大于1，那么随着层数的增加，求出的梯度的更新将以指数形式增加，发生梯度爆炸。如果此部分小于1，那么随着层数的增加求出的梯度更新的信息会以指数形式衰减，发生梯度消失。</p><p><strong>梯度消失：</strong> 即在反向传播过程中，由于梯度值逐层传递时逐渐变小，权重的更新将非常微小，导致较靠近输入层的层难以有效地学习到输入数据的特征和模式。</p><p><strong>梯度爆炸</strong> 在深度神经网络训练过程中，梯度值逐层传递时逐渐增大，并且可能超出网络的数值范围的问题。当梯度值变得非常大时，参数更新的幅度也会变得非常大，导致模型变得不稳定，甚至无法收敛。</p><p>梯度消失通常与以下几个因素有关：</p><ol><li><p><strong>激活函数的选择</strong>：某些激活函数，如Sigmoid或Tanh，在其饱和区（即输入值非常大或非常小的区域）的梯度非常小，这可能导致在反向传播过程中梯度值快速减小。</p></li><li><p><strong>网络的深度</strong>：在很深的网络中，由于梯度需要通过多个层进行传播，每个层的梯度乘积将导致最终的梯度值变得非常小。</p></li><li><p><strong>权重初始化</strong>：不适当的权重初始化可能导致梯度消失或梯度爆炸。</p></li><li><p><strong>学习率设置</strong>：过大的学习率可能导致梯度爆炸，而过小的学习率可能导致梯度更新过慢，相当于梯度消失。</p></li></ol><p><strong>具体例子：</strong></p><ol><li><p><strong>Sigmoid激活函数</strong>：<br>假设一个神经网络使用Sigmoid激活函数，其梯度为 ( \sigma’(x) &#x3D; \sigma(x)(1 - \sigma(x)) )。当 ( \sigma(x) ) 接近1或0时，梯度 ( \sigma’(x) ) 将接近0。例如，如果 ( \sigma(x) &#x3D; 0.9 )，则梯度 ( \sigma’(x) &#x3D; 0.9 \times (1 - 0.9) &#x3D; 0.09 )。在深层网络中，连续多个这样的梯度乘积将导致最终梯度非常小。</p></li><li><p><strong>深度网络</strong>：<br>考虑一个具有10层的神经网络，每层使用Sigmoid激活函数。如果每层的梯度乘积为0.1（这是一个合理的假设，因为Sigmoid激活函数的梯度通常小于1），那么经过10层后，初始梯度为1的梯度将减少到 ( 1 \times 0.1^{10} &#x3D; 1 \times 10^{-10} )，这几乎为零。</p></li><li><p><strong>长短期记忆网络（LSTM）</strong>：<br>LSTM设计之初就是为了解决传统RNN中的梯度消失问题。在标准的RNN中，梯度需要通过时间步进行传播，这同样会导致梯度消失。LSTM通过引入门控机制来缓解这个问题，允许梯度在时间序列中更有效地流动。</p></li></ol><h3 id="解决梯度消失的方法："><a href="#解决梯度消失的方法：" class="headerlink" title="解决梯度消失的方法："></a>解决梯度消失的方法：</h3><ul><li><p><strong>使用ReLU或其变种</strong>：ReLU及其变种（如Leaky ReLU）在正区间内具有恒定的梯度，这有助于缓解梯度消失问题。</p></li><li><p><strong>权重初始化</strong>：使用如He初始化或Xavier初始化等策略，可以更好地控制训练初期的梯度大小。</p></li><li><p><strong>梯度裁剪</strong>：在优化过程中限制梯度的更新幅度，以避免梯度爆炸，同时也可以减轻梯度消失的影响。</p></li><li><p><strong>使用残差连接</strong>：在网络中使用残差连接（如在ResNet中）可以帮助梯度直接流向前面的层。</p></li><li><p><strong>适当的学习率调度</strong>：通过学习率衰减或自适应学习率优化算法（如Adam）来调整学习率。</p></li></ul><p><strong>method</strong><br>1.正则化：通过 L1 或 L2 正则化来控制参数的大小，防止梯度值过大。<br>2.梯度剪裁（Gradient Clipping）：限制梯度值的范围，将超出阈值的梯度进行裁剪。<br>3.预训练：可以先使用无监督学习或其他方式进行预训练，提供一个比较好的初始参数，从而减小梯度消失和爆炸的可能性。<br>4.层标准化（Layer Normalization）或批标准化（Batch Normalization）：对层输出进行标准化，使其均值为0、方差为1，有助于缓解梯度消失情况。<br>5.参数初始化：合理选择参数的初始化方法，如使用 Xavier 或 He 等初始化方法，可以减小梯度消失和爆炸的概率。<br>6.更稳定的激活函数：使用 ReLU、Leaky ReLU 或其变体等激活函数，可以避免梯度消失，并且有助于缓解梯度爆炸。<br>7.Residual Connections（残差连接）：在网络中增加跨层连接，可以传递较浅层的梯度信息，缓解梯度消失和爆炸。</p><p><strong>Residual Connections</strong></p><blockquote><p>残差连接引入了一种跨层传递的机制，即在网络的某些层中，将前一层的输出直接加到后一层的输入中去。这种机制可以有效地传递一定的梯度信息，避免了网络深度增加时出现的梯度消失问题，同时也能够克服一些非凸优化问题，使得网络更容易优化。<br>具体而言，假设某一层的输入为 x，输出为 y，则残差连接的实现形式可以表示为：<br><code>y=F(x)+x</code><br>其中 F(x) 表示该层的非线性变换操作，即前向传播过程。在反向传播梯度计算时，则会将损失函数 L 反向传播到该层，生成梯度 ∂L&#x2F;∂y，并将该梯度传递到 x，从而计算 ∂L&#x2F;∂x，即该层输入 x 对损失函数的梯度。</p></blockquote><h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><p>梯度下降算法是一种用于最小化目标函数的优化算法，通常用于机器学习和深度学习中的参数估计问题。在深度学习中，目标函数通常是损失函数，它衡量模型预测与实际数据之间的差异。梯度下降算法的基本思想是迭代地调整模型的参数，以减少损失函数的值。</p><p>以下是梯度下降算法的基本步骤：</p><ol><li><p><strong>初始化参数</strong>：随机初始化模型参数或使用预设的值。</p></li><li><p><strong>计算梯度</strong>：计算损失函数对每个参数的偏导数，这些偏导数构成了梯度向量。梯度指向损失函数增长最快的方向。</p></li><li><p><strong>更新参数</strong>：根据梯度和一个学习率（步长）来更新每个参数。参数更新的公式通常是：<br>[ \theta_i :&#x3D; \theta_i - \eta \cdot \frac{\partial J}{\partial \theta_i} ]<br>其中，(\theta_i) 是第(i)个参数，(\eta) 是学习率，(\frac{\partial J}{\partial \theta_i}) 是损失函数(J)对参数(\theta_i)的偏导数。</p></li><li><p><strong>重复迭代</strong>：重复步骤2和3，直到满足停止条件，如梯度足够小、达到预定的迭代次数或损失函数值不再显著减小。</p></li></ol><p>梯度下降算法有几种变体，用于提高性能和稳定性：</p><ul><li><p><strong>批量梯度下降（Batch Gradient Descent）</strong>：每次迭代使用整个数据集来计算梯度和更新参数。这种方法计算准确，但可能计算成本高，且在大数据集上效率低。</p></li><li><p><strong>随机梯度下降（Stochastic Gradient Descent, SGD）</strong>：每次迭代只使用一个训练样本来计算梯度和更新参数。SGD通常更快，但可能会有较大的噪声，导致训练过程不稳定。</p></li><li><p><strong>小批量梯度下降（Mini-batch Gradient Descent）</strong>：每次迭代使用一小部分数据（称为小批量）来计算梯度和更新参数。这是批量梯度下降和随机梯度下降的折中方案，通常在实践中效果较好。</p></li><li><p><strong>动量（Momentum）</strong>：在SGD的基础上增加了动量项，可以帮助梯度下降更快地收敛，同时减少震荡。</p></li><li><p><strong>AdaGrad</strong>：自适应梯度算法，为每个参数调整学习率，使得每个参数的学习率与其历史梯度的大小成反比。</p></li><li><p><strong>RMSProp</strong>：一种自适应学习率优化算法，类似于AdaGrad，但解决了AdaGrad学习率过快减小的问题。</p></li><li><p><strong>Adam</strong>：自适应矩估计算法，结合了动量和RMSProp的思想，是目前非常流行的优化算法之一。</p></li></ul><p>梯度下降算法及其变体在深度学习中被广泛使用，它们通过有效地调整模型参数来最小化损失函数，从而训练出性能良好的深度学习模型。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>夏令营机试</title>
    <link href="/2024/05/16/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%9C%BA%E8%AF%95/"/>
    <url>/2024/05/16/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%9C%BA%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="夏令营机试"><a href="#夏令营机试" class="headerlink" title="夏令营机试"></a>夏令营机试</h1><h2 id="C语言注意事项"><a href="#C语言注意事项" class="headerlink" title="C语言注意事项"></a>C语言注意事项</h2><ol><li><p>C语言中，不允许在全局作用域（file scope）中定义可变长度数组<br>可以这样定义： <code>int s[100010];</code> </p></li><li><p>C语言字符串操作<br><a href="https://blog.csdn.net/qq_42848319/article/details/116054549">C语言字符串操作总结大全(超详细)C语言字符串操作总结大全(超详细)</a></p></li></ol><ul><li>strcmp(str1,str2) <strong>&#x3D;&#x3D; 0</strong> 代表相同</li></ul><h2 id="C语言排序实现"><a href="#C语言排序实现" class="headerlink" title="C语言排序实现"></a>C语言排序实现</h2><ol><li><p>冒泡排序<br>两个for循环，每次可以找到一个最大数字放置在未排好序列的最末尾，因此第二个for训练每次从 开头判断到n-i-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a[N],n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n-i<span class="hljs-number">-1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> t = a[j]; a[j] = a[j+<span class="hljs-number">1</span>]; a[j+<span class="hljs-number">1</span>] = t;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>快速排序</p></li></ol><p>递归处理的方式如下：</p><p>设l为当前数组最左边的下标、r为最右边的下标。</p><p>i指针（下标）从l开始前进，j指针（下标）从r开始后退。</p><p>如果左指针对应的数小于x，i前进，直到遇到第一个大于等于x的数为止；</p><p>如果右指针对应的数大于x，j后退，直到遇到第一个小于等于x的数为止；</p><p>如果i&lt;j，则a[i]与a[j]交换，之后在[l,j]、[j+1,r]的区间内分治排序即可。</p><p>（因为如果i≥j则这段区间一定是有序的）</p><p>直到最小的区间排序完后快速排序结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span>&#123;<br>    <span class="hljs-type">int</span> t = *a;<br>    *a = *b;<br>    *b = t;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qs</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//不加这句会报MLE</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> p = a[(l+r)/<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span>&#123;<br>            i++;<br>        &#125;<span class="hljs-keyword">while</span>(a[i] &lt; p); <span class="hljs-comment">//不需要取等</span><br>        <span class="hljs-keyword">do</span>&#123;<br>            j--;<br>        &#125;<span class="hljs-keyword">while</span>(a[j] &gt; p);<br>        <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>            <span class="hljs-type">int</span> t = a[i];<br>            a[i] = a[j];<br>            a[j] = t;<br>            swap(&amp;a[i],&amp;a[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//必须用右边界作为划分边界</span><br>    qs(a,l,j);<br>    qs(a,j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a[N],n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    &#125;<br>    qs(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>桶排序</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a[N],n,b[N];<br>    <span class="hljs-type">int</span> sort[N]; <span class="hljs-comment">//排序之后的数组</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    &#125;<br>    <span class="hljs-comment">//将输入数组中的数 放入到桶数组中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        b[a[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-comment">//从桶数组中取数赋值给最后的答案数组</span><br>        <span class="hljs-keyword">while</span>((b[i]--) &gt; <span class="hljs-number">0</span>)&#123;<br>            sort[j++] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,sort[i]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>核心思想：按位相加，并考虑进位</p><p>注意事项：</p><ol><li>判断是否有进位(大于等于)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//此处是 大于等于 10</span><br><span class="hljs-keyword">if</span>(v &gt;= <span class="hljs-number">10</span>) v-=<span class="hljs-number">10</span>,t=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span>&#123;<br>    t = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>当计算到最后一位时，要判断此时t是否&gt;0，如果大于要输出来<br><strong>注意最后一个进位也要考虑进来</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(t&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,t);<br></code></pre></td></tr></table></figure><p>C语言代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> a[N],b[N]; <span class="hljs-comment">//原始输入数组</span><br>    <span class="hljs-type">int</span> m[N],n[N]; <span class="hljs-comment">//转换得到的num数组</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %s&quot;</span>,b);<br>    <span class="hljs-type">int</span> sizea = <span class="hljs-built_in">strlen</span>(a);<br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">//代表num数组的第几位（倒序读入）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sizea<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        m[t] = a[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        t++;<br>    &#125;<br>    <span class="hljs-type">int</span> sizeb = <span class="hljs-built_in">strlen</span>(b);<br>    t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sizeb<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        n[t] = b[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        t++;<br>    &#125;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-keyword">if</span>(sizea &gt; sizeb)&#123;<br>        len = sizea;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        len = sizeb;<br>    &#125;<br>    t = <span class="hljs-number">0</span>; <span class="hljs-comment">//进位初始为0</span><br>    <span class="hljs-type">char</span> res[N];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-type">int</span> v = m[i] + n[i] + t;<br>        <br>        <span class="hljs-comment">//此处是 大于等于 0</span><br>        <span class="hljs-keyword">if</span>(v &gt;= <span class="hljs-number">10</span>) v-=<span class="hljs-number">10</span>,t=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            t = <span class="hljs-number">0</span>;<br>        &#125;<br>        res[i] = v + <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//当计算到最后一位时，要判断此时t是否&gt;0，如果大于要输出来</span><br>    <span class="hljs-keyword">if</span>(t&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,t);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,res[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>关键点：</p><ol><li><p>相减之后得到的前导0删除<br>int flag &#x3D; 1;<br>for(int i&#x3D;len-1;i&gt;&#x3D;0;i–){<br> if(res[i] &#x3D;&#x3D; ‘0’ &amp;&amp; flag &#x3D;&#x3D; 1) continue; &#x2F;&#x2F;此时代表还没碰到非0数<br> else{flag &#x3D; 0;} &#x2F;&#x2F;输出第一个非0数后，不再删除0<br> cout &lt;&lt; res[i];<br>}</p></li><li><p>如果两个数相同，相减为0</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span>(flag == <span class="hljs-number">1</span>) cout &lt;&lt; &#x27;<span class="hljs-number">0</span>&#x27;;  //flag为<span class="hljs-number">1</span> 代表 全是<span class="hljs-number">0</span>导致没有输出非<span class="hljs-number">0</span>数<br></code></pre></td></tr></table></figure><ol start="3"><li>比较两个字符串对应的数字大小<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//比较两个数的大小，来决定是否交换相减</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string s1,string s2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &gt; s2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(s1[i] != s2[i]) <span class="hljs-keyword">return</span> s1[i] &gt; s2[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-comment">//相减操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sub</span><span class="hljs-params">(string s1, string s2)</span></span>&#123;<br>    <span class="hljs-type">int</span> size1 = s1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> size2 = s2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size1<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        a[t] = s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        t++;<br>    &#125;<br>    t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size2<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        b[t] = s2[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        t++;<br>    &#125;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-keyword">if</span>(size1&gt;size2)&#123;<br>        len = size1;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        len = size2;<br>    &#125;<br>    <br>    t = <span class="hljs-number">0</span>; <span class="hljs-comment">//借位</span><br>    <span class="hljs-type">char</span> res[N];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-type">int</span> v = a[i] - b[i] + t;<br>        <span class="hljs-keyword">if</span>(v &lt; <span class="hljs-number">0</span>) v+=<span class="hljs-number">10</span>,t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            t = <span class="hljs-number">0</span>;<br>        &#125;<br>        res[i] = v + <span class="hljs-string">&#x27;0&#x27;</span>;  <br>    &#125;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>; <span class="hljs-comment">//前导0的删除</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(res[i] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; flag == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span>&#123;flag = <span class="hljs-number">0</span>;&#125;<br>        cout &lt;&lt; res[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">//比较两个数的大小，来决定是否交换相减</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string s1,string s2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &gt; s2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(s1[i] != s2[i]) <span class="hljs-keyword">return</span> s1[i] &gt; s2[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s1,s2;<br>    cin &gt;&gt; s1 &gt;&gt; s2;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(s1,s2))&#123;<br>        <span class="hljs-built_in">sub</span>(s1,s2);        <br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-built_in">sub</span>(s2,s1);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试问题问答</title>
    <link href="/2024/05/16/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%97%AE%E7%AD%94/"/>
    <url>/2024/05/16/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%97%AE%E7%AD%94/</url>
    
    <content type="html"><![CDATA[<h1 id="面试问题问答"><a href="#面试问题问答" class="headerlink" title="面试问题问答"></a>面试问题问答</h1><ol><li><p>最喜欢的机器学习算法</p></li><li><p>最喜欢的深度学习算法</p></li><li><p>做的工作创新点，baseline，性能；</p></li></ol><h1 id="相关面试总结帖"><a href="#相关面试总结帖" class="headerlink" title="相关面试总结帖"></a>相关面试总结帖</h1><p><a href="https://zhuanlan.zhihu.com/p/612377476">2022年(23届)计算机推免套磁&amp;面试经验帖(华科,天大,东南,川大,浙大,北航,北理,南软,西交等)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>医学图像处理</title>
    <link href="/2024/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <url>/2024/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="医学图像处理"><a href="#医学图像处理" class="headerlink" title="医学图像处理"></a>医学图像处理</h1><p><a href="https://blog.csdn.net/github_36597203/article/details/90638835">深度学习在医疗健康领域的应用概述</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>论文</title>
    <link href="/2024/05/13/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%AE%BA%E6%96%87-1/"/>
    <url>/2024/05/13/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%AE%BA%E6%96%87-1/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fa2bd4ceb8fc4278af80af6051dc3cfd4501893ab455783b873d7ee3acb00d47">184d5613b7d1f40c9857b7bf904a8fe36b33bf429edbb9059ece5af0bf6d669587f0d731360c8d9f41cff11b73c5d1f7c3da279ada8d05e9b5cb19fdac6793dd46685171cb987223432fc4d52db5bb4dd1abde3dde0f9b41f0a87f947841f8ea267d3891ba76e27f697daef1a2136bb6ce5becca5021383f3bd1b6957dda0152df2e704c584d3f9220d0f48ce81ac40dad3f48c8986ff42a05053d539a313ee98b46b482b5bd999345958dddff0f0a66f5a1c965be68e7b37cd356dcc5c5b0c2ca3019ec7da59e2ea5744d91d18d79bf8c103226daba1c1a401f7848fe7ab4f8d76739ad6dd0afcc9da14ceb44ffb3d176fea2ccc45c5f07b749eaa0684010d3c6390c878429646b8d9ab92c9ab323e83a340d90f8c140d4fd7e4613f145f3a3745c29397d98c876d392adc78f4b35616051cd22e08b39c3ffa75b6df7dbae218a224edeec9d3ce37fa683f32464165b36671068f84f33fdbf7c870e459aff20b50c9f6c3a29db6d1a5856817f1888c6d05e565f63d26ae04a508cf1187c57d061a86cc1e2f676e93957021f7f28efe01f056e4a7cdf3e021d48eafa1e8e451411bd8902c5f22e9fcf42a4d2b7d9d5ea0a090dff21931578110d00ddbb2739848f8da41cbb99171472decd009b891353d0ad18afeb78904a49b4347f15898bf6f38996b55026432ae01257ad529ae6bd17cfdf6dbd6cc658df61c7a2a093fb3df0aea52f3fa6330abe4c3aa13b9e12662a00b2261ebf5593e19247d0527ffb2cf7f67a34b4b65b13db8f8058dd500e5d0f48c7aeea2879fb8c45f6755de497fbbf0a287832a724d1675372bc834dcfa0c0d7de7530d219c3da75bab67519d22738bc2b3b40078e0e9cb0c29ddd1b899c7de4a17772c6520f9ae0665626dc22d7e95388d0eae1c768a259eb1f290bfc3617fa8318b58b52b4df6f0fa612bac1fd830cc97e7375461d1007b6ffec869a23dd5e7f25612cb1e610c8d095745a7c75bed470633d7d93164d4853700b8a218892ff7f996162a776d0242a38cea15ab67c354c81609b05d251385d6f7c1706a4b03fbc9c9fba52759549fbd19a414d905df2579e9b22df2bd35239d4cdda00b90031c5628bb565bba2409facd34812ce4c4d0684fa1c34370625fc4c5e9d4cb8e0e68845b186c2e8e28fa6a5668bc72b2f7c54e65617a5c1a16c73ef18f192e8a6bdce12fe72b48788bcc9ce61a524054e2fd7b1a9f2f69c6971485133f505aea3e1f267cfb331363b536416b8bfa39d44ba081c5ac1ff4bd70f985151c0f5274f997c99e7876c8ebc9788371e7f4817ec3ec56f54b342675f248500910e44ebdc090023da466520aa85388dfbaa576afc30d192b44dce2b34d721a6014bb3bd735c33530afda6455c1f3ec6da24353a339f86a5247a1ce43ba118075d6dccdb89c27118cea6de04a2b5d7003f0c91ae4cf6707162ccb7d7d7b1302c5b1d0c067983ceca89022050000e54840b88c472fbb19b1d2c617239ea16610f69091692e9271a316940383f638b60ff794629fcf59a21342d852cc4bccc65bb9a3fbdab4f4dcd852a8a74f11a86d223c1fa411f5f16815d38c56466153d6c2bfa5acbc7758c07581f15a4954c9b9ef98acce12f52cf003d4ab2e6a34080eaf059df582875b5dd8127354c12eb1b36ef26b6bf0b1fefd98fb15fe0ccfefed8d9ba78b27850dd60f41151e37179becda7d3a501fce1435e4beb9e016823dbd9d9aa9fbc3e79ce6594df66d86e51519941ab3333547e7a71aae1e314f1774a990e400db1aecdd54a5a6183e09ac2e45748d44383af0faa5da65f5ac74940235c74536fa0f3c0a9d5b2b2febfffe017f939380ed96414c500ac9e2d9d65169646cd318c7d6a0d2aa0386a7af4ea84aed81b5a6984494b51af5f41e046fc08add451a8b8d09c31fa7a9f173fd40ff6beac3a383b6af2b8820feaa818b47e939dafe67fbcc1d300c384d365efea8a567f293f24081537be62ada6661b478e8a0d508a5c563fcf680e18019f56d8c7636437ca66bcac87558e82c7e42b5bec1d1bf8c1aebf57ddda00e5b45d7e7f2b1ceb7537cf70efbdb22cfcb12b6cf4a1935afbd694ae0ff54c6616fef5d1e0951cc18d36449ec453696ab6e75fb278ede07d34d4f28eff42d2b109f8ec8563d4dfd3975ae3729703d2d96461d766cf8e7f2dd4b00ee9b01616efadcadc1abae33acf6799cc8331fed619a8bdc803f85fb9a8bba8cf866dcb43e04b259ec2bfe0c10e9b97bc68ddc18d45ed0f984059d6dbe2620f0d74d03c32ea908f880790a0cc8926ee775bdb5b2cd174c97c5e5e33458f3e9f899ef6df8efcba7cb2cb1247edc2ab62a108d3fb845afe26b7f4db16140a273c4ce95e6d008d865cb9e6e9252df01b71291fdcfd215ddcc7ecb646ed30558710d660e5ff9188a92c7cf0a82afcccbf1e21929c5b674c184a1521767bde58f2d2d659076f5ff3efb6cf026b29e3d3eb65a769a047bd74be3a55e7a41ff78a92b412f173d8bf6b7ddbf252dd8f84f3e67aa8c709bc52995689c03394c0ca0be1ab43af2d83ac592007afd9a5d412c03caa824b37a601e30850ae6dad7b0a3c91490f8d8e8a4fef237e1c9b7d8ac89e97c1ef4a0ae37205b0920aed25b911241a4e00ccfa9a5e82ad3e60ac837c591b769e898109f072cd704bcd6b8a31e30486ac470df4328a056e26dfc5b82ca02a2db3c7aef7c930dd2431ed48864348115f4dd5053049e224eed00f406c59425def96aff360dbc8bae93a83481a5dfba7e2678f291bba3b01c38f4ac415019c51b416d55f84b73602cb53f0c905b8c5a81b8674c9815caff41892a3d731688cf04bab47744061850854683dec570b82dbb998a66e7b1c99bbfdcf900dd78100ce11d4b0ef77763b64d5dd713e4b464d0f13c92614623318c9c29a5ed3f05179c7eda4987c6df72332c9d583903ae7d99b2fbdf122011803dce8547a4fc42ae923a1c53ca269b6d45cf6fe35b7ffaf967c45b3a46d6c15cee5bfdb4253a3f979142892f060ce0a76d93f711860c13969e7e4087572584d3192e0c167fb282a8f11b8579b77cd1c76894bbf96a409e7e873f9d56c61b2e1d1ecdc79dd2f8c61668e397cf63ae90fbe22be3cc12a0eaa1b215696d0951919368a2892382ec5894b77c4c05fbd14075c442ff72cbfced408a5b43abfa214fbc87d050e9dc0dcc430d0b04212adf0f474c54eb505d599bf212bd4b3a87563da23be6886ab2acfd469037368798bd6c9f749a8f6ce924cfe063814e403b753a78ed8cf887651d1c22b69f2d87fb4a6d7d0cdc3bfe635b2e128061eb49ceafbe85cfd474b0462dab5fdf50e17311f5d8777ac22975e933d516e3ff489217960212ca74ceb6e2e5c15ef1541b5f94a281240af58bca7aec507737c34f9529293cee097f290f8b61e6a0c63c43a93ba595144cb189ae8c49ac75c6092d01c28fd431e9895edad873fa2f26b8e2bc824b5983760a7834a7f5608e7ac0a441091825b0d388b968bafd208466d50a086c8382d8ad964ffe0d9a9b9ad1aae23c88bd34256c88592c512610a6be9e8864abd07a2c41b294abe5e752ee16bc8b9690d8519ef002a31ab5895739066f453f920c3cf8c6dc95d1dbfd2e65c562a35adc8d8e9f0841dbad5d414393fc2e3503691b49ce79fc613fa403503b9a4fc46c03227ca4167eda483a4e82abf3f201ec5825a8362096ffeb5159128da3bb76459b47505931d2a6ad3673aa060df6c049bc9ac42b5f8000e89ebacd3416b84a9955324c5706a3774019d842943194c7d29c88698b9ce1b872af6c95601c551c5e5b9080861099847dcc1d89481679e68a1aaa1e763c264687bdc5be21abf8ad25b5bee0ed9ecbf321129ae13afb8e679c1bb2d4961af2f5853d2f359e40104d9836a15c7b23c83a5c9e16260dd03191ac0f9a6c2470bd16571fd3a6e791bbba1df976fb5060b991e6c87ff5158fee657672722ececf7a5558f827fa8dad41c5723f7873fe443687b2bf9085af4cc6f3e55f9eee53616d32065f5958b650fff7027e0943f5b94c10d01c7372bd85d10b6289296019e929b412c676522ebdd958cfea23fa2050c2dcc77dd22ae9ca49e2de67c97f430e5d14d5d9f1b3c542896ab4ad8e81674364259e069c1a313b38766b85a8b4d8a5dddb44bb98c449598d365440db9650f64c5fff360a57082fcd12b8cd4a2f88164713cacff269cf898c34d6a64dfe8227fdf81d906d3346597395f341cccb4b499dfe19af9579ef9595461c7c44439a2df2484a1613fb4e1f67f5854b87b2bef11d7052c4f532a7fb4a42b6999a8dc7858ddb9c443e3ad0004f07d22676c83b73e26724e1a07c1c8ffffc0a6fc00dff665642b4b4baddd6771db934758db4b4e52198399a6bf4993c74913a0ebf06d67ee12e7e3788d1a47269bd5362ba42cdcf9a716c51c0a73dcfcf08bb2cd5101a435d9935fac0a466821a28b6ff75e8c6e43d4db4ef2ba8b80922a54a5ed933d40ecfcc014732029f3277c7634cb97a2e4823d42ff86894d84dfcf5e056052fe7661cf13f9390e89c6d495db0423a9929ec01b20eddb9310973c828b95ef7ac8b458947ea8e7bd7d65c259eb9a60975ec9ac27a8638911c8f9a59a2e2e35732c8fa6beb798a22d121319b0da3a2eea6d099df26add8cbcaf469102ea9fe3019c1b4dfff0a58cb688ff34469ddc9da4dd6912f58de391af7247e61269d62b3d8998f63941f813d857b878b0d9214804a84f7ee05483ca407ff44fc398914526ebeb501fa25a4c40b36658bc931287ee49341fa0ce76c0d3a575219721823fa0d69aa96175f04db867f091a052adf96e5a62ad43f471b164eecb422da043642537b9ab2f28ad2df1682c5ec7430ae8fe9373b78d52f4efadd5e1f2df592a7432a420358459175dd383e8565bff20b8b56836027bc25e0449045b50e6171d4893d8389c7d0f95da90a63f7cdfb2ece13e0c2c0f89ed93cbe256e91b13cf52d871fc22f6792731bc0f90bbcfb11ca2e6e9f1ae0b98aeacb562c3b2af14ce3ced446353716c619e3b1c43029b45b8aea58fa25065eb90147e16b6b9649a68fe7faec66bedf24acd9ba61e390dbfaad724f994128844ac03f5ee1eab33aaca928a1e3300ea59c962c757c4a97e7df6d6772d835a5305b79d4cf6e750fb4c7984f994da911956342dff8982c68ed862b77c8b078c37b32ce8359a6bf804aeacef52e8bab206e7821a56c3e6a53739c400bf7f03b75841689b53ae9982b1062f8a2b2ef23f13aa707e131d52ba0a4304e37403580b882f3318078397f8378e441775ac26b025cdd67ade6220f8f41cc5e7e75547fa23e012b04f9baa4ea2013e1681de6b6efa7f432617bfa07c932aa8d6b9d2d0fd44a043c4515d1152579ad74b8544a15bac33bca749acca74f3121726cd36921b3d0f0ee827eaaac5b4f57b65e8cc31eb49ab51950978097fcdb4e156a55b2a3ca951435d39cad064383a2afa3cb68da015b64eaf866506bdb8dee7079d48bbd9a0d34e9f56047a0fbba991e3ac6e91234e747581b9ce5d3bec15fee9cf9f8b6c1f810f3cd1087e6d5574eb636c44cc8e28e5a40cd761a7e98181079e7a4791ef93c2f0576c6f95cb5fc58c2286fe998e85136ce80b98e8041e376c4ace5db8b087385ab25ff2687543e65c5d670f80fb151d460a22acb026451d50d00e2f9adee633804efd5b500b17854c57b12fa03f6fc94ec36e2fc2317b013c74f2a404daad3edd2f03dc33a450d9e24a5b6811fcbbb193ba48b736ff004ee6a0a9516c80924bd747d6b4161921b165b221ac40da6ca810ce38f70b4284efd7dbc58554a2c0fd600193efaf6988feb41f7a71b11e64fd0cc21400fc554413ab98e7c61f3ec41ae9038c11f7cf84e47b9ed9c56fbbd60d0de5a99cc984979b368ea9393bd7f0be281aacbf481302cc237ffbfb17e8518bb1c810eedaf83bfb69592f66659fc9d10699f35275cec97946c21f87556a95d880e4812213a8bd82429145f91aee82e993902a8dfc6f14a92365985bc90e582d9b09a1864784f397465ad3c8402d255b4ba10125fc8a8966b94bafcb43bae56bea2a8fb8fdab6c1e740e5e379d5dfb5b118979d67a3ae2f43f08e734890ccf984def0045e3dce92cfcb3a1d6f6a656fe874846ba71770310b595171482b3aedd0d39e0dd68a2ea1deda8ab90a55c88c83c479aab028e4e7c945a6212ab497f1a9cc0f987b6fd4cada34718859469ff0494e0c17b78a0894bfcf10ea29a6a7070eece2837cd973555255590542d75714d88a69cd35a24cadecf3508e9d59597f918340f6d7d6c866ce12d0320c6167f181f86520cc74cadf60b1ae300bf9facf807b97eb8c6784ebd0aac9c9a9d7b6aadbab0f968440354f7493d3f7d0ac18e5be70e98eef36fa75d7db08276d1298df15e872ac6ffdd3bb832b8df3d52b579d7d28607c25f64bb62349ef0bbb626984112bd20276893961302ec56ecab554684105fc58124062524f0afac8c30630b67c28c741b27f3523a98f7fd6b3f55e1b84f17f8fe0d5c34c1b6e84cfcde28642ee92a03c40616494f5f2da66ac958d8fcb62ea7b7a78ff195b43f6d63f2b93593bebb547b2e4f85f72884c700680bbc9902c1534448c24d180ad37c01b81305a820eff6c44b57a42c5e50f7ff7f84f9d75593315831ec10f7965abd609802da8f00b44d7ab55725d943766560e74e33a9c49dffbad6f9728a35ed787df5c4ea09d3629615bc4f6a6fde8f4de06b7871f4e5403481291f4bdb0f4b16f169b7223a4c896f7411b8205b71ada345596c9f3306a79df8dcf02ed24f0c6e4f97a16613e34437a4f8dab96a54b16322e47e9edb550574f5c5eb2e9a83e19c0f9433be5cca8dfe654110889e7d5ef4c4fe04f95d1d1efa2474cb7d6035f9b5660574cfbb4321fe97b475686f0d5148a262bc44d25bcb64a1f42aaece67688dd42aceabb5b66c2c0f63ce4e210e9efbee4eb7a6d509c9f2aa72bdfa6ecff70a7d43ee845db8399e1cb48c975505fc9ceeebd83ad1ba5954bbd1533523e68feb6667fd15e21c619cc4be39df7e4df30e31fe472425055bb1a8849b5471e1dc09012fc10d392ba00fda870cab63c19cc6b6606740b7ff65096e6754e6b088f1208dc3e6e47870306685ff0158a4a35c52f20971d1f05c389786902f41d2a20344edf57b1d32ba8d42475963f912178f261738fe5b74b945a19d5909ee60c39344abc3c805046f7cecb801f0809131b3700165cf65f741f5e627ea62a57297cc3f889bb48312fbae077b04b3441efd1908606335ed9b5a26bb209a1265be31e554039c3bfac655e047af90f1ebb215bf234f430d89aefa6dbe674a1c145c8b25489f4c0cf06074859881844d1bf07ad7bc95848cfc13700e1d2d5716e2ff02a57a7125849510b1ec77251a603ed926975c29ee8371d857277a8e645f48f6e69cbaa1b972cfda4c7e9c737ff5ca723b2de0a81ef3bc54fd8100a3a185f1a0dafd58dbc920240ef046cb030255dccec660fbf0b32b09ad3efabb56e9513d5d0c34de27ce9c4479f330ddca0fbea239dbf2d840b1cc129f3388c09fd3c19d0e6ebd20a719f74af236d85784df988a4c996bb95a0e7de240151a30ab1884e5a96c83344ef61aed1a8bc6888ebf4410ee406a1cbb06d02dd51a66708e2e13151a4a28604742f5aba10d9a39763ac7bd3ff04d09517d3da765c403178a71cec65e45707deb8028617fcb7576ff07e673a791fdade2719f46b663e670353087a409213fd32be5321f332c034df06b68757c2d0e142fb91af0734d6efce5a684deab494a94bea7878dcac0fa653007a685c27ef9c304becef431ef94c8d436cf714860f8df11b05c5c8ad1d37300d07a40c62491596b782bafeca33f927f6d5828fd2d6ccc3ac400cb0ee49601dd1da308bf4379d34da49d23612d3941a2175705747af79d458210d0a90e61d11c0d61e5013293aedeb8e74f40981639570ba13c7eb2457bdfdb9b836b4b002547f76c00ab655628c926c3ebd78bbdb6a918e40671577e27a6f1562d65b3fdfbc3247b64a884341ffada07ebe017c06ed163ebaf4a15480f300612cb1138ba9723d18021d67efce372f36dc74a3f648cd8570dd29e7c183beab327a7c5cc257e79902427ad6bb30257ae49839946946675752a923c99ddbf3b80e38e1f6a2fd8831eca89c85e71220ea5b6b50cfadb5f08bcc9a09e949dde1de8f082a4e45a07ba32cb44a899a595cdca41be23ad1ec690a9543f96a6d1e646aecde0358eeb07711632904058ceb5df694dd7c63fd1ebf9bf7ca665737ead040de58fb18e2aa9c1ee1e5cf28509ce979d842afd6275b088d924e49c754b84e95aa6d9f9a2e98859d248235672f53e67645c78a3ec035f3d5c46cac7a8545e6b52d8cc860a7f022978fb6b3f1fb1cb79cb73e5d8bf49c2f909ba1e989747bbbf7d4cda1fadb890d03215acbbbe5860dc7483f4ca9cc64dc80b45016a5b6cf7fc4d813d19aa64aa56f9bfd17272260930901b4c1de3d45a48ea45b6824fb4470bce533ac3ad03ed8e35a891b40f6cb7b1f87e93c8b87f9404ace8292f182d9bc3052f5fd6d6aba5c3532754a03b6db3da260ec6e1151695eb88d4f15fd287658e1f9671c78cc081bbf63e577108d4c5d8f8ef38b9ebd8023ec68a563af9a6fa416e1b852411db9e351cad4318e0d706d321ef31a03a5b5b7f3e6139ff2cdde27910415ae9ab0b9433049323d6ef98d58c156b4c17eb958929b03b07770c3451a97e8bc7254e4ba50b570575b1dfce1234750913a4b7f5f703902049be338dd395f68816dfedac1bd2f42aa6824a2104ecbeea693ef60209173f3ab2312eff412307bed148f845b1fe07047c5dbe0ab4406fbcd842f8f3f5647b4ad437eff960ae955ccf4f1ee57ba40c5490fea75c818aea8891ec711857e1c1db27d9ce6dfc74fed878d2a431834fbd6c317428a88e8a60b50436b7effa30ea6c2f2aeef04941b41004ee89d9e6dc87ee5014b8727a354d4cc60520d200a97b96fdd7962332d8f2bdb3694166a563769117aff151359a8b72c3758a7bca126b445e624a378b083d1f507666dd335ab99ab2f4d05d0dc79710374b911231a445e93ae27fc1db617c6a93904974242d500b606cac5f45062d52ff9f6e8809636c673d837c83350eff54718692145f7689abc99cd37eb44d0fef228fb70fcfc574bb5158bfee9a551654398dd1809379f144710d9857d4eb78529847e416559a7e37f43a596877985fc7eb530d63cd48125debd4ebf08ba68e93e2c31196bee87d1e98671829fff5469d75602f8add7b8b37d67b6f94a7df22d33f6e5b21fe9fcfb032f77709b37ac889c7f556d34da8d307900e3df6245d56198fa66974354a9a15334cef2975cbb909a34d2bfa9537c53ad1405a8d2cc0e8c130715780a1c5a1c8b48c47fa281946b745ee750750aeb55ca1af7902c17230f7898ed1aeea269584e4e3ebdd5dcd8a91a60fc48a79d29bf39850f2af024d77a7ce69f884540036ba32e46ef05e9269f42b06bf5d248729b7766e0b57d123ca9ba088fe7f2811876d89dcaeb1d490a2ff2667a86e9b16179189b84ab05d7f41f4ae161430c82f96559a4b2c0d322928667de0fc03649ba122386fb9bd7f90b632471bd3f9ecee04cf91fee654a9e438cc74ebee12011208b73403fee14d23ffe73232306ae6e7fec803617cead192349d2ed5fff24404906e0b677e90a9ac2b9f127308d5927da76d4f26f493a1565647577f54c6740b60467c36e7411d6689d3dbd37aabfc9cdc5e0e33dede209229430fb459e1cd38edeb1a4348e9d5583060b1996d9814117b6a48c8acc8e92917826533ee6e5afaceb185f46bf8c4d64c616f3e2fa26bce204088e02c035e14ae0b49e1ce109830fe0abcbcdd922403bebb2b0f02e33bc669716de51c93b11a05e959fff328454cbc8622da00c087d817bd8e02ca8ed880f0d694c43eb56eb97c02b587a53112c9ccaeb9df04681629eba595eaf34c2dd775b77861cd37568a0a213f2dae674a14c888bca19914ed8a13e48da8a2932625ec3289df340657ea51782d03d001272440fa5724417c5503355d36e3bb65a853b0ef8767f274f6451b24829b0ef97644c3f5c5263e4a2f42cc9963b005c788ed69c4ed2f5b525fc2044965915a3651be83db5dbaa3c1080287ce8db775f8478540870e1c826eede413046c048a2516284b51ab0ed225530d3050e935e6eab979c4f2721b15ec8063c8e4bc3b2e3c6cfea138b0677e8f092db5cbf555bc6c0cd7c86079fba284eacceb21a00849e4262fc9f38b4162c5ad8d3bbf2947cda38fe81d3e9e4dbb4776ac07a73c5ad84266c3931a9ace07f28d81c2c2ecfdc8a88c69bf8cba951c727792bc23ef9cd9a1aa5ff825421c2d36acccfd1be0d3b87d9aebab87c636ae1f96fa8e4d508685c01596386811e4cf56a3e91d05ad2a38d57c861d67ce850bf41002467fac70aa61a2f2769d6f8a0e656d1563be03423e48e2faa505b432eed4c8b95498841844a71a435f435510ec46593f7d86664f8b54015d57ffb340b41326433daf15033ebfa207e8d1661bdab7e7aecaaba89fe97cff6371d9a03da6d50ee1a430b12cce89b81aab3c4d439a97778936569ccc7e6459e324858cfff5cdec754e32911a7e6ebeff917488767298090384e98571efa49b03901cbd233056afe1b9c676c0b158596b46a0078900ad729b1916f4e2b4b6534409ed197b5f35c156616e3c20447d9a532d521949f36eca8cdf54a393daef0924247f92a8cb823b6b8e0e633aa05fd0f128787d7469f89ab53d5bce4a0314579214816f67d072953fc464d398a00157447694e9e9996189777fac280eabfb27dbffc09828584585a0c4abbcef4e51cb220c8f929fc81ad9e0dd71f353b66c2fcab832c6252b799592623dc711dd39a4ef97a1c19476da5b9cb57f7c1746280b6b6d5a22cd30d797ae49f3c9c7f2378aa3081ad1fc4d90cda2d6409069c4a0a20981d214cce6ae6d8b3e817b5ec1d5f7c4898d8bf14c734e90608a1ff87f244d7cd7322c24bbc9df459344cc938a7dc4bec6d93001c2e042777d0819495d16979ef2ff91f641314a589b6f83df03b255bb1389116ccfa0e4e37487308e443a254cb2def28e17feec48a4aa95aa1dfb4e139cefcac6e61d1f5cca0f0ee7ae7703a7eb7f11ec99b56173750ac26c9d0198e824852b8984949e601192dc484d6e05e6c704a5fb21c1c4a95aeca33a6ba39b5eb4ebc021c79c7ec52d59389e20b5b24feda59448b77a19acb6b7f0c593467ac69c1db9ccc28dfcbc0d565450f6f948d29d655f44363e52527c775164314552b3c062ba000a973e248c495c99fda207fcdf50ea9a84b9f0f3cfe0112027329e28985eed1459480cbaa2ee427cd22f35b56897a915d1994efc077558d4c654c23a8bbb0fb8fbbc1c762d534e70f0a804e63133152063aa48bd04b83799ca57f6a3571f75db5cd73c9154a96fdd7bd2d5f630402ae67e9f08cde8aa1d5848119f74856ce7b11a55b0e51debb2884f0f62735e9982f8b198409afafd4e6a84f9ae8b7ead5caa2f3f47af8f9e5867c1faf7c8a9b7704fa1abc2522e7ba5e8ffcc62d7c083dd5618ff230028a901f7041ab123d2a59c211df7977b9207fe9188a8015ee511f28ba805746434bbf86813407a21c5e7b23b91433ba5e9f07853d9965bc6b4c9bf913244713c77afca94242b894d0d98651e4f47777a29d9bb6d2f4da4064eb7cb70b88338de03bc972b8961577fb9a4a4934aca81c781fd2ebc94923d435d5e3d131df23bdd845a89eacab296b59a79e30b9e115d1381f2c41a4d78ce76303c7657542955af6768c8532fd6958d977c73e7ae236bd378e404e89721130f9db4d7c3d531e553dd00a31a601906c1053478557f01f9a6c2d92f2e6939d49991e43900e5231137f820ef769ca280b037e4f5ecd1f093bb915d1198326e5a60ffc5d73290fb97598f0a23436a8afdfdc210f98e3c5ee631dd7c0965e6db25b328d311cf3bc1325ea32ae2bed9e877ba07bb3187da1f25ee7cb48c3493b0d8e618fad7e7f1723799f30cb5174394ee7b607b4287f0daf3e39c614362ad4dc2ded7b43484a421c2874cb1025ce226dde8591be925fb92b87f466831fb17d331d5a035969189353b869ef5243e3e7ce01736fc861df220e4af2eb598cc0ad7eb82cbce31cb7c7213943c70d2724d2728f54c20a6f166a224fe5dd9b57b7284a5f30018e88258680a665eaa91f945286a90a0256d67f98cfd46cecfcd4ed61e042d16a7e304a4130bd2e6e62055f1e770075f893a0d5ec33033d2bf6817db6740f39c868f6df013cb59073deca88958e2f3319c8c9b2db3048bc35eacad3da2fbc7f917d727f7ab7ccfdbef205c428289502121b0c02d1ef8636b82f48a912137952a5d11165b20a1d437a891d12869150d022dc1afa8835ae5df48192d68a27417e0e218a01fa70406c180c78aeb574e1a1e63f072e286dea6189cc373fe9251dc66bc8ccddfc7621d86733b5b1bfede17325130f54628882b1d8f5ee6a1b3bd160bd98b9b3d2b534a2bc2598f08c5bb57ea9fb1e07051c12904c0132378612dd2951b0397eb75668220d05679c3eac35ec0992343d290abac80963d2473574cd677455c32b1cc8483e87267391bdf7e7f3ca9aad63412398beb8ec43ff8f026ce9e5daa23c2b39cf9224d56c09de007d11eb92126707e5e94023ae99536f18843a569a8fd02bec4681a90f2d2e2228751c1fda45fa53d5a2ba134b112e2e49b187a592ae8d972af53bf0ea2c5ecf4709df8c8a1d31dc8cf77c4badc04c12afd321ba3eb213dc4cc8624d023a7185739f38d25553bf78f5c33700bea200f95229c96bb87a12094be577c0d0834fd2b0d802f363324cda53c69303702d37ac461391f75a42e2d048fc1f7bdb8c7a27105553ad2731e376945628eeece4233cfcd1b60e74f86670978fedd9809702de00365c7eb7044413c52f7cd053052201b7790136bf91797f4754541739388c8efdf62ac1f0b948525b781a2dcc74553adcb41d6baaa28d9d39fbc98fb744bcfbc2fcf3f491af702474036818db17b5353b84bfb5be863f47cfbaecac029e5e280288271e6ac46893eee4e6d6ea51241f67a55d715b004f4d813b88c52bc17f697caaff874c6da16c02602bbb3d7d2c03093b24c87f6b1bef83c90e3ac3855cb419e763f629bf47a758c1ac4ec212edc85eba2edcce9af4cd8d8dad513c6fe8e88cf038b5a827daff7ff31ff109618e904c61f6e7adf16321f2a28ff366b39daa66a43b39256b3c7966bf1975c3f42cb5e36037c1d666375911c8c4d3c391cad119ba7ca4cf49ba98debbb4b526b8f17276e7b01f16bf47ff87d0490560ba8e77d9c763dfcd67f5ce257d1b40770caa024d487626c68dd545fb06f04db36ada62be89fa204a39d78983d104eda45da976a628e61f6edcd69613c81b21f15d18c72eefadb23ade6dbb8037f8f8de9dbf311da4b3835ed2980682cc6413325e850dfd166d6321117a0b3577141d3a1fec15cefbffbb0eeb9f3ce3dda4574cf9bf066fe22167e6eff877d74d37d67f971741527833a127dfb07da06b6afdfe0fd9b341df7c64508a81d1ae6756c83563677a3dc8a04d4049883ae9a972bb75bd1486aee54970bc95e509e5ee72feb3cf0cc03848d9e44c5e8fcdcee39692e64b541d9a6df4d9062c82dcb5efc07917d0c7948aa475c609939b3332c1c1724a59d2940d5cf49cef6991c8708953e32168db246a1fbf1d2a99ee8c227b99d193ff646e141ee35d8ec0d894fe97a22aa165e7810a3348a33272c076dbe9cc8b2fad3a7a8000274a2f16ef19d7f53ea23d0e91ae23153e48e5946198332641a11c76cae32e11eaf90f45d5a99c755ef04aaab70bc77621bfd2c3f35a6f4b7187db5cad4d47f793329363ce657e97d4c11969c94bd18f271ac4d206cf9dd7f2dd593b24091964b516c5547df53fa513f62c652d01e4af63507a2d1b7f16adb61b35768e2272c8245f8f3bde0f696b1b3a25833bc036f607f484003fbd1dd4b0f2b716c9e5351ea8ba906a2dae5961376386cbe64965f646b91447f21c3fc8fcf525a58b3ed54d04f9ce3822e6db166e36b56998a40002de90fb91cd0ae417510dd38b815b1f6eada2a78042d30ea49d499070ed68c3f736b2d5949a49505f74b6ed6b170255bd2a2f9c8dd2c7d85a87c41b68889fdb76fdd0afeb15279e315db589bd1bc545878d401407424075404d06df543275d533935bfb2a5ba2d7f000b8c2f5c5edc7dbefb18596fb736babc406b1257a5d1276371753ad6479d72503da2609316f7aa1858d0f979b7049fea9849834ec27ee9d0ef09e7a5c740d10810256ad0a1c9d01f4cb1a8ecb52161fce6171773966535487f67abcfea8dea7cf9f7e96a42ac91ab0921cb1621b7fffd419e5477b68c8d2b1f06ab124e177c0f359198cbf4f5a7720d5dfaad9cfe180247a0e344a9d74a61cdbd7f24d06412b843dbc1e013ad5f752833a8bb777d6b6bc4e9d60ad5e45dee7c393699656ab27bfedc167f8dc0fc49b5807b5499cbc55c5367ec73ce7a8043808380b3bba7259223d087dfe1ed9f2f958d284d64466c66aed24627a86ca53d7b7dbc960e9fe7f015696d5d8bcf0aa11eba65de4a9c4a073c29fda1639c1afd35bd93e4bdc4206eaadc2f715ce6b4278acde796c35b135fcf9d33597f9b8bc8b84a244dbc6afbb71b867efd5a8d0bf35f81781ca6a6f3c70bb14a8b58c23a65077b03157cfe46eadfe56117ac14505fbd1b6a29882ae8df6506e899f5cac6361e0ef2d1b4a650dc342f25dc454de32c7fbff851b6f4bf2308847097e4d94d692899c1ba1ccb5fbc1069cb0e899175f7400ab510ab567e238cbadb0a69eda5bbb34c81919d362945486b3e66b6aea50168ebf8a128e2fc3d62d8ff8b49b456ea163c6cd5d8af6917ad73ee16ed45367b31cc6c10ab62448502b860cc106478f9f3d92dfede98c9b752d08387bfdcac890cc42c6d943faabe3064414d98f44f9ed46dfb9d90e6a42decd3ac4cc774063c9c09fc4cad6ac3a2288c2e775f95f2a589865e61516fd5da461c52d7e8d680e096bebe2ce528cf468a93dd2b4d64aae0514e4720f2443835270d85d5a1a0d882b0ae0169d8f62be9465628f48c79bb885d4764172e358c1feeaeae6990b62d08b9763cfab273f8598c4737109d01f76e9655f3211f48308627436442e9f3ffe15e7951095194c8e1181d133f88569971b785800742aa5708661e5bf005e2f565cf01c1ca727e130edd9ddbaea2d65515a595dc2f626e0979fc3ded71fc9524d92d244047131fda2c116672204bde696337db15e93419719ffc098c66e996531eef52f0f64bf96926e065bbdc70f9ef87609bcf0b762941cc534bc298dca6676f8dc2a9155bbb4d9b3f1e16899e5849610cb37eaa26d0c46aa795d1826a0141937b45b4df3f71e3d2c71ddf48260c31c5c543aa28e54b3fc7a750616a4ada060bde2c28d63a4fac511864acf110da120ff02e7cdc2d6d2333d4f1e26a04540a003f288687de2f062bcdbf759cd76a65a6b5424a5ae89db19e0d78831bbb885a4b4a356143cfd6bea6c1facc3226f29883e53749be1e376bea45d3937e951aaa02be5df9ab19477c6717c46b88a2277a34063d1c5eee46e4387707760e440541a18b972bcb0c8135b14f4f5600ee2d7be5b45dda674e44da62a10667b4ddc8f914fdf44e6c064de0d7411e48d068c5a089afbda1860b7d08105e6a9cc7967cab055cc2341754241b85363c29bb46e1feb8c1b5589bea0e76911606166779b7f293da9b8a20d875535032e2eafa8e7fbd02e12cce56db98186933e10a3a7b68693201b6cc1563e78cd86962198867f57bfe11e803cd49cd88573d135b13b15cc6e029284cdef3e12b80774c32576ddf12feccaa94d321ad66d49c9ab9a693b4bac0ffee6cb4769dfed989a2e05deeecead38868f709abbf56c9ab2bdc9d0378e37c66087479aba37e1245daa683c11aa3c8f6bde79a492f399c8ef56c618f3d63f7dce2e3cf0cf9577e5cfdef7e8100a9013e1cc90172bf46bba3c14f18228bf8c8ea1c7e0ff8818736d8eef49344af1afb8f38d11a5c9eca1cbf62a37ed7989c521cc7f54149ef14ab46e59ff57fd359043b6c6a911b3bf9ee6e85a966d99322f026cb160f7b64442692381c22ee97779aacb5a01a37126e5032e630de8ce663fdb95e76351c2807080b12d9f815633073860b9b3b8f0eca1c78953d206980999e06ffc9a37fb2b32ccefba92b1794884f80295810c492ece3211d860e1f0b26efef602ed5ce65cad3bc0e529ee066ec6093b8e0b5565e70654340d327f538275e03219c7a7b0a7ca60fb41114e34d9efe8b6b3d896490b4c586062cf2453ea07c22ee20fde25cd14f9a676638d08bc3189eb79660e23ceab7453dc921f04dd5448795764c08d4020d0bfce0f6d51b8677d20f7177a9a4fceb994aae3d3076616e11936f9d9a46751f9c2ad54dda510ded3a4ad928de0e910cf9f618a76b60331ad139fb62682c7479320c4572b3b5afabdb47be1be3897def8a0a7dd1b3d2a5a4341d05448b574cba61bbc6fd1ab109d48602c14d9b35fad5f48ea6e43dbb64a0e7ad7c73ad910f30ab44327a5a8a803707e8ee71ffb121abcc73bf676988655781abe54ccaf1f747937fbbe4e2bfc43a871424e2fc80d838f6c1497d67f073098e42d7b0acf70c377a8a48edf1915a6a466aab7e8bf983bc5bc4f634d5c0e96768627fa8aa38abaaccff7eb09ba5ebbbf3ce4202c81edb9c519fb03a8cb2148f71df73f6e80bf7ec77205a1839df55437d92cd8059f16c186a69bd7cd40db6f23f9bc33fc631b6c59feb49702fe9e5cefc28e31916e426d822725f2e171ad2b9c6dfacf2b248042057b99665505d76de11add0f4d13d8e3dfb21201b8cc1dd2d155fe6e82405697c9ac9b8a3e9c0df97da613ae5911649dd37cd9cef42a89e1f2641a20e5884024f43f254402d415c2322c07315f4ddaf57d3c83fd49296150f54fa757140ddbb37950ad35509295b81c8091f6e1307286256874c84791b885685f128cf4a071625f6cc7d34555858995a077a1a27f26a2a6fd0fe2d388a31ed4ef728591f1322ad7d38a4bc61ff5f900d0703d0f63914dee16113def7c985015f8f7aea6db0c0016cdb1ab7194d5ce43e14f677723f4804117e17ce1fe8499ddb67192327db0cad237b86372df89b34374e94b62cb85769c673a810bdfdf9bf2f535fa34e4fe4c8b2932ca1d1bb84018cf193e68eb5329bdcc7ea6adf24015f932f3677fd146d0c5f5c47b561af1a7a067399b96b3fbe2e1095316bc90832963f5adc9ab515b30c7e7eb2638436c41b374848effca7986150562f64877e61bf35f9f384a6c08e3c3e356a7b8c4207ec3d77ae2cf1ac247f1054d76dfe9d2afc4beca10a26698786ed7cd1016f973057fabbdf6b3fe8b264a0508fb916d75f2bc0205b7c368217152bae964755c16fd67270ce7a49be28cdaa5d250702f6253663a1bc747ca19a783afc7782c0eaaf0957ecaa71049af3f4fc1999da0df0697c0c952e87d2a452be8ab5d56751c57dc7ec6c9362c6cb540bb8cda8e0ec0e4bf06448bb2a6df2929e9ed5c1ac2e9997ba01f532140efef24544f4eef06f54344e4235fed6f4e33f453025bf1b408842eb298c9bb8288b1f7fec5e424e7abb0f4fc76727ce4c08010181e9dadb5254dfc1e12b789d48c6d70c6edf6bfb18e514d54176c57b03f9f09838eebd0903b9a9dd6a7bda7342242ad84b3645c826318cfb9055774ba4884e133eb4a4cd9ce008efa4f9bb65d5630b97a7805725c01ec143a75c39315d29e419a7f4101e2ebc62b806476bd17953c030783d7acdf1205371ce7e6422effa3f875147dc24bb835c80cf98ab2088a66a6919296189c862d722848b469354361500ff57ac7754a1e1f29656b6306fabcfca956f8a67561f0b76cc1508ab8f007a92a94ca84513bf627d889f6e3c3a72dd59aaa5460a9dd51679654f0bdd750a033cae46ce89b937f5b972b539d4278311b9dcb730d3d2b7aa35adb3281ef91cf096c6ac655b76dfa55f04ae08fd87592203f4d807c738db6d5fc34bd568c6b98b1df412196208987a79a3b216db33de0191af20b73c85e5806f440d970e09519d0a75e117ea78ef07635932c51ce4985880ad49fd8ea3e70ef5f9b5e1169d563485010379b4841623d80e0f156a221b9af50332b98182a59f5a95c98f9e326cb4c37651615b9b30263d1015ecd970fee826fe39e3491657716e0c4507cd627561ec732b116253ff8086e36b071dd78c57fa3d181d8290475da11cf10d826e801c9ca0e0c36a5cfea9dfd7aa5f142f800f480832f816c8e9718483836e3696ff09c37e740dfd82a8a5cd3327c69eaa8ef7596d802dda7e9435c6879ecf6a9014571becec221bcbfae01c4e308ce131731dc6ffbfc5a5ea5f4ea4fd4d8a010bf795043bca42d7d7cb02b7c7e238824b5e0c0e61f2fe204652148ed64cc3b947256dd11b5bede35bd10892ca3c691116a6ce83bcd6fc4acf92e8a859a245abd5f0e1d7881023b125799d6b7ceb41ec501da60dafef64060323c4c4952730d2019d71ff9b2963f71a83040b2da724f048c56e5b8a84963b00502df3e33d27fe56926214a422651fd92a69858883520c31089776d4fdcadf6888901d92d248f2039443c09fd2aa7d4a85af30caab2dc00987ffaf368b6a7073d1b279ca97636209122dd6a6a7a7fc2468b2a48edaf9741191084e73eafc00f01e94d328274a2bd85ec8f403a2c81169e6ea144245ad70c69e8e42b8697a51e759456865d229962d7064e8bb09efee00bfd0bb8c6931cf7395fbe207a57ef7747a4bca7562ca6b8edc5e9d6def2e54bc24e3bc5ba132ab5992808f70f11a2ccc406585b80b8feef4f44d5004213bb1b97be4acc80fefbac772e831e051bea7d5cbe309c4dc82b6b5756f9a08764e8b8182156842713469c7fb95a0a8ae222364d1fb8c8595c4774050b036fc41c6236cbc89c27be5f3b3a5b9353bedb0852c193282b50fcb8dd85790a37140fa9ebb41efe02cf0147bfb1ebe5135175546ac944637d6c82ff3aea94760955ecb3ac0bdead6d57a9af20f64b476da5bbb326d07b7989c0d45d7793e9cff036327cce4f5e325ef33300e8b586ea3834090851dcc240906f12fdf8911e02745eabafdaf8fc1e523d99fd11fd87c92aa4a765f19cf6f554e458b768715c559a275bd3b2d12fe302495e1b7219b0ab18a716b2c7c9ea1632049653df26e9af6aef6f5ad0d28f20900e0e68112fd293227d363d5dc3e15d5dbb0d731d1e521624f995389249568ea3897abb9e309211e81aa60bffeaed7b6ae82e5b1a8cee39a3d6b4a1d2ed1e897524383211ac8f6d70bc730f19145573c99863c975ca6558f454677199b681633e5d87d1189637577038cd5c0b33cc9bff552bff2a22931c631a325b5b1bfa0096259b2e9559210579be8d1f1a43e8d4ab114a33315d1938f9e81fa0d0bc9a85e0136e2b6aacf7f1cde03fa937211a654cdc4e8bc34d57e3a554974b8f25d12852c3290f3300fff88728ff4f511c3e414931ede6e23b8fc2d472bb2134d02a9da6419d6b4bf571d89ddf80cf5f9508604eca8c0aa8dbfad435a002a292f836bc152847a1a4762387b2d74b7d3e6e6f387f362d497d3048637e24d1e22abc206c15a777ce9b8f916bef5272db02194d16de073242af3b6b745218971e132a7bb3119ca3db045eb37f5198ec08c2416baf8f4e9da4ba097f1d0e7d07b1d20fb5bc92156dc791508b77716efadb3e11f6664afec25efb926db46cbc0c1dbab26a2e6303060fd9dcc4ab2e4089d2f49745ce67db7f7316ebccac8f4ad841c6bd56dadcda9fe68d8738b8ff28133b66a87063f5849af6c66515ebfed93bc979577b6fc020ccdc3d15935aba4f3d776c2412486302f869ad7cb855c763aaecb1baf5c292eb6f4b099fbcc4a1dd7143f1bddf8535ef63059ede00a4fa29323f77d1ea67b0a941dea0acfc82f8aa3cef063119a7f8b529337039853ad99916c55945d1413ca420ca137c4b479a2ef65d5209e30989f86b611da3d2514007a8af0aba59ce845901d428c995a5607b8d890c773867c89a63de78553bd3c50cd06f03d2919134175cbecbeaf212da515b94a4b8ff8053bb7f7f54396e2bf784c48c57407d7c619bfa457a3cd5d32deb1c2901917f782dd9ef3bdca3e7cb16b2af0425f53e2768148408b67004a930ed2f614c31fe28b4b9f7f00095d0d39080b18a6654f428f91182ffc569937232681e5373363f13a722cdbb3e9584f32b0a08f2eb9f0b133800c4581fa85c82b719d8bab89e156f55df027ce077c290843f0324ade8ae2955d21e5a3b7addfddad72114f2f09dff4cab4ddd927977277522232826da4d844a9545d94c434113e0e26e3a9dec3baf4b0962fe22fcbe0eff405ae0574c93c41104cb1eb9cb004ad28104b91b331c87517002d0213d7f2b88d2c960fa2d1437c7f93dd9d79eb601664adfa10cd308c6713e9c083b8d7838bc9281709bd6c22e604b351c1e3b21738dfa0eb558bdbff77cc0e7eb00f6ac966bc0b3b486825a13bf074c98ca489082fd607dd25a94b5aef36361cf36c1b2509579760e06e96ab1384f674619665d0c6b006a1ef991493fc2976066ac55bcf642e1ecf1a294679e620acb9de1e62c9cdaf924e6afd460f771ca56b4c6c5f48bd133ecda70bee25958833f40b46e29045b8e5895064f45c421630ea4a394eebada7521a2006a7848f83e6e59ffad5d4dc9eb08035455d2c65c077049ba760f1b2fd9cb7325a4a959a9de1bf86bb436a162ceb927f2cfa36aa081b35ec606d940a8ffda76598995a4bea03272ced2af71bcca35d5b66a34f00f83b925ae87dbebe1acdf06c02699d1260b997b2e473726be350033eebd23343e80f893affb7b19a9b60c3816c9777cd81b1218551f8d0aa5c1902a41e5bce7dc6feee47d512fee8b081d60452d1e495ae7a617bc3c820db86ca2f7779c22f72bcff317e2122f14cc6f45b3a5927b44a57ab85a3c7a64afab5c26b3d756e0c8ba7d108e3023a00a44bcd59191cb9e8e3da898cc78cd44d2ddb461adcf818c6606c06318bcc0ee83b74da51ac78f55cefe9453373df625a248dd9d274cb609fe944ae0db28400195b7d3a92aff3ea52a949481a88f121c1c4d6bd43f6492651b969846967b9e9b9c3eab36898dff0df988088b20925ee726f678680fc6213f15630a4831fc0359cafbc94ab750768c831bdcd2a8abab88c6614eaa5147123bb5cd3a4bd1217373e585c7e475e8ff09fc89712a8f7cd803b7b87a662c38251f7d755709f9c98677f8b0ddfcb751b3f1ac4c4aa739b1b02bcb4cf02043705cd267d2ed681043fc8f3e6d6866ded9896462e29f3e7e49183742c799c88f4871eab69c15f58f7845d7c955bd53a3337d1b2a2355499aabdf4c49acd80b90a97939ac7ba518cdc9995771e2683a00fb9ff041a15668c7f78ef4ebff7be7754baf1c00557fa9623d808c0364d7facca55467426174d0c29b1f60208f1be93798392e9e0ea5be2f0249c5bd3197fb24c4ea6940aefb1b8e348e569da34544b2edb25b54bd2b9b23b46d011af12a9783faa94923f40d5f789b6f37d0512a71ba2b9364bdcebff01215d9295d2509175080ce97225c1b684eb0c08b25fbaf46215b6532a75474c32d50d1fe3a0e853397f1aabc1f56b5a1c4e496e3162375c8426f6dc6e1a944b1e53fd60b4c6993aba40f484b5e6042be8ad7f40377705908ad3494960ebc21c7ee9b73289bc2eb57694ca41fb207d96ad7bc62e5de09079cdd24db9b5b7eb626a19be4b139d956f7be1d611ae62ee0a3215a62cd3b54dd16f932b1f195b3fbd77e677718014d1e6102c73f68bacb5a9a7b8d20ec7ce9ec21413e2b496e26cb1d8c113ea13a2e31196144421e6987c72795db284d059f190ead25a5a5ee82669910ba6d33dc926429a4d60931557e7055982cfc8faa950fdc2beb023aafa27dcb4f31b29fb5053d9380e4906a89671308dfec9eb692a2c9ef4a3c8479ace39d2354114633efdf22710b156ae32579ce570e26549af926978b2e40a5c4dea3dd171f62a2b232d68dfb7ce392a75d8d0065b14543f2fb8f8d079d6559de970620477b2565d4244c23efd7ad80cf86f09a29882498ab2cc5520d901478f81d4ad4201c526c375521b09aef883636acf7c04f0bcdb055b1024f50f8273416fc9cfed3d729dc20f6c014f3463b296d1510f0055605a9bc9fce72c44676253c5f3a77d5f27091b8d68b0ab9d24cb212bc763564f12cf969985b3a940714fd9416ebb037f599359fcb223c4f056dd3188258cbfdb672038c02109d7fae9d251a8e412ba15280f968bf39add3f767c65248ab7349829aa2a3eab177010074510bc87a120a1e6ef56215879d4dc2e0d9dff12062b1e56d7a490844b84007c78f6d2e3dfcb7e9d2b37dafc67a7af9028ca2e2383b31bbe05c2775cb607c07dd66bca48c0cf678f4c606713c7075b2954167e4e7cc8df3ccc596083e79283906e1252ff233d6c8fd9858b9f021d5d6c8a2873b9069350ff61c263a18377351df196d0e958ef58387a33c2acb74846fb7e42d32a8f47c257c72cc8809dd12ad9b08f2acfcef6ec86271b74039e328a9e25f4c02f5f233c7a727923b065a1db2b5e189d07649c2dbdae66c40a4be24ab39400c30489590d0ffa7da1acd3d2f84ef0d31082064759223663b3182705206856c2be9a60ea8b401f89d27cfefdf8bd32a34054be9f9f1503ce022117575a1b242ef3b9ee62773d3510357030c5c6f3e8a71e41f1360df56f2b728460f4c2f6a3df68e465a6b438bab277d56f5f18e13c857795f6a37ceeeb5c479d95d9816846b8357d4d167a3553dbfff28020d8f64081d2046395a51d48e3c891bdec3bc9363f5cdb6b7ec16b24f239249a7c3e8f3dedf21711940807c70abe7f2e5f238d2cf46cde17cb3fbda8f0d6dc21405887cf35a5aaf6f832dae037eabfa9a30419d9c90fa9e101357cbbda757de0d9a4d4847cadeb98274e6feb9c99c3fce389e2c9cc180238f348fa10a0462d9cc3babb47265b6a9158bde607bf17c4d86cbb79687a24e26278ad14ec64468d9c1410ea30e6441806752f58a80bcf44e05c1f882bcd516d8eedfc220b4913e427988529f6fad422f85c28b4742a39a493786139d7a314f36fdf849c56286c3a02bf17eaf17a22fe1047be03dc6a7d2a098e55f04303f7cad07a62bf07f5990d177fafdfe2435a40cddca573006b843275d9d3e8d5c16d7acaf72dac46185c415181f3c1e97bd6cbc3e940d9f31d61b66dc5bd9c3212009a51597c669ee7d66167769a79abb5e261162ae579ee3bf84c74ae66e94406e73a0c7e18f43d3b72f5c912a7da8d7e5843aa0195f4cace4ec1c593d1e385dee1b3c7d12dcc1307f7b25dae68d0df9fc41fc75a178642b3c408d4ff6a3b0ceda374fcbc30223d3dbfb0577f45f0f4556b138983eb7aa9bd21fe076972d97f1bac7ae9feca08b0959af3e9ee18396bc5d99919477863d6a58b2eb0f37642d31d70b206798abcbabc3215c3e8fe063127c1646c61d6ba721d493296d7f953e4d7b9ab0f3d1811547273b79ec67b0d19413a3dae05113fda4b4ee674921fd926291e51bea25205c7ed5a00a09bb3dd7c327ddb6c7cdaff6639a3dbca6d2bb309ed615604a39a7934bf8282acfd5a419b07605d5d6b2cf7e2c207432468f52fbe73bda0ca953e6ea1b79eeabab6cad8857312a332d2773859a059bcfbec6df5d3964a6f12fc88d323032d48ad93ad74e47e87addba31afe7eb0ef98a15f758263b9fa08815ac77a1ad6ce7d8ad1961c38d61557565b798b0e5b3db19fd96871fe7332dbc5f54bee1fec1a2c765728b2af6251e75e0653e44cfca5c835417220a2b2d7accfeb6f40d7260583a4c5d4a5667f4ad8d80420c62708b00b4d0f534fb8ecb32416677bd40a6fd575c53b9754e36e2dae8d3e6b13b718b31f9855fa457f2ab685784ea6c97bcd63973b0488e017a8d45fdc5ac1d03fff20b0cb60a153d480f384789a7a21606546bf1c26bad466378e4875b329e3dfbccee9ae0cbf5244dd3d464a4e60de9b1bfc06a483cb08c121c13cbd19c906ed8f164066ca1b3bb9d6521c9f03ae65789216e64ed8949142882c431e0c5f4b54af95059412b4b66fae65349eb9b30f23336d756b3c55067997553d95b1f0222bcd59fd12a7e0f78070d887fb4a057bcb2ceea17b53b360072e8620862b9407c13ca5271216166a2217126c3e719337194878d467efb9898be620181974926dd3c0ff88bc6123116df405bce631f52da76d293c5f42331b78e6acde67cc48e52b8979b3ec9dfaad5ae71e43c8561c1103d64249478eb676a63a441c03baadd6d32ec9d9bf06c9b17980a2e7fef6fafe7b7682f14b9e923cafb68c8532e6e1633c648ae34ca2a8d11d34541a2db2c25c5d83e036b6fb40cea7e86883bcd86f97c69a7850364d7390b4f005fdbb624f1966137437e6534adca16e0c871d440b4f747e32ed62923015ce44cc5a05bc5be6097a06035a933dbffd67baec7ff477808ae6449c71e6b6ae26799c7ad11bf59554545229569550a9eb3e867fee7d52edf7f360b8c0d3a3c161aa1b0730348b01a889cac7fe047878f239cca06f832ecd63004879c7a62d36b5e268d65ff1491b080dc5238165fbf4af3128d1b5ae8e8cb782d5623c77bbcf412154b239bb7786b7705870a68cd21023f2cd56f8e0474e2943b24e53fa6adb1d06dcd3ca3f6c3fc2d55bacd2dac19d1b3d3acbc75b68961d85928c6bd1dabdb3222f313061e062179208c201258b8d8dfa2733486ce3f85c5d7358203d4fcb2ac32cd36890c547b772e2ff347f58c43d7e44db6229eb6bffe9c911557843e29153985e89e00afe4284e76ebda167f4d2743023859fc647b07d6b655fc20dc962f812566aaf9e5527a8578e35a7f13d10795076af6a0126ce1b4230c6c5547a1a29fffe7fc04878f1e6ea6750ae572418a4c81ae7907c849f115ffa2b5a39df8bd622e7ef5874076e96c190fbb3b2a5d05c6f4e4a7df516deebc49f31c0ed7345ce0d87110a3cded5b3e809c4539456b53620774737e722cbd3a6b74554cd7e1020f33c021360ca841e256fdc80fbdd0bc5a588c255db0bd1b101371892bd44b6cdb5058e6834426f1024c8ce7b27d1bd079c9c1e33521f580f615a33aa621cfb557ca35eea7dd38d62597a700d48dbf75db4aee091b6ed158a3a33f2ca07fa44fbdfa7df56db7b6b461d2510f421e8585b47b36221ddce1e6f0f32fe418e7ff706df4715e403ed5f38d6346068cb1f667acf0679f1a1fb5a4af1544b5afd441220d03c7dd2916df0dba17d97b103049bf6a5583a8eafaba3f217e6fc21ee63086c315492be0f13ef7522f473bf8226ca6b62ec0aa3a3d5bc3958e3e60ba9c451ed69bdbec4fb2e7d7099b3ec8189fd3ea6225d040969e2b315c83fbe7f31678efdf50d6ca56ca005cb5b8144010fc15267d3cc3b328d5a32c53dd2207feb95cee0c05c811e57c0aec8abc7993a6117a5572fe8bc09841af2883e57f20934cc95e482fb45ab8d6e9b14da6501e37bc186e3caa7f22e3f9f10caceba9e4486a6bbef7dbcbd778c10757eabc89968d88ee59a13357cea24d4d87edd1e02463ac0dec01c6cd6db2bde80a2baa817a2070399fa1896ba85bd72895a5f2799383a45ac77b437507241760c12a041de43a00f946c41eebe03cb11cc3110d25f10f514a9fb96af3d8b0b39916fb4eb4b127eb77f456f3fdffc97527b1c992175218d1ea304d2c0f389ca66a663611d4cf96edebef9cc97e06755e100e58e6245f868a20546a2ff3bc06f5275c9b46a3d87332d9735eaa0c5b7bd1c0e28e086b54937fae5f14de61af6389ce36eadec8404c37382fdad86f4c10da4a99493900bec7603e011098d3f46c30fa59dc991dd1a166903ab65eb5a433027e4ce89bee50f2df0af1975f78a468cf333344c7c65c1cf82553c6e519c7f26b5904b440e60433d1517f139880d9de2556f4ace899ce041fce2761607742d374215c490690efbe00e8b0461a7c46280064258dbd7bb08cebaa63d1c7ce43fadc27d625c1814b02ac17f22689fd8df7787e81015c29ca2e0bc65774287de71c3702e45626fd6d0857d91324433bcfe1b2447efdf4526fe7bba66d98478f587a6bc5bfade54ded9b895897058484aa462117280e2fe108ba5ec5a3cab04a63cec66c4b48661bcf07f8e83649f4e75adbee76fd00960b9b2bbfa38416d7d444e5ac58a22a848ca03346a5977936f9856a37902bc2f2e263c5056222aafec19cf8c8ca4726ee364fa6b42a18f09aeafa8a15286c8dca1c533ee49e713105900ab22fd03d418a2cb236c80857404f8db8c08d8e415473aa99dee83bb865b2c27ce2d1c0dcd0106711222fe408a5d0e81ec594aa0eda77a0be5f9640b4e128e8af885038815a6bf1c147effab693aba9d076f234699aa7e7d904adeab69d99b0bdee3fe8747b80f67e5ccf44d61d8fa6b38c5ebc40bfcc1164f7e958985af5fbf6df36c1ed875ff00c55451b1c9089d20c8264d7a4dcc5c799e5b02ffc958d934ddcb8c5eaaf02adedcdd6f68b17663b31fc6cd1e08f3e2b57ee954d42865b1cf5db158d7ef6a3950b77f0376b0c8bef22437094a0ae48adf70af41d92c6185375850f5e865aea8f4a47e73daf3ebfe3d4492ce9959273262f82f681c0c9a931ef5395120a59c94d18084e225a8967e5ddff6c3a5378683a8f3251ae89f5ec4f4b19298c055c05049d6e5e7bb47fee996252b01abd687abcb95a1f9819fffac837bf523e375d37e66e54c461bff23958bc694d46023f1deef0b8b7b413b27cacadd63f145c5619734797fcbae4c80395ad45345ace6b47002bed21ca7b46703cbb32057481d7f52aa39ed46d6c9806afcb0a8f170fde3524c3b891dbcec036a1639a8c10b273dd762823dc3db452cb14673af32f6bd77db8a6014c3af5c89e0fb69041286a0e12ce9050882a3b2f59eed1625bb161fb9c20060e0285030a8d1454836231b0cdbcdb8773b40d24ea35e2f6b89fc01a41fcf789fe709598387cec8b65597150144cf8f2c4e8f10f69bff735bbad5653ff99e71e88aa0eec67e55760371f2dd41bc466a8431a4882ced04df0b1d97c5981d8aa07773a6eff556b194ff6718289c6772dd22c3dae49f109b7a090492cb39c1e3cc1d783c2c9ae79f6be1efe067d10175b4706f7b72e20a6dc87747f43386b82c702dee3ca5fa2d055de71f823f15660e51ff546135395cb6803083b8a661500aaaf6ae3a3f1ad6b10197858e94190fa38d524e5eb60920f263358c2d65fef9c5e0e6a0c0ca7063bd5ce4a853c276ee2553f7b7d5412355c85fd553df1befa6fcb4950f73885d9f313ce949692f2596fadcea88795fb1cd3cb6530744bc80de10e40139409111caf2863c74b560d49eb449404235abf2f33a5601b48d16e17ccb49b4c887571d89032d9b800af6267f930152352bc2da7934240885104df321b4203245cfaf8e50bde2e96cc2dee48841cd37251873f9ae339d33d50d003c4adab5c1d755fd50c6d4c2fee71eb491f669481b019a78d1d1f2a4987ff0ae2e963f022c70fa0ef8587b0e97dfc0b30b72b4298a88f88f2b7291a0175dc5c2e62856c0d6d208bbe0159e293c1d83aef963f976df1d16ce5357a0440a4ea4a61d09d437d952ca3679e46562fea4115555115f23823ac899e4fab1b9b41ca813956efe7b8db58d4ce02339f3c24883b68c7e4efc3ddaf6650594474b76840bf7e07984dd05317c67518ecb3771e85fbeddb9a23dff9628f09debf77ecf42bae823e2e9af8ad78c2ab74eaf8c86b78cb06b2e39ea5b8ff4dbd8874cef173d6e93ade9d68c7ee271e163a587c3a9c2287bfeeda7de14ed204422c2c8d7bd7e7c73b3441064192dbd04bc1954678deb9091818b2015034e41a74ae8f41888caecb65853e7bdf644c13ebbdf7bcabe7d7a9d84178508a804436358f2b54018b79bda797a7d9030ac930a18c362c78a92feb51262a54a54b1b754a01d4d779411c18eaabaa974ab7c5a014588aa0ff0a2fa9bfd662134fd5d1fee14694dca83d3f13a7049c05afae0fbde75a2712c5ee998bf63bf858794996588848448420921ae61bfc80733db6232a679104f2dedf8b27cd950f4b938314d82f7d39368f8a01604faeaeb3d876693920371eea9d2872e1831a9e5f8832d3f7def29e8c9261e4a106b2b86d8d0d4c33f151f2a5c6c811094d3fcc4d38376dbaa34684018f457f101ac297667e3f043d5b367d1d6526e256ba48281e995cfb1ff070d8feb3552716f4304026b9d96271378aa2d5263e89b472560966ed45fbb57b05bcae5ec840cd5e4ade068d57286fd15bf84d527ce599e57ebfe8d1a4e6b6a724ea5f6c844979866586940ba58dd242289a3dedf54346a636a8e275237ed44267ade6c0de9199c8e25f4c8e050d1c286b7fcf864f0d8e8b2ce98993acc58811e0c972b961e6e8daddec54fbe2ecd9c57ff9793f18bd17acf5fa9669dbe28bb5fe1beebfce9c995b72f95009c8200c9546a68f2d083eebe0fc159c7d2d41836df4e8bce3fb14e18800b3ca504ba790801ea7e5f36ed9b1e5b5d13e8bc8d18cc0f7667935ba765e98182496ad522c438328bef06865868fc675c3db2387ed6c49c8268ed1a8a0e29aa84e1c2b333a09fce77f9022e1db34d33e0b1f7161d7df72fe2fd2f33b92bb3314fb66cb770c344aad46ec938283b7eac032c13af1a3a0688ff4da39ebf431780932f844879c16e4a5c609502e119364c4e397f2c4f5091e2004f9cbbdcc062357c8c7535e664c03e281ad7888ec862a7e0bb66734f969c619a81e72a7ad496842eaca36ac4a6e75017ee5d2d7472f3bac45e9e9dd0a10435fa7cdc588f3eef5d9badf69a1bc4eddda6e2148dc0745d3d2bdd0325bbc443addaf3b0465bbd18d786f4c8f7debe1f6e2dfaea71c7d84c3c54f442831b7846118f34ce99360c14184d5dac85ab0b3c1818ad6a4606e38d8bf20cb0ce7f4b318f908d1bd75dff17b53d046caf593178797e23b85c7a1eea9bfc2f723a2ddf5dc7a452301fe8860b4e9d4d93f5ace494e99c5d9a5c7565b097c8315a1e44e9ca96d6e7acf39ac7f6cb3af742b5d6944d48e43dec822a71dcec6735501e221fa56f5c745308bd4961dae1258022c9b83516cf138c4077378faf09cd67b3c1eac8642d4176ff0b1c54bf730c1db4f6cc75dbe5803c8eb1cf552fb4edbe9323adb115c88692f84c1703b7910b229303112c945741063d4676641586995300411c7be5ef14dbd6a8c0a98761c1a4c783e3b1de4099f128e64bea00d68a3764af7c94f7bfbb46a8874a749a33f1080309be707392d98392ea9edc5fb584094219f9c6995e4457e1597ecb8899e03f7de38cf0ee43c5a602f0608e92094a7a70e663458a784c6464e8bc108f0eb687344b95bc5ee99974c8c47307d54089b130374de83b9dd5190ecfc78e85ff1a981699ae106c63cddb95d0fe579ba5af354d235981aa8930711e0f13e6bd96f4398e3398aae50ee9ce02303568bdf263647afa85dd96435d750fe8c1d7527c5549b3a41cd65c490cbfab8c92e85b4c15cff9c80d2296ddd79406a297fc19b15629ac10de4927f1ab125fe8065a75292ccffe52259a08642d8b4b8f8ec1873a3f199b3df302a8c2e8219aac05a8449d8f9921d59f584956b712b6c11913a8feb3172303a471ac7d0d2e7eb520f4ae74e8f05bfe13c4d0881be11d5b84866ac718cb6e36daa8b215053e0a9ea7005eeb17e0d4ecb551967934adced3a06347648fdd0cb04e84a76870e1b0ca890ab1e45d49431895caf2af9397cc14f699f57c7c724170dda485ef8f3fe280f115ff4c1a8f28c9bd309d6ffaeea8aab5b6fae251eb644a41afb1e368babe83eb1a37efb9c31c874afabb6c9d4719b7a5b35a1dd209637794cf690ec79806bd168a1a4dfb86030636cfa7f099168a45a1a85bbc8d3a50595ca1966ecad3976d797799a4367816204f3c041d7b02cd684ad1ac8a45715f52ef5ea2fb671f76c72f0a83eb9b2ee7070606a8de9b770ee36cbcb9ab6213ca0d3489a13abb69e1d60eb97d9e147fd701ed056b48a21074e5df8add45d9a2534ce5a720e8add01ccfec06cd982b2a226ce5211190ae142dc039a7200948458e0c7f91ead41cc89edf82a4f8abb39207c5cf7808d6a83346fa2995ec28094cd15f1be7bfa5cba38fb6f8bb8ec84ac5e5d594b38cce4dbbac219b011de7a357803a61be09597fd6420744dac3c489f89f3482a4c360cd6f961737d98dbe401280525693a3953af0c96405bb3a59924959e18693421109e67797f9ee3768132350f2caa121a45d5a127fa6b72aa91f3ca4a03ccff309fa676dbd5ebd1a058934ee0f18619299bbd63b0de2fbd819a80b3bae498e0a2e9bd6513de8984437c21a63acc6546508a436b928f9659c0720b4a76a1dfe2efeca111fe515683364a8c71cb1f2fda30fba63dccdd83fd8f14923e16805a114fa0b1d21866b181a923271eaeaf0d82ab73f2dff64303e6fb5ab5e8e61729bdb65758e30d3345e931eb6c4cb15843dce76fc0e68e9200d3e8f3c0961be351094ab9058928eb6b6a34a6462382769be9ad22467d6fcc59744264ef06e2805823eb60734ea057e57b4558903bad7f048340ef030a927291c122e77b89077aeaa5ad6c05745370f844d67c0ce9795541681d0987fa9c2ae9af62ca4d4182f7a6c7a9f066a4e38fa05fd74457fba789d13188b3309fb7b58a44fc1c827ae6fd47718cf7a93dbe5f196d463c7a7865ab61b597c36951a8720afc65a55b42ebb4303d608b13d66285ba8a42f4c8e8fe5b326e5844a42f3e25014c777a3d1ae17461d2e58ed02285e7a318b1afe87bb94b390bbbb9c5c212b59f9b3db9f54e38c807e5a8d22a1900740a61e910069f3ff1e6cc68cd35481397e9cad708f24ff2b34844ee5990cef3ba46db3bf79c5386c0d6be5f462461cd1d38ffcb88392ac574fe8dd103b258e197f5379ea68533f9da95f3501bbcf396c88e63cca1a251c9b79df787084a81548fa63c536f406bd9e995381332c98bf7995aa154cd4bde3a33a8a538f600da7822f8a86238a361f0b2e2dcb0e614859ca31c505fd8031402830d46ebb8319a84242c26f84bd0fa0d15636ee8432ab5e32dee9b3b437df33b6b55c52e00d4835341ce9f92f83e90c8610d63f7fc7c6c73020df3d529e62d2e83296f2d1e7c93e61e98f1a9bb8911567a0a3d19415f588973c6990375b62ac69229f171db23044d9de43e1cff16fe887677774de2ce235d19f1625340818a71028746b8ae8756a8df051b925e6e4bce47008e0b5963f2e37db73395e74d700a164875cb26e9c2b36809744e2cb430b6e3b2574fba8b15e03af56d766e9a2719f9dbe73b9bde2203ebaed9d83bf0ea65cf8ecf2b21f08b1875ae4c89d3985b8a6622d92a6b7ab17ba7e79c4a6e9d818092c0519c0101ce45ad62d39b7f67970aa5f8d90eade9de60a044f129d07e50fb02e3471e6c0afadc5f28f953688a21771ab6d0e85ed491237a888086d0390e7e6f3964fe92fae2ac191e35a6418c3edb8004f69d7c9d94d56917d949ee141efa96de44386723ff691b0721041416b20f87726ff0a884c4f6e16a61295f6e83bf6789421be101bcd2b581b5959ad25efbd8a84f0db6193b77e7e91bfc127c3fa3d6ccb31b04ab58a14796dcf520cca442898592dd54454d13d34afa1517a26cfd17a1751b2f007d0a84aa56e58e31fde85095962570de6d6e0581b95dfb169e0b684ff945d893122daca7142c95a7cd6d4f4e321b17c0cf78b62396768c108a4733c48ac20c029e3351f76b039c8f1367385071759495862f8e5ee180ffcd0a86801d31972176aa2dbdb4cbbd269a80f6a4550f621cc77f052154ac71355ec69ec92b1ff8f5a59c745c611c7b4c581add5ca17bf01fd3b5b48a7b55af3812c691534343f26806154171e2cf01c29c7ad59e03fbe5d967f077a534a975da0d4710772dfad73d59fb8722e52b7dc1653db395936133cfd95bdc6414da3bc0be6af03c4005e8f735f1ced52bc8f24fc10d87489dc9bb1406d86f7b3a58c9869cacd1d9e24efe9159e76992d58a46a19eab09b0683bde2166bb695ed497732165a3bf66fab2f2e916f1ceec9799cb2ac8f497818d503ffda50f6ac64e1cd32a2dc94afedf848e8190316a1f790b0d0464bed83b5ef914c5df5416b45954f7cad76d149fe06bb0d267a8d8b3fa1165dac3e5a1dbd1f6167b436955e1b5cae316b37c62627a441738d9eb5eecfbd5822edcc07efb6bdd9a6c5e0b1c3acf658fc92853f6b33e66acae1b54338f53a38d3dad1f264b2fe759b2b8f2a6d096fa001c37b421c94c0493b3ac23546a1f6c7e1b4d2fbcad1e2b9b4c099fe248ef5887de338e9fa3f3c35c2211722c754c79b88f4694035025983a10aae714ccde57801e30a59ca61c5f0f7771f61def3a71b589e7e7ad4b543b53a84c6c59406a6d740daa0382de994b1b2914c68ed05524d7b52ec2eeeb8237041cdb8ec9b8d4d3fcdebb4d8e5b6fd9c216839b2fe9128f7499139644df8acecb7d8672b82abd3742bb4e3bfa3bd93f4572d12b52dd46f25a2f0e1edfa6b51af0c77f92916a4ce0117a5a8c50ca39ab9a51067de84affc1119ac827f971550eea2e56234339840b6b2345ddf2f3dcae906066f71c329fcb774fbbd1dc0f2b48297dd1fca8c8c95c3783ec449528b4ace31a1eab314dfd0de04cc9a43a182df1ad9a9f09739d28568755d3f7275f9c6477c7382a0fddc5efaaefdb9153765c8a20b2fae10e9728490841f934942577b586336961f9a92be090fa32d2b2091675c67c4e46647de28b1d58ea449d57b1a8928958faf5593ef9a2315418e735e858e2cf7a9a9184e6d9bbdf015c05ea60ebeb094ac3a481a0c4f372dfc83068c80d2ea9f53298d4304e21b547072bd3f647845e31c2a9921e5608df4029ecfbeeecad001de6ae721699d5d5aa76f7aed093c120a87e8fa64e50b66119978be23f36f6bcb95ebf5f1e24f1828d978be52ef8a32cd3f0b94b44bd7b5d5de30f0b16a255d0f5745d0adb6f8bfd7747498e3abbb0c78e8c2914e78a3fefecef85882adf03303f817e88513a4c6409fce28e99bbf290d4cc97d680f72008adbad7d792029d3b1732bbc906ce7f3e6d70fa1e0827380c20ff99f546711eded3288be49f6119f6aa95c47ac814134b74bfe11bd08fc28dfa7604f71f0369b9a07922e8992fa324d04810def079cb2faf1840ed85f335bc83597d3c9188bbe09588f3cd18155ab669bd067d149ea763da1bf21e507f7504aba17443d8e327035be96cc96b18ca4fdf9514bae865b01a7e3ceda8f895c09de19141312a02e6a8273f575a7a602392ea1712c2cd6391324b3df453b376678b08cceeb94af6819bd8621f35c00b872c0ba2aa9bc038adba0a5a1cfd86c3da2d57b38a8a1e70642d4bbbd9ad92c36e880518a0ccc78351f7b3d36d8ee35eff139f6c1576644fbfcb64ecc0fb811808d8d46b33eb858842dd64bfde0081fb234774c94871abe2c5297209b20a3bbb53170ae9bbeddc48af3924adca9c897839f47e4c3f09571de7c7440849a942b536417246dbd4122d717f8bd995589efdb6d7eb336f9283a5f046a24f9d04d20f2452295e9220a08076376d9d239f833d1367e0c3c0f8d421f1e5305fd658637b17afe080e1e5bcdfaece7312663a6cd4901a13ebb473e3e74f3eb0d135c111177c1183049cd8ce935b772049ea8eb45e311aac8bc56148266c78a9e26b087564784aa036e7dd849ab33ac6951a8763cfdbf8178e8ad9df3415dd0dfe9d903f3644d42db2a68a78789a5b391aedd6a187dc9f51459d60ade5ea3939dc2ac568e1a6c5b61cb4800c9f7bff73d7d6d3482e85c32007979427fd52801c4f41242e2696f1e8938d81252c03339c3f59bfa32a57a573a7ea01cb23d174cd0fbe6f7b4f9a1416b851a0cd4d0ca9c6ed06e330319076354b20f8833831da2e7e0781a4fd310beddc72d836e39f1c1950d977d826294d79d8fad86274b59ec3e7f3e3a279ebb8fef9f91ad7d6081aba109158bc5ce92a751c5e8f715e00a683301ea8b6ab79d0f4103a8be8e663bd9a36fd59faecfc558d905c4b81b916584cd4ae37cb249d3415f5e12a46e8205461515aeead3160f8f487b33699ab5573a5448e7c27e009b4bd862aa3777799a4fd886381dd4976348d9f95ec825bafc92f8716db5917c212c59ab0e1dc9f0e28139da8968b9fd3db90e08b7a6b81eb6675ffad835752f2eb2d68f4bda6b485a514c85fa70974be954d3a650622141ff8fb0c30e5854022276547be6d920472c361215a1044ec59e877c3ea1610da97cecb826c55212890147a3738caac15c7c99aa310db357e5716c175da2dd72e4cc298cdf0fad06a116af52db28ec3a00dd85d5cacfcb933ad4f143d8e3ed90fa42f679d965c68a7c9d5bfb799fd90029b2cf42f98b4f21ae43449b27d57849e4c665064b415ca6aff013a47915c997ebf8c89a41c0508af354540e7c4f8f40990ff051f038b9170299f52a19cc8a0e1a2fd619415e171c0227a61d88d052ec124a962753878f05031f6e99d6b34e5fbc66f0f42257d25f5a890333b846ebb11ba5b2f7967aa03db6f03f0ae53d4c5b5bcb9e8f5bad54bdd9eff2630dcbe4cf3a787e085f8afc01054534daf82f5cae5f4402231849e54d4b65fac70e356cd3253530832d193ac7fff9f31de9baeb2dc7a20e8f43cadf2ab7df7192a192d7e59dba16854993e32c97036e6dc0107fc8eb26b7c2e86b2639103eb374f5bc4e9bc02dd802695b758a5895236256ffaae3ef769d09c29261f97f7861cb88510e810000dc6d5de473808529d03c9d68f7b44f8298a88db466eae5cc77ba9adce73d837d7049181253d21a4130b7f17d465c6b07a0ef0ab5b7eb2cd55537c764eac391c22ba9bc1e8b5a0eb50a559150649c2863ad253c27b06ce39df7ba8eef347ce1423456a6b1c310d8f8464c6fc306050a296161fd3643039d6c883801087a8e9c3ee9eea69cbf8f0ff0d73f3f0abe91c4300604e6264a51af6cfc15966ac3fc14ddc94bf1cf5c685555bc173a56bc157a3f544a8bd567fc3beea38b85f33fb03bd9f3f1336da3751260ee506e1dcf326da356fc45f3db6ec9a4af272f6573af85574340c386b88e4f308c34e9a46fbd8f7d6f1df64d9d24065d1bbab3884326d3b09886c6cc8784b55a80229f6b2ab3025507ca06c9ee4ffae9b89703508f2c68fe1b5e618536e7c58da34ac5fbc572058ca8dc3a1abe2022434e1c7a0592c2101b062bdaab151dde1aa31b0258ff4000f4b4ebe76f3a92a570891687650da8012ee81a01a6e799424ccb45826a564c2e656c636c8145353e9152d872c8a8d27eca0f8740096b41fc5cb484b0d73c167edbbae813fe5c1a6d52d4e7bee6e3d3cb890ef353fe8caf4663f127f4a1b6ab7c1844950c6e0fc0892c3b0c813d373971251578e8e4fd6e67ec0657bee8618c5032246cb8bb6e63d82e432d37e78426955d64ea05a092ec437c6713b72a956a73ba2ef157cc8a3e6c909962329197320f94dad76b0cd31ce5986aab427e1487a2443cf45d793c9dff0ee221904decb98c9554b5072cb7ce9dacd630135681d46b27f027bfa11c0468fd99485e0862ce91975bfcda40cc2079c793eb5eca60d49bec62055fc45810b02acfeebb40c87413e143dbb5e5e70d95b9a782b2bde198de051865d9b30f2306d2830bef1cbec4d731492eee580e2cadfc95282762ca336aab29ca4e7cddbaad4a09f2aef04ad7bcdae643a1cf9f3065055bfca4ab8e870b885f7947a16c061a628c97ce18e46349540b3a7c6b605ae2b7ef0c14e2d487c315aafc6e59b1570e5886bdbf3b67b2ed51ac5a21b3e73b86ae16c4f1619e82dd9020e7307521d0fd1b9a259dd9c1ce0b472031894a6b3c32e1ffc48651ed29ef7102ad9e04f7e6c2c5070833a6667bc45b44b579c546f07eba013b594247d00a9a35d139373e8cdc240a2ff56c4618fae4245488a0fe5b2be8d8980d9115ed81b19aae0cfd08cba6b683950122b5febc71a328878f4f4eed4e611f40b51035bfd2d1da0615787d70706ffc8a9bafdec279997dd2acbaf18a172830624b9dd21bae59432748f5bd6fce790a6e267cb8a01a0074237290ec42c3cc34d95fc391ed819c945cc8956ace8791d4696d5177e5f47cdb24993d9e55c596c00432bbaa8576c94b35c78f30172bb884de779d339ef88001a871ccdfc8f541789c4ab22aaeffe7009863ae0ffc3c8f34011438fcdafa0b6483118fd57afd56a6c5d39b0d46ac8d33df3e05cb8886f38de8bca4b8a0fd6bb97191cc336607b265a12b7c9e1300171be70b4b83ed834fcf3ef7895e1a7ba48da9c18d7acbbd9c62791d41c0fbb570dc560bc15ab3444a15f46b385c86d9cdd25791864184c6cabd3a6a00ae5ceb6a03786a2909dd2b77460ebe387007343b21ee6068f01275074d7bb7c47caa5a1e29d503771438cfebf2c9a14e61d2ed7067b71a01f49b03d9dd59058107682141493ffedd1d28a073e9574cb75fdabab1b936a5e8c5304f905a4cb8e7005a13d5c60497009c62590e09ccd556cf4a52e551e69d38c730400ff18430740fce21228ff22689a165b7e55fe6bf8a1c01f5b57c53d94c3ca93727c15c3742c891ac49816c188af9f86d0293eecf543e6207efba3e8e13a5d9719e626c1319b53c55bf7f8436609e001074e702447b49b05fbee1d8a776f3a974e7c0c07f3ee06da18566f737a9fa54c8943e59dc6abeed53acb550a37992fb7937beb99708106f99e72c7ccd528b1d6e75134b59997d487efad689d699b6b46f78cb6e9529c32143bdb0596d07ca6cd19fbdec76500486f99b6445068753202832d29ff91414db8c9a261ee1d1da1733ead53e4182e62a039499ea7bd1f46f70df1190fe49513b24fe5780ca597dc3fd1b9a764e501dcb056e7e21a162d8d1c14ceda8779e83050cb96b3a8ae5a11a10dbb8d5f857efe0f8c9e06628bda0443ac0092f73c12c628aedfe3b95fff91e722ac84b122e161bc92026f3c68bca424c7111f2524c621d7301abb193dcde9733f50949baa0c2613706a5955173c2b3d4cc130bcb202834b8168df19c6a7e5dde91f33786da49c9d7fac32bd5d80bf7047a45f0bad487117708d011b71376bb2f25a2cc204c1b00f18f00849dfc6ae678b7faafd279f401042a4d313192a6aaa1baebb3f043b0e0795bd2f6d68ca67674fdb8bfb03b8216b15e45da3b284f90dd75b9bb162daeb07ed676c133f160ee078a312dd25b0f79f39d7999e5a3c22769c74592715c4a84a2931427e3bc4e7ce32babba9bee7c40089931aa0acc5bbe8763da5f2dca6772a7784b18555c6dd23d2546961f33e2ce765f58a97ce8cfd4f678b0193aaf92473c69b65a8243a9e316a317c32b2b1ab1f97f5fe23445f3fb94191263a11b67e52eabdec95ade3d1e9d1b3156f0171d32e6420feccabb1ff5665c2b7e3dac8d2e0a89c629279c5b4ac60f33e5ef11e793f81f9695644be1af3d8d8e70f6599c8054db6a7774c4acce82a9895bbe18739a37880ff2bc1a0647243815f7e47812206bcb24877034a8a56898a0e70a606e3cff436f2f0c8a11b73a6c8960bc6926bc38ee37f2ea293937fdbdbe74b5a91245be41c21f0c31210ac6bb7b12188ef444b37cfaf5cdf2dfa5215f23c657122d9b4424b2269d5789e5f7afe80f6f8dd79e07500139958881342a3f7c04ed13e592184c4a0b63d06e360f6d78e0d69edf9c14dd7c6daf9150722e09c491360fb9590d7d06e30b6fea1ed77b381eef83d938fe0ab1b2214adc034c76c8c3d39188f47857853089c37eb95845bd3ed871a992cbca78d546185cd364ecb9bddd1ea2434805a6766e5c178315b77d59f3d1e001d7bd374e2cdbd6c2159a90b3ee9b0481db5e06be9a80990c4a737c9822df81b37c40638fbc684f561de846dd1b7cf09c39c6fef8145671c0592f122888a5ff74f48e299b1ada31e42a51981c6a6bab35bbb4c4bc7db9dc9510013bb72b1b66be25dd5917b04d2e5295ace1d55612ca47c5992de8e101786f4955739562ef150da6b163ccfe4da7c351af20451103cae249c8f3e8b0dac7a61410ff46f4d1483b80767302c874b39f77f43a1ae3943c4b0d0866238dff40c423f0ae4b3d13aebd57b38dd0db062a447fb253367aab7af933f0b3ea814299c498aaf80d877766a21e57417304b8f82b3df44f6e74b7c492cd6fbf6f5ba2f018dbf3b2ab11cbf5d4e1f403c8a0145a7650b341a86c6fd973fcff2791ab9051f144580a3abae9df827ece994721dc56c52e10587ff81acbcf0d30a59daf2d19b11b969cb955f5531342f878265eac57f8a95b60c8ee62b82cd11f7d1f8a0b5dfdf0e5f9713182d90adf5413fbbc280b01cc8f9ed9230a4851dece961cbeaa9c9faa65c69fbcca1b5de638b35f56ae48eff5bc8f1a54683b6d2bf145526a6599678af5df0790d0ee50beda8b18a814a90e51ad800baaa6dc12617e2ded3ff76f25df01dd1456b39bba99279ad2136c35b36df65e7aae8544a2a6691ddfca9f6e228396bae0a7ae8adde314c237a0d925fd52d59d97f7246a876c0dbe52df29af4c568c1a0357c2b6a957cabc46b9ead85b309526430ee9efd02f011eb603ff59d2843ae11a68cfa378e398dd2bf1dacf36b5c56694b1361d3985d457bb4fad299e65cb662b3e088c19cb484df60e543b692ced26a9c182ad6ddd8f6246d5c415291f04598c3ba48a24844073a01ae4adb4f75bf5d171903d1072b63c327e3f67f27ebe60ca10e57a7e4b787223c2e1fb2f9351357d95cb6b048bc1fb844077b7a091efd71fe36daca8e89f51e83dd012051eb932d8923dabc28d85fe6b5b2271a18ef9f76f20ee5eb92e98e9d1270fe1836d99fadd3d901029f0e65e75582f1ae75c445f61fa7a468b51dec53a766889fb6a760fa67981a3e6002aabe4e1ea87c943c2f4ec26ffc5671ae7687927ed1025f2977cf5c7e6e515783248277c4f6471a0c1a66442a9763aa3bc3915440b8489c0b08d3e44835301b5b66b064ea6d994d9925cccfe55a4a5d7b8ec13a25e2fa04ec5c2611ec8f07dd8832ab7d0aed3220033db6965c99178838b16973edfd6bed92366482bd732dc0a557f51f5c78e11310930c50f935662e38622bfbbab8d319b32de277804e714eef99e0db684c73ef1ba1e8697ecd4996e16067a5dbd7be7371ce482fb49553b9e0701b690ac15fc4037691bccfce46c7258ee23bd2e152ce11b9b803c839aeab001a0a9619270125e415273c462f5bcc28086f0991e4ab4c443fdf0bd1bb5af7ca1475e528c0cd4d7f87a4548c21d4c43ee5ea76abe3b59966673120a38f780e3fe124d2cc9a7f349b8f08ad6ba40691a45bbbe99327aa5745467b30b8a6e6b939f4ade9882f6f85ca3300ad96e97253f054dab4b8a070c6a75f673506b81190f5352eaadf758566b459024cf933cc076fb5876425eb779b56efbb37f99697ebb3f839f975063e19f8e557fe1ce8ea6622ccb86280d642635239c5ae888acdf80d45a6fa75b8a2241fadeec5626f05869fee2292ab4f78525f9f7c1571da06f4ad02bea3cfb5d74a17385f13589da94c27e5b73534fda21e6a734dea19435caa33b4c857fd131cd2761bbefc5a5637017429e2f5bfeff5a3eac91fd91c171ba9df4b695b80de468b93989de12e915fcd8737ac36ca242f520948631aeeeb451be2e964d4dd9e7c829433b3ea033635a5fb2eb256ee145f4e4608acc5e87c575bcddf321cd0fb9920c579ea0c920b677ecc754d9df796bb11c14393f5991f648343006fdff5a2b6a6d265d5ec534a31945f7e94e333311d577779f06785fb0f05576a94ccee7ff0fd3e8d4a256842a48953dc20c74592df435c871a77e1ccd75994985a9222f4f3d60a29196aa74102aa8daf7b6170075ef1e286e2bb71d565049568a0572f3818aa547aedd9b3a728ecc8e66c1ee40bfb186a1ffd82ea931c4e16cfd3f39732bdccb226f3b49001e49ed8ec8916b2f818c916a503102eeb2d41bad60f08f5899b036c8505e2fbde1de328efd6d8d1fe801bd2cb2520ef5d9edb0dd2fcdfe2f7190fc24d99bdc908defeb0eaed6940821e1014c7de72b6966949fdfab3c51513f00d3c8a04d19bc61ad980479df4edabec3dd7ae2089f653fec6ff36cc6d0bc3a0a6b7930822a997cd02ed3f4eaf11ee8f496b1c6fdf60deef8b6cfb6ec590245e02a9cea8d2251bec7d5f48976ab6d62b894a9278acd1664a1b3a6517c70ca9baa7d498f4208f6c9822f553d138714487432264c569f7bc3d4276c8d4721a7d894eac294658fdd414783b29f9b07bcc08eee1bbabc0ae9b9927bbe91f1afa730c47346c4fa832bceda2705b9b00048f325c538310df1fdb63c7b72b3910bdcb4ec916a9a7db80a9db87806f1789bb69a23736aa79ae209b57060a5f074d9391c6fe5a73c3901acdb6e95dbcfe7f812de79f2f67d6f3a24f7757179278d5557bfd43733a676857b11b8d54e8a59801fa647401c27728d2064a6d4cc52367e05e5ae0844816281b3ac61ff71b375194b3521676cf3b19575f1fdcce1688797a7eb5ed70300179102db3da21b618cc3f3e5d0a513be4a82bcc08b32aa8388c844b4f25694a1546343bfc7fb6d83c3eec9f5a8fe76033bc25af8000c30267c668458f3bac2601d629859c1989e2e1e6a65936c399a899a31ebf5518fb70a9c21dcfa7dc908901e609e74dc987abd2b70af73994d95a632ca8e719ae180c1c48703ca545c70ff6bce144f75353427bb7d2e38c61913fcaa99ab8e3a14d6bcd525bb1523228d27a3ea5c76c7ba1bfa57c282aeb309d099c39052224bd52d8b92510540bd36ecad7ec961d81ec971e4c17d95ec0739bb7f6289018e09e3e94b2af84730439127340838b73fcee0209f21670216061e60a65da49557b43251f1fa7bceb5d35a5271f1131733dd55f5c85f9014c94590617abb824f2bc8a2d90fc63439a610c6a8d0cfbe74147a3aea7b3d76bb6b58c8bb1cd586aab68728da16a7c89ec89ea4dfbf8de459e4bc5b77c4998147d1b79ee3ae5cfdef2ee0bee2dde2e9a681255cbd45d42d1f6677f983655a0d0d8668375b9dadb778e76c7c5117b1e210bd21ff6e7faa312b494ea903a06671ba04e8818428c1d36e6119abaa801fb67cf10f43df87f16b748764abb5c94a54aec6316202d453a168ff332603d502398bbcb1d0b6d7afec969e2837ef759172fe016773ba0828a11fcda96ec6510e6409765a27095f4547d9504872833756f6c0ca336b2d3a4ea14775ece14f127815ba539357aaa79738309cfbcc577b10416345c2c6cfe2123e88c62209433c29c31cba2131616517956870f67b635da7f52826e674654ffc74049a7852f303c2ce512df27ac4204ab9bbbb90df2dd7a2c17a8828f004194bc7996e470cde31b38ec9dc50408b0e34c82a685100e16bb7d7e9e921be282e0914c6be491918b379e040142481946a2132f2e255da0aa19a47aabb521d444f2434c7799a593f0ebfb166ac489d774bb09ac2ddee2266c4890d386cb144f27a2669a26f29ff49e8923222e09d164dc6e6c910b1839c81d2c39551461af9bccd2ebe440a2eb56618984a3bf63dd356be83bc37cfd3f23c237d94d52362f6c9ae62776287a67cc261458877f98a027bf898424c9978f7f108b37e8809fd19e2648b7c11e213cb19307c459c31732f451bd0622d7a7ecf4671df65b9f1deb80eb700d026073b18d8153fec37c53455860bdbce02b91974a3854a6b30052a2f7821d03114c60466b60a8ddad87121beff327362f64fd6cdd99ab8c16ef36da5a0e494eccb1debee953bfd72125508816796b7a61f167ac458c9aa9865646732c5c6d513ffc798fe5152a0a8ad6bc19ab9487830e2f40caa32ebeb6ae57718f5ada7c35c0f6ec8a477c67ba69f93899389e71675304b401edf36d31fc73947edc0401a8e70ef4eb08354c36acec5a097ac99d39039f32cf0fbf95fbdadba86bb4f617e115ff6e96e28c0fb88fa1f2458db42b266d6af3555202d8c4b2997aba77788ac3a32bef4b05a3ec861fb1f492c585382dd44beca0efe116aceee1590d5b6af22ac2c71c887224f8c19570c129eb9da8303d64a58514d5f129b525525f1bb84221ab2312f6b4a6756d69fb2acc8c7fe769c323c311bf94016196698779f99a71890d5830bab23569451aaa4edb7b8987701de55544c3686903fbac9be52643abdbb98abaa1b71478f9aa7ef7b99781defdd901da15130f44b35010ce2c930bbd4c1f7d709c39e18800c098e99698a2b7a96b35c6011c6dde778021e93359977395908350ff0501c5709c1c8d4a96dda55ae7233c05f4c0f512e7c57d2783dbe61b18262f0b8b0cffa7ab70a1bed3cb516bf4980dcddddbcee699ad50284447a6273c17c8a3a488b00352659e31fde0cce12af7a60101375deeb18eaf285767ce23fe3f6fc910aa3c8dd3070538479838d3a5d4f6ef17f85da77c5072239143281fd4831f0ebb8248a7e6a29d724cd3f0062ff2ee3cfd121ce413f8ffdd18d3b71fa6e3e5d48829207ca58da065c911800431322e2ed6cc19ada5220d755bd97e5744800ab40f396c7137c97dbff9833333cfa89f6792319754addf8266382bd7d48b24a56b9c4cdf1e2f7505802d8a50ce9452b537d240410bbc04bf8ab7aa7bf1ce1ea8f25bda955e4f18f5fe05d59e504d46de4a945ec78d0ebdd1b59dfa11888d9b526644254a3307cfb3c6ec03d227e761784e85bf2d9ab383afbed7a6dbe89447c7976ddb2eeddca711e381bcee55495f1a92f08b9b19c378c968b9697d69e92a43fa14d3ebc5493c43dfe8ffcf506715f5ca492ae984f4e88950392eb335349811c36322d941975af5506c75d7aa823ec39448651c20d64da08153010943809545d99d9215b9e22db084b7353567e5f7b30e53d71fc7ac8d77e6257b4acfd3b32a27fd6d25c48d688a672db0e9046cfa4751b50c3fd3a09b6e53ce7cbe8c172dbca892f448904aaf2e976f08c3a852649ef4db0ed48a4e6e5a3542ace539590494b47cf73cc7cd7d5911d3de4ea19600b2ed6d695163b92dbeeece5f1d81d4eec6c735c77af11df866332f327ecbc412634a6570dc7d1f805d850de0c1b1a9e46807fe67695f6abb9135a5302c30f1b35a14986e33e930ba96af36466c1b0a25a9ac56b7767</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试总结</title>
    <link href="/2024/05/13/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/13/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b98177d1192b57acf1ceea2d24185f425cb01968b3f18b1d1de6b120fe43295e">184d5613b7d1f40c9857b7bf904a8fe36b33bf429edbb9059ece5af0bf6d6695b807ee40ec26964836ecb9f4863c0fa9b2655d1f085a708be047d1c39621756b648a7eb19c4902e5c24b41b2eaf7166ddb431abaa632fe1f1c48252adecbf274963eb3eff812bf37bb2e1f081cc1083a883922841089caf5bc26eeb9f2ff29a7a64cd9384d91003db3c1a338673cc3bc7818afad9ffe0b089249d506323fb5a64049731919ea716887a339961da494c6b92e9be0c9edf65f74b8cea608b855c56d2162b8015fb38dc4500ec26950e16c41fe435bc96ee11848042a9c5a0f7d055876dd626d152c2aa10ad782b9bcebffef2af3374efabeea816cf8c208b88a3fcf6be532810f649302861258dd6879fa62bfd4730fa85ca91272924b7f5cd4dfe2eb634636c0f0a69d801fd6ec978ac83fda677f923195e8b86e82d2071cb19a59246f84471dc5d2992938fcac43129ba362ac6fbba537bab6f56d033398e25dbc6a4dc6aff11a53ef8636fe48cac0cadb69787cd27defa272444c586a78a527f5f539d915082b91238f224c77288cf21095108b20cc7ddfce83381c2b09ce0ac4ce9cec72f35d6357c0330ad4bc7f049a1a5fa5af5d400a2e835cdd3a3a42cc46b8c77b9460c4ee7cd3aaad7651cfd0b556a652990b1d3d15a3991324c77b18ffca3fdabc847c9c5636d94c024cd0c0e0042dc4594467cb8e2a69fa61db115340ece0ee18e22ee69d6edc087909cc02c8a84839be03196c59938ba867c7e5504d3f5a1591e288abddd3ad7e80dfaa4d0aab98966f5b56fc9e7ac2dcb0b7ef83a7aa0883ade6087b98ae474324f2558a67a099fb50b038a153c3de8fd0d39d9e462feb5477d82f582d18a25e8660dd8fd1fef5349b7a583589059ee662d7af5a42a32029aa0f43040cf153fe856802d881a2f0701b3940b95b7e3a3201837464cb467928d5d17bcc51de4c9adc8a646b1d9147cd21f5b5c6855bd1bcae6158a2f06322b449f486eed42d30e56c1968d4ceca40546d350b54c9c0e6e644dc48f84349795da7ce7192fc5f208c296ada596fb7846e45a87e71ea08da98f7ea8c38d696c7c694bca1b2b3537828e094256733e6f85e5bc8785563dbbb95a78a186ff4ce5cd025e422de307a9b6352c33cda3bdb6d6bde4ee44d83a45b4478b37d8cf9faa246b888f1a9c06459bcf6714231fd063733473af26ed99f85acccaf0aaaa6428d440efe1253bf75c865c15d49ae4d1067ed8d6e2ef8d6359fd3015fea4c9d97c8375a43826c60f41613b811eddbd66ac159d9dce63796b5b3e6f72df22ea286b6f9c6f617d18f1ca562cc900f60b56bf963ac121e21124ed1a4bd6520e4f47b31f990794e6a1a944b112f9a86f31b9fb1eec0cafd4cab2eb171ceb139c4242788bb9e05cc7106b57e5cb4d4805343c43afaca707f289f628df2879ffd44b9e21c9a02b385d37526838c53ff7e0a4f7c43cf3d243cfedb0fe1ed9eaa1a5b5de9832187ba2af073519d9cc3ee5219ece19a18168127589ef3feac14e256a412026138304fadb3aca1d81a1f9dcbe759a3f225c99530792c46af2a9b8d0151dabd23da4c8053c2a6a65ff5d61e60a7c143972f7dd234db1c8628395e51c0d6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试准备</title>
    <link href="/2024/05/12/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2024/05/12/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="cfcfcd697ae32f4e0e4a7da9e8400e807207d5234d25f28df7c2e03688565bb6">184d5613b7d1f40c9857b7bf904a8fe36b33bf429edbb9059ece5af0bf6d6695ac355b6c7a214a4a27181a4f968c1d2f246afb8a75b412a958e9e8c8e2a18da2d0b06f33821683177711822fabc08721ea1930553392aa09d5a09dd3638a3eb8e22b1f680b1b85c16f88d840f6015fba77471d0c3328bbfb425f19545d64fb698520f493cf11cc0a7f284d200357df220b0e17df8195c4a43023315dd53237cb6ba4243666afeba288ac29277462958dc4fff91d67aa1c82b86a54e36c1cc67749f381b339f9ac29d4a6ebf23ebdfbb3cc4158a96ad6fdae983f34de918138ab2f5a71f9ccb66e5d626697cd16c79f92a5c866270e6fae793861a069ddd571bd96229774468fa7e89bd4407ab6ce2a6a6d77dd6c5a686b5b111269963675a8e316941f163edca34b4545e9d70726c60162a8f88ec7f9c5b03010a991788e11f044bfb29bc7cf0acfd056a1175d9832ca7d8a332452fdb48a0db12ba7a1b062b6e822330ab3f694747178e7eb834c28ab128481ee98d15458ddc0f1d0700491c4581161a631a504f674e2dce847ed494293b58668b505f7927b98476a50b0c49297a0a15ed80deb33a7f28b2c287dfe7ee36203b79e9b40846e02a4cfa98fb1be12afb905c1e0acd7fd283a12b5e4d5b8b4d8e53a7cc8ae2e772aa28378c26a7d569bbae206920b0f93d1e7f851f33607a678702412eecb9143b48769b690196fd0aa7efb74a19e0870c4fcf5b687a30507b07263991532ab002cba9b215408d4f5c120889543d21247df33b46acc7d361b7a15552b1f8ba34ea0db25b9636162d9a6432e212620fc080e4c3cff7c88b0a1b8ad6bc0f492b3c0861c8fd2011ac3c875dc1fb9f99898bec8a6f38489eddd56964c1e3741a159ce06de19e341ae860812ea1d9050f7c4fc638a90c88e8581da38e5f3f1c4918a4c2e6dad83cf14397ccbebb7629701e81a4ca92b9354373deb2ac1db183b8c47d9efc151186b2cfbc423f233d714e4ba454bb1dd8e1f4b6de3037acc116f543de846901b921385b440c2cf2ad0efff26e1b43b07d1f6b518327170d100025e6fb5378194d0363174d19ccccfcb6b0967df373918fd23c26610e87821700f6b6dac2c1dec51642d4a1d242cb1f69ccd4bc97dd7541cf9c5579da8cd48816c733c2665e053c2752fa409683e00d706596dea164b8d368a9b60d9612a74408d9baa4cacaae63d9617cab0dbb9d40ff5dbe30ba69fc4f9a5fb8d13261b80723c62c8114bdfcd872748c680979590fea27bd795c870a4a1259e479adca049a9909dbc990edbb62a2427da799bc00d9f42a2f9361d3304b3e7e1339f9f9900cd67c8d63eb8983a9319300d1f3062172b90644c2309bc0f022d2c539655f777e9b5b8c4157c43c3871a3e3e27857a80e0c750930bdab1a4757c41b9882a6e33d120ff51e50750bdce08a42a2ee2a2cf9998a47b555f17a36970c6e568e28c08f8479ac2e45e130a0f7657cc95a15eac90afb353c7459342bcaf8a6aea22599dde811245ee1c3b0d8050efc1c72fd7e5e6d8c6c8a8e35464c29d13fbf9833313291409aec3706fa9ceab90fbdb0ce0be3048b8cdd58f7ba9f0a815103d1461982c3a6579e01ae92f8a72fb273ea7329abd0e9fac618c8c27c216ce640da771e1d62236fff18808089717a9137df0eb85bcfbf6eb1007c657774293017e88d3e2aa3aaaf43e8e623a2de74735972c5d6ce4b30323cb292d1f61a262afd0d1ad88b42640875ad4615fac4253e441c30f9d65e7f576cf2865b403cdca8db4c1f6831a16a98aeef4419f9ab2b9de745b41cb2bb79999ca07bedc3cd01c32fe10e8b4c754e7071f799a262d2929869f9adc6c8bdbc67a4990c062f8c320e2d8fda25ac50e7ec9e48b5aa7a2699af0891f0027a01c227ce7e4848ec8b820c2642ff08d878b45abfa41c36a00a4423e824cd788834509772b1f64b02d86ac44f85a71abb7f38e916fb62908be00df16afe03cd1d61848530e1c87ea273ae4457406486681562049dafef56a42d3578ba22c253878e443a10f9e11a31a2b959acca571a93b07e073ea909dd3473cd8e2f629223a3a69813d558dfc08848217bc6b865fcbb43a0fe4a69c733dea2cc903c5dca04b84a81d6898831362022a366fb0415893a41860d5a8faf8b030396e39f729a1fc1daf72fbd36fbc040c2ead7ba9a40244e636cd5f1ec5774568c1ed014b0c60a6cbf7f8bd6ab0792f2b8a1fa368c45b4cdb08dfde64390f2ffc46d2da8c077d31f8c0b3145edb66b3300548d5d86bc5d6f1e12fa593d23cc69ee4b25f8d1b74198fedf6d6d722183f313ae2b6ec45009182dc16deae3940670fe5b9643e6a6904a0de37b96da985424015a284c175df398bacaaea782f2780c89cbb1707c2c85ae11246a476cec55f20325a50793dc04dc142351562e0ea4bdefa8bacf7b8899ac06fb7801ef4bb8547354cb379b93b764b8b415e9bc53a270e9339916223f771bef9b262e1b83702f0bf55493d3136ba975d8079e05e858db2d16dd12a3cf885ced022f74c7ca877e5e2144fbac3683d7b26d1f9d66e31ccaa120c827decdc86741e7708ffb7cb95c5b05bdd414cfce95a22b5ccabc28e19634b9719c095a2d11ebc66f12963f293e878a5af93bc542999bafebc3d9c2e3c64cb4c340ddb58f65089eccaf491ce32302cd9fc93d0ae4b85a3ebb0cb27f3a749fc2c7631a2852da5a3642a087df213dbbe00897d7821fb0a84e06e0322e5f9a25a7be403d0287d584f81475b48160eef60b878fc558774a22731f22651938194fbe56d791857a5d9bd6993a2219d8641d0b332e45f789f52299957db21cd06165f65c8caa7e9d9745ee833ad096b1be491b70008cb56b6bd5b90994467d199561b60b2de099b309bda11c9f18dd8ecc534c36941c5e22aa7baf6dd017dc457e957e5b99806f82bfee6bcb5d0b3b2aae54e62ed37c2aeb4b7d3dd4224a3f6c43220d0f1acdc3e0b97fee1f28a016e379f39d0c323156c742746852b42beeb1f6dc252040573b03cb7d1c3348f6cf00721181574b535ea4ec0dcd41d29634a0ff0a062621eaf6db714b4127c72af8cef228544ef98b2213f7fa060e7abdfb605cb831831b56876039bd6395dc0593d5fc3a1e2edf7b1efb65b08cde0bc07f8dee847a3bd1a4096d6e9a1bf03c6dc8c84709fd8baa955716288409418c552a1eafc68098c6ad61c6b318e1a48c934fc6353fd3ed39358e5512db2fbe12ae557c416eb58243a69bdc1432b72cf24887517fb0b6e0f89c8b7ed5e11fdce33a091b3b4d441232f25be6d5278ef76e2c5bbd2d54e74ceed6412ce536b2bea6eaefb860a43b89d82ce723a88b9b19ef393c18c69a25c3dfeb9603ae9a25561a6855cae8ef08261dced87a3a4ff1b269eb2228a6707ce63c908809e0f809d9efb4b45ef7f532cfab090a7335e0e362b262bf408ed8a383f0870ef2cc0b4def4e84409502e3bd1ca35d2af6061c0c623611b57cb31a9b79291a194a4dfeb9578f67a1595dc3bd794305ccfab4359a68ddb24459848236c53e386c2da2de91331487453ef111fa322367c4b42d806fb325a64129ed7b182c54eb84a16be3cafac5e1864474eef5fc68918a14b0bf6b9564c0bd98ef6aedc92024400fd8a588bce21aefc18c552eb63ef30bc2af801896b9b6198990f3bf36e78c19cecaf3fc05a028cd6909a382fe028f089809b09f0b0d62e5fe65db7f1e41f81f02f4ca9da1ef7ca47e48caa677b696d5be6d9a7fcd3f1200a2374889100c4279d710369466db48d33992404feb9db53d99ae37a319ffc575154be70174220c1ff221e7a2e08411559b52c12e187cc53f930bef485b1cd803f7d5df86b2c1a51b0de2bd97a87e01892e9cc5d0964ece3824de27f851132599e145d87b352d51cdf0d670bd6aaa42656dc7a0b1f7956445b01b7734b9f2088dd32af221bc1ada909362179e8f664754b3059f9852fd0230570960438f1600d5902295d7332cf4999771b2404bc8a41715f904141e5a2b3eeb8534289126b8a1e2d7958305407d73d0c6eabb46fbe42c7748cb3908756e8c2bb881e70479c9682b0efd8066a21680380b39cbd394f48d31dac11b91a71aaba99f01a7dd2f1df6aa62d6873a78b7eab4303826f1ceeba325461b49e10988e50c9cefda60141b003ed5800ce78058e690e25a8307d920e38387c62ab32689db418d9d4aac1b15b98fceba63790fd83d89426d188fe86588d57d2499d201074135bc0894be4da0a5a7fa42c96cd3615877d1f8799aa1adf06d3a34033e0fff2110c2d06b14f4ad5f77ff07352e5dbc03121b61a52fa00cbfea5e157c720e5a950d0ede040635495d100ffe92ce7d7c5d4c5725231242cfed6366b4f5df150939c3b15dc479ee90c646328c2c9548a19b6065421ed3637b9d46ffab609863af03cbdca114e9929d8b800cea152d27480675f934d38e6881961ab285c628753d06f434cbe4901bc0ed6d24bd29f71445faf3cf157fd2fc316bfb8c84e3f369e2752cd542a9699cdd6da3ffea1c1c63b6ef80725e850b1e9177b7b8e54efb8645b2c5a96b1a18a264d32f495854ba767a061c2b71f9085146cb14f69e044cde54a74a97afc779925d7df6c919362ec05f84fe04f946ed5389018e248bb4348a41d9854a71bd805b63e68fa8ce87f6b94faed0a16f58c5c7ce5f41cfa37dbe4d6ec563353d5984b153b7465e8da3ceccca9cc361bf7b38c628eb24e111cac2102d84a713ed852c4430c94aefbe2a4926578633dd825eeb6f87a8917a9b8d5f115b0008e070e4055d5bb295ca6231c9aaaf6b55828f89b645100e50595429faadabc8c286c7819702fed3dda7ac02ba713039e37f7aa89599108b4566d9a6c955ee60ea845835ee6ea97cd3d3831c3adba4513ba0a94e3d92e553ac1e77871b7d3ab20fe9b0ca96089526b6cc53bfbbfbb0f851c809ff6867a9e98e31c575278be00258fe29c90a8da788a6748aa86fbeb49d885badd2cd11cb1046f04d538c0daba74815d2bfba7474638a7043cc50915e9db17d63e7e732ae2a871683cf138ae3b54f2112835159b4ac86b97f285d3b5ba66d6e00744ae0ca71b25fc05a672d52586dc9cb0ad59bbee662031960fe688b0e91bac7e84dff638fb3292d2653cada5b7932c3f12dd4ad70225886bf5b7b5c6352b88fa0cd3f8c14ebefda1a73a3b3ad8dfca9aef84fa8a9e47cb9480d4ce8be6abb167db5ed5b7445a0dfd6fd146e3837d52e3ed7eb9bb4fe038ae141b112c23150b45b2b7b9ebf12f67e0248e94cbb88587657c4c7ae929c4b4c60c926fcc24d8651a9d460f3cd5095820c758cc9737c8286a18f8e1bb981da268db554a07d5f4587a7e8ea5cefd0c2724e318c73f898678a768693d85b615226c40ef189a6fa89310b7cd98284d9fabd72f585b930ef3502ec6627f270de8e1fc90c2df9336e2868b5d9036f3dfc9349ffc7c5b7663ef2f3ac0a743941397125580d6c0dca9cc0c68a3581c63cfc5972d75d076445fa7257da6bd3321b6e735f9e3c50c77a49daad5f2eb4f49a2e8162bf32679d9984be8ce41b21e79cca19a072c27e3fd2bc9a4d0037f408ef642cc8b5559c3d0aa763c51d1c013bed547c7e25b0c7cac8d5a4be98b3fe4598514394b13b3d17c78a112fb214c20b1057afc8da38cf221d75eedc1f060557b7cd97906252a9627628bbab90f5da5e6fe6188a10267da906328aa3692c843446608e47dbc4799d705227fc64e9e8d0094293d1ebfd2d4747b936a9c41feb22fb91c5b9ed7aa1d4fe29b49ac2c402d9c6b99edc7f82930b30203db38ad1359240b988a63759949aace972bed8f26d2916577103173372eb2a08ee9bc11d4ad4d1835932d1322e6dafbe10abcb51b066ccf7529e90b4fbd5b7a89cf78f8c084cebc99d2e41f915660842f7331fef5908905f829c15ca3053ff9a58977b5370cdf1f2d053ec0286b2aecff6fa6202ed5292955ecf161dbd56ce0da09cf0f454bf1134926dd846027adbd2b64127b2b683aa9e1611ce8d0c1f1102f4a49df6b099961cc6637dafb089923872eef366f9c5e14ec156480c72264a80f8ff9ce75c7ca5a8c41501a8985f021ba66540a3b10b319dc3a53c90c1f9ee831749f07d9e86ccf3c5d531de3008dcfa4634fb9ecdb02e5b6804172b71811adb9a504b5d9fb850239099ee43c0d8ad82adf4be39d9e570f5b885242ed1999c1140f841983529eab453fc05f1c2f4d880c9228649f3b46e3c8e87ada4f1d7f6512d1ec6006ffeb78f5ad8edad9a121b5437a425ce48db0b042dd4ff02ba3239f008526ed0c5a52a7a8d7eea08a5d84bc169344e4e141e46e172a8eaf63f89ad5b99d60f532a370596163b6ebfe44a8bfe886f615d0d2ec34cc422ae7d158cb0397cff21586e90aee8c593c990fbad10d99fdf309f05df403b3a58622c66999c591940ad6d3737f76fcbd0d60aabd316489d1fd751b57e9943a5329b24e534487306f8c15c74b1bb86f64290a0ce89c865df516d7d4cdf9d857951bf9cc5a3f46ff63e29919e822a2e924bf00eb2bc8ea1d10338a7b65209c6d2f16c611e609e45c6372cd2fce6a0b3b78bc7fa91a31fb1f12816ea89d5f0c142c0fe2669d4605d4c32f9fbec9d7405830ee1546884e2d6b3ca9f62fb203b49f53084e4529e15eae3c6d78bdacc401b81aed61d2071a67af0c64ae37ead395b43bf5c31378cfe8a461681a636a49fc6e7436696210ed9e9ab1e27b1f7c34fedc3f361619088b915e1c1356d10e8395a95f0d4d5492f7e8d741201bd13de137135a316e040dc63df861fe7bca6324c40a1b4f5017b345f4c7ef15105a5fa888f21e2647237fde0becb2183618072880cdebc72cd6ec35cdcc0991507cb581709ff917700bc961d275e785465685de889f56c606a26c09e57444edf2590904793272fe1630ee645d130f039ba49ec515711cb63df36585369596a796c9a8436cd308b65827c0cd88d8f249160b08b69002e664b49d4b29de6aefb7dad23cec37bdc13d1033f2cb7011556d2c0b5bf8600b19326af242d8434d080d062723066fdeed1efb13e66a7877d896f748e6f880c7f7d9603705c750a6443010e89c8effeea6a051de5df731a70f1d0ddbc1e2b4388e20dc4897de078091e9574c35313a25979dfb1e32734cf39a8d93f9e0b80594cb1413bdc0c4870655f37585fc427b5886982f5b97086335a700174dbcc11944b458c0b6a1b52ce6f3a41c6c653c380e1a1daafef70962754da7d5af1910ebddc25c3fd1d7aac393bfc337d8688eba133c6cb7ac6806e7a13a4e0600aeb7d56e14985cbb233bcbaa6a509b2e7dbd7ec1374c5bf70abb3c68662431df06ca2ad73850f0f947b9c7c5ffdd8aba56ebfef080bcfcb10dc04524032fc9fcbd4214b05c06f3df6de64ae82e0d68f00d2c2c1d423caee6607982e45b89656a5c80352988f1decf4edae67029b5c0176b64db79f9031e8737126a59800ad81991b125c82542e30b4faf35b3aee0fee4c4f492f7bf471b3b6e7440ef3f03b76639956069ecf5ba02ebda32943a1606246db4fe99102a28d76df7be16ac96f661fb07169f001a7bfdedbd87f636f550d5a39f09ce9e799ebe8229dbce2fe2704727567a356632981ec286301db8c3cc54d14383d73fbec9392be4605d2449ddab7e640ed72cf9c083c0bc031498e2ddd6aad14bd6f70da506bbe5f2d02e241dee815dd3d286d965c87844c63c7cbf01a400c69b0499977e2f1858561323ad9d5081b9b174cdc4c361ebe5ee9ed7addc892bd82d851c9a3df6526eed5432300aa26c915d672c1612956b817762a8bfe12c73dca5d37d9951d5685c9b66609c566ab8931ffcd76f43e7257f8f7b7870b3b9315427ab53dc7f3ef8b41440c5230907c3518313a949f67da11a6a904d1145f841467dddf0dba54f48e7552477d15227bc5e733e69090d5747ec5a904174d13137b12367cdfabfafe836d9fffdd2b97885efb3f5a7433521c395d171df8fbb1f6d535f1690c7ef23d7593889840bffd01b0a4fb0d7c1d61f9f641bbc7a08f5f345858734c8bbd338b2da6ad675f70d61c8236a2e84194e2e6ad1aba7b6a5d22e9d50d0e1cfd8478fc1f3f4dab8de660f857b84882bb276b3d46716e9dd11889bdd93d86c09ec39d885deb44b86ea0d0cd494a5edaeba953dbaf312d4f84e5940e73e914222bb72e50e6c86341850c2cf25f37b1c90978026d252d508ca2603920f2827ab00874228c39574770113de248ddcbcdfea7b72e1905f122df048887327f6fa057293c21e2d5343c72b9ba8405b3a808a20caa94f9f299625f71bab7627193bd13df27eb4053cee854b766e13cb68ab9b8e5dd6dcd33f250670c6b22925245f63ccdc3a525405a84eb509fc5f71621c4edc2a7323cf978055861280535e18a20bf3ace73403acd0e0a5c8bac318c55f3cf7451f74bc06971ef05ec552f7913193b284da73ddb7e3abd714bff3f751abb7acc86f24543d87f4bf03e1fe9b1511d9a5a5effe43ce05d5f2423e6bf766a4acc400d3ea37b603eff7dc01feb8727c7c043afd81e9170cdbce6863faa6be1a0b584e2c5bd1660a75e6b0f8bcb9d980eed2042242d4bdb9a98fc00dddc41b17b1bf2aa7d3242bdc5e2a1845d9560a0f9332e0703318489721a15237745bfd5e84e02d40bb87e92f76a04b14d8882ea8d459b90a59feb5c36625befed90796f107a444449a77e63a55bbe58e1c32d253c1d9d2f3cdf4ee6e7d768777aa6bfd7428adb9574dd378fe4fac22d8074cd3e7a5eeac0d9ebb89bf6a63caaaf12b927904d43dca246c8e1bf49b96b6f24cb6b203bc921fee1af41573b7b4e87151bc901def004c8eff382e74851a31b147c5376402c40e56c0b47b484c98392737f6992366f7be76b5493479066e376b48b86d52a3a7ba45b077e8ec007bb551ea9224146caf860a7ef4af7a684d026e9b4b19c093d2aadf2db8bd414cc21fefdec095ced2991dcb4b8596947f044b314a829feec41d362f17876c814b2a5abfcff2785a795e062e9aa1840cf4da44dd85e279a99a62cb02bcf090636c7f1dc7a350f517ce4664c8ef695227a39b5ea8ad0b7f8e11f5899dc50213668e7435583d82d0a4f37962904502f3fc04a68e590ce4ec41f440041584d36b73f2b3d006c05f023f4f1bcc73f49fe83a11bb6ddffdd445dad7c0365cb6c92f2974df549a9642ffccc81da7f4dc8e03336703b9b7ec4d2fb47826c92e3bc177991959263f90428800c4a3041571878b1d8574c630ab2b6e9799ea2ec62a1b9378fec9f8a4f6d76bfa6451a4b49dea0d391fea840dd16f450c5c79f3eac653ce49fc66c2e635687deb383f80a70d6938e50ac2bc6f56142d7d341407d63f469a19cdaf9a0a7f6b0c804f0e67d1517bce7ad3e966bf140013fe17cf661d1b9583d8a7326ebb7687c353600b7abab29f71bb137c5c17956507bbc694b08e0f40bb30dc9cc8f21aa51368980f126bf9de3547d6d2f9af24df7f0647ae58983b3b984566c57d76f46962dd8e69f0402919ff434ba1607de6649eb661dfc2e88a26e47b2eb78883b1e1ff42fa9510f043b1f1d6e5e52a8ec59519fc9abb41aa62a86081b2d882af79bc83c5246baf0b2ef6d3d1eb10d5bad7ac21a30a4f6bb03fd8c64f0545758f32a8e75ca27d3270aa4034404a4143d288096903d8dc474290325ca9a82c03c32cd63608e0b7c4acb66871b1317711966ac9d3000b675839abfa6eb23f82211c798437eb505a2a6f00039c0866819f5564f6f729ba93d46d678b5ef3c830830ebf941a434f1bc8f51fd048a1fb45fb02e4f3210e175c15fb6d38f6d01c32552c81f13a712331851366b3b9a342384330169f55ffb41a9b4269fb2f3473db4e4d927f94f3e3e1865fccb5a05f947e1cce664e46795adb4c7714223dd77c35f77390019e9e84f82dae7d0edc5e15f36827dc3507f2cef533ef4c91a736342cc6cb7d837f9f48ad03809e09702daae4b8f593fb0f7fa1bbf01675d13ffef39eccf520e4e6391a722b9844a916976fa14a4baf0dd708ddd5b71c9f6fb979875471bf43f73cc55095b53c955bcb736c92156abdb1437f893fc60c10bd95b364326f4463587667da6c8b21a09f221be25734af5de35194e9c9500ff50803aca7b889790ade4fda069250e3498f546c4ee6146abe60385bde40d0bb308054cdd3cf76aad62c21a7635b48d99fe96fce1d4a43ca6fda355c848d9258e4ce987b13f4ea90bde443e2fedf5b1c29ca2baa22111c02b373fd95e1b03d132c12bd782a95164ce6080097abe42018067da0895fb17b286f5a7cf4a20dd0cfb8af240b0b1474b020c05b54903e4feb6e4ca95af4aed0b26d5972715586f96d40d57cfc80b04ab524dd067c414544037b30960ee96dde7f68687dfc2ae6ff4476cf34a8651543bea9e41fe858ed431bf5c6be6a71f368952ead42de82e917bf6df6f937732112f6a2688a053519d0bb34523480f68c90358a86a3255c60f09ce54d7d27d57a64d87ab8e1df38c41aecf405ee7e0b5f07cf1a036360f0cbf8a2078c6eaa26662567d791b480bdffd1979450ffcf30d0544df88db48029da3196e8133fd96b4bef12fc6a2561d4e9ac3cd3bc4eb644d1c8f96b887255fea175c32f875978c7e8f87a8e5a2e0edce4ebf007d3973d689a6cda23d54eb73cf394e1743a386168dcdd9be0280275f34ca7f3922dfab649f24e83e6b09e4e03fe032cf381a333bb654bea50c5c54117a416c5be7e2153d72f48375c4ce45b3a4efc88fc39d732c8fa31fb1fab7b5a5edeb36e8a6202b22f3bcc2707c39f9a1890902bbea463ee7ec2b89f4f5eefc961e99faf179bfedf2e204c8d48a429f3859026a9477c2ddae9bf2fba89906d7b4472f875849f6a3a8516beee26fdad86963036c74f1802eaffcb337f72f4cb85aba2ee06add17207fe98e752e6afe87857f491f6e3669fc4fde6e713c109df42d8b1d2bb17c1e047cbba0f3e080ee8dcfb1f41c72fc275387924a8fd259cf80e387e91d3466c76a9f46740341c49b73d2a3869fd9f2385d26739106fc95aa3d9b806b8cb4f9e0460662a68c82e9feb2f290c9d35db247985f4430e3664bc0f9579773e5f42acc3a3db92a32c25afcfabf309d6c2eda96ea6f13976edff680f8b2a8988b2f89851aecf5091c4100849f25c3625a017d8801286cf0862c881b7178796e8aba7252b5b88d4e19d6e98a08fd4b835a4903b2ac3905ed808325a60a8699b1cb91eae1b7ac70d5ed74f2263d37e72590b73b4526957e79afeda9a148c6fe966049100b43de42b346942ff84533595e45832ed1d1a666c3857316d7d9d686756982ff86237b18f927f48b8a6beeef4fadb863fa7d5b1fe13f13bd624864a0417916648e72bc95913cf6771a1cfb146b5976fc7b6a9a8ce740f3267abc32331620f8d6a506c1e6a1449190b4da3b387bb13934953c777cab96dface42cd6c80043640bb50fef98c89bf4291c3b1f40c1baa3135ac8b1e6d25810e3ac8ee7dece01cec7c6bcc601d6f014bcf82b50b2d347cd86e12bdcc249b3a32a2de12e6f153a2bf58223d7b719d53cd23aa8567f4dc4ae913fff8ff08c4cceec1eb91d86785dd32a0779136fc87ffe217bd923a0f55d2369bffc5e3d618e82103d021e29c37e86bfd583dc27f02669e046f2a01a3454139a0e2437e67aebf1f583022b1ee55fb459a5d91bb16c06c4a4c06ebc3587cfad061bdc48929f8a0478bac6082845277bee71c0c4014e2816bb2319ca84f423ddc43f6a44cc0576c74d5313dffe0f7a92af3b029aac194ff755fb6431de27c48633d1d0831f164442c3b96afd8e2d46e68410be750e579142a945dc3c91d649708e6833eb4e15db59a4c6641579ac150022d16a17d925a6fed91914325fc9d2f21097332b9c7657a4cc83491a99b1660ca06ef19a42db04eb26b9a472bd2f954e3211a3a796dd15620ac92c36c1daf49079f0ce468b5f1004f51fa21f29bf279167db7e9b36c2c3291d9dd06a8b7e28369f135b31de494de0c72e394971c590fb2011f2914813c859e3846296c1c44b094dc872ff21bdaec535158abe037b7578c3b4fe42cfbd6ea715adf93c4a3c82cc917bc544698023e05f43ab5daf2097632a4b29a1870d3fb01e709fcee43d94b837f3df7ce7219c7421b64d9d57546d82a885e5c7c04d95b57ae6611ea3a957c6fd6b8bf9fa64641793993604d77f23d5eac239ff971860f5ab0cc9c08cfdc4b50a45d73e613b8b28294dff0107edef4beafa3afaa64cc1d205f1ef11a44afc69a1ecd53180b4176623a8ebce8b906d6933a6570cd1fe20210a6ace08d7c991c747b11f13b7d40c8fd460e46b64efde40cbd7238c1ffc89391b0caa757572ec7f880c0f281efb7a7ba8073742eeb72286e192172015890a1580da6fb9acd87cc0d5b6482e5443e8a3578982cb21eb7d68f9e27cbc7e981beacd5984c9f43737358cc8360b58c5e79797e7890d4f170d0495cf9fd13ea57be722035abdd9a829a9eb5bbf2f95419568b0c31e2ff6f90e121e0f9aa22a812065c6e59d323e8ea63ec2664658b3415585b6aec40dbeb6275a1861ee4d2b9683f6c3b2635afbd28fd49d912c8cbfb8cdb3b2d19d594db2f127ae042d0c6e55f400a0c367fe2477a40c453f94297ce66d512e786130b4910c8ebd3ca3ea70ec297ce7bca337409e8c3b520e5eb476805dd1f7aa748076ce23afa6c96475836e69d16f2ccd5d7151f8383feff975517dab156ab24b74652ae6bb19d1a2e2c999ec93284241df5729edbe1cae041121f49a1f293ab1e4bc9e85bc020bd141ba1765ed84a217850103d8d1967ab0d974a5a9aaa69d1164b7e6b35bbf5b6a0e97bc56cade89a0c42a008f559ec958f351857439c07f37021edf12710dcb9bad4ea099cba6dc2ff137e4ca78446792328ea888d9ff7a47eb280ab49313f8e48e8d7fce7dab56ecba53dda96844de326fb608ae357e296745dfe094c68c296c0b4d1e4bcc541f83c00db22821eb5abcc1d512e8d166ea094b09ebdb1c1925e6bdddc8b3c7af5373dbd82e349e7c0774d6ac30f5d48141d1a3e5ab76a3b0eb252e680efe84552da896cd5964e130b14385d4dd7669341dd0278a2c31e8625434b27f14b70a2ba7c94b2619256fe897ba50aaf2b890a4b2b88d9878c2ceb2c46f38e1eed11c33fee60b840a502d96fdbca6aafd58fe6b71ff457c52d83e6cf9864e9ccae92f77a38fedec5770754a2a4196780933bb169a0390d54ddc361b1629735e9ffce95d6c52fa0f41d0e5a06cf7f879667c690127940eaa6d380559dcc0107894bf03014e38a42ede67fa74c6bb59da38313788d323a1d780c6a3289b86f56f834528071b10327f2a606151e4a30c70fc15313f64736d72db770395c02dc901daf21bcbd351c60cdf6eae1c29909c2db43c548dc95435e7f3bce579247315c84738b77c66fc4fb8714e7b1086f318c6335b8ce5d2d95621668ec6514dddc3418b7ac9713535ac358289f4cc4e1a8c109944e032ea9e15dde15851a4c5462d990a1fe499b8a2efcef596bd8b4d272b371c5b669111eab9c2a294618bbbdf8e6a19c70fe075d7a78f6146b495faadd0ed25350ed0ee23179c9a8d39e01ae16ca7a1690d25319ac51a17e295a25afe9590502ee8dc596166734c1b2d6a7628d327a997baf1f95eee114d1e5956b444d3ae523564cb5620fca3a31cd9b844a2445d9d9d706af3c4b205799881733b3812fcff81ac1f80101485d6feaeaaad29f95eda0c8be211942f4b5f8265aa66f50cecb0fba188e2bdb25638a7f94d9c14c797718e724ff99beb2f94912533b1b982558943d9b0fca00d129ec51f7a0385377e6c40779a99dc2f1d5f906dff76fcd3d118999f6b80f360d971047970f58d97ce9d6661bb572ee9fd310e8778e51347d891062ff7b080e96d1f2ef49d5423ca8e8a286dbefb480ff6246850c10b5a2f6c7e4b8a78ebc2eba45f00c6d38248fca2781ce4eeaa0176090883b99dc4f34cb5d0dc7c0fb303e5da871576fcc752235640db1dc9a75a1c30d1651d9b41b896794b2e4d92c4925a6efba536ea99753a914001624283674c5a7167076dfaf262cee3be6d832b03887a74835202a848cfd1508881fcdaa90f67760684ce447bc21c01cb235d39a38bd8834ec907576a784eaa1b35a343f06ec2a981fedae4da7c5457d550e94a104792e62839abedc05c89055c9084f1459d80954e5a912dc2977d75d71480ee6bef6db5a28424302a392e8c37119061cfac7591bf946e0d23e5f3d594acc1d9ba2ed83e8d5988dca9cfa0effb8f3d1183dfa0ab0e8e26c8d8e89404b1e47272c63b268d844c978adc180b8a9161b38e151a8ebe3fb2a0135f3493e424c0786cc5d691b8ed1312a37639293e8dd7465b4f960fde82e8809617ed10b17acedeb50ed282f2755208f79103d963d986d037a5f270cca368751b4a1322f980b4e484cc6a854c62841d4fc3d8712627e47bc368c5b287e6d52771be303b1a925b21312f468a9b3959cbe8316ddd01f3e97757c8f7feeca0c4bf1b1122f7488cd547f1ddd5a2c5d82c4509e77b1846a48c1f68703afe699bf0e9ecb1a5e7751d65e7ec5f16088fc3220bcb699a6425285a106e3f4103415d121963331462d7bcab0f618a58adcc966bc525f6fd7c2c670fa9210441495dd23108432e646c40c7d1ed123103ebaaafbd6aa29717716e6ea60b55a9abde42457dbf659fa07795bdc1665c901ab14afe9fac80c3fe9d074f5e04df9c17bbc4eb277250a5c1b7856ccf2aad7c6b748d3363901344c8d267e0b7645d557a4dbd5f3779d490e0a4515fc604f7b1514df042277e375ed7739b706d46778d0e66ada08e473e77c25e90bd8608bb1b08dae4e0ec2c3a2009985c22bbf8ce3f31fd771a870ee31b93ba23ce7eb1f1eebed743f7271f5ba3f13d5533334541b738170f31a5dd783205dacd83e26314f557130ef93663d83cebcc71fa152ca7169423f728725f386300b8ac6bb8853cc6edc40bec5d81449704728badd6d629c9b978d1c9866c2f8cf802e444a866273db6e23ef24713693e0424ce923a1c2f05de8ac60d62c46b2ea721d7b812d970a00c8a53ae7bd9abfcb771329a024daf801ababb5321b0f260ccf3f5b4acd30ab9580c9a4aafe66ca5642cc5e04ec6c3693947e486b18d9ef59998d4d6428c3e911c3c9be977cd2c31c2100e14f9a2d54cb14d5bac932f18d6676427c3915d5b2e8b41dc0a830dd41707623131451f48ff7322010d71f3371a50d6c5bc6134e2b4da91712985ef2e039c725e23fd29ccc94d383dedc2e6bdf8aef8ed7c3b06f6d3e8bac436297df64fcdd4243ae407e03b813b5dd17ff528d0d0a72ef8bdcc3dcc9b9516bae59470311ae897d99330ffabdf01a10b4ebab6518c6c1a766ef125a0f3a72f11f72a0f8028916e3f168b74e40e2a20591aeaf3419926a8680882cf6a66b12f466ca69c98bdbc006031dbc3f55ff2d166876e60dcf4465e8a50d129982adcac38260e73aed5cf5651cce3091c676c428ff0afc523e7bf45fafd17e2a23c72871c72471ed741d82749ed0c2d1212a382bc7303f3597fac82d6ee6cc9547e583c5cef32c5ce3b5c4bf0f87bdaaa6ddf2af7da0d99cbd0081655bee5169b461257ae31250d9fa515e08e9a8fced59ad520c62d75dcae7f70e6a26ec0ab5cde454e5d1b7eb241b6be5b431a0ccab68c7c50c50ccedaf9c5b1a3d40b42a7f9280a6e29355329914c17a2e68b355f0f1c81c53c4a70f23bd3e6d2e629ef6c856fe84d7341491be5b4220e2c3be04ca44451e659332efae8294c00eb9e8a2fe31d6d6da307c2fa03cfa492b62f0cff2ad876ad0b6c8fd807161cbb1d345081a395a1b4cca4a728c9204388e6f96838c66d9cc6c48e29bc28bebbef50e54027b90d515f1a29627f82563a402e9d45e86a5af7411dda8cee1b85bb9093ed10ed3a84b85fcd41fd063d9fea003919d8254c3010965afe7feb0ee0c33b93ed5f36b4e0f440b9b5c324d5d26e0ef976805908fd56e82ebcc9529ed42e3d86f6092c8388aba6774f91f16b4ff266e5e076720110011a7dfd24adf6aa42623216f2dca9230463f870195ad2a8787c8b6f827eac31a9abdc897629509a9135a39b51a5e54a1eb6b5d30f97ee9f2b83f58c5c1c470f3269748f21986e67248223ebbdfe70468988c83d7459e6e4cb1a597c52cd5b6999d7eb2df00ed4f699e56514ccc76bbd6c1ce2042c52a4ced5f3f40137ce788995a50c9a42153e00891ec946a0d70a5acf930b0aa3ec187c36b5ac982c8367001bbe6cf06d7121317b88830e893335017b03e95590940ad9f300a1d744989091ab0a00a51943176027cabaf98e6005d24a0a4f337a84ffe0708f0cba127e4b5af093d3ae0d549c05a603536125c9bf1a639cf405b56639647a07cf873480aac5ed1719c1f0e2ab48158b5bef2c076f2d59724dedb92e9cf8bc53072b2a567d70a933bc8bf1819b3c1cc0853b80a83347217dc87999628d1d939f527f56e094570f08ee028ff9688ba71628356e54583e22cd469d76ed2428c3de816717f3c08c86d944700acde737dc9fa29ff0360df49155df0cd68946e58b08c9f35a93064230417b9272291c34b39b9b46d16c95c55da2f25b46cd322e7c91b03a81ce31b27fa3657285ba88a1a17c5ff834eda4cef287271927baaa322ad3307dd3e7f509f8ce5d614bf4d86d3bfaf447439923b35cfd68c1c2c9c22d2265275aee64e5b521a0d18b89b83e40ce450a42d458f284b72665ddda655e8c9c07882841faef1076a13c8b02384ed572bf30bce3fa5a2a08ceba2e692a323b352fdae33c4ae7ca3cc23c9b4a7c9d264903978a6dcfc4f49a1c6253dd7eb4c9fef001e10d32d2911f09ae5213bf061145b260340f62335b7fb0bca16f473018630f76751858174ff8879421d7491678a34bc9e4771dca24af0638638e6cff1f6301770653c13790ce080fd47a5a06409ced7de4c2e2153fee598b6b776ea48ab9aec3dd6e0baceffade8bfa34beaa6065cfb79a65b0f2dd1f3ec79ec10c496259a9b9c1b4d9eeb797525ddb57ac7425aedb3d77d5f85841c0ad4699fb15ecca11a83349760cd93f1805cad48fdc2dea3eec780e39e3a1c726a05b977b9a9b2d127346a716becc6afaee2fb9a863b8b41344bba40fc1aeeb88c8b4c975c8435a764c64e57f2925a086980cc9b85ae9ae373300e3330301449d229ccad50f35573fb82cf484a87a8f5999b11b3d80470e853c1af7627a1e8a2dddd31ce35de34c6fae309e7a3d5087ed81f5576639429eb2333ba3c90294f58af483c36da36abdd0acad48edbba811b88f98cb73e262c1a4098e4ddcf55b412995c88be41392870e615f1b2f0d1167fc610ab5f0bf9c6be4c0af8ac865269cc17e524b00683c5415cb84974050bbd7d35114639605888a9ce98e430ac9df40cc4d393582f9351715508153f1145ef76e39fba71817d55fe89c67bfa3c828166046dd2f5541e43831addffcb7aa6623645e63d1276cb78af9bffbb246c2dda5c61fcfb5e7d3d4ab384986502392379302b7398ffb17973424890b4b09ce7f519b60dc286674b30634383b503809f07c1e76150f7a01383aa803d79d44e45f9449390ae0800f66ad01d261214d1e9038df9fbbac7b5ce3b31166717d4ed15486c4cf07fd4242931cfa9da3bf8aabe1bdf49881b32ee82b01cf5cb41a2b9ed5e617a62d226a7761d2876f21fa8f6d5a379ca20b6c2b12b0bbf217ea83b79356b48882383f94b333d00b2f24027ebe0d69e8d52a5bca34640ff1e38140e1198ebc2fa90e692a2add1208c0fd4c024b258a8d803e211f39f1854d908ac2fe65a27ca72215e8cb862e52a251c102f1ef00aefa2ca6155e1379ecba884ee1b92fbb3158051466b923c10c1f04f80c0a04477af76d366896eda101bb1d6a854b2af38763c8b5f52711622f5a9628967b2c9ac6a5451f235c711e6f5954a95a84a3527670af267bce0c681bb0332445d5a62f05e5b0b8b26d0027ffa20655e727019ddfabaebabec91ce33cf9515f4220f1fa4270ecfef95c3dc62ed61f7c51c3d3d379d11fd26a7ba6c7c3d01ffe5c769d036c8c751f78d071751abc370bfeb5bc9e4c7fdd94b54d449bc1f6e0ec3e999a8b5eb035e00e8935be17e6f2d8bcb71fe1e61c4a18924ae92fe0bbc767dd0df62a9ab80d8d31f97ac61f58573905c26b801448cdc077dd7d398daaedec94366c4c130835de37ac269213f533c0b27f54530f09d32c5bfc64c3194fb0fb1bad3b75ebe5e7fb6b05cdc4b66cbc963fe48b617892b7222e1e35c6fdc92e52b65cdf300ec65e0aed04328fdde5294b375a44976c7cdc9f6ac5d06cdd2dee08e9b68337080e56d5ef9c3566f0628501b7e77f053de919e0a1eb374c601d96b434610f0e0c485c9f3f64913a7d07696a54be590953ac8221026cad8669451d57d1fbfadd5084bbd4dcfb62563dd54d0c79040fddce284614ac006f13e6d603ce2d56a08a6ef3f5e1062f56abb99c3851f4028c74d6c905a0b2a0cf2cf11c67f5b1a09e140153a5da9df4f08efe05b374b5e1a306a28cd278d72710ea3178ceb3f63218992cdfa88229b7fa5aacb13bf4df5da243b414eab5765f0c487164974377b5263f918fcb8a33011076bd9f85c4d838549f2803d76a65d308e8a167f7302bfa66109eab0a0d8203a3830c7981314dc7dd55ca7482c6296f3cf5f7c32f6845c5b924982dfceeaa232d27dee6c51bd5991e9bcb19baeb4418b96197db28a3bd6976a7ba2bfc63676bd178331d6dea16441bbc1a606c2cca7bc7cdba801ccf76f967042f8cd9b9b5d1d7b03a71d95fc4083d6359783a1ec182dbb088fd021767b686e27fb5ee3f020e82a320096034243672bce2cc506983cfe136a90ccde141c947cefd322590d66ef70a4d54d1226773e3133e3ffbb0a8783a795c3006971187e1f5512a8478a7e894952aa0ff2065560242d4ea86ad107a3d61e396403e77ddac62e1bf61c0c396f4ed13cf8084c24c66c014e1b78c5226c8280a801771f539b3e0cba89786428cbebc68402f55019ec2e2b801818d360315925ccbd5575d7ea97a332b6f0b02c649034685a8cad7faf5146653f327222e47141cd7b23bd9c4f3548fb5a1b7d6851211ccc8595602d4bb00e6b07480dc5741b742086bb828716a9969ada2198063514a1a7f3f375f4eb5c6dcd50bfdd0b8abd02397a82987ae2f87521ece693739f65f2a0b3cde6165ac68dabfeb320528c2f5a56b8775923ca6c3e487b32cab391292dcb942fc38e8052412ba4ceeddb3b6be87bcdc3543faf0a4d4a64ea037f695603137cadc0b574ebaee672c62707032e2bf82b78e87726c81e6d32ba3a6f8fee0b1e7e1b779260b41abbecb266c0a7ef0ac7558a190a92dcc083b58f2370ac8f4c487f019f4eb180ccd342f2aff5736c291d438c69aba067166394cdb9ce96ec5f204fb9c46f0b41dc35757fd7196adb1153a5a5d4f1f70c1ec0677b94bb4f23025c65ef2a2e711a9234696042a3f3068228f81b65a7d5cb6f97e7e9fd827d6cd9bdc220135bdc4eb1be503f946aa31fc274b6f7838b0064998d49e558bcb680e3b50bdf622d49ecda438e4daa8151aed19a12d44fe44c80c2140b7786d373bf4d23e9c1e282eaea8b19e940d6a3fcffbf266bda87a13568c63597c3ab802cee0211d6f72765455cff377a61f75acbba0e3656ddf7db4dcfcac472ba3c194283f8e79b2273e6fad55524e9f202bf4c9d4cab5fffae1bc97bfc6f6886b94d1afb2397a87fb0228e1970889b3ce2a16f38c007b92a32787ad48b50db756f05b02258fbf394c849c2681fef94a2d710345c6cf849d4947b93efa617f3b2eb0e6d4772852cebb94c9863e0b1bf9d9ef3e89031f104bdd0cb050d33d182e904d08e1ec95c6702da6edb5b129643fc6fa222428e8e36781e14f3f4cf532a7377fc00907028d6f0cfadeb47903c9ea862d9574db275552fd239dcc8a9128c19f42751c663b8d3236d9b99146dd6a722dd8eea806783e55049867dfe79983128606ae36be2d3a7dfeb0b1ecb4af1bbc2e08c6c12341f89c2ef9185028833f24fe7106e7fc6b437140a9a73ec7a53de4dc2293850d1090647229a779601d5e266e23ab04e6259524fa7bf16640bf75c965605383c1e48e24f5e528dd5b824781709987081730fce8de611c82b6bca224062d9ffb375a77c2116aff06b794eab81af36844da65607b12016ee5ab0ca618ee45f6cea773849f053a68e6fdc1910281c5288b03ebce85ccd3eafb5d9593421b385af1138aaffb686e0cce9ae2de2c85deaa997acde3f1d98d24d48b008e5a5e850bb27f3d8338339bfc37d87efaabb8d0e81f98bcdefd29bc9bd417e78f84ee5e5aab9cf8601a64b57d219408bbe7a1f7d907cff6895e891b174812512788c98ee3d214326371f72361dea09c22d0d5ac789747c3d42dd7bbeaccda054e7071b4bebdc65244f2e9c223c3df4fe1feb1f04744d88920ad7c46236fe8784ae211907a576b4b24cc439d7fde9e7e9d869f96dde5eb099d52d5b5318f9b52f81416163b731a5c61fdc2f76d0a123a9da732ba09bc5323c4fb5e08f8d7f02f8d0070f8afa9a61121680e8cb7d3833301a69b5ab631251358368939fcd57bb730a00f192724bdb15cc32826d824732434b06a6639286dc83ad8af0d270c6970275a4a2b4e7810fb3a2bfa19e985c55f31d9ca1442f6ef70d17a082f78e5384c7285e41bc46600f0f37823eb26ccf23a5f698ce21d65c76604f1a0a2d569d5182291f8384ecfc48f9774cd074e5cabf4581c65e47d59118424474507c6aaca389376a15e992187e1944f6b9f6f701bcf04e99558b596ecb154ade82462680d6f335a04e4948ffc15b86dfd9278c528ac5aca884af8c4cbe70a53f76950da34ca30d80455189cd08ad55486fee8473a038edf50688c979f6d6d8c6c62656d6fac93c7e7439f2c3eeddc6ff8bc7f65d207dfa28b144decbe587c9a7508e76fabcd12810b868f8619001d8b3a2505a763f1bb295c206c3c8180f0d566c0f96fe93d91249e1dc828088d902f8bd962dbf2cb22cea2f65a93dc544a3cc7606fef7d1b0177a96372b158a0d9025f0329e7ccb9089683880c90fc4c50497f8e086dc0f7435898252b3849d33dca9c32c5106ac37f81435a72634e8b0afaee68f50ec23413f3dd28c52027b78e810f7b2d4dcaae6db11bc4fbd5914ae87758daeb99cc70da1ccc71c0bbc6899876147539aef5e8dbb6af694bb5a93d14bbe0c93a36f8a62f711f67171104f8ea1cb5a210e6869cb0908a67dd15ab89cb81a2bc2d100fe3f06eab597877fd35af5d0ce2890349343ee014ff5d26e0863b9b7424ddfe311a0a3635fbb50990334fa6b5166e8ac14eb93d684169626be10b313a4c4a63fdce7b69e64a2f37e61ffba504f6147b6206a553b5d507490824a7fc6ac86b10959fc663dc909a91ff6cd1a281c1adcc36179809a9f021759cfade8c88dc6161063d2e1420c907a7f04bcf61d49fc5dacbe7b47b3ba1553b6ece87ed1f535aa56bf443e2ef7671eb069b22bb8e7aee80f926f9b4bcf0465e94628d6214446eb15fd219df7274d8636c86c0a0f825b685678dadc2a8a830fdbe68e47928d56bd1a194ed22a73fa7030e1f7f3586b035407acff1aadb816800926ed4d335f5faaba4c78e94696da3781a708f8fd6273f0aca1ed932b96a27e13371504f25b1de1a184d6a209febf60a054e3dddaba2de1f55ff3cc712d3b801acd2dc379b3bf4265dfd15ad145c90e9902d2858720fef19db70790fe9d5441b08ed4fb3347777857c75c5636066d317e68826e8e98d32d43e55269dacfe44b3b2c2434f6366462b45c1d5cd6deeae64d311ea38015c71d21ebb953c5d7bd91e9b13959d80ae0ebe9b72b9c0b1ee2ec8a10e68e748e2fd687ac0e7854ac9ebeb15085f4b342a638dec9a758dfe42d2c1c34d6c550f228bbddb997c68a2173d5fdd1f7bf9e3ef53ef39dbdf9093af66471cad4d0ca5a6554e465e88622ae8c449dcdd8726d77744b3441ed883f18028c0556c7fe533553df78a2f15b10077f1b98a7851dcc11a0c5b85bc7277d2fac73b2dbf4e9d75677ab41381a878c92fbe7eb99cde2d296bde2f8b15eec7dc3c612f832f5ed788ca5193fe1b0ecfcd9b3bb1bc7f3fa764a4b66a9af59e1909091d8c31392b5c2afa4fa2caa6b32d93537f5fcf2ab2ac73ab02e7a9446ee9041271e21ffccd415a212aad8724ae9ef9c342a70d27d3405a8975859c3c3cdb29da50b04426911210d3bbb4feb4bcc8118358b344d4359e8e6bdff1be00761005a1be0c0a3eeb5abe966f7d2767478644e628d2bb154c83b0da99ef1654ef181095f486caae0c7862aa40d2c659184445d8a5b7cffccb9dbab2b0e91754f9d94de755a686e4f77fb6973ea9868f0da7860a14198b972fbd4e835cfc8bb8ba2ecd20f288f0edc48a03aca62d47023a8509087ec9a6720bf9df2b30d28092c75f32c46a082f6767f7ef4ba2ac897766dbcf54218b15713d13eb90aa28f8ec402c613e2a39929f9366426954c46d6294bf2ee9e096837ca4655b59ee2f6700b378b32cd468ec28b31ab04e0adea1ab806aec516f04c8c30ee79b68b092b5828e905aa26488633c6e4d32cdaba0bdc0268bae9538a59f7e2ac994e55d55d98696fd3ea38a7b920daae7bcf1d3e96a0551accc0a0e3a463898b7f84e4dcac2d38eda880602f6db4b4abd6089d6349a5a8d2d6b545bd727f761e6f9a5f97c614976bb255ab3e106f3f2dd2e74c6e97a273caf97b9a13149e9d2c78c129d66ad24b75a48a66b4c599bbcbdad7458fcdefd73984d649853bca2db4c07cc25cd7a1eabcfbee39bc3dffdf3c14e53b592590e5131248a9d1a851218bf9c63ae29a3cb1802a8b33df4413f450c027261d8043e89ed8aa676438361fc96353dc09b64c3e8639d532d2f09c976d2390146a360bf1626d6cb6520e29eec261faef24b81956204594530e78ae5fe7f1a886b7632ba7527b8b2728411381e8f415709d4faef8c5a120852956b0f0a3cd5ac30a3f73baf5b2f64bdb03652a2aa8fd2f08840d6e436b5cd4e210ad45dca9fac108012b5da7559b18d5e696c293d85bd81df01a992707bbf068c8e1295e86ddda60484ef6e1d744ef3d1b6e6d4e714ef708c3167da5762ab75eb15fee0caaedf37796a71dbf87acab37f67318895cb67846407aeabd954a805aa7205beeefb08bd9e2e498e566c67bbd1f70d65f973e1d620da01168e8e25664e1a151896457bec0793f65dbdb51e7143534710490cab84098884dccefc2b67c4d8bc1040fee038fd2de3499ff6a0eaa5f30af20a8540d5c4ba6ee06a3155f1c508c7ccd8355522c0ed03bdae8893f125cc7703601908a794000884ca002c97c8b5d62bc36bd93d0ebe7cc8b75431f00f1148c00a71616ed06a7bd575fb4fda96124760d3d4dd9955de8ce2dc3f40af72f1a77be75e327c4205ac4a1029ce127e068012bfc73f16e1d71ac9e2e30dfa6f6363420fb77292f5a478879e49ab2e405c3879456051302debfc7de15f4ea5b9aae1498eb31eb542f9e746e27b0f0b7b99f8e3a8080bb7a2dc4f07909ad6fbba34006776e05706a301d24383aa81367f81aa4b2edfdfcd433e4ce1565387630f9db7d0560f936c3bdbd83eea66f58655a227d731c8133a80faa843c08accfe4c36bf20d0c3e12cd40db2494dbc89207d0bd4378d9ff8fb176fe0cd66d1ffd0581010ae3b1167a9537f4b7806ceb63bb340e9bf07391ecb081f6a3132851f390ef31cdfb990913a789404100346696ecfe12c5fab9846728ce9d2a78b732db638b111894b6d26fe50fcf64c208da6c75336ffd853f7120432f66f19ab8f9877aa5a48c038e1c50d153e6ffc08dd9cc7943bf1b38b5328f5c4c229dcd671b032404ef25dab7713227a03deee6b9b12c913c351f3a6549deb64f9a04b38eb211fe569b2c275cad193471e5d08da2a40f8d6d66bcea2777122f9b316ba9643e55b676afb84a8b4fad41510e680f10bdbce0299bc6c98602b8b8efedffbfa0979ba7e1c60c895ee416332d6260865270a78ff51fac2ee453049bd9fbf4c48737ba086a2f27e8405971c075303cf14a534f9eaee50c660015cadae7f034452f3cf7733766ecb1a1f4d07450899e33bcb3e5c3c89f732419c9b482a5199cd43ede45d80d2406d7b9952b5e2085c666fd08a0ba0ecbe6927ac256d4d1c05ce7c31d389a168c2df2d158f1dab2e966613e51e6c415a0551c371019e2a75e648dd475b98b21490fb7935d77a4230bbafef8192d29e88671eac16a949dbe521472b492e7421221b76af3ff020f7fa5b614e4c35ed8b066ededa2f908c3703ed1df8b43df229161db1ab3913a1e9d13423bf16a8ebdcf521d135b91430163ab8ad48b9983d9f5781fd55e8ba3c211e0006b4feada63899e19ee64c4e4dd02ad353e244deaad3f4c059b9f48ca5543a517dd8059517fb3099161219eee4f3983f80ded629c6dd8f5aaeca0218e71a64c7ac984e99083a9d5d0b7b9b969f8c0d2ff013f328a26b7c84e40fe5aa2695ef783bbe52ef0c46e60742aade476be06fe164b7151cddddfefd1bb3731db7b82b8c63eb032656ddaf8f0711e02e768bba351108ece08e4df4c813d0d1476ec736e99ec383523a4a4daa5861606cabfa81fbf12b824ae85c5f112ed2e8534f75e766297d0e22fd71e6c0a599422d20d75f806a55527e381867c6f98f917e08ed64ee1fb199194e8f343b6b047393053590337fd7c9f89568734c3342ac97594863cc4fdc5e83e777634d9910dbcffc1ac830c838119134709b1b2d4cece0bf363ee7c59b4871dbb7539369051835297429082340859827650682ac2dee22d68006111f21d200caf0bcfa76ec2e5730e692a42656f35541ebac28d79e04debf80b2262c523379e1fd67f5a673b583770cb35c7c6c45b884f38bf11bbac03f3945991cc20cfcd7213b0f7ac61b880e6214a28817b9f024545918e3b27dd49658b40f867d1fc1f16b353fd13a84309a5613af19e58021243ea0b6673d5f7060a572f1441a91b886c7952c8dcd8481de9a8f30c7c0927564abf065fbe6c3eaba0fe97bab4c2808c8acdcd38bfbcdfe5a0507b0db4ba5e7cb2c27a212b33ae72d545bcb9aae4458ebfffe741032d62a9f1e28b6eaa43b0607ed11545adc3badfa30ed26de96568a6af893bf90dd5badde105c5ced25b7260f734d524dcfcf49fdcbac7a8d0923f75d5ac110a225fd6316e41f2d003fd8f57583f8ca40feae75ef96e1362e5ab5d1511368b325f4b98ad31f43038fb71dd2351750bd8c7aa24ee86bb4bca8950adb9f8d2638c90e874be2923f82e6f6d9d7212a19e51a6d90a1a5ba7029b4e98f317200836642b36e9f28588cc82af18dcd7b40307636fa45080c4bf3ff23b7ff33b0bf5a8968b57b5ae62d3c6db685be4ea8c3db8e3ccf231a4b399238652ed97d3905380198b035653ba18b6a3864ce752cf2d6efab30de7bb8bc51335c5d9eb7891e9e20b5ff7c846a8704de5d13b9ca0a716a4fd2382e8de43bca172293f893060756edea2efca6e22b1e2e8310d3bad99f798f87f2701270d4bd7e38f468c3a9afee280e7b2a532e2cd896e67ef0189ab4d0c565cb9570957fbcd5e2fc7f4670403c53de2ecee58fda6710c064ad01679a07d9e2c814c9fed88ef3ac8eef43ddd9290c4dfb67df3eebeed7af23ff1fba9e6cd97846eec13f2c6a9af9bce6aa0964e095410603ed5891c0ae9896ebf7554072ee7ba66cd0f918393bf7f1d006681cf1d41487f86d78f4ee03c046dc3a6c260825420599890d1e5517db67b9936790a49b4225fa456ffb3bb54bf64cf875f2ee18021e7f76a162346fb00a3e11e2ff27fc5752213d6f836ed47d9afe2676a1e486c6a760bde0a3e8829a143ac3a64fe1605f4994e2f5fe727a5dcec36cbd611bbdecbf1d63d10b98d1e29d0a2438d69e27147c1d81c8ee9f015669bcece74fc5aa06e6af7f2acc6f808fb315781801493430e0726ebf2702305d1efff416527d7a32a739c2113a5ec30b2824ae76e7b57fec6b7ea6deebf08aec98931bfd2e31c35b82569eaf563099f181106db035066faeb264fab02ad41c42750c74a1ffa52fb5fd3b2f515f7854bfc243349120a4bac5556dbd9c419c00acc0e43bbfaa64566d8aba746067bc48bbb8572ed88e050a44aa27543e029fd6c6e5fc4c84283ade51569aed16894896c37c5ab27ddf65f2aea829842c57da31f3e463932e9707512500bf76dbcd06fd3990049c3efd758b09aab810e8f8ad39e151d9dd351f681cf8d8a20cd4f07c768797918d11a934ce877f55796bb33764cb7e790322d31d75a1462ff81be67e689fd6bd2d90dd8001037382b3e31ca98b112c1cd050ba81dacc568a7a45016996bec21aee9e9725db84895b0ad031f25895a7161b14054a6e2c668e8bbb8e63342387e2320372bbd1e9336c0eef0d7e1bd768b4466a40787277f75f963435475e6816c8beb5cb7b06cb8b712844f32e27d2d4f72f86e250e649656ea4655f127fa04c5c445c78b0f639564c8360b73e83358dfaf3ce92beae009eb9a6fc1634af8a9cefdf0d1ebbfdfa4b67bf1b389e644113e8ac02567522a287cf0de7f5fbbd03c79abe02cb44ce7559a15d2f020656dc5f24a7b6518cc1809f6d7346f74e71a2c6837208d97dbcafdcb827d6b5d5c4d563a486b8a3941388d2b41206f9e470e00614ca6ce1f3372459d7e4599c3c1e54e5b8fb164514f57ccaa27f3e7255cf30bff2eda27e15de2394a504cd1171f49dd1132d26aaeb0783c54da4976eb798c51205951cabf786b39a6ffea1c2f5a79fef62df4d391ba519e5bfd709a5c69e022025f8d9ee8cf105e61e083e63a086850e2431f3858031c5a509b65021a1623a5b55aa12caa85f352e25880c141b8dcdd5d5c43880c9ebe4acd38fa10b3493864094f9ac3c18512e187a47856c948a35f15e7feb0d6da386e8689bec6d9f2d89adee5a8ef64351a682a45acda1b00d1bc5cb3b1070d8c7a159f4c9a8296986fd6bcc74ca3f0ffe20ae4d2342f9fa7d4dddb2bf30fa92519884192e2d148929542568f1a9a671ec270da37cc3a0035427be9b24c8914f09404cea4d5af3dc821a18aedf407ea9c5f3c4db522851c64e25d8fca89e469e4e3d634dc854f106d33d2517658b7ea4af2f96f9c3c627d3b483beb78e6914050f3b652e525e3f7198d5cc74648ad29aa9d99daa8eea2eb80de51b4a07675100b2b181df951e665f09f1918f4b59c8355ff22e4f6ee2ca9ad62e94a0ce23c8b09fddb5f7c2b3e8b963a4e7a0c79f9e778bd3dc7971322f1eebb29bfb8f027d18e03b2ebd359b43b40cda37cdce36c87b19682cb7ca139706b8702c13fc18e4bf0cb56b2f591585f2e44eeb059d06892affae945415bd3eef57a89b30e91d011f8dbb70e47869034778f808a46324b520e24f0cbbfee501f4ce62587a3a93d8c0edf7b78740df62d37b0bea022e33e60ba8a484eeb752c77ae77134e79be6c34177997fa3ea0c55622524d6b5f4d42bda38b505b0cd1121a9206f978056b5cdd99c0846d1478fd50251793368a48472daf09bda1fef8c7b639edae08f9b12e16660866d0a95fe73fafd1e382cdb8b8b3f1bef073126f19941f8d07a529594a480865b4e0f127c21d6f5f5b1779fe991e0cc986b3e26deac119c1a8be58ec5718c22340f962063142b3c6142c30be9fc25619c83256d551baa0bb7b84b5964ef9beb3764727bcc019794cdbe9031c4416fb276704aa38bbcb40bded51c480e90a8a414dda06d81e3307163aed57648e021d2d95e71faafe5904334b8cbab3ceb8ce6bb1ef5b064eaf87d35cb110fdfeea84e4feea402d9d3514a56e7914e0293de771016b9fabe8d2d3f558760b80a12a877827cf762c46a816257d3aab72375384ea7116e7d258480448abd62a6c0a06ee5bc2e6da8361722731322d29c170bb194651c0e85388cd0c92369148ac9f81cbad7f236a9a5b1abd47c689e417650c2622345c70972a9283f98fd7a1348915cbc2cd6b5da787d8868f7e3ac06c93f8641f0406594adae09ff94c069267781c625bd879405a84bd7418233c70616325ff7a85a784823128645b5284fdca6cf3513958a4dbaa072033f14e98138cc74f4cf4e1db65b01a431accf78c93436e0025cbd113ca18a4af0ac51eaf8725f5f28b25ae8ce68271b279029a9c4d20ed92de3e47fb3b31c9407290fbf83155529273560fa1ff10aa78c11f629dae4c255feea94405e03eba710029459dbff0976415c97425fce941001f385d987cac4db12882c70f72cc7d33311b9b278a56ab3230fbae47d62ad00d7b0e28b44b9b17ea3645f2478c811449a303b74515494f17b3edabf678e786ff9ccd783235add4d6232cdfc90008dc84b310b712e337f78394400c45883ef603ca349a5ac77fefd70b77cbc566394857bba84dbcac363eb39ddadaf34d95b5e2497176324bba5a81366cff2e48d3068504d1cc93cad8f6c52440aed4c43d56cd088160191c1552af52a412e63a2763c794d98363891687c47de20ca56e120d040617d88f1c898feaa5a1f915f56e79e1cc40b8cb1a6a06094496c532a531cfd2f7b10dc3ae7d1adac71d04d354686fe6cda3d0ff0c23c2a7ebce581be7e53d8a97c603fcbe61c5c1ac5ac4beeb494fcdeecbe1a9c6794e58a5d14782f8b1761a69208a8a9b50ac4c0919eb516bb5d994e1e7a50a984805ff3b314654c5f0fb3b94f7d57f39808b72e500402fc7262481f6ba6fb4856c36da6e5a0ff68fbd094fac2d7b8f9bd6a8497a266589bcb560cf2517201b60daae9b78fef6230cd405dc71766704d9f9a755619cfaad2fd594a61bb49b3c78668c0e3c15e50bca3fc1ac962612eeac12a579f88e0b56e8fd051f3dc9e4fb56fbba3743f1d8f704fa09a003b1893ff2c6824218ae2423db28af54ddbb6eea12d40c84450c7d4cfc8c208a9cab46507132039e6efb038c0ccdb749a60c15bc614f1f18d1915247dac1e3eace2dd80b7dc9a33155d6322bc68c253e7cc10ba096f081961316c20004635ced4004284006aedd07f72c6a60f5c361f71bf99ca47bae85697bc46a4f71c2ac707c6b82b70d3c508ea178c8c74be9a3eda11356a6745ea811f865ec45f85edcfa55bc576999af703b00cc0387efc5c88ba8cc299c93f25694ce9db19ecd238442a3e811a4d524591adca7eed0990417a162994e0957227b9b55e0008b2413451c9d46f991deb08c62a1d32ece89a7d4261a0229a515f170f566407105b1806bdbf6afdbd05682f9913bdd424b3b1b34376da9eec7d7e351b1e668eb662abf8faa61915524cc88f49586a1ce7b6d430432b3f65cb11c40de9cc98dad456568fa360b8be9e3b6eeaee7779da5bea26979ab200dccc2e7e043dbe8476b19554535498746f3067b644b08c8abb1fb0e4d0553a5ebecbc013e1a4ce5b78774ddc797a863559146abe849338cb71859b3a4fc7a890414b3abb21b050499c89c589eb96d56f5a9388c890ce2a5b88db5a9e3624c03d2f2c4a509d0d2b89b3f58a227566dfcded11b0bc5f9d0b7b57bbb945114361a74890889b12af30b725960d3bebd5617294174477bb4c503083c84e6408be1e7084edcc78271ad24d1b8f4659c26de9e205830db60bcbc7808ec493d696b3faed04108e395bca9ac3c35e0c17058433733fa44dac6d854cd128cd363202f747f6a9ec8d3c34840f4948df4c93fe3762c6d64d81d9f293ab652fea6325e3aacf31fb6ed7616ef5072c4238723e4784bf3d4cb12de6df1da3ae2b5fe1bc7427505cf62f7dba77eac9626d86e77edb3e74a94a0514eb08bf360abd74650b98ad3ee72cdc0c00ce175dac6fad89c76bd60744d29aa214def4b669b9d93331d4a97a08aeaa17b1047e2c20650bda0f142439a35da605b041ae35d8ced42fd44a0667b05f5b74799ee4282cd270bdda6b21032eb1b8c0f8cc71f7739e02d5a3560f2abee5b40bfe8a728a3d163b461c71611e6a4fa0548f4e1ec1077b2c7c97c441fc5a20f01a12943c3396bc20e7fc476379f29d3816e7b863e2c1829e155f9f6c865c7fb10da0fc670febf8619296d437478c628cc48ac6c0cdad8047dc152dc1421e0eb88feb8865a1008541e8920d6756cc6981dd61f402fbca790030a11f16f7161273bef75cf1b383d1488cd1da662a86985183cb664d5d81832e721bc418ca0b71e89b0f0a490d5fac35218b6d2bafd4134f73f004e47a3e2cb35a1d3122715868b353e281e939cb71bdc739ab9e1a97fbb7a70bcb2d91df94ba13320c5f4a91fa4a2d1b3c3308686ec00310ce3044fb7030cb39af19049bcd8da2f041f03bd62af1b3e31fee263b1c403f725400c363a7a868d7cc6f52305e1c3363aa773b7d21084437abc7f0172fb5611a7e85471100235a1bd89de886dc5a4efbebfc8a661d1004abbe7791a8279d12b14e4f040d85ccd98c8ddd23304133794dced22c784e53b94ae963db2c6f74e495d7965e7445a348a6f4dcc5689dd64d08cd88fba9e53d1d1bc366e9d87ebcb7bf27dd7fa70914f6a067706cc164cd6c8ddf889d3e32db427dfaf582ca1396d1a6aaa19c90d3c94f312c265fbdae12e0f6bb328bf401e20694b98575c8c57dc3cffdd3849d599867470c1ee4c87a22444ccb14cc828e4edae70c5d2c98c2aaed6b72d3b8f59ef859fede2565d23fcb63420b77d511a3a052b9fafdface44d33b884aaa47823ae01d12fa6c4ff982db763d01013f9a3fec5382bf3a7090d90d3f7911bcf3df80b8b118fb8ae1df402de8cf27123204a0833fe7a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数学原理</title>
    <link href="/2024/05/12/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    <url>/2024/05/12/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h1><h2 id="大数定理"><a href="#大数定理" class="headerlink" title="大数定理"></a>大数定理</h2><p>大数定理是概率论和统计学中的一个基本概念，它描述了当样本数量足够大时，样本均值会趋近于总体均值的性质。大数定理有两个主要的形式：</p><ol><li><p><strong>切比雪夫大数定理</strong>：如果随机变量的序列 (X_1, X_2, …, X_n) 具有相同的期望 (E(X_i) &#x3D; \mu) 和有限的方差 (Var(X_i) &#x3D; \sigma^2)，那么样本均值 (\overline{X} &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^{n} X_i) 会以概率 1 收敛到 (\mu)，即随着 (n) 的增加，样本均值的分布越来越集中于 (\mu)。</p></li><li><p><strong>伯努利大数定理</strong>：特别地，当每个 (X_i) 都是独立同分布的伯努利试验（即只有两种可能的结果，成功和失败，且每次试验成功的概率为 (p)），则样本均值 (\overline{X}) 收敛到 (E(X_i) &#x3D; p)。</p></li></ol><p>大数定理在统计推断、机器学习、金融风险评估等领域都有广泛的应用。它为从样本推断总体提供了理论基础，尤其是在估计总体参数时。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git操作</title>
    <link href="/2024/05/09/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/git%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/05/09/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h1><ol><li>git clone</li></ol><blockquote><p>克隆仓库 <code>git clone https://github.com/cs-lb/lnnu_medicine_order.git</code><br>2. git checkout -b {分支名称}</p></blockquote><blockquote><p>在本地创建一个分支</p></blockquote><ol start="3"><li><p>在本地分支修改代码</p></li><li><p>提交本地修改，在远程仓库创建同名分支，并推送过去</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git add .<br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span><br>git merge <span class="hljs-keyword">master</span><br><span class="hljs-title">git</span> push -u origin &#123;分支名称&#125;<br></code></pre></td></tr></table></figure></li><li><p>在远程仓库对应项目中请求合并<br>GitHub操作流程：进入Pull requests选项卡页面，找到New pull request按钮，填写相关信息，点击Create pull request按钮。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>语义分割</title>
    <link href="/2024/05/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    <url>/2024/05/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h1><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><p>平均交并比 (Mean Intersection over Union, <strong>MIoU</strong> )：计算每一类的IoU，然后求平均值，是语义分割问题中常用的评价指标</p><p><img src="/../../img/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>国家级大创</title>
    <link href="/2024/05/03/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%9B%BD%E5%AE%B6%E7%BA%A7%E5%A4%A7%E5%88%9B/"/>
    <url>/2024/05/03/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%9B%BD%E5%AE%B6%E7%BA%A7%E5%A4%A7%E5%88%9B/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f05b333d5e1c1264a01a843d113ddfea9475b73dafb0776e9764069834f90684">184d5613b7d1f40c9857b7bf904a8fe36b33bf429edbb9059ece5af0bf6d66950fb519579963d197a6c9a43409a6c9948d343dc848ce4dd415650f161e59e06da6d6597fc8fd69233110874b667b6cf97d275e1d533fe9fa2de94f6711cf038c71591288bda8e9f69ffb6d9ba17f35b172b77b74922786d515cceb34e24351854be28d92b26dac48ce3191d032049ab144f86015362609a60e51bb78c04a77bb872860cc1e2880729955c234c8c3ffec5b227668323e546cc58b6eb55b154522d9ecfe56304b5e3ea107d8ff11bc68b250f5f71e9e0a5f644317ef2bc74b0845457276bbc510f07b9f41225a6a73ac480e6ff72c80128ca338d5987385a944faa8e453b21088f96439753a457020a6197c17a73c6621cee578c3443aa38e8f36b217d7a94eda3cf8c508068f67b08c88badb56820152cef1febdfbb95ae191c25d7885d3788de58db09bf76d41f7eb4a648bca8c79230e672c0ed99b4defb9096c2cb171974de6bded2af802ab0706acb1ce87f984380007aa64890b0c5ea57cfa06c4bebe279e69a508904ff2a3544c39aea8ed76ea156d8fb24fd7cb80785ff56d5195bcd4592b96692364ba615306504cbf1978f44750b7bd0873427644d6c90fdb18ea6a725611b7772e443653e10998e6b4c53bc6c23957f09957eea99a7851f672abf268937d3502dda3c83fb58ec2f32f3d47a8354586be4f702f2d14f455e602e65db35dc27c608933fbca19db63a0657449824e2eca8ffcf32506ef0f6218c9d59e73142b963cfa1550addc1fd884c8968f1efd1d28f951be779a7233191f191ff49234c6f807812cba97d4fcef2de751ccd1eaf24d207a78975e41a21448b5de11c31d693fac487d192b27f432adeae0027742eee0942b59d82940b8571bcbecb85e97fd282138e5b4d037d194230090a707269b6a825191f7014dce18336ffc35308c09d0a64030583fc0d3572dfd529f98c3181310b5294ac9dca8ce61c9fac4ddf49a24d1720bd91e02e45e9fbf64e21a30bf766ea0b0f25e5abce50412964c8d67814f2d13d1674cc47a7b1aae5c58c096ee907db7d28f969e2f6043bee447dab68ff08c11b823e52b9d3075c63a13118b76be497f2206fa408da7925a8b4ff71630a6367796802b848c89451ba3ffaa996d8e787de7bb60506873646fed72c3a75ca86abe04e6afc66ee76ccf33d6c426a75900be7323358553d3f2797e299fd990170f0560bc89d54d93aaf0aaa91c5872d40813442f898b8e24060bbd922ae3ad4e710dcb0d408f05614ee793e07b826202d9272507eb26858ed1b663a97c5e52cc3aac1a957d939dc7c270634fc4ceb06a40628a1d0ab562a5e598c68f313ec111a15908e7c058b40e863664779a27300ff5a15ebd6f6e42a57ce81c31ebad0bde6cb97e5c6905e906d3b1d5fb7df01fe59f567f59c641e7ebe4b3a6f6f04012486aa90bc728dee80658571b49df83a2f62e001fbdbb41bb8f8fe7415da3b67b8567c696382faf4eaabd2c0f868e864f5df41ab0bfe20826c5050657c4004719f6000d619a000c57033e816e9c17481b97259612317540eef45a9142a332d338f075de368bacb63a3f6b34e725dddb4a3064523dbd7bb6d25485561a5f3b142bbfc280da070ec3d1a8170ed2e06dab2e9e55fce1af02956937ae5d4ea3db4ad10e5df17807f2783d986c36f14711f0d44ee981b5e0d420bb10bfd4c4553f9bd29e0db96ca82f94a731904163d675fb373c091158a5dc9b61ee37fd71a312b030965157a1b627a6013ed9cd0987c392374b6ba7af33c461b49a24d81c62a93763a467203d21e8843ce0141de05fc16c4bcef3e13403640b1675fb58171b5264fd5d3dd3e88a9fc14ea1f6a316ac9d591cd5245a7ac4145a9c94c5c1c139118b9fd76b10db997d453f0c378ef775875f6abf4cdb677c1949181b234949fb1fd2883542e9a20afbe3b2a922af6669dcad3195961ec18977f1b8d2aef2524440eaa26e4a7fea7d7da00c5cac6555b4c3646e23b5ebac0708009adc40f985479ec7ecd729dc2abe3d2c4851308b420a9ecdf25e7fedf977be1024b47a8c4b51ae425a2dfeb9c61e09543e6601590679bc7fa2f691046c1a1a1f0d32a3d2bcd43e26b097774e890e8bc974dc355f8acd9281e22003c723c4e6732bf3a83cf59297d587df8f276ed49ecd6f07a3023a15ba396ce80499953985d12f97559af9167f7b70f7945a8c135f8f3527ac2615e77cf491d6be8f89d8f2c2cbc108ccb8ce645aa2408d4e04fa3762af1b14635658c2310cd3ac941a7cc1b7644e30a3edf40b1d1e7064131691096a5474210e1b9c884495a17af3d760aadb0f159e9dee0d9439f74fe46190304649496f96534aebb897e3c72b3aacb855a88d3bbca57b21e52cb0c499fee7e70b8c4bb99a67302f6edc2fa97545c1491d16a43c93ff7948314139d91982cea089011621e628ad0e01f3e2bc17a258279d766bf49236931269e96c0e1fa14453de2ff5dbed494a65614977f13076ea7b6a2fed907ae101c3cbae2f36e817cfa1b080c9076e3cd97526d4707cb46cb0a16206f104de0c8a3baf22cb20bfe6296f56f20870fe8c21efac8a76fec0b13d7755a39f96b493e8bae0b4f94ddc6769b250a4fc7291fd7c00ac719a32be46576f57f166a67c1d9fe353d563190e97070359464f46a698505edfc3df8ee988a12e30b2278b4ef6aba47651cd966f0a82a878b2045d23a57364b03cb23155faf58f89cef4c8636893b2b8a8fccec21e84225ae1a421b358e096acc096c63daaffb100abb809c316529c30c585420c82a5bea0ca9018d5232400d5318d77d76e439c1854d7f61b28114b711d09351e82aded4097cd3e699a75f1a95783879e84dac2a5cf3b8dddf51d2a0d95c0f1a2dc594c8c52ecdfe6e0f4711e4287c0ec48413e6ef2e2224030b78f646d12e43258e17e17330e348ec5bee60f74ca258a87a438dc28929071c1e290d119a8f6f8a9df68889f3b0645d4750e4b4046360a809e25ce096877d83a5d79a5dbac7133408cc95601b4836f08aa267fe7a916d356fd77c6805b1af0f1446d004c86665cf16a1f4032f05ef64db44d3846b72c9b2602f53bc1ef598bffface4b186bed6e6f3e26c91dde3d47ef266b10e2a5730da891608064c9a4e1017933469cf5f1ade7728e9d6c7a954849e6acd42b0a650b6771a61e6a5737ea4437c7e8e3712337619ac1180d9da6b0d1bdc31cc6e6914d94ae16f9251607ed94c86eb7c8a7c89b011706457228d3f20a40a5ae13863783ce805b8c2207f0fe36ab448fb900c707b9c4742bca2ceb58d2dfc246c025b6a3dfda948fcecda25c56ed5a9267e6dcaed5151bba61b2435b8d754b5445e243fa0850919f8f07bd41e2b0f21db21a5c508329efaf76a3f514a7ecb1ec41ec4cf85d8b9da44c34c7b1b217c0fa18b02af1401c0abecd4efff163a83c2c24227eeb58eda67f1848d8ed0c106835bb1507174667f191cf0bafdcb4822c1ff13eee0ecfb63a2ef6f140f7ee876c8762aca189b70abc334973983c8d83a1bc1fbf71550d93c61de08bfbd0f39890120a0b3925d339b084dc4439568ba60c30f6af599e7860de3a86238a8405d4a5e58e485f55dd53f0ba7380f43f57bf8c052be9a20961b8674b9e8b5ae7b916f7ab07627e6fb126a6f8cff2bc438cec62f3a9ad27afb9bd5151deadcfa3255a57dbb806f9ecf08e0dc190d8acf4b6e596490843c99f67d072a546e22bfa9cf9d0fbbfe196926d0c609be0e8545864ceba0a06d296a66be1c5c92accbf747d583be90ec4e8b8f81744673d81bd1492325bb7dd69bb2a7bddf94c180556882190058bd0fb7ae398d51a3f0062dad3b269abe1d0cb017d95cf00bc9f76554826af5d21eea1f65ea19311e0bada7652116451b84f923606bf9246d72792387cf091763a5a17715ab88621cf6cec928a26be60398a99ce65bf5a1c96d50d79d9beef3fa0fb91b819bb1f5fb1bd581d1d2791595869f0d65f080beedeab2e4d2bc684482b1e59cdaa25439bdece4dc2ad957a6709436b546d83bda8e73bc471af5995ef450dbf919764e338741f976b4b2929c9b5bf2c52f9015b462c3c250235052c868181c4ec10686173dedb87fedc3c2af90e7f1d367f1b8e28cbf33d536de5a1581cb80e635df4e2adcb45f1411df585d48676a9994f1072c4877c836e541ed05e54bb6cd0bf092ba22242726bc60a752ed42b9f4a7c797781ea4edae6db8bb5501b795e93e48d2f96599538ab4c55723b0edf7760416a00d1e44538ad9d80ace39ccce8dc21547ddb6dd2fe0d3073a678e843e164d00d654b9819caa96a17912e0b9fbeb14dc8caf5c93bfeac0d5e088cee86876c9a72fcbc99f412fd2d439d388b29bbe792207d43141b155d54f8055c78559e67ef9ca51bbd1c72688e5279fa5ab6dad2763195c33cc27d426d32440c23482aa055b46dab1a13</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swin-transformer</title>
    <link href="/2024/04/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Swin-transformer/"/>
    <url>/2024/04/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Swin-transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Swin-transformer"><a href="#Swin-transformer" class="headerlink" title="Swin-transformer"></a>Swin-transformer</h1><h3 id="mask-作用"><a href="#mask-作用" class="headerlink" title="mask 作用"></a>mask 作用</h3><p>swin采用了滑动窗口的机制</p><p>好处是之间被分割的小窗口只能在窗口内部通信，大窗口滑动后能够使得曾经不能在一起通信的图像像素现在能互相计算了。</p><p>大窗口滑动后，将被移出去的图像又对称性得移动到大窗口中来。此时为了限制原始图像时不是挨着的窗口 就算移动后现在挨着了也不能相互通信，因此采用mask方式来限制（即给想要丢弃的部分赋值为无穷或者-100，使得其softmax之后为0）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>注意力机制</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><p>注意力机制相关介绍链接</p><p><a href="https://blog.csdn.net/qq_52785473/article/details/125804579">深度学习中一些注意力机制的介绍以及pytorch代码实现</a></p><h2 id="注意力机制的种类"><a href="#注意力机制的种类" class="headerlink" title="注意力机制的种类"></a>注意力机制的种类</h2><ol><li><p>聚焦式注意力和显著性注意力</p><ul><li>聚焦式注意力：</li><li>显著性注意力：</li></ul></li><li><p>通道注意力（Channel Attention），空间注意力（Spatial Attention），分支注意力（Branch Attention），自注意力（Self Attention）和交叉注意力（Cross Attention）</p></li><li><p>软注意力和硬注意力<br><strong>软性注意力机制</strong> 可以理解为表示的是所有输入向量在注意力分布下的期望<br>而硬性注意力关注某一个输入向量。</p></li></ol><p>硬注意力实现：选取最高概率的一个输入向量</p><p><strong>硬注意力缺点：</strong> 最终的损失函数与注意力分布之间的函数关系<strong>不可导</strong>，不能反向传播来训练，需要使用强化学习训练。</p><h2 id="注意力机制的计算"><a href="#注意力机制的计算" class="headerlink" title="注意力机制的计算"></a>注意力机制的计算</h2><p><strong>注意力机制的计算</strong>可以分为两步：<br>一是在所有输入信息上计算注意力分布<br>二是根据注意力分布来计算输入信息的加权平均</p><p>卷据、池化、全连接都是只考虑不随意线索<br>而注意力机制考虑随意线索。</p><ul><li>随意线索被称为查询（query）</li><li>每个输入是一个值（value）和不随意线索（key）的对</li><li>通过<strong>注意力池化层（最大汇聚）</strong> 来有偏向性得选择某些输入</li></ul><p>注意力就是从一堆线索中根据指定的规则挑选出需要的线索。类似于池化层去降维的感觉，可以节省计算资源。将注意力集中到有用的信息上，不要在噪声中花费时间</p><p><img src="/../../img/attention%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><ol><li>根据 queay 和 key 计算两者的相似性或者相关性</li><li>对1的原始分数进行 softmax 归一化处理</li><li>根据权重系数对 value 进行加权求和</li></ol><p>$$<br>f(q) &#x3D; \alpha(q,k_1)v_1 + \alpha(q,k_2)v_2 + \alpha(q,k_3)v_3 &#x3D; \sum_{i&#x3D;1}^3\alpha(q,k_i)v_i<br>$$</p><p>$\alpha(q,k_i) &#x3D; softmax(a(q,k_i))$<br>注意力权重 &#x3D; softmax(注意力分数)</p><p>注意力分数可以通过以下几种模型计算出来<br><img src="/../../img/%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%88%86%E6%95%B0.png"></p><p>vit中的自注意力机机制采用的就是缩放点积注意力模型</p><p><img src="/../../img/attention%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.png"></p><h2 id="vision-transformer中Attention是怎么计算的"><a href="#vision-transformer中Attention是怎么计算的" class="headerlink" title="vision transformer中Attention是怎么计算的"></a>vision transformer中Attention是怎么计算的</h2><p>Vision Transformer (ViT) 是一种将 Transformer 架构应用于图像分类任务的模型。Transformer 架构最初是为自然语言处理任务设计的，它的核心是自注意力（Self-Attention）机制，ViT 将这一机制扩展到了视觉领域。</p><p>在 Vision Transformer 中，图像首先被划分为多个小块（称为 Patch），然后这些小块被线性投影到一个固定维度的嵌入空间中。随后，这些嵌入被送入 Transformer 模型中进行处理。</p><p>Attention 机制的计算可以概括为以下几个步骤：</p><ol><li><p><strong>查询（Query）、键（Key）、值（Value）的计算</strong>：</p><ul><li>对于输入的每个 Patch 嵌入，模型会分别计算其对应的查询（Q）、键（K）和值（V）。这通常通过三个不同的线性层实现。</li></ul></li><li><p><strong>注意力分数的计算</strong>：</p><ul><li>使用查询（Q）和键（K）计算注意力分数。具体来说，对于每个查询，模型会计算它与所有键的相似度，这通常通过点积（dot product）来实现：<br>[ \text{Attention Score} &#x3D; \frac{Q \cdot K^T}{\sqrt{d_k}} ]<br>其中，( Q ) 和 ( K ) 分别是查询和键的矩阵，( K^T ) 是 ( K ) 的转置，( d_k ) 是键的维度，分母中的 ( \sqrt{d_k} ) 是为了稳定训练过程中的梯度。</li></ul></li><li><p><strong>Softmax 归一化</strong>：</p><ul><li>计算得到的注意力分数通过 Softmax 函数进行归一化，使得所有分数的和为 1，这样可以得到每个查询对于每个值的注意力权重：<br>[ \text{Attention Weights} &#x3D; \text{Softmax}(\text{Attention Score}) ]</li></ul></li><li><p><strong>加权值（Value）的计算</strong>：</p><ul><li>使用归一化的注意力权重对值（V）进行加权求和，得到最终的输出：<br>[ \text{Output} &#x3D; \sum (\text{Attention Weights} \cdot V) ]</li></ul></li><li><p><strong>多头注意力（Multi-Head Attention）</strong>：</p><ul><li>在 Transformer 中，通常会使用多头注意力机制，即上述过程会被复制多次（头数），每个头学习到的是输入的不同表示。最后，所有头的输出会被合并起来，通常是通过拼接（concatenation）和再次线性变换来实现。</li></ul></li><li><p><strong>位置编码（Positional Encoding）</strong>：</p><ul><li>由于 Transformer 架构本身不具备捕捉序列顺序的能力，因此在 Vision Transformer 中，需要为图像的每个 Patch 添加位置编码，以提供位置信息。</li></ul></li><li><p><strong>层归一化（Layer Normalization）和残差连接（Residual Connection）</strong>：</p><ul><li>在每个注意力块之后，通常会使用层归一化和残差连接来促进深层网络的训练。</li></ul></li></ol><p>Vision Transformer 通过这种注意力机制能够捕捉图像中不同区域之间的关系，从而实现有效的图像表示学习。这种模型在多个视觉任务中展现出了与卷积神经网络（CNN）相比拟或更优的性能。</p><h3 id="层归一化和残差连接的作用"><a href="#层归一化和残差连接的作用" class="headerlink" title="层归一化和残差连接的作用"></a>层归一化和残差连接的作用</h3><p>层归一化（Layer Normalization）和残差连接（Residual Connection）是深度学习中两种常用的技术，它们在提高网络训练效率和性能方面起着重要作用，尤其是在深度网络中。</p><p><strong>层归一化（Layer Normalization）</strong></p><p>层归一化是一种归一化技术，旨在在网络的每一层对输入进行归一化处理。与传统的批量归一化（Batch Normalization）不同，层归一化是在单个数据样本的层面上进行归一化，而不是在整个批次上。</p><p><strong>作用</strong>：</p><ol><li><strong>减少内部协变量偏移</strong>：层归一化通过规范化处理，减少了网络内部的协变量偏移问题，这有助于加速收敛速度。</li><li><strong>提高模型稳定性</strong>：由于归一化减少了不同层间的尺度差异，这有助于网络训练过程中的稳定性。</li><li><strong>允许更高的学习率</strong>：由于层归一化减少了梯度消失或爆炸的问题，因此可以使用更高的学习率进行训练。</li><li><strong>简化网络初始化</strong>：归一化层使得网络对初始化不那么敏感，从而简化了网络的初始化过程。</li></ol><p><strong>残差连接（Residual Connection）</strong></p><p>残差连接，也称为跳跃连接（Skip Connection），是一种允许网络中的信号绕过一层或多层直接传递的技术。</p><p><strong>作用</strong>：</p><ol><li><strong>缓解梯度消失问题</strong>：在深层网络中，梯度可能会随着层数的增加而迅速减小，导致深层网络难以训练。残差连接通过直接连接层，帮助梯度直接流向前面的层，从而缓解了梯度消失问题。</li><li><strong>提高模型容量</strong>：残差连接允许模型学习残差函数，这意味着模型可以学习到恒等映射（即直接传递输入到输出），这增加了模型的容量。</li><li><strong>网络深度的扩展</strong>：残差连接使得可以训练更深的网络结构，因为它们减少了随着网络深度增加而性能下降的问题。</li><li><strong>提高训练速度</strong>：残差连接有时可以加速模型的训练过程，因为它们允许网络更快地收敛。</li></ol><h3 id="在-Transformer-架构中的应用"><a href="#在-Transformer-架构中的应用" class="headerlink" title="在 Transformer 架构中的应用"></a>在 Transformer 架构中的应用</h3><p>在 Transformer 架构中，层归一化和残差连接被广泛使用：</p><ul><li><strong>层归一化</strong>通常应用于多头自注意力机制和前馈网络的输出上，以稳定训练过程并提高性能。</li><li><strong>残差连接</strong>则被用于连接自注意力层和前馈网络的输入与输出，确保信息可以在网络中直接流动。</li></ul><p>这两种技术的结合使得 Transformer 架构能够有效地处理长距离依赖问题，并在多种任务中取得了显著的性能提升。</p><h3 id="为什么要使用缩放点积"><a href="#为什么要使用缩放点积" class="headerlink" title="为什么要使用缩放点积"></a>为什么要使用缩放点积</h3><p>点积之后方差为 $ d_k $</p><p><a href="https://blog.csdn.net/ytusdc/article/details/121622205">为什么在进行softmax之前需要对attention进行scaled</a></p><h3 id="多头注意力计算"><a href="#多头注意力计算" class="headerlink" title="多头注意力计算"></a>多头注意力计算</h3><p>是的，多头注意力机制（Multi-Head Attention）在每个头内部独立进行注意力计算。这种机制是 Transformer 架构的关键组成部分，它允许模型同时从不同的表示子空间中捕获信息。</p><p>以下是多头注意力机制的一般步骤：</p><ol><li><p><strong>线性投影</strong>：输入序列首先被分割成查询（Query）、键（Key）和值（Value）三个部分，并且每个部分都通过独立的线性层（即一维卷积）进行投影，以生成不同头的输入。</p></li><li><p><strong>分割为头</strong>：每个部分（Q、K、V）被分割成多个头，每个头处理输入序列的一部分信息。</p></li><li><p><strong>并行处理</strong>：每个头独立地计算自注意力，即在每个头内，使用 Query 和 Key 计算注意力分数，然后这些分数用于加权 Value。</p></li><li><p><strong>拼接头</strong>：所有头的输出被拼接在一起，形成一个较长的序列。</p></li><li><p><strong>最终线性投影</strong>：拼接后的序列通过另一个线性层进行投影，以生成最终的输出。</p></li></ol><p>在数学上，如果我们有 ( L ) 个头，每个头的注意力计算可以表示为：</p><p>[ \text{Attention}^l(Q, K, V) &#x3D; \text{softmax}\left(\frac{QW^Q_l K^T W^K_l}{\sqrt{d_k}}\right) W^V_l V ]<br>[ \text{Output} &#x3D; W^O \left[ \text{head}_1; \text{head}_2; …; \text{head}_L \right] ]</p><p>其中，( W^Q_l, W^K_l, W^V_l ) 是第 ( l ) 个头的线性层权重，( d_k ) 是 Key 的维度，( W^O ) 是最终输出的线性层权重。</p><p>多头注意力机制的主要优点</p><ol><li>它能够使模型<strong>在不同的表示子空间中捕获信息</strong>，增强了模型的表达能力。</li><li>每个头可以学习到序列的不同方面，例如，一个头可能专注于捕捉短距离依赖，而另一个头可能专注于长距离依赖。最终，所有头的信息被整合，以<strong>获得全面的序列表示。</strong></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>激活函数</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><h1 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h1><h1 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习超参数的介绍</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B6%85%E5%8F%82%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B6%85%E5%8F%82%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习超参数的介绍"><a href="#深度学习超参数的介绍" class="headerlink" title="深度学习超参数的介绍"></a>深度学习超参数的介绍</h1><h2 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习模型微调</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习模型微调（Fine-tuning）"><a href="#深度学习模型微调（Fine-tuning）" class="headerlink" title="深度学习模型微调（Fine-tuning）"></a>深度学习模型微调（Fine-tuning）</h1><p>由于在很多任务场景下，所能够使用到的数据集往往样本较少，这个时候就会思考能不能使用一些在较大数据集（如ImageNet）上训练好的模型，对其进行微调，进而运用在自己的领域任务上，即迁移学习和模型微调</p><ol><li>微调时通常使用更强的正则化、更小的学习率、更少的数据迭代</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python数据分析</title>
    <link href="/2024/04/25/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <url>/2024/04/25/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="python数据分析"><a href="#python数据分析" class="headerlink" title="python数据分析"></a>python数据分析</h1><h2 id="相关的库"><a href="#相关的库" class="headerlink" title="相关的库"></a>相关的库</h2><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>Matplotlib是一个用于绘制数据图表的库。它提供了各种绘图函数和工具，可以用于创建各种类型的图表，如折线图、散点图、柱状图等。以下是使用Matplotlib绘制折线图的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 创建数据</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 绘制折线图</span><br>plt.plot(x, y)<br><br><span class="hljs-comment"># 添加标题和标签</span><br>plt.title(<span class="hljs-string">&quot;折线图示例&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X轴&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y轴&quot;</span>)<br><br><span class="hljs-comment"># 显示图表</span><br>plt.show()<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><ol><li>矩阵SVD分解</li><li>矩阵能够相似对角化的充要条件</li><li>讲一讲SVM的原理</li><li>对特征值和特征向量的理解</li></ol><h3 id="1-线性变换"><a href="#1-线性变换" class="headerlink" title="1. 线性变换"></a>1. 线性变换</h3><p><strong>定义</strong>：<br>线性变换是指一个函数 ( T: V \rightarrow W )，它将一个向量空间 ( V ) 中的向量 ( v ) 映射到另一个向量空间 ( W ) 中的向量 ( w )，且满足以下两个条件：</p><ul><li>加法保持性：对于任意向量 ( u, v \in V )，有 ( T(u + v) &#x3D; T(u) + T(v) )。</li><li>标量乘法保持性：对于任意向量 ( v \in V ) 和任意标量 ( a )，有 ( T(av) &#x3D; aT(v) )。</li></ul><p><strong>几何意义</strong>：<br><strong>线性变换可以看作是一种在空间中的“拉伸”或“压缩”，甚至可以是“旋转”或“反射”。</strong> 在二维空间中，线性变换可以想象为一个网格被均匀地拉伸或压缩，而不会发生撕裂或折叠。</p><h3 id="2-特征值和特征向量"><a href="#2-特征值和特征向量" class="headerlink" title="2. 特征值和特征向量"></a>2. 特征值和特征向量</h3><p><strong>定义</strong>：<br>对于一个给定的线性变换 ( T )，如果存在一个非零向量 ( v ) 和一个标量 ( \lambda )，使得 ( T(v) &#x3D; \lambda v )，那么 ( v ) 就是 ( T ) 的一个特征向量，而 ( \lambda ) 就是对应的特征值。</p><p><strong>几何意义</strong>：<br><strong>特征向量：是线性变换下保持方向不变的向量，</strong><br><strong>特征值：则表示这个方向上的伸缩比例。</strong> 在二维空间中，可以想象一个线性变换将一个向量“拉伸”或“压缩”成另一个向量，而特征向量就是在这个过程中方向不变的向量。</p><p><strong>计算</strong>：<br>特征值和特征向量的计算通常通过求解特征方程 ( T(v) &#x3D; \lambda v ) 来完成，即：</p><p>[ (T - \lambda I)v &#x3D; 0 ]</p><p>其中，( T ) 是线性变换的矩阵表示，( I ) 是单位矩阵，( \lambda ) 是特征值，( v ) 是特征向量。</p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul><li><strong>机器学习</strong>：在机器学习中，特征值和特征向量被用于主成分分析（PCA）等降维技术，以及谱聚类等聚类算法。</li><li><strong>深度学习</strong>：在深度学习的卷积神经网络中，卷积核可以看作是一种线性变换，其参数（权重）可以通过特征值分解来优化。</li><li><strong>物理学</strong>：在经典力学中，特征值问题与系统的固有频率相关，特征向量则与系统的振动模式相关。</li></ul><p>理解线性变换、特征值和特征向量对于深入学习数学、物理以及相关工程领域非常重要，它们提供了一种强大的工具来分析和理解复杂系统的行为。</p><p>学完之后学习降维算法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch</title>
    <link href="/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/"/>
    <url>/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/</url>
    
    <content type="html"><![CDATA[<h1 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>pytorch 计算图<br>pytorch 自动求导的原理？<br>pytorch detach()方法 clone()方法 load save方法</p><h2 id="两大法宝"><a href="#两大法宝" class="headerlink" title="两大法宝"></a>两大法宝</h2><ol><li>dir 打卡工具箱 <code>dir(torch.cuda)</code></li><li>help 查看具体函数的使用方式 <code>help(torch.cuda.is_available)</code></li></ol><h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><blockquote><p>提供一种方式去获取数据及其label，以及数据集的大小</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image <span class="hljs-comment"># 图像操作（open、show）</span><br><span class="hljs-keyword">import</span> os  <span class="hljs-comment">#文件操作</span><br><br><span class="hljs-comment"># 继承Dataset类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-comment"># 通过定义一个特殊的__init__方法，在创建实例的时候，把所需要的属性绑上去</span><br>    <span class="hljs-comment"># 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self</span><br>    <span class="hljs-comment"># __init__方法的第一个参数永远是self，表示创建的实例本身</span><br>    <span class="hljs-comment"># 因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,root_dir,label_dir</span>):<br>        self.root_dir = root_dir<br>        self.label_dir = label_dir<br>        self.path = os.path.join(root_dir,label_dir)<br>        self.img_path = os.listdir(self.path) <span class="hljs-comment">#返回指定path路径文件夹中图片名称组成的列表</span><br><br>    <span class="hljs-comment"># 当实例对象做P[key]运算时，就会调用类中的__getitem__()方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        img_name = self.img_path[idx]<br>        img_item_path = os.path.join(root_dir,label_dir,img_name)<br>        <span class="hljs-built_in">print</span>(img_item_path)<br>        img = Image.<span class="hljs-built_in">open</span>(img_item_path)<br>        img.show()<br>        label = self.label_dir<br>        <span class="hljs-keyword">return</span> img, label<br><br>    <span class="hljs-comment"># 当使用len(p)时，就会调用类中的__len__()方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_path)<br><span class="hljs-comment"># 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去</span><br><br>root_dir = <span class="hljs-string">&#x27;D:\ADNI_classify _v-3.0\ADCNMCI\\train&#x27;</span><br>label_dir = <span class="hljs-string">&#x27;AD&#x27;</span><br>ad_dataset = MyData(root_dir,label_dir)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(ad_dataset))<br><br></code></pre></td></tr></table></figure><h3 id="tensorboard"><a href="#tensorboard" class="headerlink" title="tensorboard"></a>tensorboard</h3><blockquote><p>可视化训练过程的数据</p></blockquote><ol><li><code>add_image()</code></li><li><code>add_scalar</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 参数：title；y轴数值；x轴数值</span><br>writer.add_scalar(<span class="hljs-string">&quot;y=2x&quot;</span>, <span class="hljs-number">2</span>*i, i)<br><br><span class="hljs-comment"># tag：是保存图的标题</span><br><span class="hljs-comment"># img_tensor：图片变量名,图片的类型要是torch.Tensor, numpy.array, or string这三种</span><br><span class="hljs-comment"># global_step：第几张图片</span><br><span class="hljs-comment"># dataformats=‘CHW’，默认CHW，tensor是CHW，numpy是HWC</span><br>writer.add_image(tag,img_tensor,global_step,dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="Dataloader"><a href="#Dataloader" class="headerlink" title="Dataloader"></a>Dataloader</h3><blockquote><p>为后面的网络提供不同的数据形式</p></blockquote><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h2 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h2><p>PyTorch 是一个开源的深度学习框架，它提供了张量作为其核心数据结构。在 PyTorch 中，张量类似于 NumPy 中的数组，但是拥有额外的功能，特别是与 GPU 加速计算有关的功能。以下是 PyTorch 中张量的一些介绍：</p><ol><li><p><strong>创建张量：</strong> 你可以使用 torch.tensor() 函数创建张量，也可以使用一些特殊的函数如 torch.zeros()、torch.ones() 来创建特定大小的张量，还可以从 Python 列表或 NumPy 数组中创建张量。</p></li><li><p><strong>张量属性：</strong> 张量有很多属性，比如形状（shape）、数据类型（dtype）、设备（device，表示张量所在的设备，如 CPU 或 GPU）、布局（layout，表示张量的存储方式，如连续存储或分块存储）等。</p></li><li><p><strong>张量操作：</strong> PyTorch 提供了许多张量操作函数，包括数学运算、逻辑运算、索引和切片等。你可以对张量进行加法、乘法、指数运算等操作，也可以使用索引和切片来访问张量的特定元素或子集。</p></li><li><p><strong>自动求导：</strong> PyTorch 的一个重要功能是自动求导，它可以自动计算张量的梯度。你可以通过 tensor.requires_grad&#x3D;True 将张量设置为需要求导，然后进行计算，PyTorch 会自动构建计算图并计算梯度。</p></li><li><p><strong>张量和神经网络：</strong> 在深度学习中，张量是神经网络的基本数据结构。神经网络的输入、输出和参数都表示为张量，而神经网络的前向传播和反向传播也是基于张量的运算实现的。</p></li></ol><p>总的来说，PyTorch 的张量是一种灵活、强大的数据结构，它为深度学习提供了高效的数值计算和自动求导的功能。</p><h3 id="tensor函数"><a href="#tensor函数" class="headerlink" title="tensor函数"></a>tensor函数</h3><ol><li><code>torchvision.transforms.ToTensor()</code><br>在使用 transforms.ToTensor() 进行图片数据<strong>转换过程中会对图像的像素值进行正则化</strong>，即一般读取的图片像素值都是8 bit 的二进制，那么它的十进制的范围为 [0, 255]，而正则化会对每个像素值除以255，也就是把像素值正则化成 [0.0, 1.0]的范围<br><strong>意义：</strong>将图片表示为数字化的数据，方便神经网络进行处理和学习</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库学习</title>
    <link href="/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库学习"><a href="#数据库学习" class="headerlink" title="数据库学习"></a>数据库学习</h1><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><ol><li>数据库作用是组织并存储数据</li><li>数据组织形式：库 -&gt; 表 -&gt; 数据</li></ol><h2 id="SQL学习"><a href="#SQL学习" class="headerlink" title="SQL学习"></a>SQL学习</h2><p>sql密码： 123456</p><ol><li><p>登录本地的数据库 mysql -u（用户名） -p（密码）<br><code>MySQL -uroot -p123456</code></p></li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>联系导师经验总结</title>
    <link href="/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%81%94%E7%B3%BB%E5%AF%BC%E5%B8%88%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%81%94%E7%B3%BB%E5%AF%BC%E5%B8%88%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a9d6a092d5a36880c1c999bf8b78feb7665c7c040284c10467b5783db79d02b4">184d5613b7d1f40c9857b7bf904a8fe384dc586addb4cd4cfc68c98a0f1df306</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>夏令营经验贴总结</title>
    <link href="/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="85566a1d0d0124a772e129113aacfe00684ca33004697994f79bde81d68ef31f">184d5613b7d1f40c9857b7bf904a8fe36b33bf429edbb9059ece5af0bf6d6695fbe83ac3e024ed502a727d981ac7692a1791730a4348f90bbee5c9cdc5b8b0f3dab26871bbfc86ef5fcc9a60bbe72a84635e0cc7e2283dc0769b5d5ce111220bbbc6713b6be16e21038456185a891c9c2b030106fa39b6c67e056342f79b66af76ad039bbed3d0b53f30942aba67f8833f6392e748036e6c07d03423cb36cbf82172caf7b298af82b81687b10154fa0b33fa931b4620c10cff0f1c2e30dcd0a060deafe0d95209554dc7c8dce3730636d56640df2350baeb26572fae2d684296b46334b36b74746e7f40dfe3ee7c782b0aba333a5545a356c8224c7b02706a16dd7720add66ad49a32ba34f8ff933baeecd9daf4f24e4f6c249ce1678284a871081ec7c8ade773900b4ad2118b38452596ed0fa9b4556c61a52d77b6cb9ce4a02b1703f63e30a4776d21d651c12f9d1eb08e41d77983f3b22648f201a17526f55ae46f63c477529399e00187290572787d28aedcb07075988d9d5ccce76d899964a2685b5f1bec0e5687d54f0462ed80c689281b8a104c275a9924f402bb1b51eadea064b3c5d4e4cab94fae305e66e8a7f348118f8b60acb1773b11a2f0f55db4659055269aefed9ae45e1d0ef2c77c7dd31c16d9d11de64a3c46a279e6a07780ea2a19d7a8938b07ec8c342d3103e03ed7da4a590ba3759b52bae4b41d4d132c96dc825669f6c2ab37179048b506dc6f18884219c558feef13becd82f85474724150642117708b1ee2b8bded25fcdcdbb0f1a9576e52cc301e89dd51bea669d57caf7b007c4c1216743f7fbac096291091661a1ea7d54f45fb20215c5567cb359cb2abc95950462289c2b85e1aeea5547948351401b4f3d0b51f21618579d88fd19d647aa331393fff66d449da9cd21eb586e8a7729b8e2f82c416315af03ac60dc9acd14e4a0eaa71a6504df088e913bf56db6b2371436446c9a21a3e8a32b1eebf20c6103d402afdc62f28b59cadc644686353a6fc3572322744f3a9c7f4bae7e5d5f4a3b09c71cd94577132c736c6d9bd15b7fa29d7553ef801c6d937dd166beec0d717cc81b916b366d5a7dc0e03f789d2a98d0259141ab236565a61da772fada28909286ec8417e9a98c2b291288cda42931572ce84b19d2faa90e075bf721806af55f76b2ac4e96c74001436db654e6a4e9158dc9cab8a733bd6992efd7880446675248b3470d682dc1a14620ceba4b1b49dc74ded95329e53449e42b2de0542a2e973d94b5c77c31184c2338d6473bc50c370c741567c54edb535e69616d70805b13cce52080c36e3ae00265ccf59c87f672f0dfb58b56963e643836b77a6d7efb8ee281a1c28298710ab49296c33ed8c7604464e234b0521485290f6fd4c34a2f2cd4cc283be2f6a2f9d97306a7a82cc2c5208bca94f5501093b0380696691ae53ab4ef51e437f59ca6430e89f1d8d3bbb8ea3963c7a01bd8e5e670c26ca867eb345f0176a366efd6c09399a7c798525d28ca77fa34feaa142617c9f4c19ad2798149c8bea6739d5eea3166ee9d36586f09ade039f4e0027611509d88733cf886600f2c6976d4fd9a0167cc0059ea1818853a54840f7200f8216fa9e6764c3e3100bb27af6e1c1e84326f5a9cf41b2d5e0831a9e41cdf3949c6c508fdf627c79b0e4e6c0260d04b3d610a1118f7e4d4d59238ad5453e493da8744da3b620fa2eddf15b6db74edbff6e0ecaddac2ccf4290da918385fe1235226265406b59b6401c174a9a39c20dd6e7f64f3baaa1a5cfc5794fd7943236b46e6140957b45a2c7900a02c49a0902610e764c397b8e296f3f1053c4c0f62aa5253595bc74df10df2d17a30214d4609c7d081bda322cf0348d90b70af22634bc46c0a425d9aa7bff711847d07756165c7f1052af602a761e30f188d966eadf66c9f5d67f478fb5c425156be8d1736f31e83d6407edd1dbf71f867426237d1f897fe5a4024b2439f61f28df1813564dafad8877821407507a1572cdc0bdd662ed67c47f9374c926145b54fd2a9553ffe99df8f6876b1b11711ced2f757af0b9d750c27b793ba3996631a6c52d2e31e048136d2392b170430aecf92c5f7f1be5e2883660d80b0e8656088e7f416b648fd12af16beff2c705ccb1c64cf8d3d49c0fec199eb17070d0af8424a8fa390598fecfea1c096dd41527bc248f4f7971e75e3cb14f2c9131d6876262f79ffd244c5e7e97f5d06e2692f0a8b43194726ca25c33bd3e6529ccbf57a6b8ea867df76c16ad201edf6d948f5b29d2ec83536b0df525f8990de1fdc1a5983423080ccbf6deafa24aa3d098b1da4e45f5f2403f263d5e24d7dbe69749514f3f1c08e02f766495ccba261ca4b056906544689e7998c19b5d4ce3541dbdba5f32ba5a99757ffdedbd183ddaaafe5aacc0d21048ee68b7092e6ff75ee028146777c487aa172f1f8ab6abdd1b3fe6f01c8b22c2670ed95d78d2dfe7435f7b37ab84fd8ea0251fbd325877866f006ce98cdd34befd3c57991f69b956243124258696f0dce043f7964f8bc61845c86444e8a37a947d1869de08146bc509e4303ae672f8784acec177c7ce350b4f99c4e2ebe62d5fd2397d629302de319a21d5a375db7b4ff17eb0408adcde9125c644ab62036cef6e3fc3ab2155c2e2efd813fbde329b5d6f9009ac205cc4eb45fdfd0a1ed83d5de0a5a4429fb18e3144b05f1e5b7c0ecf973dda57af808371c8d2a2d58c3a67bc5457b08dde8282ad66af05c11583703566f9c1963c6aeb3b79571df158717c47f12a814de822e9ce60dcabc89046eb7c53f20305dc8a2b6fd5ab6b79302c3e330b396ef440c387b7f5901df6285e2fb6eeb3af92aab1b049acd0af4ee714b14bfe9b00e895551121df7772e8e4b5ec4c786c0afa400a714f4b27bb9db44ece08942d1f8dad22a19935f44db54165afc27889692ad617a09dd1481292c11d3efbc9077c7726b1706eaffd18fdb153e5d7b3f26538edd1666e4d24591e4389a621c950c726300be125288adb71851050f6f022418db9046d8fb7a99aedb0965aecb6714de6c2664c41e695149f07efa94aacfefafcbc1c92f26e6a8713588d990575b2a2097317fe7bb46cf6ad6e19d53c22d1f3800fb6b1ccfe2de43c9e1e58285372b0ff03f5c5275e444d718dbf0daf94bf6ea47f075b69f459286c4bfb3b480c50fb48676b9c6bf227a256b0317f6cf44fd8db4ab462eef4d469fbc4ac15fba07b4a4344790c194761e727549e62e31006e5dc8c852287cbf6b573366540420e5a3531ad6f5037897d39a94f5fc0c8962bce6d869d84a06c6ab9162f0f5afbfba6d130822a6abafc743524a519aa4f06f517bbb7017880b1a832200344857329fc45e3fa4e1b0eeba8568d71177bc044ed836664535073e53843828cecabb3857857bac9a6adad8db90f80f9e52cd3041656b2d95acf57e94452ebddd5fe8bdb4332cc69cf0a6cb0ae14c63d06ef65aa796ec115a3ad6a5c85ee2b6c598a2da0e51144c83ef44e4f6f042f77e86aa6500f9acca7dac1e559e184bbd821f700e50db808cfc14b0e90c1477d7f6de473f7e832629ceb8e6345226b6e09b7d56e45f7093f7b237bbb4bcd9151135f1a2d04cddf32d5eb1ef63e42e94f11c46167b4ba8fda64f516222a99aecf8c47870c3db2c111ff1b8723c4af5880eb5396a0e5726fa78be7ad22d1fe71848ef6f5ffa859a5dacfb999906e09f88a5d9649f6836eae3b5f2ef3a9f5d9de567dc10b28262f0e652ff22eba984c0a0d33d2c16930736286e0e05514d21375d6a761057fe3993aa03b6775af7d4a6c1979684ccad470b0c30ac29d79ea694ee2e54139d294ee572b00133d3b7bb902d999e6cb61790e3d40c60f65dd0972fc6a45cba24e31f579c97521510ead9429f6aedf59605dd47f30035bb9eda38f3b680fae12ea9e01a27d3d885c5caf48f6470330f543e12a050a08d973fdd6adfaaad56596521db6a78e3c20a34bb90d4989f7c74f761043db2438e6196e99e540456325c0a9d76e90c765efb4243d4fff774f633872230ed8a8d618723ea69398f1afcb937ec4de22d60c04ad32488872d586d5242229aa8d7d9bbcdd1c4ef3b41db1b61d4bd3563902a51979b405953f1445177df7698aa42a736c0e1bc1e2658963b8eef113ce2df9491d819fbb2643269377d18e7421ed843b7336</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小程序开发问题汇总</title>
    <link href="/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="小程序开发遇到的问题"><a href="#小程序开发遇到的问题" class="headerlink" title="小程序开发遇到的问题"></a>小程序开发遇到的问题</h1><blockquote><ul><li>通过slider改变自动播放的间隔时间时，即使没有打开自动播放，也会使得轮播图开始自动播放</li></ul></blockquote><h2 id="页面下拉刷新"><a href="#页面下拉刷新" class="headerlink" title="页面下拉刷新"></a>页面下拉刷新</h2><blockquote><p>1.开启下拉刷新 ，在页面的<code>.json</code>文件中将enablePullDownRefresh 设置为true<br>2.监听页面的下拉刷新事件：onPullDownRefresh<br>3.停止下拉刷新效果：调用wx.stopPullDownRefresh()函数即可</p></blockquote><h2 id="页面上拉触底"><a href="#页面上拉触底" class="headerlink" title="页面上拉触底"></a>页面上拉触底</h2><blockquote><p>1.下拉触底刷新事件：onReachBottom<br>2.通过.json文件的<code>onReachBottomDistance</code>属性来配置上拉触底的距离（默认是50px）</p></blockquote><h2 id="小程序生命周期"><a href="#小程序生命周期" class="headerlink" title="小程序生命周期"></a>小程序生命周期</h2><blockquote><p>onLoad-&gt;onShow-&gt;onReady-&gt;onHide-&gt;onUnLoad</p></blockquote><h2 id="小程序常用API"><a href="#小程序常用API" class="headerlink" title="小程序常用API"></a>小程序常用API</h2><blockquote><p>显示消息提示框 wx.showToast({title:’ ‘, icon:’ ‘,duration:’ ‘})<br>显示对话框： wx.showModel<br>显示loading提示框：wx.showLoading, 关闭loading提示框：wx.hideLoading<br>页面路由API</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++内存分区</title>
    <link href="/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/C-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    <url>/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/C-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="C-内存分区模型"><a href="#C-内存分区模型" class="headerlink" title="C++内存分区模型"></a>C++内存分区模型</h2><p><strong>程序运行前划分为代码区和全局区，程序运行后分为栈区和堆区</strong></p><blockquote><ul><li>全局区：全局变量，静态变量（static关键字），常量（字符串常量 和 const修饰的全局常量）</li><li>栈区：由编译器自动分配释放，存放着函数的参数值，局部变量等，注意不要返回局部变量的地址</li><li>堆区：由程序员分配释放，若程序员不释放，程序结束后将由操作系统回收</li></ul></blockquote><h3 id="栈空间和堆空间区别"><a href="#栈空间和堆空间区别" class="headerlink" title="栈空间和堆空间区别"></a>栈空间和堆空间区别</h3><table><thead><tr><th>特性&#x2F;方面</th><th>栈空间（Stack）</th><th>堆空间（Heap）</th></tr></thead><tbody><tr><td>内存管理</td><td>自动管理</td><td>手动管理</td></tr><tr><td>生命周期</td><td>函数调用结束时自动销毁</td><td>需手动释放，否则可能导致内存泄漏</td></tr><tr><td>分配速度</td><td>快</td><td>慢</td></tr><tr><td>大小</td><td>相对较小</td><td>相对较大</td></tr><tr><td>内存碎片</td><td>不容易产生</td><td>容易产生</td></tr><tr><td>性能</td><td>高</td><td>相对较低</td></tr><tr><td>使用场景</td><td>存储局部变量、函数调用上下文</td><td>存储大型数据结构、动态分配的对象</td></tr><tr><td>分配&#x2F;释放操作符</td><td>无（自动）</td><td><code>new</code> &#x2F; <code>delete</code></td></tr><tr><td>典型限制</td><td>大小有限制，不适合大型数据</td><td>受限于系统可用内存</td></tr><tr><td>访问速度</td><td>访问速度通常比堆内存快</td><td>访问速度相对较慢</td></tr><tr><td>示例</td><td><code>int a;</code></td><td><code>int* b = new int;</code> <code>delete b;</code></td></tr></tbody></table><h3 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h3><blockquote><ul><li>利用new运算符可以将数据开辟到堆区：<code>int *p = new int(10)</code></li><li>new运算符返回的是数据在栈中的地址</li><li>利用 <code>delete</code>  可以释放堆区数据（<code>delete p</code> ）</li></ul></blockquote><p>开辟数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">let* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>    arr[ i ] = i + <span class="hljs-number">100</span>;<br> &#125;<br> <span class="hljs-comment">//释放数组</span><br> <span class="hljs-keyword">delete</span>[ ] arr<br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h3><blockquote><ul><li>作用：给变量起别名</li><li>基本语法：数据类型 &amp;别名 &#x3D; 原名（ int &amp;b &#x3D; a ）</li><li>引用一定要初始化，且之后不能再更改了</li><li>函数参数的引用传递，形参也会修饰实参</li></ul></blockquote><h3 id="引用和指针区别"><a href="#引用和指针区别" class="headerlink" title="引用和指针区别"></a>引用和指针区别</h3><p>引用是提供对已存在对象的一个别名<br>指针是指向对象的内存地址</p><ol><li><strong>不存在空引用</strong>。引用必须连接到一块合法的内存。</li><li><strong>指向改变</strong>：一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li><strong>初始化</strong>：引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ol><p>引用的主要优点是语法简单、使用安全，因为它们不允许空引用，也不能重新指向另一个对象。指针则更加灵活，但也更复杂，需要程序员手动管理，包括处理空指针和内存泄漏等问题。</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h3><blockquote><p>类的默认访问权限是private</p></blockquote><table><thead><tr><th>权限名</th><th>描述</th></tr></thead><tbody><tr><td>public</td><td>类的内外都可以访问</td></tr><tr><td>protected</td><td>只有类内可以访问，且可以被继承</td></tr><tr><td>private</td><td>只有类内可以访问，且不可以被继承</td></tr></tbody></table><p><strong>成员属性私有化</strong><br>1.可以自己控制读写权限<br>2.对于写可以检测数据的有效性</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>构造函数语法：<code>名（）&#123; &#125;</code></p><blockquote><ul><li>1.构造函数，没有返回值也不写void</li><li>2.构造函数名称应与类名相同</li><li>3.构造函数可以有参数，也可以重载</li><li>4.程序在调用对象时会自动调用构造函数</li></ul></blockquote><p>析构函数语法：<code>（）&#123; &#125;</code></p><blockquote><ul><li>1.析构函数，没有返回值也不写void</li><li>2.析构函数名称应与类名相同，在名称前加上 ~</li><li>3.析构函数不可以有参数</li><li>4.程序在对象被销毁时会自动调用析构函数</li></ul></blockquote><h2 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝&amp;浅拷贝"></a>深拷贝&amp;浅拷贝</h2><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><blockquote><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外访问</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/Vue/"/>
    <url>/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><strong>初识Vue：</strong><br>1.想要Vue工作，就必须要创建一个Vue实例，且要传入一个配置对象<br>2.demo容器里的代码任然符合html规范，只不过加入了一些Vue语法<br>3.demo容器里的代码被称为【Vue模板】<br>4.Vue实例和容器是一一对应的<br>5.真实开发中只会有一个Vue实例，并且会配合着组件一起使用<br>6.中的xxx要写js表达式，且xxx会自动读取到data里的所有属性<br>7.一旦data中的数据发生改变，那么页面中用到该数据的地方都会自动更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;初识Vue&lt;/title&gt;<br>    &lt;!-- 修改页签icon logo --&gt;<br>    &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;../images/vue.png&quot;&gt;&lt;/link&gt;<br>    &lt;!-- 引入vue --&gt;<br>    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    // 准备一个容器<br>    &lt;div class=&quot;demo&quot;&gt;<br>        &lt;h1&gt;今天是&#123;&#123;date&#125;&#125;,这是&#123;&#123;name&#125;&#125;的第一个vue程序&lt;/h1&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示<br>        console.log(Vue.config)<br>            //创建Vue实例<br>        new Vue(&#123;<br>            el: &#x27;.demo&#x27;,<br>            data: &#123;<br>                date: &#x27;2022/8/11&#x27;,<br>                name: &#x27;jyd&#x27;<br>            &#125;<br>        &#125;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h3><blockquote><p>用于解析标签体内容<br>写法：,xxx是js表达式，且xxx会自动读取到data里的所有属性</p></blockquote><h3 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h3><blockquote><p>用于解析标签（包括：标签属性，标签体内容，绑定事件…）<br>举例：v-bind:href&#x3D;”xxx” 或 简写为 <strong>:href&#x3D;”xxx”</strong> ,xxx同样要写出js表达式的形式<br>Vue中有很多指令，都是v-xxx</p></blockquote><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>Vue中有两种数据绑定的方式：<br>1.单向绑定（v-bind）：数据只能从 data 流向页面<br>2.双向绑定（v-model）：数据不仅能从data流向页面，还可以从页面流向 data</p><blockquote><p>双向绑定一般只应用在表单类元素上（如：input, select）<br>v-model:value 可以简写成 <strong>v-model</strong> ，因为v-model默认收集的就是value值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-<span class="hljs-attr">model</span>:value=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="el和data的两种写法"><a href="#el和data的两种写法" class="headerlink" title="el和data的两种写法"></a>el和data的两种写法</h2><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><blockquote><p>通过一个对象代理对另一个对象中的属性的操作（读&#x2F;写）<br>1.Vue中的数据代理：通过 vm 对象来代理data中属性的操作<br>2.Vue中数据代理的好处：更加方便地操作data中的数据<br>3.基本原理：<br>    通过<strong>Object.defineProperty()</strong> 把data对象中的所有属性都添加到vm上<br>    为每一个添加到vm上的属性，都指定一个getter&#x2F;setter<br>    在getter&#x2F;setter 内部去操作（读&#x2F;写）data中对应的属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>何为数据代理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">let</span> obj2 = &#123;<span class="hljs-attr">y</span>:<span class="hljs-number">200</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 给obj2添加了x属性，实际指向obj.x</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 通过修改obj2.x的值达到修改obj.x的值</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 这就是数据代理，obj2成为了obj的代理对象</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj2,<span class="hljs-string">&#x27;x&#x27;</span>,&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-keyword">return</span> obj.<span class="hljs-property">x</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    obj.<span class="hljs-property">x</span> = value</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><blockquote><p>事件的基本使用：</p><ul><li>1.使用v-on:xxx 或 <strong>@xxx 绑定事件</strong> ，其中xxx是事件名</li><li>2.事件的回调需要配置在 <strong>methods 对象</strong>中，最终会在vm上</li><li>3.methods 中配置的函数 ，不要用箭头函数！ 否则this就不是vm了</li><li>4.methods 中配置的函数 ，都是被Vue所管理的对象，this的指向是vm 或 组件实例对象</li><li>5.@click&#x3D;”demo” 和 @click&#x3D;”demo($event)” 效果一致，但后者可以传参</li></ul></blockquote><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><table><thead><tr><th>事件修饰符</th><th>作用</th></tr></thead><tbody><tr><td>prevent</td><td>阻止默认事件</td></tr><tr><td>stop</td><td>阻止冒泡</td></tr><tr><td>once</td><td>事件只触发一次</td></tr><tr><td>capture</td><td>使用时间的捕获机制</td></tr><tr><td>self</td><td>只有event.target是当前元素时才触发事件</td></tr><tr><td>passive</td><td>事件的默认行为立即执行，无需等待事件回调执行完毕</td></tr></tbody></table><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>1.Vue常用按键别名：</p><table><thead><tr><th>按键</th><th>别名</th></tr></thead><tbody><tr><td>回车</td><td>enter</td></tr><tr><td>删除</td><td>delete</td></tr><tr><td>退出</td><td>esc</td></tr><tr><td>空格</td><td>space</td></tr><tr><td>换行</td><td>tab</td></tr><tr><td>上</td><td>up</td></tr><tr><td>下</td><td>down</td></tr><tr><td>左</td><td>left</td></tr><tr><td>右</td><td>right</td></tr><tr><td>2.Vue中未提供别名的按键，可以使用原始的key值去绑定，但是部分键位要把key值转换为kebab-case（短横线命名），如（CapsLock &#x3D;&gt; caps-lock）</td><td></td></tr><tr><td>3.系统修饰键（用法特殊）：cltr、alt、shift、meta</td><td></td></tr><tr><td>(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发</td><td></td></tr><tr><td>(2).配合keydown使用：正常触发事件</td><td></td></tr><tr><td>4.Vue.config.keyCodes.自定义键名 &#x3D; 键码，可以自定义按键别名</td><td></td></tr></tbody></table><h2 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a>计算属性与监视</h2><h3 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性(computed)"></a>计算属性(computed)</h3><blockquote><ul><li>定义：通过已有属性计算得来</li><li>原理：底层借助了Object.defineProperty()方法提供的getter和setter</li><li>getter函数执行时机：初次读取执行一次 和 当依赖的数据发生改变时会被再次调用</li><li>优势：与methods相比内部有缓存机制（复用），效率更高，调试方便</li><li><ul><li>计算属性最终会出现在 vm 上，直接读取即可</li></ul></li><li><ul><li>如果计算属性要被修改，那必须写set函数去响应修改，在set中将计算属性所依赖的那些data数据进行相应改变</li></ul></li></ul></blockquote><h3 id="监视属性-watch"><a href="#监视属性-watch" class="headerlink" title="监视属性(watch)"></a>监视属性(watch)</h3><blockquote><ul><li>当被监视的属性变化时，回调函数handler自动调用，进行相关操作</li><li>监视的属性必须存在，才能进行监视</li><li>监视的两种方法</li><li><ul><li>new Vue()时传入 watch 配置</li></ul></li><li><ul><li>通过 vm.$watch 监视（<strong>要加引号</strong>）</li></ul></li></ul></blockquote><table><thead><tr><th>配置对象</th><th>作用</th></tr></thead><tbody><tr><td>immediate</td><td>初始化时回调函数自动调用一次</td></tr><tr><td>deep</td><td>深度监视</td></tr></tbody></table><h3 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h3><blockquote><ul><li>Vue自身可以监视对象内部值的改变，但Vue提供的watch默认不可以</li><li>在监视对象中配置 deep:true 可以监视对象内部值改变</li></ul></blockquote><h3 id="计算属性与监视的区别"><a href="#计算属性与监视的区别" class="headerlink" title="计算属性与监视的区别"></a>计算属性与监视的区别</h3><p>1.computed能完成的功能，watch都可以完成<br>2.watch可以完成异步操作（如定时器），但computed不行（因为computed要有return返回值，而return不能写在回调函数里）</p><h3 id="Vue中的this"><a href="#Vue中的this" class="headerlink" title="Vue中的this"></a>Vue中的this</h3><p>1.所有被Vue管理的函数，最好写成普通函数，这样this的指向才是Vue 或 组件实例对象<br>2.所有不被Vue管理的函数（定时器函数、ajax的回调函数、Promise的回调函数）最好写成箭头函数，这样this的指向才是Vue 或 组件实例对象</p><h2 id="绑定CSS样式"><a href="#绑定CSS样式" class="headerlink" title="绑定CSS样式"></a>绑定CSS样式</h2><p><strong>1.class样式：</strong></p><blockquote><p>:calss&#x3D;”xxx” ,xxx可以是字符串，对象，数组</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;style&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;changeMood&#x27;</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//阻止 vue 在启动时生成生产提示</span></span><br><span class="language-javascript">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.demo&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">mood</span>: <span class="hljs-string">&#x27;happy&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">style</span>: &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">border</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">text</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">position</span>: <span class="hljs-literal">true</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">changeMood</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;happy&#x27;</span>, <span class="hljs-string">&#x27;sad&#x27;</span>, <span class="hljs-string">&#x27;upset&#x27;</span>]</span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">3</span>)</span><br><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mood</span> = arr[index]</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.style样式</strong></p><blockquote><p>:style&#x3D;”{fontSize:xxx}”,xxx是动态值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleArr&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;changeMood&#x27;</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.demo&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">mood</span>: <span class="hljs-string">&#x27;happy&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">styleObj</span>: &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;40px&#x27;</span> <span class="hljs-comment">//这里对象里的key要用驼峰写法</span></span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                <span class="hljs-attr">styleArr</span>: [&#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;20px&#x27;</span></span><br><span class="language-javascript">                &#125;, &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;orange&#x27;</span></span><br><span class="language-javascript">                &#125;]</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br></code></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><strong>1.v-if</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;n===1&quot;</span>&gt;</span>html<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;n===2&quot;</span>&gt;</span>css<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;n===3&quot;</span>&gt;</span>javascript<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><blockquote><p>v-if可以和v-else-if、v-else 一起使用，但要求结构不能打乱<br>v-if：不展示的DOM元素直接被移除，适用于切换频率较低的场景<br><strong>2.v-show</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div v-show=<span class="hljs-string">&#x27;n===1&#x27;</span>&gt;v-show&lt;/div&gt;<br></code></pre></td></tr></table></figure><blockquote><p>v-show：不展示的DOM元素不会被移除，仅仅是样式被隐藏，适用于切换频率较高的场景</p></blockquote><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><blockquote><p>v-for用于展示列表数据<br>语法：v-for&#x3D;”(item,index) of xxx” :key&#x3D;”yyy”<br>可遍历：数组，对象，字符串，指定次数</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) of filPersons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>    &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="key作用与原理"><a href="#key作用与原理" class="headerlink" title="key作用与原理"></a>key作用与原理</h2><h2 id="列表过滤"><a href="#列表过滤" class="headerlink" title="列表过滤"></a>列表过滤</h2><h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><h2 id="Vue监视数据原理"><a href="#Vue监视数据原理" class="headerlink" title="Vue监视数据原理"></a>Vue监视数据原理</h2><p>Vue会监视data中所有层级的数据<br><strong>监测对象中的数据：</strong></p><blockquote><ul><li>Vue是通过setter实现的监视，且默认Vue只监视new Vue()时传入的数据</li><li>Vue 不允许动态添加根级响应式属性</li><li>如需给后加的属性做响应式，需要使用如下API：</li><li><ul><li>Vue.set(target, propertyName&#x2F;index, value)</li></ul></li><li><ul><li>vm.$set(target, propertyName&#x2F;index, value)<br>三个参数如下：<br>{Object | Array} target<br>{string | number} propertyName&#x2F;index<br>{any} value</li></ul></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.$set(vm.<span class="hljs-property">userProfile</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">27</span>)<br>vm.$set(app.<span class="hljs-property">list</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;lemon&quot;</span>)<br><br></code></pre></td></tr></table></figure><p><strong>Vue.set()&amp;vm.$set() 不能给vm 或 vm的根数据对象（vm._data）添加属性</strong><br><strong>监测数组中的数据：</strong></p><blockquote><ul><li>Vue2是通过object.defineproperty()来劫持数据，无法直接劫持数组</li><li>数组中的每一项是没有自己的get，set的</li><li>通过包裹数组更新方法实现，本质上就是做了两件事：</li><li><ul><li>调用原生所对应的数组方法对数组进行更新</li></ul></li><li><ul><li>重新解析模板，进而更新页面</li></ul></li><li>Vue修改数组的方法：</li><li><ul><li>push()、pop()、shift()、unshift()、splice()、sort()、reverse() （这些数组方法会对原数组进行改变）</li></ul></li><li><ul><li>Vue.set()&amp;vm.$set()</li></ul></li></ul></blockquote><blockquote><p>向其所在的节点中渲染文本内容<br>与插值语法的区别：v-text会替换掉节点中的内容，而不会</p></blockquote><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><blockquote><p>向指定节点中渲染包含html结构的内容<br>v-html有安全性问题，在网站上动态渲染任意HTML是非常危险的，容易遭到xss攻击</p></blockquote><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><blockquote><p>本质是一个没有值的特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性<br>使用css属性配合v-cloak可以解决网速慢页面展示出的问题</p></blockquote><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><blockquote><p>v-once 所在节点在初次动态渲染后，就视为静态内容了<br>以后数据的改变不会引起v-once所在结构的更新，可用于性能优化</p></blockquote><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><blockquote><p>可以跳过所在节点的编译过程<br>可利用它跳过没有使用指令语法和插值语法的节点，会加快编译</p></blockquote><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p><strong>函数式：</strong></p><blockquote><ul><li>函数式指令调用时机：</li><li><ul><li>指令与元素成功绑定时（一上来）</li></ul></li><li><ul><li>指令所在模板被重新解析时<br>参数为（DOM元素，绑定对象）</li></ul></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>放大10倍的值: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-big</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;n++&quot;</span>&gt;</span>n++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.demo&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">data</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">n</span>: <span class="hljs-number">1</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">directives</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">big</span>(<span class="hljs-params">e, binding</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, binding)<span class="hljs-comment">//e是DOM元素，binding是</span></span></span><br><span class="language-javascript"><span class="language-xml">                    e.<span class="hljs-property">innerText</span> = binding.<span class="hljs-property">value</span> * <span class="hljs-number">10</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>对象式：</strong><br>配置对象中常用的三个回调函数<br>(1).bind:指令与元素成功绑定时调用<br>(2).inserted:指令所在元素被插入页面时调用<br>(3).update:指令所在模板结构被重新解析时调用<br><strong>总结：</strong></p><blockquote><p>函数式即为对象式的简写<br>分为全局指令和局部指令 Vue.directive(指令名，回调函数&#x2F;配置对象)<br>指令定义时不加v-,但使用时要加v-<br>自定义指令里的 this 是 window<br>指令名如果是多个单词，要使用kebab-case命名，不要用camelCase命名</p></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote><p>Vue 在关键时候调用的一些特殊名称的函数<br>生命周期函数的名字不可更改，其中的 this 指向是vm 或 组件实例对象<br>常见的生命周期钩子：<br>1.mounted：发生ajax请求，启动定时器，绑定自定义事件，订阅消息【初始化操作】<br>2.beforeDestroy：清除定时器，解绑自定义事件，取消订阅消息【收尾工作】</p></blockquote><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>Vue中使用组件的三大步骤：</p><blockquote><ul><li>1.定义组件（创建组件）</li><li>2.注册组件</li><li>3.使用组件（写组件标签）<br>一、如何定义组件？</li><li>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别：</li><li>区别如下：<br>   - 1.el 不要写 —— 因为最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器<br>   - data 必须写成函数 —— 避免组件被复用时，数据存在引用关系，防止data中的数据被修改时会引起所有引用该组件的模板里的数据都被修改<br>简写方式：const 组件名 &#x3D; options（配置对象）<br>二、如何注册组件？<br>1.局部注册：靠new Vue 的时候传入components选项<br>2.全局注册：靠Vue.components(‘组件名’,组件)<br>三、编写组件标签    <br>    &lt;组件名&gt;&lt;&#x2F;组件名&gt;<br>    &lt;组件名&#x2F;&gt;</li></ul></blockquote><h3 id="VueComponent-构造函数"><a href="#VueComponent-构造函数" class="headerlink" title="VueComponent 构造函数"></a>VueComponent 构造函数</h3><h3 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系"></a>一个重要的内置关系</h3><blockquote><p>VueComponent.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Vue.prototype<br>让组件实例对象（vc）可以访问到 Vue原型对象上的属性，方法</p></blockquote><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><h1 id="vue-脚手架笔记"><a href="#vue-脚手架笔记" class="headerlink" title="vue 脚手架笔记"></a>vue 脚手架笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><p> |—— node_modules<br> |—— public<br> |   |—— favicon.ico: 页签图标<br> |   |—— index.html: 主页面<br> |—— src<br> |   |—— assets: 存放静态资源<br> |   |   ㆐—— logo.png<br> |   |—— components: 存放组件<br> |   |   ㆐—— HelloWorld.vue<br> |   |—— App.vue: 汇总所有组件<br> |   |—— main.js: 入口文件<br> |—— .gitignore: git版本管制忽略的配置<br> |—— babel.config.js: babel的配置文件<br> |—— package.json: 应用包配置文件<br> |—— README.md: 应用描述文件<br> |—— package-lock.json: 包版本控制文件</p><h2 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><span class="hljs-title function_">render</span>(<span class="hljs-params">createElement</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;html标签&#x27;</span>,<span class="hljs-string">&#x27;标签里的内容&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><blockquote><ul><li>1.被用来给元素或子组件注册引用信息（id的替代者）</li><li>2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;h1 v-text=<span class="hljs-string">&quot;msg&quot;</span> ref=<span class="hljs-string">&quot;title&quot;</span>&gt;&lt;/h1&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showDom&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点我输出ref属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SchoolName</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sch&quot;</span>/&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><blockquote><p>让组件接受外部传过来的数据<br>一、传递数据<br><Demo name="xxx"><br>如果是数字传入时要用 :age&#x3D;””(数据绑定的写法，<strong>这样的形式代表将引号中的东西看作一个js表达式来处理</strong>)<br>二、接收数据<br>1.只接收<br>props:[‘name’]<br>2.限制类型<br>props:{<br>    name:String<br>}<br>3.限制类型、限制必要性、指定默认值<br>props:{<br>    name:{<br>        type:String, &#x2F;&#x2F;类型<br>        required:true, &#x2F;&#x2F;必要性<br>        default:’jyd’ &#x2F;&#x2F;默认值<br>    }<br>}<br><strong>props是只读的</strong>，若确需修改，那么将props中的内容复制到data中一份，然后去改造data中的数据。</p></blockquote><h2 id="mixin（混入）"><a href="#mixin（混入）" class="headerlink" title="mixin（混入）"></a>mixin（混入）</h2><blockquote><p>可以帮多个组件共用的配置提取成一个混入对象<br>一、定义混合（在一个新的js文件中）<br>{<br>    data(){<br>    },<br>    methods(){<br>    }<br>}<br>二、使用混入<br>(1).全局混入：Vue.mixin(xxx)<br>(2).局部混入: mixins:[xxx]</p></blockquote><h2 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h2><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><p>1.组件化编码流程</p><blockquote><ul><li>(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突</li><li>(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：<br>  - 一个组件在用：放在组件自身即可<br>  - 一些组件在用：放在他们共同的父组件上（状态提升）</li><li>(3).实现交互：从绑定事件开始<br>2.props适用于：<br>(1).父组件&#x3D;&#x3D;&gt; 子组件 通信<br>(1).子组件&#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）<br>3.使用v-model时要切记: v-model绑定的值不能是props传过来的值，因为props是不可以修改的<br>4.props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做</li></ul></blockquote><h2 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h2><p>sessionStorage&#x2F;localStorage 的常用方法和属性：</p><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>setItem()</td><td>保存数据</td></tr><tr><td>getItem()</td><td>读取数据</td></tr><tr><td>removeItem()</td><td>删除数据</td></tr><tr><td>clear()</td><td>清除数据</td></tr><tr><td>length</td><td>数据长度</td></tr><tr><td>注意事项：</td><td></td></tr></tbody></table><blockquote><p>localStorage需要手动清除才消失，sessionStorage随着浏览器的关闭而消失<br>如果getItem(xxx)对应的value获取不到，返回值为null<br>JSON.parse(null)的结果为null</p></blockquote><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li>一种组件间通信的方式，适用于：子组件 &#x3D;&#x3D;&gt; 父组件</li><li>适用场景：A是父组件，B是子组件，B要给A传数据，那么就在A中给B绑定自定义事件（回调函数写在A中 ）</li><li>绑定自定义事件：</li><li>触发自定义事件：</li><li>解绑自定义事件：</li><li>组件上也可以绑定原生DOM事件，需要使用native修饰符</li><li>注意，通过 <code>this.$refs.std.$on('jyd',callback)</code> 绑定自定义事件时,回调函数要么配置在methos中，要么使用箭头函数，否则this指向会出问题</li></ol><h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><blockquote><ul><li>一种组件间通信的方式，适用于任意组件通信</li><li>全局事件总线是一个独立存在的部分，要想实现组件间的相互通信，又是自定义事件，那就要满足两个条件<br>  - 满足所有组件都能访问得到全局事件总线<br>  - 可以调用 $on ,和 $off 和 $emit<br>一、实现全局事件总线<br><code>main.js：</code></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span>h (<span class="hljs-title class_">App</span>)<br>    <span class="hljs-comment">//beforeCreate中模板未解析，且this是vm</span><br>    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span> <span class="hljs-comment">//安装全局事件总线</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>二、绑定全局事件总线</p><blockquote><p>谁要接收数据，自定义事件就绑定在谁身上</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;自定义事件名&#x27;</span>,callback)<br>&#125;,<br></code></pre></td></tr></table></figure><p>三、触发全局事件总线</p><blockquote><p>谁要传递数据，谁就触发事件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">methods：&#123;<br>    触发事件方法名()&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$emit(<span class="hljs-string">&#x27;自定义事件名&#x27;</span>,传递参数)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>四、在销毁前解绑事件，提高性能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 销毁对应自定义事件</span><br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$off(<span class="hljs-string">&#x27;自定义事件名&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><p>1.语法: <code>this.$nextTick(callback)</code><br>2.作用: 在下一次DOM更新结束后执行其回调函数<br>3.例子：使得input框在创建的时候自动获得焦点</p><h2 id="过渡和动画"><a href="#过渡和动画" class="headerlink" title="过渡和动画"></a>过渡和动画</h2><h2 id="Vue配置跨域"><a href="#Vue配置跨域" class="headerlink" title="Vue配置跨域"></a>Vue配置跨域</h2><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p><strong>1.概念</strong><br>在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信<br><strong>2.作用</strong><br>多个组件需要共享数据时<br><strong>3.搭建vuex环境</strong><br><strong>4.流程</strong><br><img src="https://vuex.vuejs.org/vuex.png" alt="流程图"><br>5.getter(类似于计算属性)</p><blockquote><p>用于将state中的数据加工<br>注意要使用其前要先在 new Vuex.Store 中添加</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getters = &#123;<br>    <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>) &#123;<br>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6.mapState &amp; mapGetters</strong></p><blockquote><p>写在计算属性里，用于简便快速生成计算属性的<br>使用前要在组件中<strong>先引用</strong> (<code>import &#123;mapState&#125; from 'vuex'</code>)<br>key-value形式：<strong>key指的是模板中的写法，value指的是store中的写法</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-comment">//传统写法</span><br>    <span class="hljs-comment">/*sum()&#123;</span><br><span class="hljs-comment">        return this.$store.state.sum</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">//对象写法</span><br>   <br>    ...<span class="hljs-title function_">mapState</span>(&#123;<span class="hljs-attr">sum</span>:<span class="hljs-string">&#x27;sum&#x27;</span>&#125;)<br>    <span class="hljs-comment">//数组写法</span><br>    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;sum&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>7.mapActions &amp; mapMutations</strong></p><blockquote><p>mapActions 用于生成于actions对话的方法<br>mapMutations用于生成于mutations对话的方法<br><strong>8.namespace</strong></p></blockquote><h2 id="route路由"><a href="#route路由" class="headerlink" title="route路由"></a>route路由</h2><blockquote><p>vue-router:vue的一个插件库，专门实现SPA（单页）应用<br>一、对SPA的理解：<br>1.整个应用只有一个完整的页面<br>2.点击页面中的导航链接不会刷新页面，只会做页面的局部更新<br>3.数据需要通过AJAX请求获取<br>二、路由的理解：<br>1.一个路由就是一组 key-value 的映射关系<br>2.key 为路径，value 可能是component（前端，用于展示页面内容）&#x2F; function（后端，用于处理客户端请求）<br>三、路由的注意点：<br>1.路由组件通常存放在pages文件夹，一般组件通常放在components文件夹<br>2.通过切换，”隐藏”了的路由组件，默认是被销毁的，需要的时候再去挂载<br>3.每个组件都有自己的 <strong>$route</strong> 属性，里面存储着自己的路由信息<br>4.整个应用只有一个router，可以通过组件的 $router属性获取<br>四、路由在模板中的使用：<br><router-link>路由的组件名</router-link> :路由的跳装链接<br><router-view></router-view> :路由在模板中的位置</p></blockquote><h3 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由"></a>多级路由</h3><blockquote><p>在父路由中使用children配置项</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [&#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/subject&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Subject</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/students&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span>,<br>            <span class="hljs-attr">children</span>: [&#123; <span class="hljs-comment">//在路由中通过children配置子路由</span><br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;lb&#x27;</span>, <span class="hljs-comment">//此处一定不要加&#x27;/&#x27;</span><br>                    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Lb</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;jyd&#x27;</span>, <span class="hljs-comment">//此处一定不要加&#x27;/&#x27;</span><br>                    <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Jyd&#x27;</span><br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>命名路由</strong></p><blockquote><p>作用：简化路由的跳转路径<br>1.给路由命名</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/students&#x27;</span><br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.简化跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;router-link to=<span class="hljs-string">&quot;/students&quot;</span>&gt;&lt;/router-link&gt;<br> ==&gt;<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span> （此时这里面不要再写path）<br></code></pre></td></tr></table></figure><h3 id="路由的-query-参数"><a href="#路由的-query-参数" class="headerlink" title="路由的 query 参数"></a>路由的 query 参数</h3><p>1.传递参数<br><strong>to 要加 ：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in p&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;`/students/lb/msg?id=$&#123;item.id&#125;&amp;title=$&#123;item.title&#125;`&quot;</span>&gt;</span><br>          &#123;&#123; item.title &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 对象写法 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;router-link</span><br><span class="hljs-comment">        :to=&quot;&#123;</span><br><span class="hljs-comment">            path:&#x27;/students/lb/msg&#x27;</span><br><span class="hljs-comment">            query:&#123;</span><br><span class="hljs-comment">              id:item.id</span><br><span class="hljs-comment">              title:item.title</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;&quot;&gt;</span><br><span class="hljs-comment">        &#123;&#123;item.title&#125;&#125;</span><br><span class="hljs-comment">        &lt;/router-link&gt; --&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.接收参数</p><blockquote><p>$route.query.属性</p></blockquote><h3 id="路由的params参数"><a href="#路由的params参数" class="headerlink" title="路由的params参数"></a>路由的params参数</h3><p>1.配置路由声明接收参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/students/:id/:title&#x27;</span>, <span class="hljs-comment">//使用占位符  </span><br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>2.传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;router-link to=<span class="hljs-string">&quot;/students/666/你好&quot;</span>&gt;&lt;/router-link&gt;<br> <span class="hljs-comment">//对象写法</span><br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span></span><br><span class="hljs-tag"><span class="language-xml"> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">    name:&#x27;hello&#x27; //当使用的是params参数时，对象写法里只能写成name属性，不能使用path</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">    params:&#123;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">        id:666,</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">        title:&#x27;你好&#x27;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">    &#125;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml"> &#125;&quot;</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><blockquote><p><strong>让路由组件更方便的收到参数</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/students/:id/:title&#x27;</span>,  <br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span>,<br>    <span class="hljs-comment">//第一种写法(不常用)：会把对象中的每一组key-value值通过props传给组件</span><br>    <span class="hljs-attr">props</span>:&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">900</span>&#125;<br>    <span class="hljs-comment">//第二种写法：props为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给组件</span><br>    <span class="hljs-comment">//（只有params能用）</span><br>    <span class="hljs-attr">props</span>:<span class="hljs-literal">true</span><br>    <span class="hljs-comment">//第三种写法：props为函数，会把函数返回的对象中的每一组key-value值通过props传给组件</span><br>    <span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">id</span>:route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>,<br>            <span class="hljs-attr">title</span>:route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h3><blockquote><p>作用：控制路由跳转时操作浏览器历史记录的模式<br>历史记录有push和replace两种写入方式，push是追加（默认），replace是替换当前记录<br>如何开启replace模式：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link replace to=<span class="hljs-string">&quot;/students&quot;</span>&gt;&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><h3 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h3><blockquote><p>作用：让不展示的路由组件保持挂载，不被销毁</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果有多个——  :include=&#x27;[&#x27;组件名&#x27;,&#x27;&#x27;]&#x27;</span><br>&lt;keep-alive include=<span class="hljs-string">&#x27;组件名&#x27;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><p>这段代码写在不想被销毁的组件的父路由上</p><h3 id="路由中的生命周期钩子"><a href="#路由中的生命周期钩子" class="headerlink" title="路由中的生命周期钩子"></a>路由中的生命周期钩子</h3><blockquote><p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态<br>1.<code>activated</code>:路由组件激活时触发<br>2.<code>deactivated</code>:路由组件失活时触发</p></blockquote><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><h3 id="hash-history"><a href="#hash-history" class="headerlink" title="hash &amp; history"></a>hash &amp; history</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署</title>
    <link href="/2024/04/20/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/2024/04/20/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="前端程序员如何在宝塔面板部署Vue-nodejs前后端项目"><a href="#前端程序员如何在宝塔面板部署Vue-nodejs前后端项目" class="headerlink" title="前端程序员如何在宝塔面板部署Vue+nodejs前后端项目"></a>前端程序员如何在宝塔面板部署Vue+nodejs前后端项目</h1><p><img src="https://www.bigneck.top/#/article/ca66d3b6-ac5c-44d7-b1a8-464def149ff5" alt="前端程序员如何在宝塔面板部署Vue+nodejs前后端项目"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>卷积神经网络</title>
    <link href="/2024/04/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/04/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p><strong>从输入层 -&gt; 中间隐藏层 -&gt;  输出层</strong><br>一个神经网络也可以分为两块，前一块是特征抽取，从输入中提取到容易线性分割的提取，后一块使用线性分类器来做分类</p><p>中间隐藏层 包括 卷积层、全连接层、 分类层 、批量归一化层（BN）、残差连接层 等</p><p>最简单结构是 输入层 -&gt; 卷积层 -&gt; 全连接层 -&gt; 输出层 </p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><blockquote><p>主要用于处理图像数据或具有类似结构的数据，通过卷积操作<strong>提取局部特征</strong>，例如边缘、纹理等</p><p>前面的层通常负责提取低级别的特征，随着网络的深度增加，特征提取的层次也逐渐升高，从低级别的特征到高级别的抽象特征</p><p>单个卷积核在原图上能够计算的响应区域被我们称为该<strong>卷积的感受野</strong>, 小的像素区域是难以得到关于图像的高阶语义信息的，因为感受野太小了。随着网络层次深入，最终神经元感受野通常会涵盖整个输入图像</p></blockquote><p><strong>实际计算中</strong>，并不是通过卷积核在输入上进行滑动计算，效率太低，而是将卷积核转换为等效矩阵，将输入转化为向量，通过输入向量和卷积核矩阵的相乘获得输出向量。输出的向量经过整形便可得到我们的二维输出特征。</p><p><a href="https://zhuanlan.zhihu.com/p/113525131#:~:text=%E8%BD%AC%E7%BD%AE%E5%8D%B7%E7%A7%AF%E5%8F%88%E7%A7%B0%E5%8F%8D%E5%8D%B7%E7%A7%AF%EF%BC%8C%E9%80%86%E5%8D%B7%E7%A7%AF%E3%80%82%20%E5%9C%A8%E4%B8%BB%E6%B5%81%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E4%B9%8B%E4%B8%AD%EF%BC%8C%E5%A6%82Tensorflow%EF%BC%8CPytorch%2CKreas%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E9%83%BD%E6%98%AFconv_transpose,%E5%B0%86%E4%B8%80%E4%B8%AA4%2A4%E7%9A%84%E8%BE%93%E5%85%A5%E9%80%9A%E8%BF%873%2A3%E7%9A%84%E5%8D%B7%E7%A7%AF%E6%A0%B8%E6%A0%B8%E8%BF%9B%E8%A1%8C%E6%99%AE%E9%80%9A%E5%8D%B7%E7%A7%AF%E5%90%8E%EF%BC%88%E6%97%A0padding%2Cstride%3D1%EF%BC%89%2C%E5%B0%86%E5%BE%97%E5%88%B02%2A2%E7%9A%84%E8%BE%93%E5%87%BA%E3%80%82%20%E8%80%8C%E8%BD%AC%E7%BD%AE%E5%8D%B7%E7%A7%AF%E5%B0%86%E4%B8%80%E4%B8%AA2%2A2%E7%9A%84%E8%BE%93%E5%85%A5%E9%80%9A%E8%BF%87%E5%90%8C%E6%A0%B7%E7%9A%843%2A3%E7%9A%84%E5%8D%B7%E7%A7%AF%E6%A0%B8%EF%BC%8C%E5%B0%86%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA4%2A4%E7%9A%84%E8%BE%93%E5%87%BA%E3%80%82">卷积的实际计算过程</a></p><ul><li><p>卷积层在图像处理等领域表现出色，因为图像数据具有<strong>局部相关性</strong>和<strong>平移不变性</strong>，卷积操作可以有效地捕捉这些特征。</p><ul><li>局部相关性：相邻像素之间具有较高的相关性，这意味着在图像的局部区域内，像素之间的数值变化不会太大</li><li>平移不变性：无论图像中的物体位置如何变化，我们仍然能够正确地识别和理解图像中的内容</li></ul></li><li><p>其<strong>参数共享</strong>和<strong>局部连接</strong>的特性使得模型具有较少的参数量和更强的泛化能力。</p><ul><li>参数共享：在整个输入数据的不同位置使用相同的滤波器（卷积核参数）参数。这样可以大大减少模型的参数量，使得模型更加轻量化，同时也有利于提高模型的泛化能力，因为参数共享使得模型可以从不同位置学习到相似的特征。</li><li>局部连接：滤波器只与输入数据的局部区域进行卷积计算，而不是与整个输入数据进行计算。这种局部连接的方式能够捕捉到输入数据中的局部特征，也有利于减少计算量</li></ul></li></ul><h4 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h4><p><strong>感受野：</strong> 感受野是指神经网络中某一层输出的特征图上的某个单元所对应输入图像中的区域大小。在卷积神经网络中，每个神经元只与输入中的一个局部区域连接，这个局部区域即为该神经元的感受野。</p><p>感受野的大小取决于神经元所在的层级以及网络结构中使用的卷积核和池化操作。较浅层的神经元的感受野通常较小，而深层神经元的感受野较大，因为深层神经元能够看到更广阔的输入图像区域。</p><p><img src="/../../img/%E6%84%9F%E5%8F%97%E9%87%8E%E8%AE%A1%E7%AE%97.png"></p><p><strong>假设卷积核的长宽为N，在步长为1的情况下，每深入一层，神经元的感受野增加N-1</strong></p><p><a href="https://blog.csdn.net/tugouxp/article/details/119854992#:~:text=%E6%80%BB%E7%BB%93%EF%BC%9A,%E8%A7%84%E5%BE%8B%EF%BC%8C%E5%81%87%E8%AE%BE%E5%8D%B7%E7%A7%AF%E6%A0%B8%E7%9A%84%E9%95%BF%E5%AE%BD%E4%B8%BAN%EF%BC%8C%E5%9C%A8%E6%AD%A5%E9%95%BF%E4%B8%BA1%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%AF%8F%E6%B7%B1%E5%85%A5%E4%B8%80%E5%B1%82%EF%BC%8C%E7%A5%9E%E7%BB%8F%E5%85%83%E7%9A%84%E6%84%9F%E5%8F%97%E9%87%8E%E5%A2%9E%E5%8A%A0N-1.">感受野变化图解</a></p><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><blockquote><p>用于<strong>降低特征图的空间维度，减少参数数量，同时保留重要的特征信息</strong><br>常见的池化操作包括最大池化和平均池化</p></blockquote><h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><blockquote><p>也称为密集连接层，是一种常见的神经网络层结构，其中每个神经元都与前一层的所有神经元连接。<br>全连接层通常出现在网络的最后几层，用于<strong>将前面层提取到的特征进行组合和分类</strong>。</p></blockquote><h4 id="全连接层的作用"><a href="#全连接层的作用" class="headerlink" title="全连接层的作用"></a>全连接层的作用</h4><ol><li><p><strong>特征整合</strong>：全连接层将前一层（可以是卷积层、池化层或另一个全连接层）的输出作为输入，通过权重和偏置进行线性变换，然后通常通过非线性激活函数进行非线性变换。这使得全连接层能够整合来自前一层的特征，捕捉输入数据的复杂模式。</p></li><li><p><strong>分类或回归</strong>：在神经网络的末端，全连接层通常用于执行分类或回归任务。例如，在图像分类任务中，最后一个全连接层的输出维度通常与类别的数量相同，通过softmax函数可以输出每个类别的概率。</p></li><li><p><strong>信息压缩</strong>：全连接层可以减少数据的维度，将大量的特征压缩成更少的维度，这有助于减少计算量，并且可以防止过拟合。</p></li><li><p><strong>特征转换</strong>：全连接层可以学习输入特征之间的复杂映射关系，将原始特征转换为更高级的特征表示，这些表示对于解决特定问题更有用。</p></li></ol><h4 id="多层感知机的作用"><a href="#多层感知机的作用" class="headerlink" title="多层感知机的作用"></a>多层感知机的作用</h4><p>多层感知机是一种前馈人工神经网络，由多个层组成，每层包含多个神经元（或称为节点）。每个神经元对输入进行加权求和，然后通过一个激活函数进行非线性变换。MLP的关键特点和作用包括：</p><ol><li><p><strong>非线性建模能力</strong>：通过堆叠多个隐藏层，MLP能够学习输入数据的非线性映射，这是解决复杂问题的关键。</p></li><li><p><strong>特征学习</strong>：MLP的每一层都能够学习数据的不同特征表示。较低层可能学习到边缘等基础特征，而较高层可能学习到更复杂的形状或对象特征。</p></li><li><p><strong>通用函数逼近器</strong>：理论上，一个足够大的MLP可以逼近任何连续函数，这意味着MLP具有非常强大的建模能力。</p></li><li><p><strong>分类和回归</strong>：MLP可以用于分类和回归任务。在分类任务中，输出层通常使用softmax激活函数来输出类别概率；在回归任务中，输出层通常不使用激活函数或使用线性激活函数。</p></li><li><p><strong>自适应学习能力</strong>：通过反向传播算法和梯度下降，MLP能够自适应地调整权重和偏置，以最小化预测误差。</p></li></ol><h3 id="多层感知机与全连接层的关系"><a href="#多层感知机与全连接层的关系" class="headerlink" title="多层感知机与全连接层的关系"></a>多层感知机与全连接层的关系</h3><p>在某种程度上，全连接层可以看作是多层感知机的一个特例。一个全连接层本质上是一个简化的MLP层，其中每个神经元都连接到前一层的所有神经元。而在一个完整的MLP中，通常会包含多个这样的全连接层，每层都可能有不同的神经元数量和激活函数。</p><p>在实际应用中，全连接层和MLP通常与其他类型的层（如卷积层、池化层等）结合使用，以构建能够解决特定问题的复杂神经网络架构。</p><h3 id="非线性激活层"><a href="#非线性激活层" class="headerlink" title="非线性激活层"></a>非线性激活层</h3><p>非线性激活函数在深度学习中扮演着非常重要的角色，它们能够为神经网络引入非线性因素，提高模型的表达能力和学习能力。常见的非线性激活函数包括但不限于以下几种：</p><p><strong>ReLU（Rectified Linear Unit）函数：</strong> ReLU函数将所有负的输入值设为0，而正的输入值保持不变。其数学表达式为 $f(x) &#x3D; max(0, x)$ ，简单且易于计算，被广泛应用于深度学习网络中</p><p><strong>Sigmoid函数：</strong> Sigmoid函数将输入值映射到0和1之间，具有平滑的S形曲线。其数学表达式为 $f(x) &#x3D; 1 &#x2F; (1 + exp(-x))$ ，适合用于二分类问题输出概率值</p><p><strong>Tanh函数：</strong> Tanh函数是双曲正切函数，将输入值映射到-1和1之间。其数学表达式为 $f(x) &#x3D; (exp(x) - exp(-x)) &#x2F; (exp(x) + exp(-x))$ ，比Sigmoid函数范围更广，常用于隐藏层的非线性变换</p><p><strong>Leaky ReLU函数：</strong> Leaky ReLU函数在ReLU的基础上稍作修改，当输入值为负时不再直接变为0，而是乘以一个小的斜率值。其数学表达式为 $f(x) &#x3D; max(0.01x, x)$ ，<strong>有助于解决ReLU函数在负值区域的死亡神经元问题</strong></p><h3 id="线性层"><a href="#线性层" class="headerlink" title="线性层"></a>线性层</h3><p>将特征拉平进行线性输入</p><p>线性层通常指的是神经网络中的一层，其每个神经元与上一层的所有神经元相连接，通过权重矩阵的线性变换和偏置项的加法计算输出。<br>线性层不包含非线性激活函数，因此输出是一个线性变换过后的结果</p><p>神经网络线性层中权重矩阵和偏置项的值通常是在模型训练过程中通过反向传播算法不断优化得到的。<br>在模型初始化阶段，这些参数通常会被随机初始化为较小的值。<br>然后通过在训练数据上进行前向传播和反向传播，不断调整这些参数，使得模型的损失函数最小化。</p><h3 id="归一化层（Normalization-layer）"><a href="#归一化层（Normalization-layer）" class="headerlink" title="归一化层（Normalization layer）"></a>归一化层（Normalization layer）</h3><p>在神经网络训练过程中，数据分布的变化可能会导致训练不稳定，梯度消失或爆炸等问题。归一化层通过对每个特征进行标准化处理，使得输入数据在训练过程中保持一定的范围，<strong>有助于加快收敛速度，增加模型的鲁棒性。</strong></p><p><strong>批量归一化层（BN）</strong><br>批量归一化通过<strong>对每个批次的输入</strong>进行归一化，即将每个特征维度的数据都减去均值并除以标准差，然后再乘以一个可学习的缩放因子和平移因子，使得网络的输入在训练过程中保持一定的分布，有利于梯度的传播和网络的收敛。</p><p><strong>归一化概念</strong>:使得数据的分布范围或者特征值范围在一定范围内，以便更好地适应模型的训练和提高模型的稳定性</p><p><strong>Batch Normalization (BN) 和 Layer Normalization (层归一化) 的区别：</strong></p><p>应用场景：BN 主要应用在深度卷积神经网络（CNN）中，并且通常作用在卷积层的输出；而 LN 更适用于循环神经网络（RNN）和 Transformer 等序列模型中，并且作用在层的输出。</p><p>归一化对象：</p><ol><li>BN 是在每个 mini-batch 的特征维度上进行归一化，即对每个特征通道的值进行归一化；</li><li>LN 则是在每个样本的特征维度上进行归一化，即对每个样本和特征通道的值进行归一化。</li></ol><p>归一化公式：</p><ol><li>BN 的归一化公式是对每个特征通道的值进行归一化，涉及到均值和方差的计算；</li><li>LN 的归一化公式是对每个样本和特征通道的值进行归一化，涉及到对特征通道进行求和。</li></ol><p>计算效率：</p><ol><li>BN 可能在推理阶段需要计算均值和方差的移动平均值，会增加计算成本；**(BN区分训练和推理状态，LN不区分)**</li><li>LN 在训练阶段和推理阶段的计算成本相对较低。</li></ol><h3 id="残差连接层"><a href="#残差连接层" class="headerlink" title="残差连接层"></a>残差连接层</h3><blockquote><p>用于<strong>解决深度网络训练过程中的梯度消失问题</strong>。<br>在深度神经网络中，随着网络层数的增加，传统的前向传播和反向传播容易导致梯度逐渐减小，使得网络难以训练。<br>残差连接通过在网络中添加跨层连接，即将某一层的输入直接与后续层的输出相加，将原始的输入信息保留并传递给后续层，有助于减轻梯度消失问题，加速网络的训练和收敛。</p></blockquote><h3 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h3><blockquote><p>网络的最后一层，负责产生网络的输出，其结构通常根据具体任务的需求而定。<br>例如，在分类任务中，输出层可能采用softmax函数来输出每个类别的概率；在回归任务中，输出层可能直接输出连续值</p></blockquote><h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><h3 id="上采样和下采样"><a href="#上采样和下采样" class="headerlink" title="上采样和下采样"></a>上采样和下采样</h3><p>在卷积神经网络（CNN）中，上采样和下采样是两种常用的操作，用于改变特征图的尺寸和分辨率。</p><p><strong>下采样（Pooling）：</strong> 也称为池化（Pooling），是指通过在特征图上移动一个固定大小的窗口，在每个窗口上应用一个聚合函数（如最大值、平均值等），从而减小特征图的尺寸。下采样的作用是降低特征图的空间维度，减少网络参数和计算量，同时保留重要的特征。常见的下采样操作包括最大池化（Max Pooling）和平均池化（Average Pooling）。</p><p><strong>上采样（Upsampling）：</strong> 也称为反卷积（Deconvolution）或转置卷积（Transpose Convolution），是指通过插值操作将特征图的尺寸扩大。上采样的作用是增加特征图的分辨率，提供更多的空间信息。常见的上采样方法包括双线性插值、转置卷积等。</p><p><strong>上采样方法</strong></p><ol><li><p>双线性插值（Bilinear Interpolation）：是一种基于邻近四个像素的插值方法，在上采样过程中通过线性插值计算新像素的值。双线性插值可以有效地保持图像的平滑性，但可能导致一些细节的丢失。</p></li><li><p>转置卷积（Transpose Convolution，也称为反卷积）：不是卷积的逆运算，通过权重矩阵的转置来进行卷积运算，从而扩大特征图的尺寸。转置卷积允许学习上采样过程中的模式和特征，提高了生成图像的质量和准确度</p></li></ol><p><strong>转置卷积步骤</strong></p><p>设卷积核大小为 k*k，卷积核步长为 s ，padding为 p</p><p>（1）在输入特征图 元素间补充 s-1行、列个 0 元素<br>（2）在输入特征图 四周补充 k-p-1行、列个 0 元素<br>（3）将卷积核参数上下、左右翻转（卷积核旋转180度）<br>（4）做正常卷积运算（此时填充为0，步距为1）</p><p>$$<br>H_{out} &#x3D; (H_{in}-1) * s-2*p + k<br>$$</p><p>$$<br>H_{out} &#x3D; (H_{in}-1) * s-2*p + k<br>$$</p><p><img src="/../../img/%E8%BD%AC%E7%BD%AE%E5%8D%B7%E7%A7%AF.png"></p><p>这两种操作在CNN中常常相互配合使用，如在卷积神经网络的编码器-解码器结构中，编码器部分通常进行下采样操作以提取特征，解码器部分则进行上采样操作以恢复原始尺寸的特征图。通过上采样和下采样的结合使用，CNN可以更好地学习并利用输入数据的特征，提高模型的性能和准确度。</p><h2 id="pytorch中卷积神经网络涉及计算"><a href="#pytorch中卷积神经网络涉及计算" class="headerlink" title="pytorch中卷积神经网络涉及计算"></a>pytorch中卷积神经网络涉及计算</h2><p>经过 卷积&#x2F;池化 后的矩阵尺寸大小计算公式<br>$$<br>N &#x3D; (W-F+2P)&#x2F;S + 1<br>$$<br>ex. input(3, 32, 32) ——&gt; output(16, 28, 28)<br>(32-5+2*0)&#x2F;1 + 1 &#x3D; 28</p><p>计算所得矩阵特征图<strong>尺寸不为整数时</strong>，卷积和池化<strong>都向下取整</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vision transformer</title>
    <link href="/2024/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/vision-transformer/"/>
    <url>/2024/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/vision-transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Vision-Transformer"><a href="#Vision-Transformer" class="headerlink" title="Vision Transformer"></a>Vision Transformer</h1><h2 id="自注意力机制（self-attention）"><a href="#自注意力机制（self-attention）" class="headerlink" title="自注意力机制（self-attention）"></a>自注意力机制（self-attention）</h2><p><img src="/../../img/self_attention.png"></p><p>计算注意力分数使用的是缩放点积模型。<br>Scale（缩放）的作用：由于进行点乘后的数值很大，导致通过的softmax后梯度变得很小</p><p><a href="https://blog.csdn.net/weixin_43312117/article/details/122922513">自注意力机制手写讲解</a></p><h2 id="多头注意力机制（Multi-Head-Attention）"><a href="#多头注意力机制（Multi-Head-Attention）" class="headerlink" title="多头注意力机制（Multi-Head Attention）"></a>多头注意力机制（Multi-Head Attention）</h2><p><img src="/../../img/Multi-Head%20Attention.png"></p><p>tips:</p><ol><li>每个Patch数据通过映射得到一个长度为768的token向量，即[16, 16, 3] -&gt; [768]</li></ol><h2 id="MLP"><a href="#MLP" class="headerlink" title="MLP"></a>MLP</h2><h3 id="Transformer-Block中的MLP"><a href="#Transformer-Block中的MLP" class="headerlink" title="Transformer Block中的MLP"></a>Transformer Block中的MLP</h3><p>在自注意力机制之后，通常会有一个简单的MLP，其作用是对自注意力机制的输出进行进一步的非线性变换。</p><p>这个MLP通常包含两个<strong>线性变换（FC），</strong> 它们之间有一个激活函数（通常是GELU激活函数）。MLP的输入是自注意力机制的输出，输出是经过MLP变换后的特征，这些特征将被送入下一个Transformer块或最终的分类头部。</p><h3 id="分类头部中的MLP"><a href="#分类头部中的MLP" class="headerlink" title="分类头部中的MLP"></a>分类头部中的MLP</h3><p>在ViT的末尾，特征图经过一个分类头部来生成最终的分类结果。在ViT的早期版本中，分类头部可能仅仅是一个线性层，它将Transformer的输出特征映射到类别数量的维度上。然而，现代的ViT变体通常在分类头部使用一个或多个MLP层，以提供更复杂的非线性变换能力。</p><p>这些MLP层允许模型在最终的分类决策中捕捉更高层次的特征交互，有助于提高分类的准确性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习"><a href="#数据结构复习" class="headerlink" title="数据结构复习"></a>数据结构复习</h1>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>408</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理复习"><a href="#计算机组成原理复习" class="headerlink" title="计算机组成原理复习"></a>计算机组成原理复习</h1><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><ol><li>计算机硬件系统由<strong>运算器、存储器、控制器、输入设备和输出设备</strong>5 大部件组成</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h1><p>1. </p>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习"><a href="#计算机网络复习" class="headerlink" title="计算机网络复习"></a>计算机网络复习</h1><h2 id="计算机网络参考模型"><a href="#计算机网络参考模型" class="headerlink" title="计算机网络参考模型"></a>计算机网络参考模型</h2><p><img src="/../../img/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1.png"></p><p><strong>5层模型</strong></p><blockquote><p>方便用于知识点讲解的模型</p></blockquote><p>物理层、数据链路层、网络层、传输层、应用层</p><p><strong>TCP&#x2F;IP模型</strong></p><blockquote><p>只有四层，<strong>将物理层和数据链路层合并合并为网络接口层</strong></p></blockquote><p><strong>OSI模型</strong></p><ol><li>由 物理层、数据链路层、网络层、传输层、（会话层）、（表示层）、应用层 组成</li><li>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理</li></ol><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><blockquote><p>考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异</p></blockquote><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><blockquote><p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。<br>（封装成帧、差错控制、流量控制、传输管理）</p></blockquote><p><strong>ARP协议</strong></p><p>ARP协议位于OSI模型的第二层，即数据链路层（Data Link Layer），以及TCP&#x2F;IP模型的网络接口层（Network Interface Layer）。它负责将<strong>网络层的IP地址解析为数据链路层的MAC地址</strong>  ——&gt; 从而使得数据能够在物理网络中传输。</p><p>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。<br>没有ARP，IP网络中的主机将无法知道如何将数据帧发送到同一局域网内的其他主机。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><blockquote><p>为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。<br>（流量控制、拥塞控制、差错控制、网际互联）</p></blockquote><p><strong>IP协议</strong></p><ol><li><strong>IP是一种 「不可靠」的 「端到端」的数据包 「传输服务」</strong></li><li>主要实现两个功能：<strong>数据传输</strong> 和 <strong>数据分片</strong>。</li><li>所有的 TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</li><li><strong>地址类别：</strong> IPv4地址被分为A、B、C、D和E五类，其中A、B和C类是最常见的，用于不同的网络规模和用途。</li><li><strong>子网划分：</strong> 通过子网掩码，可以将一个较大的网络划分为多个较小的子网，以提高网络的管理性和性能。</li><li><strong>路由：</strong> IPv4地址包含网络部分和主机部分，路由器使用这些信息来决定如何将数据包转发到正确的网络。</li><li>IPv4 （2^32个地址）与 IPv6（2^128个地址）<br><img src="/../../img/IP%E5%8D%8F%E8%AE%AE.png"></li></ol><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><blockquote><p>为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。<br>运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。<br>TCP 主要提供完整性服务，UDP 主要提供及时性服务。<br>（流量控制、差错控制、服务质量、数据传输管理、端到端）</p></blockquote><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p><strong>三次握手建立连接</strong>（在不可靠信道上建立可靠连接）</p><ol><li>客户端向服务端发送 SYN 报⽂。客户端进⼊ SYN_SEND 状态，等待服务器确认。</li><li>服务端收到SYN包后，回复一个SYN-ACK（同步确认）包。服务端进⼊ SYN_RECV 状态</li><li>客户端收到SYN-ACK后，发送一个ACK（确认）包，完成TCP连接的建立。客户端和服务器端都进⼊ ESTABLISHED 状态</li></ol><p><strong>为什么不是两次</strong><br>因为如果存在已失效的连接请求报文重新传到了服务器端，则服务器会响应然后向客户端发送ACK，此时认为已经建立连接，之后服务器便开始等待客户机传送数据。<br>但是由于连接请求报文是已失效的，所以客户机并未响应这个ACK，所以服务器会一直等待下去，造成资源的浪费。</p><p><strong>四次握手释放连接</strong></p><ol><li>客户端发送 FIN 报文给服务端，表示⾃⼰要断开数据传送</li><li>服务端收到 FIN 报文后，回复一个 ACK 报文给客户端</li><li>服务端也要断开连接时，发送 FIN 报⽂给客户端</li><li>客户端收到 FIN 报⽂后，发出 ACK 报⽂进⾏应答；服务端在收到客户端的 ACK 报⽂后进⼊<strong>超时等待状态</strong>（如果客户端等待 2MSL 没有收到回复，才关闭连接。）在超时等待状态中，如果服务端没收到 ACK 报文，会重发 FIN 报文。客户端可以重新响应，并重发 ACK 报文</li></ol><p><strong>为什么是四次挥⼿？</strong><br>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，<br>待对方确认后进⼊半关闭状态。 当另⼀方也没有数据再发送的时候，则发出连接释放通知，对方确认后才会完全关闭了 TCP 连接。</p><h3 id="TCP协议和UDP协议"><a href="#TCP协议和UDP协议" class="headerlink" title="TCP协议和UDP协议"></a>TCP协议和UDP协议</h3><ol><li><p>TCP与UDP的概念<br>TCP （传输控制协议）是⼀种⾯向连接的、可靠的、基于字节流的传输层通信协议。<br>UDP （⽤户数据报协议）为应⽤程序提供了⼀种⽆需建⽴连接就可以发送封装的IP数据包的⽅法。</p></li><li><p>特点<br>TCP ：⾯向连接，传输可靠，传输形式为字节流，传输效率慢，所需资源多。<br>UDP ：⽆连接、传输不可靠、传输形式为数据报⽂段，传输效率快，所需资源少。</p></li><li><p>区别<br><strong>是否⾯向连接</strong>: TCP 是⾯向连接的传输，UDP 是⽆连接的传输。<br><strong>是否是可靠传输</strong>：TCP是可靠的传输服务，在传递数据之前，会有三次握⼿来建⽴连接；在数据传递时，有确认、窗⼝、重传、拥塞控制机制。 UDP是不可靠传输，数据传递不需要给出任何确认，且不保证数据不丢失及到达顺序。<br><strong>是否有状态</strong>：TCP 传输是有状态的，它会去记录⾃⼰发送消息的状态⽐如消息是否发送了、是否被接收了等等，⽽ UDP 是⽆状态的。<br><strong>传输形式</strong>: TCP 是⾯向字节流的，UDP 是⾯向报⽂的。<br><strong>传输效率</strong>:由于TCP 传输的时候多了连接、确认重传等机制，所以TCP 的传输效率要⽐UDP 低。<br><strong>⾸部开销</strong> :TCP ⾸部开销 (20 ~ 60字节)⽐UDP ⾸部开销 (8字节)要⼤。<br><strong>是否提供⼴播或多播服务</strong>: TCP 只⽀持点对点通信UDP ⽀持⼀对⼀、⼀对多、多对⼀、多对多。</p></li><li><p>对应的使⽤场景<br>TCP常⽤于要求通信数据可靠场景（如⽹⻚浏览、⽂件传输、邮件传输、远程登录、数据库操作等）。<br>UDP常⽤于要求通信速度⾼场景（如域名转换、视频直播、实时游戏等）。</p></li><li><p>对应应用层协议<br>TCP: HTTP&#x2F;HTTPS; FTP; SMTP<br>UDP: DNS; VoIP（网络电话）</p></li></ol><p><strong>TCP连接如何确保可靠性</strong></p><ol><li><strong>校验和：</strong> TCP会根据首部和数据生成校验和，接收方匹配如果不一致的话则认为传输有误</li><li><strong>序列号：</strong> TCP给每个数据包指定序列号，接收⽅根据序列号对数据包进⾏排序，并根据序列号对数据包去重。</li><li><strong>确认应答：</strong> 通过 ARQ 协议实现。每次接收方收到数据，会发送ACK 报文对传输方进行确认应答。</li><li><strong>超时重传:</strong>  当TCP发出⼀个数据段后，它启动一个定时器，等待⽬的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报⽂段。</li><li><strong>连接管理（三握四挥）</strong></li><li><strong>流量控制：</strong> TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅降低发送的速率，防止包丢失。TCP利⽤滑动窗⼝实现流量控制。</li><li><strong>拥塞控制：</strong> 当⽹络拥塞时，减少数据的发送。</li></ol><p><strong>拥塞控制的实现</strong><br>与流量控制的区别：<br>拥塞控制是一个全局性的过程，涉及所有的主机、路由器；<br>流量控制指在给定的发送和接收端之间的点对点通信量的控制</p><p>拥塞控制算法：<br>拥塞控制是网络传输中非常重要的一部分，特别是在TCP&#x2F;IP网络中。拥塞控制算法的目的是确保网络中的数据流量不会因为过多的数据包同时传输而导致网络拥塞和丢包。</p><p>以下是一些常见的拥塞控制算法：</p><p><img src="/../../img/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png"></p><ol><li><p><strong>慢启动（Slow Start）</strong>:</p><ul><li>在TCP连接开始时，发送方以一个较小的窗口开始发送数据。</li><li>每收到一个确认（ACK），窗口大小指数增长，直到达到一个阈值（ssthresh）。</li></ul></li><li><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p><ul><li>当达到阈值后，窗口大小的增长变为线性增长，即每收到一个ACK，窗口大小增加1&#x2F;窗口大小。</li><li>这是为了防止网络拥塞的发生。</li></ul></li><li><p><strong>快重传（Fast Retransmit）</strong>:</p><ul><li>当发送方连续收到三个重复的ACK时，会立即重传丢失的数据包，而不是等待超时计时器到期。</li><li>这可以快速响应丢包事件，避免不必要的延迟。</li></ul></li><li><p><strong>快恢复（Fast Recovery）</strong>:</p><ul><li>与快重传配合使用，当发生丢包时，将ssthresh降低到当前窗口大小的一半，然后进入拥塞避免阶段，而不是慢启动。</li></ul></li><li><p><strong>拥塞窗⼝调整</strong>:</p><ul><li>发送方根据⽹络的拥塞程度动态调整发送窗⼝的⼤⼩; 通过监测⽹络延迟和丢包情况来确定合适的发送速率，以避免⽹络拥塞</li></ul></li></ol><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><blockquote><p>为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p></blockquote><ol><li>DNS 域名解析协议<br>域名和IP地址的相互映射，以UDP数据报传输</li><li>FTP文件传输协议（file Transfer Protocol）<br>使用TCP可靠传输</li><li>SMTP简单邮件传输协议（Simple Mail Transfer Protocol）<br>邮件通信三个阶段：(1) 连接建立(2) 邮件传送 (3)连接释放</li><li>POP邮局协议(Post Office Protocol)<br>是一个非常简单但功能有限的邮件读取协议</li><li>HTTP超文本传输协议<br>HTTP 是面向事务的(Transaction-oriented) 应用层协<br>议，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</li></ol><p><strong>访问网页的事件顺序</strong></p><ol><li><p><strong>缓存</strong> 检查浏览器中是否有缓存资源，有则返回缓存资源，没有则发起网络请求</p></li><li><p><strong>DNS解析</strong> 网络请求前，进行DNS解析，以获取IP地址</p><ul><li>如果请求协议是https，还需要建立TLS连接</li><li>DNS解析时会按本地浏览器缓存-&gt;本地 Host ⽂件-&gt;路由器缓存-&gt; DNS 服务器-&gt; 根 DNS 服务器的顺序查询域名对应 IP</li></ul></li><li><p><strong>TCP连接</strong> 浏览器与服务器IP建⽴TCP连接。连接建⽴后，浏览器端会构建请求⾏、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，向服务器构建请求信息</p><ul><li>浏览器使用传输层的TCP协议向目标服务器的80端口（如果是HTTP）或443端口（如果是HTTPS）发送一个SYN（同步序列编号）包，请求建立连接。</li><li>服务器收到SYN包后，回复一个SYN-ACK（同步确认）包。</li><li>浏览器收到SYN-ACK后，发送一个ACK（确认）包，完成TCP连接的建立。</li></ul></li><li><p><strong>发送HTTP&#x2F;HTTPS请求</strong></p><ul><li>浏览器通过已建立的TCP连接发送一个HTTP或HTTPS请求。</li><li>请求包含了请求方法（如GET或POST）、请求的资源路径、HTTP版本、请求头（包含用户代理、接受类型等信息）和可能的请求体。</li></ul></li><li><p><strong>服务器处理请求</strong> 服务器接收到请求信息，根据请求⽣成响应数据。</p></li><li><p><strong>发送响应</strong></p><ul><li>服务器将请求的资源或生成的网页作为HTTP响应发送回浏览器。</li><li>响应包括HTTP状态码（如200表示成功）、响应头和响应体（网页内容）。</li></ul></li><li><p><strong>浏览器解析响应头</strong></p><ul><li>若响应头状态码为 301、302 ，会重定向到新地址；</li><li>若响应数据类型是字节流类型，⼀般会将请求提交给下载管理器；</li><li>若是HTML类型，会进⼊下⼀部渲染流程。</li></ul></li><li><p><strong>TCP连接释放</strong></p><ul><li>浏览器接收到完整的响应后，可能会发送一个FIN（结束）包，请求关闭连接。</li><li>服务器收到FIN包后，发送一个ACK包，并准备关闭连接。</li><li>服务器发送一个FIN包，请求关闭另一端的连接。</li><li>浏览器收到服务器的FIN包后，发送一个ACK包，完成TCP连接的关闭。</li></ul></li><li><p><strong>浏览器渲染网页</strong> 解析 HTML ⽂件，创建 DOM 树，解析 CSS 进⾏样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成⻚⾯展示。</p></li></ol><p><strong>HTTP 和 HTTPs协议</strong></p><ol><li>HTTP 是明⽂传输，⽽ HTTPS 通过 SSL\TLS 进⾏了加密</li><li>HTTP 的端⼝号是 80，HTTPS 是 443</li><li>HTTPS 需要到 CA 申请证书</li><li>HTTP 的连接简单，是⽆状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进⾏加密传输、身份认证的⽹络协议，⽐ HTTP 协议安全。</li></ol><p><strong>SSL\TLS</strong></p><p>SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）是两种主要的网络安全协议</p><p>用于在计算机网络上提供<strong>加密通信和数据完整性保障</strong> （SSL&#x2F;TLS握手，验证服务器的证书）。</p><p>它们主要用于Web浏览器和服务器之间、电子邮件、即时通讯、VoIP（网络电话）和其他应用程序之间的安全通信。</p><h2 id="相关计算机网络知识"><a href="#相关计算机网络知识" class="headerlink" title="相关计算机网络知识"></a>相关计算机网络知识</h2><p><strong>GET 和 POST 请求区别</strong><br>对于 GET ⽅式的请求，浏览器会把 header 和 data ⼀并发送出去，服务器响应 200（返回数据）；<br>⽽对于 POST，浏览器先发送 Header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）</p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>作用</td><td>请求获取数据</td><td>向服务器提交数据</td></tr><tr><td>参数传递方式</td><td>写在URL中</td><td>写在请求体中</td></tr><tr><td>安全性</td><td>低（请求参数直接暴露URL中）</td><td>高</td></tr><tr><td>数据量</td><td>小</td><td>大</td></tr><tr><td>时间消耗</td><td>产生一个TCP数据包</td><td>两个TCP数据包</td></tr></tbody></table><p><strong>Cookie和Session是什么？有什么区别？</strong><br>Cookie 和 Session 都⽤于管理⽤户的状态和身份, Cookie 通过在客户端记录信息确定⽤户身份， Session 通过在服务器端记录信息确定⽤户身份。<br>● 存储位置：Cookie 数据存储在⽤户的浏览器中，⽽ Session 数据存储在服务器上。<br>● 数据容量：Cookie 存储容量较⼩，⼀般为⼏ KB。Session 存储容量较⼤，通常没有固定限制，取决于服务器的配置和资源。<br>● 安全性：由于 Cookie 存储在⽤户浏览器中，因此可以被⽤户读取和篡改。相⽐之下，Session 数据存储在服务器上，更难被⽤户访问和修改。<br>● 传输⽅式：Cookie 在每次 HTTP 请求中都会被⾃动发送到服务器，⽽ Session ID 通常通过 Cookie 或 URL 参数传递。</p><p><strong>跨域和解决方法</strong></p><p><strong>跨域:</strong> 由于浏览器同源策略（请求url的<strong>协议、域名、端口</strong>三者与当前页面url都必须完全相同）的限制，一个域名下的Web应用不能发起请求到另一个域名的服务器获取资源或数据的情况</p><p><strong>跨域解决方案：</strong></p><ol><li><p><strong>CORS（Cross-Origin Resource Sharing）</strong>:</p><ul><li>CORS是一个W3C标准，允许服务器通过在HTTP响应中包含特定的头信息来放松同源策略的限制。</li><li>服务器可以设置<code>Access-Control-Allow-Origin</code>头来指定哪些源可以访问资源，或者使用<code>*</code>来允许所有源。</li></ul></li><li><p><strong>JSONP（JSON with Padding）</strong>:</p><ul><li>JSONP是一种老的解决方案，它通过动态创建<code>&lt;script&gt;</code>标签来绕过同源策略的限制，因为<code>&lt;script&gt;</code>标签可以加载跨域的JavaScript。</li><li>JSONP请求通过添加一个查询参数（通常为<code>callback</code>）到URL中，服务器响应时将数据包装在函数调用中。</li></ul></li><li><p><strong>代理服务器</strong>:（webpack本地代理，nginx反向代理）</p><ul><li>在客户端和目标服务器之间设置一个代理服务器，客户端的请求首先发送到代理服务器，然后由代理服务器转发请求到目标服务器。</li><li>代理服务器获取响应后再转发回客户端，由于客户端与代理服务器同域，这样就规避了浏览器的同源策略。</li></ul></li><li><p><strong>修改文档域（document.domain）</strong>:</p><ul><li>如果两个页面的域名相同但子域名不同，可以通过设置<code>document.domain</code>为共同的上级域来允许它们之间进行通信。</li></ul></li><li><p><strong>Web Storage</strong>:</p><ul><li>利用localStorage或sessionStorage作为不同源间通信的媒介，但这种方式受到存储空间大小的限制。</li></ul></li></ol><p>选择哪种解决方案取决于具体场景和需求。在开发现代Web应用时，CORS是最常用和推荐的解决方案，因为它提供了一种标准、安全的方式来处理跨域资源共享问题。</p><h3 id="计算机网络的本质"><a href="#计算机网络的本质" class="headerlink" title="计算机网络的本质"></a>计算机网络的本质</h3><ol><li><p>计算机之间通过一条电线相连接实现电信号的传输进行网络通信。每多一台设备就要多 n 根线（n为目前总的设备数，太费线）</p></li><li><p>使用<strong>Hub（集线器）</strong> 来对网络请求进行转发。</p><ul><li>每个设备只需要与集线器相连就行，多一台设备只多一根线。</li><li>但是集线器并不知道每个设备都是谁，因此不能实现精准得发给指定的设备，所以会群发，隐私性差。</li><li>并且它是半双工通信，无法双向通信。</li></ul></li><li><p><strong>交换机</strong> 会记录设备的唯一标识（MAC地址）来区分不同的连接设备。</p><ul><li>交换机通过 MAC 地址表（包含设备的MAC地址和对应端口号）即可实现点对点的连接。</li><li>支持全双工通信，允许两台设备同时相互传输数据</li><li>支持桥接网络，可以实现两个交换机相连，从而可以使得连接在不同交换机上的设备也可以通信</li><li>问题1：交换机能够记录的MAC地址是有限的</li><li>问题2：相互连接的交换机越多，会让消息传播的路径变长，还可能因为连接顺序不合理导致经过不必要的设备</li></ul></li><li><p><strong>路由器</strong> 基于路由算法，管理来自多个网络的设备连接，适用于多个网络的互联和数据转发。为了对多个网络和网络设备进行区分，因此用IP地址进行标识（实际通信还是用 MAC 地址）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习知识点汇总</title>
    <link href="/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习知识点汇总"><a href="#深度学习知识点汇总" class="headerlink" title="深度学习知识点汇总"></a>深度学习知识点汇总</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 定义模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Net, self).__init__()<br>        self.fc1 = nn.Linear(input_size, hidden_units)<br>        self.dropout = nn.Dropout(dropout_rate)<br>        self.fc2 = nn.Linear(hidden_units, num_classes)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = torch.relu(self.fc1(x))<br>        x = self.dropout(x)<br>        x = self.fc2(x)<br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># 创建模型实例</span><br>model = Net()<br><br><span class="hljs-comment"># 定义损失函数和优化器</span><br>criterion = nn.CrossEntropyLoss()<br>optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)<br><br><span class="hljs-comment"># 训练模型</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> i, (images, labels) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        images = images.reshape(-<span class="hljs-number">1</span>, input_size)<br>        <br>        <span class="hljs-comment"># 前向传播</span><br>        outputs = model(images)<br>        loss = criterion(outputs, labels)<br>        <br>        <span class="hljs-comment"># 反向传播和优化</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br>        <br>        <span class="hljs-comment"># 打印训练信息</span><br>        <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % display_step == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;&#x27;</span><br>                  .<span class="hljs-built_in">format</span>(epoch+<span class="hljs-number">1</span>, num_epochs, i+<span class="hljs-number">1</span>, total_steps, loss.item()))<br><br><span class="hljs-comment"># 在测试集上评估模型</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    correct = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> test_loader:<br>        images = images.reshape(-<span class="hljs-number">1</span>, input_size)<br>        outputs = model(images)<br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs.data, <span class="hljs-number">1</span>)<br>        total += labels.size(<span class="hljs-number">0</span>)<br>        correct += (predicted == labels).<span class="hljs-built_in">sum</span>()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test Accuracy: &#123;&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">100</span> * correct / total))<br></code></pre></td></tr></table></figure><h1 id="12-1"><a href="#12-1" class="headerlink" title="12.1"></a>12.1</h1><h2 id="过拟合和欠拟合（Overfitting-and-underfitting）"><a href="#过拟合和欠拟合（Overfitting-and-underfitting）" class="headerlink" title="过拟合和欠拟合（Overfitting and underfitting）"></a>过拟合和欠拟合（Overfitting and underfitting）</h2><p>过拟合和欠拟合是导致模型泛化能力不高的两种常见原因，都是模型学习能力与数据复杂度之间失配的结果。<br><strong>“欠拟合”</strong>常常在模型学习能力较弱，而数据复杂度较高的情况出现，此时模型由于学习能力不足，无法学习到数据集中的“一般规律”，因而导致泛化能力弱。<br><strong>“过拟合”</strong>常常在模型学习能力过强的情况中出现，此时的模型学习能力太强，以至于将训练集单个样本自身的特点都能捕捉到，并将其认为是“一般规律”，同样这种情况也会导致模型泛化能力下降。</p><h3 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h3><p>过拟合（over-fitting）也称为过学习，它的直观表现是算法在训练集上表现好，但在测试集上表现不好，泛化性能差<br><strong>cause</strong></p><blockquote><ul><li>训练集的数据太少或者缺乏代表性；</li><li>训练集样本存在的噪音干扰过大，导致模型拟合了噪音的特征，反而忽略了真实的输入输出间的关系；</li><li>参数太多，模型复杂度过高；</li></ul></blockquote><p><strong>method</strong></p><p>1.增加数据量  </p><ul><li>从数据源头获取更多数据；</li><li>通过数据增强对数据进行扩充：对图像进行翻转、裁剪、缩放、平移、添加噪声等。</li></ul><p>2.正则化<br>在进行目标函数或代价函数（损失函数）优化时，在函数后面加上一个正则项，一般有L1正则、L2正则等。</p><blockquote><ul><li><strong>L1正则化：</strong> L1正则化是通过在目标函数中加入L1范数惩罚项来实现的。L1范数是指权重向量W中的各个元素绝对值之和，因此L1正则化的目的是使模型参数尽可能地稀疏。L1正则化可以促使模型参数向零值收缩，进而减少特征的数量。</li><li><strong>L2正则化：</strong> L2正则化是通过在目标函数中加入L2范数惩罚项来实现的。L2范数是指权重向量W中的各个元素的平方和开根号，因此L2正则化的目的是通过约束模型参数的平方和，使得它们的值不会过大。L2正则化可以帮助避免模型的权值过拟合，并使得模型更具有鲁棒性和泛化能力。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加L2正则化项</span><br>l2_reg = torch.tensor(<span class="hljs-number">0.</span>) <span class="hljs-comment"># 创建一个初始值为零的 torch.Tensor 对象，用于累加模型参数的 L2 范数。</span><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.parameters():<br>    l2_reg += torch.norm(param, <span class="hljs-number">2</span>)<br>loss += l2_penalty * l2_reg <span class="hljs-comment">#  L2 正则化的惩罚系数（penalty coefficient），用于控制正则化的强度。它是一个超参数，需要根据具体问题进行调整(交叉验证)。</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>区别：</strong> L1正则化减少的是一个常量，L2正则化减少的是权重的固定比例；使用L1可以得到稀疏的权值，使用L2可以得到平滑的权值；实践中L2正则化通常优于L1正则化。</p></blockquote><p>3.Dropout<br>Dropout 是一种常用的正则化技术，用于减少深度神经网络的过拟合现象。Dropout 在训练过程中随机地丢弃一部分神经元的输出，从而强制模型去学习其他特征的表示。</p><blockquote><p><code>self.dropout = nn.Dropout(dropout_rate)</code></p></blockquote><p>具体来说，Dropout 在前向传播的过程中，以一定的概率 p（通常设置为0.5）将某个神经元的输出设为0，即丢弃该神经元。这样做的结果是，每个神经元在训练过程中都有一定概率暂时被“关闭”，从而迫使网络去考虑其他神经元的贡献，减少了对特定神经元的依赖性。同时，在前向传播过程中，通过保留每个神经元输出的比例，可以确保网络的总体期望值不变。</p><h1 id="12-2"><a href="#12-2" class="headerlink" title="12.2"></a>12.2</h1><h2 id="Triplet-Loss-和-Center-Loss"><a href="#Triplet-Loss-和-Center-Loss" class="headerlink" title="Triplet Loss 和 Center Loss"></a>Triplet Loss 和 Center Loss</h2><blockquote><p><code>https://blog.csdn.net/weixin_40671425/article/details/98068190</code></p></blockquote><h1 id="12-2-1"><a href="#12-2-1" class="headerlink" title="12.2"></a>12.2</h1><blockquote><p><code>https://zhuanlan.zhihu.com/p/438085414</code></p></blockquote><h1 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h1><p>Tensor（张量）是一个多维数组，它是深度学习中最基本的数据结构之一，也是基于计算图的深度学习框架的核心组成部分。Tensor 可以存储和表示任意维度的数据，支持各种数值和数据类型，并提供了类似于 numpy 的数据操作接口，例如加、减、乘、除、运算、矩阵乘法、转置等。在深度学习中，我们使用 Tensor 来存储训练样本和模型参数，并对它们进行线性和非线性的运算。</p><p>Tensor 的维度通常被称作“阶”，例如，阶为 0 的 Tensor 又被称作“标量”（scalar），表示一个单独的数值；阶为 1 的 Tensor 又被称作“向量”（vector），表示一列数值；阶为 2 的 Tensor 又被称作“矩阵”（matrix），表示一个二维的表格。在深度学习中，我们通常会使用阶数更高的 Tensor，例如 3 阶、4 阶或更高阶的 Tensor，以表示更复杂的数据结构，如图像、视频或音频数据等。</p><h2 id="1-张量的创建"><a href="#1-张量的创建" class="headerlink" title="1.张量的创建"></a>1.张量的创建</h2><h3 id="1-1-通过列表或者元组"><a href="#1-1-通过列表或者元组" class="headerlink" title="1.1 通过列表或者元组"></a>1.1 通过列表或者元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t = torch([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]) / t = torch((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(t)<br><span class="hljs-comment"># tensor([1, 2])</span><br></code></pre></td></tr></table></figure><h3 id="1-2-通过numpy创建"><a href="#1-2-通过numpy创建" class="headerlink" title="1.2 通过numpy创建"></a>1.2 通过numpy创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>n = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>t = torch.tensor(n)<br><span class="hljs-built_in">print</span>(t)<br><span class="hljs-comment"># tensor([1, 2])</span><br></code></pre></td></tr></table></figure><h3 id="1-3-tensor-type-and-convert"><a href="#1-3-tensor-type-and-convert" class="headerlink" title="1.3 tensor-type and convert"></a>1.3 tensor-type and convert</h3><p>type()不能识别出Tensor内部的数据类型，只能识别出变量的基本类型是Tensor，而dtype方法可以识别出变量具体为哪种类型的Tensor。<br>可以使用.float()、.int()等方法对张量类型进行转化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">i = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>f = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(i), i.dtype, sep = <span class="hljs-string">&#x27; , &#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(f), f.dtype, sep = <span class="hljs-string">&#x27; , &#x27;</span>)<br><span class="hljs-comment"># &lt;class &#x27;torch.Tensor&#x27;&gt; , torch.int64</span><br><span class="hljs-comment"># &lt;class &#x27;torch.Tensor&#x27;&gt; , torch.float32</span><br><br>t = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>f = t.<span class="hljs-built_in">float</span>()<br><span class="hljs-built_in">print</span>(f)<br><span class="hljs-built_in">print</span>(t) <span class="hljs-comment"># 并不会改变原来t的数据类型</span><br><span class="hljs-comment"># tensor([1., 2.])</span><br><span class="hljs-comment"># tensor([1, 2])</span><br></code></pre></td></tr></table></figure><h2 id="tensor—shape"><a href="#tensor—shape" class="headerlink" title="tensor—shape"></a>tensor—shape</h2><p>张量的维度中，我们使用的张量如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一维向量</span><br>t1 = torch.tensor((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-comment"># 二维向量</span><br>t2 = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-comment"># 三维向量</span><br>t3 = torch.tensor([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]],[[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]])<br><br><span class="hljs-comment"># ndim查看张量维度</span><br><span class="hljs-built_in">print</span>(t1.ndim, t2.ndim, t3.ndim, sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># 1, 2, 3</span><br><span class="hljs-comment"># t1为1维向量</span><br><span class="hljs-comment"># t2为2维矩阵</span><br><span class="hljs-comment"># t3为3维张量</span><br><br><span class="hljs-comment"># shape&amp;size查看向量的形状</span><br><span class="hljs-built_in">print</span>(t1.shape, t2.shape, t3.shape, sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># torch.Size([2]), torch.Size([2, 3]), torch.Size([2, 2, 2])</span><br><br><span class="hljs-built_in">print</span>(t1.size(), t2.size(), t3.size(), sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># torch.Size([2]), torch.Size([2, 3]), torch.Size([2, 2, 2])</span><br><br><span class="hljs-comment"># numel查看张量中的元素个数</span><br><span class="hljs-built_in">print</span>(t1.numel(), t2.numel(), t3.numel(), sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># 2, 6, 8</span><br><span class="hljs-comment"># t1向量中共有2个元素</span><br><span class="hljs-comment"># t2矩阵中共有6个元素</span><br><span class="hljs-comment"># t3张量中共有8个元素</span><br><br><span class="hljs-comment"># flatten将任意维度张量转为一维张量</span><br>t2.flatten()<br><span class="hljs-comment"># tensor([1, 2, 3, 4, 5, 6])</span><br><br>t3.flatten()<br><span class="hljs-comment"># tensor([1, 2, 3, 4, 5, 6, 7, 8])</span><br><br><br></code></pre></td></tr></table></figure><blockquote><ul><li>t1向量torch.Size([2])的理解：向量的形状是1行2列。</li><li>t2矩阵torch.Size([2, 3])的理解：二维矩阵的形状是2行3列。</li><li>t3矩阵torch.Size([2, 2, 2])的理解：包含两个二维矩阵，每个二维矩阵的形状是2行2列。</li></ul></blockquote><h3 id="reshape任意变形"><a href="#reshape任意变形" class="headerlink" title="reshape任意变形"></a>reshape任意变形</h3><p><strong>形变维度的乘积需要等于张量元素的个数。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将`t3`变成2×4的矩阵</span><br>t3.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment">#tensor([[1, 2, 3, 4],[5, 6, 7, 8]])</span><br><br><span class="hljs-comment"># 将`t3`变成1×4×2的矩阵</span><br>t3.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># tensor([[[1, 2], [3, 4], [5, 6], [7, 8]]])</span><br></code></pre></td></tr></table></figure><h3 id="squeeze-unsqueeze"><a href="#squeeze-unsqueeze" class="headerlink" title="squeeze&amp;unsqueeze"></a>squeeze&amp;unsqueeze</h3><ul><li>squeeze的作用是压缩张量，去掉维数为1位置的维度</li><li>unsqueeze的作用是解压张量，给<strong>指定位置</strong>加上维数为一的维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将t3的维度变为2×1×4</span><br>t_214 = t3.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(t_214)<br><span class="hljs-comment"># tensor([[[1, 2, 3, 4]], [[5, 6, 7, 8]]])</span><br><br><span class="hljs-comment"># 使用squeeze将其变成2×4，去掉维度为1位置的维度</span><br>t_24 = t_214.squeeze(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t_24)<br><span class="hljs-comment"># tensor([[1, 2, 3, 4], [5, 6, 7, 8]])</span><br><br><span class="hljs-comment"># 将2×4的维度再转换成2×1×4，在第二个维度上加一维</span><br><span class="hljs-comment"># 索引是从0开始的。参数0代表第一维，参数1代表第二维，以此类推</span><br><span class="hljs-built_in">print</span>(t_24.unsqueeze(<span class="hljs-number">1</span>))<br>tensor([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]], [[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]])<br></code></pre></td></tr></table></figure><h3 id="tensor-——-value"><a href="#tensor-——-value" class="headerlink" title="tensor ——&gt; value"></a>tensor ——&gt; value</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n = torch.tensor(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(n) <span class="hljs-comment"># tensor(1)</span><br><br><span class="hljs-comment"># 使用.item()方法将张量转为python中的数值</span><br>n.item() <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><h2 id="张量的索引"><a href="#张量的索引" class="headerlink" title="张量的索引"></a>张量的索引</h2><p>张量是有序序列，我们可以根据每个元素在系统内的顺序位置，来找出特定的元素，也就是索引。</p><p>一维张量索引与Python中的索引一样是是从左到右，从0开始的，遵循格式为[start: end: step]。</p><h2 id="张量的合并与分割"><a href="#张量的合并与分割" class="headerlink" title="张量的合并与分割"></a>张量的合并与分割</h2><blockquote><p>当对一个张量进行切割时，返回的是原始张量的一个视图（view）或子集，而不是创建一个新的张量。这意味着切片返回的是原始张量的一个引用，并与原始张量共享数据存储，<strong>所以在修改切片返回的张量时，会同时修改原始张量中相应的元素。</strong> 需要注意的是，如果我们希望创建一个拷贝而非共享内存的切片，可以使用 .copy() 方法，这样操作切片将不会对原始张量产生影响。</p></blockquote><h3 id="张量的分割-chunk-split"><a href="#张量的分割-chunk-split" class="headerlink" title="张量的分割 chunk &amp; split"></a>张量的分割 chunk &amp; split</h3><p>chunk(tensor, chunks, dim)能够按照某个维度(dim)对张量进行均匀切分(chunks)，并且返回结果是原张量的视图。</p><h3 id="张量的合并-cat"><a href="#张量的合并-cat" class="headerlink" title="张量的合并 cat"></a>张量的合并 cat</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.zeros(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[0., 0., 0.],</span><br><span class="hljs-comment">#         [0., 0., 0.]])</span><br><br>b = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]])</span><br><br><br>因为在张量a与b中，shape的第一个位置是代表向量维度，所以当dim取<span class="hljs-number">0</span>时，就是将向量进行合并，向量中的标量数不变：<br>torch.cat([a, b], dim = <span class="hljs-number">0</span>) <br><span class="hljs-comment"># tensor([[0., 0., 0.],</span><br><span class="hljs-comment">#         [0., 0., 0.],</span><br><span class="hljs-comment">#         [1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]])</span><br><br>当dim取<span class="hljs-number">1</span>时，shape的第二个位置是代表列，即标量数，就是在列上（标量维度）进行拼接，行数（向量数）不变：<br>torch.cat([a, b], dim = <span class="hljs-number">1</span>)<br><span class="hljs-comment"># tensor([[0., 0., 0., 1., 1., 1.],</span><br><span class="hljs-comment">##        [0., 0., 0., 1., 1., 1.]])</span><br></code></pre></td></tr></table></figure><h3 id="张量的堆叠-stack"><a href="#张量的堆叠-stack" class="headerlink" title="张量的堆叠 stack"></a>张量的堆叠 stack</h3><p>和拼接不同，堆叠不是将元素拆分重装，而是将各参与堆叠的对象分装到一个更高维度的张量里。<br>和 cat 的区别：拼接之后维度不变，堆叠之后维度升高。拼接是把一个个元素单独提取出来之后再放到二维张量里，而堆叠则是直接将两个二维向量封装到一个三维张量中。因此，堆叠的要求更高，参与堆叠的张量必须形状完全相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.zeros(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[0., 0., 0.],</span><br><span class="hljs-comment">#         [0., 0., 0.]])</span><br><br>b = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]])</span><br><br>torch.stack([a, b], dim = <span class="hljs-number">0</span>)<br><span class="hljs-comment"># tensor([[[0., 0., 0.],</span><br><span class="hljs-comment">#          [0., 0., 0.]],</span><br><span class="hljs-comment">#         [[1., 1., 1.],</span><br><span class="hljs-comment">#          [1., 1., 1.]]])</span><br><br>torch.stack([a, b], dim = <span class="hljs-number">0</span>).shape<br><span class="hljs-comment"># torch.Size([2, 2, 3])</span><br></code></pre></td></tr></table></figure><h1 id="12-3"><a href="#12-3" class="headerlink" title="12.3"></a>12.3</h1><h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><blockquote><p>通道注意力（Channel Attention），空间注意力（Spatial Attention），分支注意力（Branch Attention），自注意力（Self Attention）和交叉注意力（Cross Attention）</p></blockquote><h1 id="12-8"><a href="#12-8" class="headerlink" title="12.8"></a>12.8</h1><h1 id="vision-transformer"><a href="#vision-transformer" class="headerlink" title="vision transformer"></a>vision transformer</h1><h1 id="grad-cam"><a href="#grad-cam" class="headerlink" title="grad-cam"></a>grad-cam</h1><h1 id="Vit-Grad-Cam"><a href="#Vit-Grad-Cam" class="headerlink" title="Vit + Grad-Cam"></a>Vit + Grad-Cam</h1><blockquote><p><code>https://zhuanlan.zhihu.com/p/640450435</code><br>Grad-CAM 对 ViT 的输出进行可视化的原理是利用 ViT 的最后一个注意力块的输出和梯度，计算出每个 token 对分类结果的贡献度，然后将这些贡献度映射回原始图像的空间位置，形成一张热力图。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>损失函数</title>
    <link href="/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><blockquote><p>用来量化模型预测值和真实标签之间的差异</p></blockquote><h2 id="0-1损失函数"><a href="#0-1损失函数" class="headerlink" title="0-1损失函数"></a>0-1损失函数</h2><blockquote><p>模型在训练集上的错误率</p></blockquote><h2 id="平方损失函数"><a href="#平方损失函数" class="headerlink" title="平方损失函数"></a>平方损失函数</h2><blockquote><p>用来预测标签 y 为实数值的任务，一般不适用于分类任务</p></blockquote><h2 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h2><blockquote><p>一般用于分类任务<br>计算：比如三分类问题，一个样本标签的one-hot向量为 $y &#x3D; [0,0,1]^T$ , 模型预测的标签分布为 $[0.3,0.3,0.4]^T$ , 则它们的交叉熵为 $-(0 * log(0.3) + 0 * log(0.3) + 1 * log(0.4)) &#x3D; -log(0.4)$</p></blockquote><h1 id="过-欠拟合"><a href="#过-欠拟合" class="headerlink" title="过&#x2F;欠拟合"></a>过&#x2F;欠拟合</h1><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>梯度下降法就是一种<strong>通过求目标函数的导数来寻找目标函数最小化的方法</strong></p><ol><li>批量梯度下降法（BGD）在每次迭代时要计算每个样本上损失函数的梯度并求和</li><li>随机梯度下降法（SGD）为了减少每次迭代的</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>表示学习</title>
    <link href="/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h1><blockquote><p>在深度学习中，前面的层为表示学习，最后一层为预测学习</p></blockquote><ol><li><strong>自动地学习出有效的特征</strong>，并最终提高机器学习模型的性能的算法就叫做表示学习。</li><li>表示学习关键是解决语义鸿沟问题————是指输入数据的底层特征表示和高层的抽象语义特征不一致性。（对于一些不同颜色和形状的车来说，它们在像素级别的表示（底层特征表示）上相差很大，但我们认为它们都是车是建立在高层语义特征上的）</li><li>表示学习的两个核心问题：<br><strong>什么是一个好的表示</strong><br><strong>如何学习到好的表示</strong></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="局部表示"><a href="#局部表示" class="headerlink" title="局部表示"></a>局部表示</h3><p>也叫离散表示或符号表示，通常用<strong>one-hot向量</strong>表示，假设所有颜色构成一个词表，词表长度为|V|,可以用一个v维的向量来表示特征，在第i种颜色所对应的one-hot向量中的第 i 维为1，其他维为0</p><p><strong>优点：</strong></p><ol><li>离散的表示方式具有好的解释性</li><li>这种特征表示通常是稀疏的二值向量，计算效率高</li></ol><p><strong>缺点：</strong></p><ol><li>维数高，不易扩展</li><li>不同特征之间的相似度都为0（按理来说红色与粉红色的相似度肯定比 红色和黑色高）</li></ol><h3 id="分布式表示"><a href="#分布式表示" class="headerlink" title="分布式表示"></a>分布式表示</h3><p>用RGB三个数值来表示颜色</p><p>优点：</p><ol><li>向量维度要低，更容易扩展</li><li>不同颜色的相似度也容易计算</li></ol><p><strong>嵌入</strong></p><blockquote><p>使用神经网络将高维的局部表示空间映射到一个低维的分布式表示空间，这个过程被称为嵌入</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>浅层学习，不涉及特征学习，特征来源于人工提取</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li><p><code>Sklearn</code> python的机器学习库</p></li><li><p>鸢尾花数据集（iris dataset）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br><span class="hljs-comment"># 加载数据集</span><br><span class="hljs-comment"># 鸢尾花数据集（iris dataset）是一个经典的机器学习数据集，其中包含了150个样本，</span><br><span class="hljs-comment"># 每个样本有四个特征：花萼长度、花萼宽度、花瓣长度、花瓣宽度。</span><br><span class="hljs-comment"># 这些样本被分为三个类别：山鸢尾（setosa）、变色鸢尾（versicolor）和维吉尼亚鸢尾（virginica）。</span><br><span class="hljs-comment"># 鸢尾花数据集通常被用来进行分类问题的训练和评估，是机器学习领域常用的基准数据集之一。您可以使用sklearn库中的datasets.load_iris()函数加载这个数据集。</span><br>iris = datasets.load_iris()<br>X = iris.data<br>y = iris.target<br><span class="hljs-built_in">print</span>(X)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-comment"># 划分训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 创建线性分类器模型</span><br>model = LogisticRegression(max_iter=<span class="hljs-number">1</span>) <span class="hljs-comment"># 迭代次数</span><br><br><span class="hljs-comment"># 拟合模型</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 预测</span><br>y_pred = model.predict(X_test)<br><br><span class="hljs-comment"># 评估性能</span><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(accuracy))<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol><li><strong>数据预处理</strong>（去掉一些有缺失特征的样本；去掉一些冗余的数据特征；对数值特征进行缩放和归一化；）</li><li><strong>特征提取：</strong>从数据的原始特征中提取一些对特定机器学习任务有用的高质量特征（比如在图像分类中提取边缘）</li><li><strong>特征转换：</strong>对特征进行进一步的加工，比如降维和升维，降维包括特征抽取和特征选择。常用特征转换方法有主成分分析（PCA）和线性判别（LDA）</li><li><strong>预测：</strong>学习一个函数并进行预测</li></ol><h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><blockquote><p>线性模型是机器学习中应用最广泛的模型，指通过样本特征的线性组合来进行预测的模型，给定一个D维样本 $x &#x3D; [x_1,…,x_D]^T$ , 其<strong>线性组合(判别)函数</strong>为 </p></blockquote><p>$$<br>f(x;w) &#x3D; w_1x_1 + w_2x_2 + … + w_Dx_D + b<br>       &#x3D; w^Tx + b<br>$$</p><p>其中 $w &#x3D; [w_1,…,w_D]$ 为 D维的权重向量，b为偏置<br>对于分类问题，要在线性组合函数的基础上引入<strong>非线性的决策函数</strong> $g()$ 来预测输出目标<br>$$<br>y &#x3D; g(f(x;w))<br>$$</p><ol><li><p><strong>一个 线性分类模型 主要由 一个或多个线性的判别函数 和 非线性的决策函数 组成</strong></p></li><li><p>接下来介绍四种不同的线性分类模型（线性分类器）：Logistic回归、Softmax回归、感知机、支持向量机。主要区别在于<strong>使用了不同的损失函数</strong></p></li></ol><p><strong>训练数据集是线性可分</strong></p><p>当说训练数据集是线性可分的时，意味着在数据集中存在一个能够清晰划分两个或多个类别的线性决策边界。<br>换句话说，存在一个线性函数或平面，可以将不同类别的样本有效地分开。这意味着在特征空间中，不同类别的样本在一定程度上能够被一条直线、平面或超平面等线性边界分开。</p><p>如果训练数据集是线性可分的，则意味着使用线性分类器（例如线性回归、逻辑回归、支持向量机等）能够很好地对数据进行分类或预测<br>如果数据集不是线性可分的，就需要使用更复杂的模型或非线性技术来处理数据。</p><h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><p>机器学习算法分类：监督学习、无监督学习、强化学习<br><strong>监督学习算法</strong> (Supervised Algorithms) 在监督学习训练过程中，可以由训练数据集学到或建立一个模式（函数 &#x2F; learning model），并依此模式推测新的实例。该算法要求特定的输入&#x2F;输出，首先需要决定使用哪种数据作为范例。例如，文字识别应用中一个手写的字符，或一行手写文字。主要算法包括神经网络、支持向量机、最近邻居法、朴素贝叶斯法、决策树等。</p><p><strong>无监督学习算法</strong> (Unsupervised Algorithms) 这类算法没有特定的目标输出，算法将数据集分为不同的组。</p><p><strong>强化学习算法</strong> (Reinforcement Algorithms) 强化学习普适性强，主要基于决策进行训练，算法根据输出结果（决策）的成功或错误来训练自己，通过大量经验训练优化后的算法将能够给出较好的预测。类似有机体在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。在运筹学和控制论的语境下，强化学习被称作“近似动态规划”</p><p>基本的机器学习算法：线性回归、支持向量机(SVM)、最近邻居(KNN)、逻辑回归、决策树、k平均、随机森林、朴素贝叶斯、降维、梯度增强</p><h3 id="线性回归（Linear-Regression）"><a href="#线性回归（Linear-Regression）" class="headerlink" title="线性回归（Linear Regression）"></a>线性回归（Linear Regression）</h3><p>线性回归算法（Linear Regression）的建模过程就是使用数据点来寻找最佳拟合线</p><ol><li>多元线性回归<br>多元线性回归是回归分析中的一种复杂模型，它考虑了多个输入变量对输出变量的影响。与一元线性回归不同，多元线性回归通过引入多个因素，更全面地建模了系统关系。</li></ol><p>多元线性回归模型的表达式为：$f ( x ) &#x3D;\mathbf{k^T}\mathbf{x}+b$<br>其中，$\mathbf{x}$为输入向量，包含多个特征（自变量）；$f(\mathbf{x})$为模型的输出或响应（预测的目标变量）；$\mathbf{k^T}$ 为特征权重；$b$为是模型的截距或偏置；我们的目标是通过学习$\mathbf{k^T}$ 和 $b$ 使得 $f(\mathbf{x})$ 尽可能的接近真实观测值 $\mathbf{y}$</p><p><img src="/../../img/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.png"></p><p>直白点说：首先求出当前模型的 所有采样点上的预测值𝑤𝑥(𝑖) +𝑏与真实值𝑦(𝑖)之间的差的平方和作为总误差ℒ，然后搜索一组参数𝑤∗,𝑏∗使得ℒ最小，对应的直线就是我们要寻找的最优直线</p><ol start="2"><li>实现方式</li></ol><p><strong>全局梯度下降</strong><br>梯度下降法是一种迭代算法。选取适当的初值x(0)，不断迭代，更新x的值，进行<strong>目标函数(也是线性回归的损失函数)的极小化</strong>，直到收敛。（它从一个初始点开始，反复使用某种规则从移动到下一个点，构造这样一个数列，直到<strong>收敛到梯度为0的点处</strong>，即梯度下降算法）</p><p>由于负梯度方向时使函数值下降最快的方向，在迭代的每一步，<strong>以负梯度方向更新x的值</strong>，从而达到减少函数值的目的</p><p>线性回归一般选择的是MSE（均方误差）<br><strong>均方误差</strong>是预测值与真实值之间差值的平方的平均值</p><p><strong>学习率在梯度下降法中的作用</strong><br>我们可以通过 𝜼 来控制每一步走的距离</p><ol><li>以保证不要走的太快，错过了最低点</li><li>同时也要保证收敛速度不要太慢</li></ol><h3 id="逻辑回归（Logistic-regression）"><a href="#逻辑回归（Logistic-regression）" class="headerlink" title="逻辑回归（Logistic regression）"></a>逻辑回归（Logistic regression）</h3><p><strong>逻辑回归和线性回归区别：</strong></p><p>逻辑回归：</p><ol><li>逻辑回归是一种用于分类问题的模型，而不是回归问题。它用于预测二元分类或多元分类的概率。</li><li>损失函数通常是对数损失函数（log loss），也称为交叉熵损失函数（cross-entropy loss）。</li><li>目标是最大化似然函数或最小化损失函数，通常通过梯度下降等方法实现。</li><li>相比较线性回归的连续值直接求解，在逻辑回归中，还需要<strong>使用Sigmoid函数将回归方程映射成概率进行分类</strong></li></ol><p><img src="/../../img/sigmid.png"></p><p>线性回归：</p><ol><li>线性回归用于预测连续型变量的值，是一种回归模型。</li><li>损失函数通常是均方误差（Mean Squared Error，MSE）。</li><li>目标是最小化损失函数，通过梯度下降等方法实现。</li></ol><h3 id="KNN算法（最近邻居-k-近邻算法，K-Nearest-Neighbors）"><a href="#KNN算法（最近邻居-k-近邻算法，K-Nearest-Neighbors）" class="headerlink" title="KNN算法（最近邻居&#x2F;k-近邻算法，K-Nearest Neighbors）"></a>KNN算法（最近邻居&#x2F;k-近邻算法，K-Nearest Neighbors）</h3><p>口诀：近朱者赤，近墨者黑</p><p><img src="/../../img/KNN.png"></p><p>KNN算法是一种基于实例的学习，或者是局部近似和将所有计算推迟到分类之后的惰性学习。KNN主要用于<strong>分类</strong>问题</p><p>用最近的邻居（k）来预测未知数据点。k 值是预测精度的一个关键因素，无论是分类还是回归，衡量邻居的权重都非常有用，较近邻居的权重比较远邻居的权重大</p><p>ex. 假设k &#x3D; 5，代表用周围5个点来估计未知数据点的类别，这5个点中比例最高的类别即为该预测类别</p><ol><li><p>需要想办法来计算两个样本之间的距离或者相似度，之后才能选出最相近的样本。<strong>欧氏距离</strong>是一个最简单常用的方法</p></li><li><p>怎么确定K值<br>确定KNN算法的K值通常需要通过<strong>交叉验证</strong></p></li></ol><ul><li>将数据集分成K份（通常K取5或10），每次选择其中一份作为验证集，剩下的K-1份作为训练集。</li><li>对于每个K值，重复K次交叉验证，计算模型在验证集上的性能指标（如准确率、F1分数等）的平均值。</li><li>根据性能指标的表现选择最优的K值。</li></ul><h3 id="决策树（Decision-Tress）"><a href="#决策树（Decision-Tress）" class="headerlink" title="决策树（Decision Tress）"></a>决策树（Decision Tress）</h3><ol><li>决策树（Decision tree）是一种特殊的树结构，由一个决策图和可能的结果（例如成本和风险）组成，用来辅助决策。</li><li>机器学习中，决策树是一个预测模型，树中每个节点表示某个对象，而每个分叉路径则代表某个可能的属性值，而每个叶节点则对应从根节点到该叶节点所经历的路径所表示的对象的值。</li><li>决策树仅有单一输出，通常该算法用于解决<strong>分类</strong>问题。</li></ol><p><img src="/../../img/%E5%86%B3%E7%AD%96%E6%A0%91.png"></p><p><strong>决策树节点的划分</strong><br>熵：代表一个系统的混乱程度，越混乱熵越高</p><p>划分依据：<strong>最大化信息增益（熵）</strong><br>比较多个特征的信息增益，选择信息增益最大的特征作为根节点进行划分。然后，重复这个过程，对每个子节点进行划分，直到满足停止条件（如节点包含的样本数小于预定义阈值）为止</p><p>信息增益的计算步骤：</p><ol><li>计算每个类别的信息熵</li><li>求离散的特征属性值 a 对数据集 D 的条件信息熵</li><li>计算信息增益</li></ol><p><img src="/../../img/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A.png"></p><h3 id="k-平均算法（K-Means）"><a href="#k-平均算法（K-Means）" class="headerlink" title="k-平均算法（K-Means）"></a>k-平均算法（K-Means）</h3><p>口诀：物以类聚，人以群分</p><p><img src="/../../img/K-Means.png"></p><p>k-平均算法(K-Means)是一种<strong>无监督学习算法</strong>，为<strong>聚类问题</strong>提供了一种解决方案。<br>K-Means 算法把 n 个点（可以是样本的一次观察或一个实例）划分到 k 个集群（cluster），使得每个点都属于离他最近的均值（即聚类中心，centroid）对应的集群。重复上述过程一直持续到重心不改变。</p><p>计算过程如下：</p><ol><li><p>分配阶段：对每个数据点，计算其与每个类中心的距离，然后将其分配到距离最近的类中心所对应的类里。</p></li><li><p>更新阶段：对于每个类，根据该类中所有数据点的均值计算新的类中心。假设某个类包含的数据点集合为 𝑆, 其中包含 𝑛 个数据点，则该类的新的类中心 $𝐶_𝑗$ 可以通过以下公式计算得到, $𝑥_𝑖$ 是数据点集合 $S$ 中的第 $i$ 个数据点</p></li></ol><p>$$<br>[ C_j &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} x_i ]<br>$$</p><ol><li>重复迭代：重复执行分配和更新阶段，直至达到停止条件为止。停止条件可以是类中心不再发生变化，即算法收敛；或者是达到最大迭代次数。</li></ol><p>预测新的未知数据点：迭代每类的聚类（簇）中心，计算该样本点距离每个中心的距离，距离最近的点即为该样本的类别</p><h3 id="SVM-支持向量机，Support-Vector-Machine"><a href="#SVM-支持向量机，Support-Vector-Machine" class="headerlink" title="SVM (支持向量机，Support Vector Machine)"></a>SVM (支持向量机，Support Vector Machine)</h3><p><strong>基本想法</strong> 是求解能够正确划分训练数据集并且几何间隔最大的分离超平面<br>最大化类别间隔实现分类</p><p><strong>支持向量</strong> 是指训练样本中，与分类超平面最近的数据点。其是训练数据的子集同时也是最难分类的点</p><p><img src="/../../img/SVM.png"></p><p>SVM 模型将实例表示为空间中的点，将使用一条直线分隔数据点。需要注意的是，支持向量机需要对输入数据进行<strong>完全标记</strong>，仅直接适用于两类任务，如果是多类任务需要减少到几个二元问题 或者 修改损失函数比如使用softmax</p><p><strong>支持向量机包含几种模型</strong></p><p>主要是根据<strong>训练数据集是否线性可分</strong>以及<strong>是否允许出现分类错误</strong>进行划分的。主要包含以下三种模型：</p><p>硬间隔支持向量机：当训练数据线性可分时，硬间隔最大化不允许出现分类错误，此时超平面将所有训练数据集都分类正确，所以叫硬间隔支持向量机</p><p>软间隔支持向量机：当训练数据近似线性可分时，软间隔最大化允许出现分类错误，此时超平面不能将所有训练数据点都分类正确，所以叫软间隔支持向量机</p><p>非线性支持向量机：当训练数据线性不可分时，通过使用核函数和软间隔最大化对数据进行分类</p><p><strong>硬间隔软间隔</strong></p><p>间隔(margin)就是指决策面(y&#x3D;0)与任意训练数据点之间的最小距离。</p><p>硬间隔是指SVM在分类中不允许出现分类错误。通俗点，硬间隔就是训练集中的任何数据点不允许出现在间隔内，即两条蓝线之间，但数据点可以出现在蓝色线上，这些点叫支持向量。</p><p>软间隔是指SVM在分类中允许出现分类错误的点，如下图所示。这些圈出的数据点都是支持向量，但是其中两个点不在蓝线上，一个在间隔内，另一个被分类错误(黑色直线所指的两个点)。软间隔允许这种情况存在，硬间隔则不允许。</p><p><img src="/../../img/svm%E9%97%B4%E9%9A%94.png"></p><p><strong>SVM的优化</strong><br>更好得找出混在正类中的负类 以及 混在负类中的正类 </p><ol><li><p>增加惩罚项</p></li><li><p>使用核函数<br>通俗解释：如果想把混在一起的沙子和黄豆分开，可以用力一拍，用于弹起后的高度不同，因此可以据此将其分开</p></li></ol><h3 id="集成算法"><a href="#集成算法" class="headerlink" title="集成算法"></a>集成算法</h3><p>构建多个学习器，然后通过一定策略结合把它们来完成学习任务的，常常可以获得比单一学习显著优越的学习器。</p><p><img src="/../../img/%E9%9B%86%E6%88%90%E7%AE%97%E6%B3%95.png"></p><p>集成学习通过训练学习出多个估计器<br>预测时通过结合器将多个估计器的结果整合起来当作最后的结果输出。<br>即训练时用多种分类器一起完成同一份任务，测试时对待测试样本分别通过不同的分类器，汇总最后的结果。</p><p><strong>集成学习的优势:</strong> 是提升了单个估计器的通用性与鲁棒性，比单个估计器拥有更好的预测性能并且能更好得防止过拟合。集成学习的另一个特点是能方便的进行并行化操作</p><p>集成算法一般分为三类：Bagging，Boosting，Stacking（我们可以把它简单地看成并行，串行和树型）</p><h4 id="Bagging-并行"><a href="#Bagging-并行" class="headerlink" title="Bagging 并行"></a>Bagging 并行</h4><p>Bagging的全称是bootstrap averaging，它把各个基模型的结果组织起来</p><h5 id="随机森林（Random-Forest）"><a href="#随机森林（Random-Forest）" class="headerlink" title="随机森林（Random Forest）"></a>随机森林（Random Forest）</h5><p>随机：数据采样随机，特征选择随机（每次数据集是随机有放回的选出，同时随机选出部分特征作为输入）</p><p>森林：很多个决策树并行放在一起</p><p><img src="/../../img/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.png"></p><p><strong>随机森林可以看作一个决策树的集合</strong>，随机森林中每棵决策树估计一个分类，这个过程称为 “<strong>投票</strong>（vote）”。理想情况下，我们根据每棵决策树的每个投票，选择最多投票的分类</p><p>投票策略：软投票与硬投票<br><strong>硬投票</strong>：直接用类别值，少数服从多数。<br><strong>软投票</strong>：各自分类器的概率值进行加权平均</p><p>用随机的方式建立一个决策树的森林。当有一个新的输入样本进入的时候，就<strong>让森林中的每一棵决策树分别进行判断</strong>，预测时使用投票结果最多的分类，也是少数服从多数的算法。</p><p>随机森林优势：</p><ol><li>它能够处理很高维度（feature很多）的数据，并且不用做特征选择。</li><li>在训练完后，它能够给出哪些feature比较重要。</li><li>容易做成并行化方法，速度比较快。</li><li>可以进行可视化展示，便于分析。</li></ol><p><strong>和决策树区别</strong></p><h5 id="BaggingClassifier-BaggingRegressor"><a href="#BaggingClassifier-BaggingRegressor" class="headerlink" title="BaggingClassifier&#x2F;BaggingRegressor"></a>BaggingClassifier&#x2F;BaggingRegressor</h5><p>是从原始数据集抽选Ｓ次（抽取实例，抽取属性），得到S个新数据集（有的值可能重复，有的值可能不出现）。使用同一模型，训练得到S个分类器，预测时使用投票结果最多的分类</p><h5 id="VotingClassifier"><a href="#VotingClassifier" class="headerlink" title="VotingClassifier"></a>VotingClassifier</h5><p>可选择多个不同的基模型，分别进行预测，以投票方式决定最终结果。</p><h4 id="Boosting-串行"><a href="#Boosting-串行" class="headerlink" title="Boosting 串行"></a>Boosting 串行</h4><p>从弱学习器开始加强，通过加权来进行训练。新模型是在旧模型的基本上建立的</p><p><img src="/../../img/Boosting.png"></p><p>Boosting相当于串联电路，先需要做好第一个模型，再做第二个，再做第三个，按照顺序一步一步做。</p><h5 id="AdaBoost自适应提升算法"><a href="#AdaBoost自适应提升算法" class="headerlink" title="AdaBoost自适应提升算法"></a>AdaBoost自适应提升算法</h5><p>它对分类错误属性的给予更大权重，再做下次迭代，直到收敛</p><h5 id="Gradient-Boosting-Machine（简称GBM）梯度提升算法"><a href="#Gradient-Boosting-Machine（简称GBM）梯度提升算法" class="headerlink" title="Gradient Boosting Machine（简称GBM）梯度提升算法"></a>Gradient Boosting Machine（简称GBM）梯度提升算法</h5><p>它通过求损失函数在梯度方向下降的方法，层层改进，sklearn中也实现了该算法GradientBoostingClassifier&#x2F;GradientBoostingRegressor。GBM是目前非常流行的一类算法。</p><h3 id="降维算法（Dimensional-Reduction）"><a href="#降维算法（Dimensional-Reduction）" class="headerlink" title="降维算法（Dimensional Reduction）"></a>降维算法（Dimensional Reduction）</h3><p>降维其更深层次的意义在于<strong>有效信息的提取综合及无用信息的摈弃</strong>。</p><p>数据降维算法是机器学习算法中的大家族，与分类、回归、聚类等算法不同，它的<strong>目标</strong>是将向量投影到低维空间，以达到某种目的如可视化，或是做分类。</p><p>数据降维就是寻找一个映射函数f，将高维向量x映射成低维向量y<br>$$<br>f : (x)  -&gt; (y)<br>$$</p><p>如何确定这个映射函数，是各降维算法核心，它们往往根据不同的准则进行构造。</p><p><strong>降维算法分类</strong></p><p>目前已经存在大量的数据降维算法，可以从另个不同的维度对它们进行分类。</p><p>按照是否有使用样本的标签值，可以将降维算法分为有监督降维和无监督降维；</p><p>按照降维算法使用的映射函数，可以将算法分为线性降维与非线性降维；</p><p>无监督降维算法不使用样本标签值，因此是一种无监督学习算法，其典型代表是<strong>PCA</strong>；</p><p>有监督的降维算法则使用了样本标签值，是一种有监督学习算法，其典型代表是<strong>LDA</strong>；</p><p>线性降维算根据样本集构造出线性函数完成向低维空间的映射。一般通过对向量x进行线性变换即左乘一个投影矩阵W而得到结果向量y</p><p>$$<br> y &#x3D; W x<br>$$</p><p>非线性降维算法则构造一个非线性映射完成数据的降维。很多时候数据是非线性的，因此需要使用非线性降维算法以取得更好的效果。</p><h4 id="LAD算法（线性判别分析法）"><a href="#LAD算法（线性判别分析法）" class="headerlink" title="LAD算法（线性判别分析法）"></a>LAD算法（线性判别分析法）</h4><p>Linear Discriminant Analysis<br><strong>线性、有监督降维算法</strong></p><p>LDA降维的<strong>目标</strong>：将带有标签的数据降维，投影到低维空间同时满足三个条件：</p><ul><li>尽可能多地保留数据样本的信息（即选择最大的特征是对应的特征向量所代表的的方向）。</li><li>寻找使样本尽可能好分的最佳投影方向。</li><li>投影后使得同类样本尽可能近，不同类样本尽可能远。</li></ul><p><strong>思想：</strong> 投影之后同类的样本尽量集中，不同类的样本尽量分开</p><p><strong>衡量指标：</strong> 类间散度&#x2F;类内散度最大</p><h4 id="PCA算法（主成分分析法）"><a href="#PCA算法（主成分分析法）" class="headerlink" title="PCA算法（主成分分析法）"></a>PCA算法（主成分分析法）</h4><p><strong>线性、无监督降维算法</strong></p><p>主成分分析（Principal Component Analysis，PCA）是一种常用的降维技术，用于将高维数据转换为低维数据，同时保留数据集中的最大方差。PCA通过找到数据中的<strong>主成分（即数据最大方差方向）</strong> 来实现这一目标</p><p>从而可以减少数据集的特征数量，减少数据的维度，降低计算和存储开销，并帮助提高模型的泛化能力</p><p><strong>PCA算法思想：</strong> 是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征</p><p><strong>实现方法：</strong><br>PCA算法有两种实现方法：</p><ul><li>基于特征值 分解协方差矩阵 实现PCA算法</li><li>基于SVD 分解协方差矩阵 实现PCA算法</li></ul><h2 id="损失函数、代价函数、目标函数"><a href="#损失函数、代价函数、目标函数" class="headerlink" title="损失函数、代价函数、目标函数"></a>损失函数、代价函数、目标函数</h2><ul><li><strong>损失函数</strong> Loss Function 通常是<strong>针对单个训练样本而言</strong>，给定一个模型输出 $\hat{y}$ 和一个真实 $y$ ，损失函数输出一个实值损失 $L&#x3D;f(y_i, \hat{y_i})$</li><li><strong>代价函数</strong> Cost Function 通常是<strong>针对整个训练集</strong>（或者在使用 mini-batch gradient descent 时一个 mini-batch）的总损失 $J&#x3D;\sum_{i&#x3D;1}^{N} f(y_i,\hat{y_i})$</li><li><strong>目标函数</strong> Objective Function 是一个更通用的术语，表示任意<strong>希望被优化的函数</strong>，用于机器学习领域和非机器学习领域（比如运筹优化）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和和差分</title>
    <link href="/2024/04/12/algorithm_know/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2024/04/12/algorithm_know/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h1><p><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">前缀和和差分</a></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>一个数组 a[n] &#x3D; b[1] + b[2] + … + b[n]<br>数组b 即为 a的差分数组 （a为b的前缀和数组）</p><p>当 <code>b[3] += c</code> 时意味着 从a[3] 到 a[n] 都会加上c</p><p>如果想要对原数组 a 中的某段区间[l,r]都加上一个数<br>操作分为两步：</p><ol><li><p>对其差分数组进行 <code>b[l] += c;  b[r+1] -= c;</code></p></li><li><p><strong>再对差分数组求和</strong>即可得到想要的数组</p></li></ol><blockquote><p>给定两个序列，要求将其中一个序列变成另一个序列，我们都可以将其转化到差分数组上，让两个序列的差分数组相同 <code>A ——&gt; B 相当于从 A-B ——&gt; 0</code></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dfs/bfs练习题</title>
    <link href="/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-bfs%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-bfs%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs-bfs练习题"><a href="#dfs-bfs练习题" class="headerlink" title="dfs&#x2F;bfs练习题"></a>dfs&#x2F;bfs练习题</h1><h2 id="母亲的牛奶"><a href="#母亲的牛奶" class="headerlink" title="母亲的牛奶"></a>母亲的牛奶</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/1357/">母亲的牛奶</a></p><p><img src="/../../img/%E6%AF%8D%E4%BA%B2%E7%9A%84%E7%89%9B%E5%A5%B6.png"></p><p><strong>步骤：</strong></p><ol><li>分析题目，找出总共有多少种状态，从而得出队列数组的内存空间</li><li>每种状态相当于一个点，状态与状态之间的转变相当于一条边</li><li>bfs遍历，将每种状态都存在队列中。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//A，B，C最大为20升</span><br><span class="hljs-comment">//状态个数为20^3</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>;<br><span class="hljs-type">int</span> A,B,C;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>&#125;q[N*N*N]; <span class="hljs-comment">//关键点，队列数组q有N^3个状态</span><br> <br><span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br><br><span class="hljs-type">bool</span> st[N][N][N];<br><span class="hljs-type">int</span> s[N]; <span class="hljs-comment">//记录当 A桶是空的时候，C桶中可能包含多少升牛奶</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!st[a][b][c])&#123;<br>        q[++tt] = &#123;a,b,c&#125;;<br>        st[a][b][c] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    q[++tt] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,C&#125;;<br>    st[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][C] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        node t = q[hh];<br>        hh++;<br>        <span class="hljs-type">int</span> a = t.a; <span class="hljs-type">int</span> b = t.b; <span class="hljs-type">int</span> c = t.c;<br>        <span class="hljs-comment">//由当前状态可以得到2*3 = 6 种状态</span><br>        <span class="hljs-comment">//从A开始转移</span><br>        <span class="hljs-built_in">insert</span>(a-<span class="hljs-built_in">min</span>(a,B-b), <span class="hljs-built_in">min</span>(a+b,B), c);<br>        <span class="hljs-built_in">insert</span>(a-<span class="hljs-built_in">min</span>(a,C-c), b, <span class="hljs-built_in">min</span>(a+c,C));<br>        <span class="hljs-comment">//从B开始转移</span><br>        <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">min</span>(a+b,A), b-<span class="hljs-built_in">min</span>(b,A-a), c);<br>        <span class="hljs-built_in">insert</span>(a, b-<span class="hljs-built_in">min</span>(b,C-c), <span class="hljs-built_in">min</span>(b+c,C));<br>        <span class="hljs-comment">//从C开始转移</span><br>        <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">min</span>(a+c,A), b, c-<span class="hljs-built_in">min</span>(c,A-a));<br>        <span class="hljs-built_in">insert</span>(a, <span class="hljs-built_in">min</span>(b+c,B), c-<span class="hljs-built_in">min</span>(c,B-b));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;<br>    <span class="hljs-built_in">bfs</span>();<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;hh;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q[i].a == <span class="hljs-number">0</span>)&#123;<br>            s[cnt] = q[i].c;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(s,s+cnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小红走矩阵-bfs"><a href="#小红走矩阵-bfs" class="headerlink" title="小红走矩阵(bfs)"></a>小红走矩阵(bfs)</h2><p><a href="https://ac.nowcoder.com/acm/problem/269999">小红走矩阵</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> dist[N][N];<br><br><span class="hljs-type">int</span> ax[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> ay[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><br>queue&lt;PII&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>    dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        PII t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//该处永远是循环4次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> x = t.first + ax[i]; <span class="hljs-type">int</span> y = t.second + ay[i];<br>            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;m &amp;&amp; g[x][y] != g[t.first][t.second] &amp;&amp; dist[x][y] == <span class="hljs-number">-1</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>                dist[x][y] = dist[t.first][t.second] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// for(int i=0;i&lt;n;i++)&#123;</span><br>    <span class="hljs-comment">//     for(int j=0;j&lt;m;j++)&#123;</span><br>    <span class="hljs-comment">//         cout &lt;&lt; dist[i][j] &lt;&lt; &quot; &quot;;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> dist[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(dist));<br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a href="https://ac.nowcoder.com/acm/contest/76652/B">老师的签到</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连通图的遍历</title>
    <link href="/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="连通图的遍历"><a href="#连通图的遍历" class="headerlink" title="连通图的遍历"></a>连通图的遍历</h1><blockquote><p>“连通块问题”，是基础搜索。用DFS或BFS都行：遍历一个连通块（找到这个连通块中所有的’#‘，并标记已经搜过，不用再搜）；再遍历下一个连通块…；遍历完所有连通块，统计有多少个连通块。</p></blockquote><h2 id="全球变暖"><a href="#全球变暖" class="headerlink" title="全球变暖"></a>全球变暖</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/1235/">全球变暖</a></p><p><img src="/../../img/%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96.png"></p><p><strong>步骤：</strong></p><ol><li>对图g[N][N]进行循环，每次从是陆地并且没有遍历过的点开始搜索</li><li>进入dfs函数，将当前搜到的点置为true</li><li>然后以此点为中心向四个方向遍历，直到周围没有满足条件（即是陆地又没遍历过的）的点</li><li>便会开始向上回溯直到一步步回溯到退出dfs函数</li><li>如果本次找到的连通块中有一个点其四个方向都是陆地，则这个岛屿不会被完全淹没，否则会被完全淹没。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> st[N][N];<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> d[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">//四个方向</span><br><span class="hljs-type">int</span> flag,ans=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    st[i][j] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;ij:&quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-keyword">if</span>(g[i+<span class="hljs-number">1</span>][j]==<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//继续DFS周围的陆地</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;<span class="hljs-number">4</span>;a++)&#123;<br>        <span class="hljs-type">int</span> x = i+dx[a]; <span class="hljs-type">int</span> y = j+dy[a];<br>        <span class="hljs-comment">//继续DFS未搜过的陆地，目的是标记它们   </span><br>        <span class="hljs-comment">//if(nx&gt;=1 &amp;&amp; nx&lt;=n &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=n &amp;&amp; vis[nx][ny]==0 &amp;&amp; a[nx][ny]==&#x27;#&#x27;) //题目说边上都是水，所以不用这么写了</span><br>        <span class="hljs-keyword">if</span>(!st[x][y] &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(x,y);<br>            <span class="hljs-comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; !st[i][j])&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(i,j);<br>                <span class="hljs-comment">// cout &lt;&lt; &quot;本次连通图查找完毕&quot; &lt;&lt; &quot;\n&quot;;</span><br>                <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//这个岛全部被淹</span><br>                    ans++; <span class="hljs-comment">//统计被淹的岛的数量</span><br>                    <br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈和单调队列</title>
    <link href="/2024/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h1><p><strong>单调栈和优先队列</strong><br>单调栈能保证全部元素的单调性，会直接舍去不合的元素，因此没有额外维护成本<br>小根堆只能保证堆顶是最小值，不会直接舍去元素，但需要O(logn)的decreaseKey成本</p><p>有些题目答案一定是当前最大最小值，直接用单调栈维护即可，不是答案直接舍去，时间复杂度为O(n)<br>当然使用优先队列也正确，因为堆顶一定是极值，但时间复杂度为O(nlogn)</p><p>另外，单调队列是双端版的单调栈，元素可以从两端排除，不等于优先队列</p><ol><li>先想暴力怎么做，再考虑把没有用的元素删掉，再看有没有单调性，有单调性的话再看怎么优化 </li><li>直接看逆序有没有用，若逆序没用，就有单调性！（在一个从小到大排列的数列中，若左边的数比右边的数大，就称作逆序数）</li></ol><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><blockquote><p>一段本不具有单调性的区间，用一个栈去维护使得其具有单调性（将元素入栈，如果其是逆序的，就让它出栈）</p></blockquote><p><img src="/../../img/%E5%8D%95%E8%B0%83%E6%A0%88.png"></p><p><strong>步骤：</strong></p><ol><li><strong>while循环</strong>判断栈顶元素是否大于 a[i]，如果大于则出栈</li><li>如果<strong>此时栈不空</strong>则将新的元素 a[i] 赋给答案数组ans</li><li>如果<strong>此时栈空</strong>则将 -1 赋给答案数组ans</li><li>将当前元素 a[i] 入栈</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,a[N];<br><span class="hljs-type">int</span> stk[N],tt; <span class="hljs-comment">//tt为0代表栈空</span><br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//这个地方是while</span><br>        <span class="hljs-comment">//直到队列为空或者新的元素小于队尾的元素才进行下一步</span><br>        <span class="hljs-keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= a[i]) tt--; <span class="hljs-comment">//出栈</span><br>        <span class="hljs-keyword">if</span>(tt) ans[i] = stk[tt];<br>        <span class="hljs-keyword">else</span> ans[i] = <span class="hljs-number">-1</span>;<br>        stk[++tt] = a[i]; <span class="hljs-comment">//入栈</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/156/">滑动窗口</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,k,a[N];<br><span class="hljs-type">int</span> q[N],hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//判断队头是否已经不在滑动窗口内了</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; i-k+<span class="hljs-number">1</span> &gt; q[hh]) hh++;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; <span class="hljs-comment">//不满足条件出队</span><br>        q[++tt] = i; <span class="hljs-comment">//新元素入队</span><br>        <br>        <span class="hljs-comment">//i指针到达滑动窗口末端,可以开始输出队头值</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出单调地址队列的队头，即最小值</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <br>    <span class="hljs-comment">//队列清空</span><br>    hh = <span class="hljs-number">0</span>; tt=<span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//判断队头是否已经不在滑动窗口内了</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; i-k+<span class="hljs-number">1</span> &gt; q[hh]) hh++;<br>        <span class="hljs-comment">//两个for循环只有 这里从 &gt;= 变成了 &lt;=</span><br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; <span class="hljs-comment">//不满足条件出队</span><br>        q[++tt] = i; <span class="hljs-comment">//新元素入队</span><br>        <br>        <span class="hljs-comment">//i指针到达滑动窗口末端,可以开始输出队头值</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出单调地址队列的队头，即最小值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的直径</title>
    <link href="/2024/04/10/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2024/04/10/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><blockquote><p>定义：树上任意两节点之间最长的简单路径即为树的「直径」<br>显然，一棵树可以有多条直径，他们的长度相等。<br>可以用两次 DFS 或者树形 DP 的方法在 O(n) 时间求出树的直径。</p></blockquote><p><strong>求树的直径的方法：</strong></p><ol><li><p>任取一点作为起始点k，找到距离该点最远的一个点v。</p></li><li><p>从点v开始搜，找到距离点v最远的一点u，则uv间的距离是树的直径。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//1KB=1024B（字节），1MB=1024KB，所以1MB大约等于100w字节（1e6）64MB = 6400w字节 （6*1e7）</span><br><span class="hljs-comment">//int 占四字节</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2</span>*N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx=<span class="hljs-number">1</span>,w[M]; <span class="hljs-comment">//</span><br><span class="hljs-type">bool</span> st[N];<br>LL s[<span class="hljs-number">10100</span>];<br>LL maxu,maxd;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    e[idx] = b; ne[idx] = h[a]; h[a] = idx; w[idx] = d; idx++; <span class="hljs-comment">//idx要最后再++</span><br>&#125;<br><br><span class="hljs-comment">//求距离某个点u最远的点maxu,以及距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])&#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(maxd &lt; d+w[i])&#123;<br>                <span class="hljs-comment">//maxu是距离u最远的点，maxd是 u和maxu 的距离</span><br>                maxd = d+w[i];<br>                maxu = j;<br>            &#125;<br>            <span class="hljs-built_in">dfs</span>(j,d+w[i]);<br>            st[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-comment">//这里是到n-1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,d;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;<br>        <span class="hljs-built_in">add</span>(a,b,d); <span class="hljs-built_in">add</span>(b,a,d);<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; s[4] &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">// int ans,max=0,pos;</span><br>    <span class="hljs-comment">// for(int i=2;i&lt;=n;i++)&#123;</span><br>    <span class="hljs-comment">//     memset(st,0,sizeof(st));</span><br>    <span class="hljs-comment">//     ans = dfs(1,i,0);</span><br>    <span class="hljs-comment">//     if(ans &gt; max)&#123;</span><br>    <span class="hljs-comment">//         max = ans;</span><br>    <span class="hljs-comment">//         pos = i;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <span class="hljs-built_in">dfs</span>(maxu,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; u &lt;&lt; pos;</span><br>    <span class="hljs-comment">// memset(st,0,sizeof(st));</span><br>    <span class="hljs-comment">// cout &lt;&lt; maxd; </span><br>    <span class="hljs-comment">//n(a1+an)/2</span><br>    cout &lt;&lt; ( <span class="hljs-number">11</span> + (<span class="hljs-number">11</span>+maxd<span class="hljs-number">-1</span>) )*maxd/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; s[maxd];</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2024/04/10/algorithm_know/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2024/04/10/algorithm_know/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p>步骤：</p><ol><li>将区间按照左端点进行排序</li><li>循环判断，如果下一个区间的左端点小于（等于）当前区间的右端点时则可以合并，并更新右端点的最大值</li><li>如果下一个区间的左端点大于当前区间的右端点时则不可以合并，则更新右端点的最大值为下一个区间的右端点</li></ol><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//t代表有人挤奶牛的区间的集合，f代表没有挤奶牛的区间的集合</span><br><span class="hljs-comment">//初始化</span><br>    LL maxr = a[<span class="hljs-number">1</span>].r;<br>    t[++<span class="hljs-type">num_t</span>] = a[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//循环遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>].l &lt;= maxr)&#123;<br>            maxr = <span class="hljs-built_in">max</span>(maxr,a[i+<span class="hljs-number">1</span>].r);<br>            t[<span class="hljs-type">num_t</span>].r = maxr;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            f[++num_f] = &#123;t[<span class="hljs-type">num_t</span>].r , a[i+<span class="hljs-number">1</span>].l&#125;; <span class="hljs-comment">//老区间的r和新区间的l</span><br>            t[++<span class="hljs-type">num_t</span>] = a[i+<span class="hljs-number">1</span>];<br>            maxr = a[i+<span class="hljs-number">1</span>].r;<br>            <span class="hljs-comment">// cnt++; 区间个数</span><br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>求区间合并之后区间的总个数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">int</span> n,cnt=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    LL l,r;<br>&#125;a[N],ans[N];<br><span class="hljs-comment">//左端点从小到大排列</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmd</span><span class="hljs-params">(node a, node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.l &lt; b.l;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        a[i] = &#123;l,r&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmd);<br>    <span class="hljs-comment">//从第二个区间开始判断</span><br>    LL maxr = a[<span class="hljs-number">1</span>].r;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>].l &lt;= maxr)&#123;<br>            maxr = <span class="hljs-built_in">max</span>(maxr,a[i+<span class="hljs-number">1</span>].r);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cnt++;<br>            maxr = a[i+<span class="hljs-number">1</span>].r;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="挤奶牛"><a href="#挤奶牛" class="headerlink" title="挤奶牛"></a>挤奶牛</h3><blockquote><p>求区间合并后各个区间的范围</p></blockquote><p><img src="/../../img/%E6%8C%A4%E5%A5%B6%E7%89%9B.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">int</span> n;<br>LL <span class="hljs-type">num_t</span>,num_f,<span class="hljs-type">max_t</span>,max_f;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    LL l,r;<br>&#125;a[N],t[N],f[N]; <span class="hljs-comment">//t代表有人挤奶牛的区间的集合，f代表没有挤奶牛的区间的集合</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmd</span><span class="hljs-params">(node a,node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.l &lt; b.l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmd);<br>    LL maxr = a[<span class="hljs-number">1</span>].r;<br>    t[++<span class="hljs-type">num_t</span>] = a[<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>].l &lt;= maxr)&#123;<br>            maxr = <span class="hljs-built_in">max</span>(maxr,a[i+<span class="hljs-number">1</span>].r);<br>            t[<span class="hljs-type">num_t</span>].r = maxr;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            f[++num_f] = &#123;t[<span class="hljs-type">num_t</span>].r , a[i+<span class="hljs-number">1</span>].l&#125;; <span class="hljs-comment">//老区间的r和新区间的l</span><br>            t[++<span class="hljs-type">num_t</span>] = a[i+<span class="hljs-number">1</span>];<br>            maxr = a[i+<span class="hljs-number">1</span>].r;<br>            <span class="hljs-comment">// cnt++; 区间个数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-type">num_t</span>;i++)&#123;<br>        <span class="hljs-comment">// cout &lt;&lt; t[i].l &lt;&lt; &quot; &quot; &lt;&lt; t[i].r &lt;&lt; &quot;\n&quot;;</span><br>        <span class="hljs-type">max_t</span> = <span class="hljs-built_in">max</span>(<span class="hljs-type">max_t</span>,t[i].r-t[i].l);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num_f;i++)&#123;<br>        <span class="hljs-comment">// cout &lt;&lt; f[i].l &lt;&lt; &quot; &quot; &lt;&lt; f[i].r &lt;&lt; &quot;\n&quot;;</span><br>        max_f = <span class="hljs-built_in">max</span>(max_f,f[i].r-f[i].l);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-type">max_t</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; max_f;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>区间合并</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>区间合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><ol><li>考预测分析法，不考梯度下降法</li></ol>]]></content>
    
    
    <categories>
      
      <category>期末复习</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>期末复习</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日期问题</title>
    <link href="/2024/04/10/algorithm_know/%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/10/algorithm_know/%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h1><h2 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h2><ol><li>是否是闰年来确定二月的天数</li><li>日期是否合理（month在1<del>12 day在1</del>28&#x2F;29&#x2F;30&#x2F;31（根据月份来判断））</li><li>日期的输出顺序是否合理</li><li>日期相同时只需要输出一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string c;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    string yy,mm,dd;<br>&#125;d[<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmd</span><span class="hljs-params">(<span class="hljs-type">const</span> node&amp; a, <span class="hljs-type">const</span> node&amp; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.yy != b.yy) <span class="hljs-keyword">return</span> a.yy &lt; b.yy;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.mm != b.mm) <span class="hljs-keyword">return</span> a.mm &lt; b.mm;<br>    <span class="hljs-keyword">else</span>&#123;<br>        a.dd &lt; b.dd;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; c;<br>    string yy,mm,dd;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> day[<span class="hljs-number">12</span>] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        string str = c;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>            yy = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>); mm = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); dd = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>            yy = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>); mm = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>); dd = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            yy = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>); mm = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); dd = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(yy &lt;= <span class="hljs-string">&quot;59&quot;</span>)&#123;<br>            yy = <span class="hljs-string">&quot;20&quot;</span> + yy;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            yy = <span class="hljs-string">&quot;19&quot;</span> + yy;<br>        &#125;<br>        <br>        string t = yy;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">stoi</span>(t);<br>        <br>        <span class="hljs-keyword">if</span>(mm &lt;= <span class="hljs-string">&quot;00&quot;</span> || mm &gt; <span class="hljs-string">&quot;12&quot;</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mm == <span class="hljs-string">&quot;02&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || (a % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; a % <span class="hljs-number">100</span> !=<span class="hljs-number">0</span> ))&#123;<br>                <span class="hljs-keyword">if</span>(dd &gt; <span class="hljs-string">&quot;29&quot;</span> || dd &lt;= <span class="hljs-string">&quot;00&quot;</span> ) <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(dd &gt; <span class="hljs-string">&quot;28&quot;</span> || dd &lt;= <span class="hljs-string">&quot;00&quot;</span> ) <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mm == <span class="hljs-string">&quot;01&quot;</span> || mm == <span class="hljs-string">&quot;03&quot;</span> || mm == <span class="hljs-string">&quot;05&quot;</span> || mm == <span class="hljs-string">&quot;07&quot;</span> || mm == <span class="hljs-string">&quot;08&quot;</span> || mm == <span class="hljs-string">&quot;10&quot;</span> || mm == <span class="hljs-string">&quot;12&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(dd &lt;= <span class="hljs-string">&quot;00&quot;</span> || dd &gt; <span class="hljs-string">&quot;31&quot;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(dd &lt;= <span class="hljs-string">&quot;00&quot;</span> || dd &gt; <span class="hljs-string">&quot;30&quot;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>            <span class="hljs-keyword">if</span>(yy == d[i].yy &amp;&amp; mm == d[i].mm &amp;&amp; dd == d[i].dd) flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//这个地方要用cnt，不能用i，因为i一直在循环中增加，但放入结构体数组中的数只有满足条件才会放入</span><br>        d[cnt] = &#123;yy,mm,dd&#125;;<br>        cnt ++;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(d,d+cnt,cmd);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        cout &lt;&lt; d[i].yy &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; d[i].mm &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; d[i].dd &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找练习题</title>
    <link href="/2024/04/08/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/08/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找练习题"><a href="#二分查找练习题" class="headerlink" title="二分查找练习题"></a>二分查找练习题</h1><h2 id="卡牌"><a href="#卡牌" class="headerlink" title="卡牌"></a>卡牌</h2><p>题目链接：<a href="https://www.lanqiao.cn/problems/2191/learning/?subject_code=1&group_code=4&match_num=13&match_flow=2&origin=cup">卡牌</a></p><p><img src="/../../img/%E5%8D%A1%E7%89%8C%E4%BA%8C%E5%88%86.png"></p><p><strong>tips:</strong></p><ol><li>记得开long long （最好把<strong>所有的数据都从 int 变成 long long</strong>）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e11</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL n,m,a[N],b[N];<br><br><span class="hljs-comment">//mid为能凑出的牌的套数</span><br><span class="hljs-comment">//m是全局变量，而每次判断 mid 是否满足条件时都要用到总空白牌数m这个值，因此 要用一个变量去代替 m 去操作 </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span>&#123;<br>  LL sum = m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(a[i] &gt;= mid) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(b[i]+a[i] &lt; mid || sum+a[i] &lt; mid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    sum = sum - (mid - a[i]); <br>  &#125;<br>  <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; b[i];<br>  &#125;<br>  LL l = <span class="hljs-number">0</span>, r = INT_MAX; <br>  <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    LL mid = (l+r+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>      l = mid;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      r = mid<span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; l;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp背包问题练习题</title>
    <link href="/2024/04/07/dp/dp%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/07/dp/dp%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="dp背包问题练习题"><a href="#dp背包问题练习题" class="headerlink" title="dp背包问题练习题"></a>dp背包问题练习题</h1><h2 id="货币系统（完全背包）"><a href="#货币系统（完全背包）" class="headerlink" title="货币系统（完全背包）"></a>货币系统（完全背包）</h2><p><strong>tips：</strong></p><ol><li>要将$f[0][0]$ 等特殊的点进行初始化操作</li><li>要将$f[N][N] $设置为 $long long$</li></ol><p><img src="/../../img/1371_%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//从前v种货币中选，凑出N元钱的方案的集合的长度</span><br><span class="hljs-comment">//第v种货币不选或者选一个/两个/...</span><br><span class="hljs-comment">//如果第v种货币选一个的方案数相当于从前v-1种货币中选凑出N-v[i]的方案数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL n,m;<br>LL v[N];<br>LL f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i];<br>    &#125;<br>    <span class="hljs-comment">//注意边界值要记得初始化</span><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-comment">// f[i][j] = f[i-1][j];</span><br>            <span class="hljs-comment">// for(int k=1;k*v[i]&lt;=j;k++)</span><br>            <span class="hljs-comment">//     f[i][j] += f[i-1][j-k*v[i]];</span><br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) f[i][j] += f[i][j - v[i]];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n][m];<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="包子凑数"><a href="#包子凑数" class="headerlink" title="包子凑数"></a>包子凑数</h2><blockquote><p>问题简化为：输入n个数，求整数域内共有多少个数无法被这n个数通过加法来表示；</p></blockquote><p><strong>tips：</strong></p><ol><li>要将$f[0][0]$ 等特殊的点进行初始化操作</li><li>输入n个数，求整数域内共有多少个数无法被这n个数通过加法来表示；</li><li>当这n个数<strong>最大公因数等于 1 的时候，个数有限</strong></li><li><strong>最大公因数大于 1 的时候，个数无限</strong></li><li>最大不能表示出来的数必定有个上界; 当两个数a,b（当gcd&#x3D;1时），最大不能表示的数为(a-1)(b-1)-1 ; 当数字更多的时候，这个上界必然更小（可选的数字变多了）; 而99和98是100内最大的互质的数，所以这个上界选择10000</li></ol><p><img src="/../../img/%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//f[i][j]: 从前 i 种蒸笼种选，使得这若干笼中恰好一共有 j 个包子的方案集合</span><br><span class="hljs-comment">//属性：集合是否非空</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,a[<span class="hljs-number">110</span>],f[N][N];<br><span class="hljs-type">int</span> d; <span class="hljs-comment">//所给的几个数的最大公因数</span><br><span class="hljs-comment">//输入n个数，求整数域内共有多少个数无法被这n个数通过加法来表示；</span><br><span class="hljs-comment">//最大公因数等于 1 的时候，个数有限</span><br><span class="hljs-comment">//最大公因数大于 1 的时候，个数无限</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>        d = <span class="hljs-built_in">gcd</span>(d,a[i]); <span class="hljs-comment">//0和a[i]的最大公因数为 a[i]</span><br>    &#125;<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1e4</span>;j++)&#123;<br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= a[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i][j-a[i]]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//最大不能表示出来的数必定有个上界</span><br>    <span class="hljs-comment">//当两个数a,b（当gcd=1时），最大不能表示的数为(a-1)(b-1)-1</span><br>    <span class="hljs-comment">//当数字更多的时候，这个上界必然更小（可选的数字变多了）</span><br>    <span class="hljs-comment">//而99和98是100内最大的互质的数，所以这个上界选择10000</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">1e4</span>;i++)&#123;<br>        <span class="hljs-comment">//方案数为0 代表其不可表示</span><br>        <span class="hljs-keyword">if</span>(f[n][i] == <span class="hljs-number">0</span>) cnt++;<br>    &#125;<br>    <span class="hljs-comment">//最大公因数大于 1 的时候，个数无限</span><br>    <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;INF&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h2><blockquote><p>从2022个物品中选择10个物品，并且物品总体积为2022的方案数</p></blockquote><p><img src="/../../img/2022.png"></p><p><strong>tips:</strong></p><ol><li>从 0到N 初始化 $f[i][0][0]$<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)&#123;<br>    f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2030</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-comment">//从2022个物品中选择10个物品，并且物品总体积为2022</span><br>LL f[N][<span class="hljs-number">15</span>][N]; <span class="hljs-comment">//f[i][j][k]表示从前i个物品中选择j个物品，物体的总体积为k </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a[N];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)&#123;<br>    a[i] = i;<br>    f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2022</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;j++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2022</span>;k++)&#123;<br>        <span class="hljs-comment">//如果没有选择第i个物品，那么当前的方案数就是前i-1个物品中选j </span><br>        f[i][j][k] =  f[i<span class="hljs-number">-1</span>][j][k];<br>        <span class="hljs-keyword">if</span>(k &gt;= a[i]) f[i][j][k] += f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>][k-a[i]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; f[<span class="hljs-number">2022</span>][<span class="hljs-number">10</span>][<span class="hljs-number">2022</span>];<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="砝码称重（0-1背包）"><a href="#砝码称重（0-1背包）" class="headerlink" title="砝码称重（0-1背包）"></a>砝码称重（0-1背包）</h2><blockquote><p>从前i个砝码中选，重量为 j 的方案数</p></blockquote><p><img src="/../../img/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//0-1背包</span><br><span class="hljs-comment">//从前i个砝码中选，重量为 j 的方案数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> w[N];<br><span class="hljs-type">int</span> n,sum;<br><span class="hljs-comment">//如果数据只有一个砝码，重量是1e5，那么当j=1e5，转移时的f[i][j+w[i]]就越界了，所以开了两倍</span><br><span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>*M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; w[i];<br>        sum+=w[i];<br>    &#125;<br>    <span class="hljs-comment">//初始化</span><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sum;j++)&#123;<br>            <span class="hljs-comment">// bool f[N][2*M]</span><br>            <span class="hljs-comment">// f[i][j]=f[i-1][j]||f[i-1][j+w[i]]||f[i-1][abs(j-w[i])];</span><br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            f[i][j] += f[i<span class="hljs-number">-1</span>][<span class="hljs-built_in">abs</span>(j-w[i])]; <span class="hljs-comment">//由于这里加了abs，所以不需要再判断j&gt;=w[i]了</span><br>            f[i][j] += f[i<span class="hljs-number">-1</span>][j+w[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sum;i++)&#123;<br>        <span class="hljs-keyword">if</span>(f[n][i]) cnt++;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/description/?envType=problem-list-v2&envId=2cktkvj">279. 完全平方数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> f[<span class="hljs-number">110</span>][<span class="hljs-number">10010</span>]; <span class="hljs-comment">//d[i][j] 从前i个中选，数量不限制，背包容量等于j的情况下，选择的数量的最小值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f)); <span class="hljs-comment">//由于求最小值min，因此要将所有值初始化为最大值</span><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 由于循环里有f[i-1]，因此i要从1开始循环，所以f[0][0]单独放到循环外面初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=n;i++)&#123;<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)&#123;<br>                f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>                <span class="hljs-keyword">if</span>(j &gt;= i*i) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j],f[i][j-i*i]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> m = <span class="hljs-built_in">pow</span>(n,<span class="hljs-number">1.0</span>/<span class="hljs-number">2</span>);  <span class="hljs-comment">//m为背包数量</span><br>        <span class="hljs-keyword">return</span> f[m][n]; <br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>背包问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性dp练习题</title>
    <link href="/2024/04/07/dp/%E7%BA%BF%E6%80%A7dp%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/07/dp/%E7%BA%BF%E6%80%A7dp%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="线性dp练习题"><a href="#线性dp练习题" class="headerlink" title="线性dp练习题"></a>线性dp练习题</h1><h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/900/">数字三角形</a></p><p><img src="/../../img/900_%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2.png"></p><p><strong>tips</strong></p><ol><li>因为有些值为负数，因此要将所有$f[i][j]$初始为负无穷<br>如果初始化为0会导致部分$f[i][j]$的值大于 本不应该大于 的f$f[i-1][j-1]$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N][N],f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin &gt;&gt; a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 因为有些值为负数，因此要将所有f[i][j]初始为负无穷</span><br>    <span class="hljs-comment">//如果初始化为0会导致部分f[i][j]的值大于 本不应该大于 的f[i-1][j-1]</span><br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));<br>    <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j] + a[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> max_v = INT_MIN;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        max_v = <span class="hljs-built_in">max</span>(max_v,f[n][j]);<br>    &#125;<br>    cout &lt;&lt; max_v;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="松散子序列"><a href="#松散子序列" class="headerlink" title="松散子序列"></a>松散子序列</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/5409/">松散子序列</a></p><p><img src="/../../img/%E6%9D%BE%E6%95%A3%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><p><strong>dp 思路：</strong><br>以下标 $i$ (从1开始)结尾的松散子序列长度的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">char</span> s[N];<br>string str;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; str;<br>    <span class="hljs-type">int</span> n = str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        s[i] = str[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    f[<span class="hljs-number">1</span>] = s[<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) f[i] = <span class="hljs-built_in">max</span>(f[i],f[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">if</span>(i<span class="hljs-number">-2</span>&gt;=<span class="hljs-number">0</span>) f[i] = <span class="hljs-built_in">max</span>(f[i],f[i<span class="hljs-number">-2</span>] + s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;i++)&#123;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; f[i] &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    cout &lt;&lt; f[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>线性dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的最短路问题</title>
    <link href="/2024/04/07/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/07/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="图的最短路问题"><a href="#图的最短路问题" class="headerlink" title="图的最短路问题"></a>图的最短路问题</h1><p><img src="/../../img/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF.png"></p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><h3 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h3><p><strong>核心思想：</strong></p><ol><li><strong>先确定最短距离点</strong></li><li><strong>然后用该点去更新其他点的最短距离</strong></li></ol><blockquote><p>适合稠密图<br>变量：dist[N] （距离源点的距离数组） , st[N]（某个点是否已经被更新为距离最短的点的集合中的状态数组）<br>重边与自环：在min中会循环找出最短距离的边<br>算法步骤：</p></blockquote><ol><li>初始化：dist 初始化为正无穷（0x3f）<code>memset(dist,0x3f,sizeof(dist));</code> st 初始化为0</li><li>更新已经得到最短距离的所有点所在集合；更新方法：遍历距离数组的所有点，将其中最小距离的点放入集合。</li><li>根据第二步最新得到那个点 t ，去更新其他点的最短距离<br><code>d[j] = min(d[j],d[t] + t-&gt;j的距离)</code></li></ol><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/1906644/">Dijkstra求最短路图解 </a></p><p><strong>邻接矩阵版</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>; <span class="hljs-comment">//数据范围（最大输入节点数）</span><br><br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// 节点/边数</span><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 图的邻接矩阵（稠密图用这个） ，算法复杂度为n^2</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">//用于记录每一个点距离第一个点的距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">//已经确定了最短路径的点为true</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist)); <span class="hljs-comment">//将距离矩阵初始化为正无穷</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 题目要求 求出 1号点到 n号点的最短距离，第一个点到自身的距离为0</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;   <span class="hljs-comment">//有n个点所以要进行n次 迭代</span><br>    <br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;         <span class="hljs-comment">//t存储着下方某轮次循环中找出的距离源点距离最近的点</span><br>        <br>        <span class="hljs-comment">//找到路径最短的点：</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;  <span class="hljs-comment">//此时的j代表从1号点开始,该处循环是找出此时距离源点距离最近的点</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t==<span class="hljs-number">-1</span> || dist[t]&gt;dist[j]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//t的最短路径确定好了</span><br>        <br>        <span class="hljs-comment">//对每个点的最短路径更新：</span><br>        <span class="hljs-comment">//当有新的被确定最短路径的点加入到集合中时，</span><br>        <span class="hljs-comment">//要对所有点（但实际只有剩余未被确定最短路径的点会被更新，因为最短路径的确定是由短到长的）距离源点的最短距离进行更新。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;    <span class="hljs-comment">//此处j&lt;=n 必须要有等于号 //依次更新每个点所到相邻的点路径值</span><br>            <span class="hljs-keyword">if</span>(!st[j])&#123;     <span class="hljs-comment">//跳过已经确定为最短路径的点</span><br>                dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<span class="hljs-comment">//初始化图（邻接矩阵）</span><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c); <span class="hljs-comment">//建图（邻接矩阵） ；当有重边时更新邻接矩阵中的权重为较小的那个权重。</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">dijkstra</span>();<br>    <br>    cout &lt;&lt; t &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],w[M],idx;<br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//堆里存储距离和节点编号</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    e[idx] = b;<br>    w[idx] = v;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="hljs-comment">//小根堆</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//插入距离和节点编号</span><br>    <span class="hljs-comment">//遍历n次，每次找出一个点的最短距离</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>; <span class="hljs-comment">//需要被放入集合的点t</span><br><br>        <span class="hljs-comment">//此时的j代表从1号点开始,该处循环是找出此时距离源点距离最近的点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[j] &lt; d[t]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        st[t] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//更新未确定点的最短距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=h[t];k!=<span class="hljs-number">-1</span>;k=ne[k])&#123;<br>            <span class="hljs-type">int</span> j = e[k];<br>            <span class="hljs-keyword">if</span>(st[j]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//如果该点已经被确定为了最短点集合中了就没必要再去更新它了</span><br>            d[j] = <span class="hljs-built_in">min</span>(d[j],d[t] + w[k]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(a,b,v);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(); <span class="hljs-comment">//找出所有点到源点的距离</span><br>    <span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; d[n];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化Dijkstra算法"><a href="#堆优化Dijkstra算法" class="headerlink" title="堆优化Dijkstra算法"></a>堆优化Dijkstra算法</h3><blockquote><p>适合稀疏图<br>使用小根堆：<code>priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2</span>*<span class="hljs-number">1e5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">3</span>*<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],w[M],idx;<br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//堆里存储距离和节点编号</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    e[idx] = b;<br>    w[idx] = v;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="hljs-comment">//小根堆</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//插入距离和节点编号</span><br>    <span class="hljs-comment">//此处有while循环</span><br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br>        PII t = heap.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-comment">//距离源点的距离dist，其节点编号为index</span><br>        <span class="hljs-type">int</span> dist = t.first; <span class="hljs-type">int</span> index = t.second;<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//如果该点已经被放入到最短路径集合中了的话就可以continue</span><br>        <span class="hljs-keyword">if</span>(st[index]) <span class="hljs-keyword">continue</span>;<br>        st[index] = <span class="hljs-literal">true</span>;<br>            <br>        <span class="hljs-comment">//更新index所指向的节点距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=h[index];k!=<span class="hljs-number">-1</span>;k=ne[k])&#123;<br>            <span class="hljs-type">int</span> j = e[k];<br>            d[j] = <span class="hljs-built_in">min</span>(d[j],dist + w[k]);<br>            heap.<span class="hljs-built_in">push</span>(&#123;d[j],j&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(a,b,v);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(); <span class="hljs-comment">//找出所有点到源点的距离</span><br>    <span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; d[n];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h2><ol><li>初始化（结构体数组，d数组设置为无穷大）</li><li>循环k次（边数限制为k）</li><li>每次循环时，对所有的边进行更新操作（要先进行<strong>数组备份</strong>，使用备份的数组进行更新，防止出现串联操作从而<strong>导致实际最短路走过的长度大于k</strong>）</li><li>判断是否有路径（大于 0x3f3f3f3f &#x2F; 2）即为无路径（起点和终点不连通，但终点和别的点连通）</li></ol><p><a href="https://www.acwing.com/solution/content/17551/">有边数限制的最短路</a></p><blockquote><p>适用于有负权边的最短路（有边数限制的最短路）</p></blockquote><p><strong>注意事项</strong><br>由于存在负权边，返回值长度可能恰好是 -1 的情况下会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span>(d[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//不能这么写，因为有可能路径长度恰好是 -1</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> d[n];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ...<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>&#125;u[M];<br><br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> d[N],backup[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//边数限制为k</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>        <span class="hljs-built_in">memcpy</span>(backup,d,<span class="hljs-built_in">sizeof</span>(d));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-type">int</span> a = u[i].a, b = u[i].b, w = u[i].w;<br>            d[b] = <span class="hljs-built_in">min</span>(d[b] , backup[a] + w); <span class="hljs-comment">//防止形成的最短路长度超过k</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(d[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>; <span class="hljs-comment">//注意有可能路径长度恰好是 -1</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; d[n];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,w;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        u[i] = &#123;a,b,w&#125;;<br>    &#125;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h2><p><strong>dijkstra 和 spfa算法的区别</strong><br>dijkstra是基于贪心的思想，每次选择最近的点去更新其它点，过后就不再访问。<br>而在spfa算法中，只要有某个点的距离被更新了，就把它加到队列中，去更新其它点，所有每个点有被重复加入队列的可能。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map</title>
    <link href="/2024/04/06/stl/map/"/>
    <url>/2024/04/06/stl/map/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>拓扑序列</title>
    <link href="/2024/04/05/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
    <url>/2024/04/05/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><blockquote><p>定义：拓扑序列是图中的顶点的线性排序，使得从顶点u到顶点v的每个有向边u-&gt;v ,在拓扑序列中u都在v前面</p></blockquote><ol><li><p>不是所有的有向图都是有拓扑序的，只有<strong>有向无环图才有拓扑序</strong>，所以有向无环图又被称为拓扑图</p></li><li><p>有向无环图的<strong>拓扑序不是唯一的</strong></p></li></ol><h2 id="拓扑序列的求法"><a href="#拓扑序列的求法" class="headerlink" title="拓扑序列的求法"></a>拓扑序列的求法</h2><blockquote><p>对于拓扑序列而言，入度为0的点一定是排在前面的<br>对一个图BFS一遍，BFS过程中更新每个点的入度，如果一个点的入度为0，那么就将其加入拓扑序，并且删除其与后继结点的所有边。</p></blockquote><p>1.入度的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">在建立邻接表时计算每个节点的入度<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    d[b] ++; <span class="hljs-comment">//节点b的入度加1</span><br>    <br>    ne[idx] = h[a];<br>    h[a] = idx;<br>    idx ++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>得到拓扑序列<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//先将目前入度为0的节点入队</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)&#123;<br>            q[++tt] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh];<br>        hh++;<br>        <span class="hljs-comment">//删除由节点t所指出的边（并不是真的删除，而是将节点入度减1）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            d[j] --; <span class="hljs-comment">//该边的终点入度减1</span><br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">0</span>)&#123;<br>                q[++tt] = j; <span class="hljs-comment">//让入度为0的节点入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是不是拓扑序列</span><br>    <span class="hljs-comment">//如果所有点都入队了（所有点的入度都为0）就是拓扑序列，反之就不是</span><br>    <span class="hljs-keyword">return</span> tt == n<span class="hljs-number">-1</span>; <span class="hljs-comment">//tt初始化时为-1，tt代表节点下标从0开始，因此是与n-1对比</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>判断是不是拓扑序列</strong><br>看队尾指针tt的值 加1 （下标从0开始）是不是等于节点个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//判断是不是拓扑序列</span><br><span class="hljs-comment">//如果所有点都入队了（所有点的入度都为0）就是拓扑序列，反之就不是</span><br><span class="hljs-keyword">return</span> tt == n<span class="hljs-number">-1</span>; <span class="hljs-comment">//tt初始化时为-1，tt代表节点下标从0开始，因此是与n-1对比</span><br><br></code></pre></td></tr></table></figure></li><li><strong>输出拓扑序列</strong><br>由于出队只是将指针向后移动，但前面入队的元素还在队列数组中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h2><ol><li>所需变量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> e[N],ne[N],idx<br><span class="hljs-comment">// head 代表头指针</span><br><span class="hljs-comment">// e[N] 代表节点元素的值</span><br><span class="hljs-comment">// ne[N] 代表节点元素的next指针，即其所指向的下一个节点的下标</span><br><span class="hljs-comment">// idx 代表目前已经已经用到哪个节点了</span><br><br></code></pre></td></tr></table></figure></li><li>初始化操作</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">head = <span class="hljs-number">-1</span>; <span class="hljs-comment">//初始时头指针指向NULL</span><br>idx = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>将x插到头节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">e[idx] = x;<br>ne[idx] = head;<br>head = idx;<br>idx++;<br></code></pre></td></tr></table></figure><ol start="4"><li>将x插到下标是k的点后面</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">e[idx] = x;<br>ne[idx] = ne[k];<br>ne[k] = idx;<br>idx++;<br></code></pre></td></tr></table></figure><ol start="5"><li>删除<strong>下标为k</strong>的数（即为第k-1个插入的数）后面的那一个节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">ne[k] = ne[ne[k]];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树和图的存储和遍历</title>
    <link href="/2024/04/04/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"/>
    <url>/2024/04/04/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="树和图的存储和遍历"><a href="#树和图的存储和遍历" class="headerlink" title="树和图的存储和遍历"></a>树和图的存储和遍历</h1><h2 id="树和图的存储"><a href="#树和图的存储" class="headerlink" title="树和图的存储"></a>树和图的存储</h2><ol><li>树是一种特殊的图（无环连通图），因此可以把树当作图来处理</li><li>图分为有向图(a-&gt;b)和无向图(a-b),但我们在算法题中如果<strong>遇到无向图，就直接（a-&gt;b）和（b-&gt;a）都建立</strong>，因此无向图就是特殊的有向图。</li><li>存储方式</li></ol><p>（1）邻接矩阵 g[N][N]</p><ul><li>g[a][b] &#x3D; 0 代表 节点a-&gt;b没有边 </li><li>g[a][b] &#x3D; 1 代表 a-&gt;b有边 </li><li>g[b][a] &#x3D; 1 代表 b-&gt;a有边</li><li>g[a][b] &#x3D; w 代表 a-&gt;b 该边的权重或者长度为w</li><li>空间复杂度为O(n²)，适合存储稠密图</li></ul><p>（2）邻接表 </p><blockquote><p>我们可以想一下对于任意一个结点u, 需要记录邻边的哪些信息。</p><p>这些信息应该包括这条邻边的终点，权重，以及下一条邻边的编号。</p></blockquote><ul><li>每个点上都有一个单链表，存的是这个点可以走到哪些点</li><li><strong>h数组的下标为结点的编号，e,ne数组的下标为边的编号，e数组的值为该边的终点，idx为边的编号</strong></li><li>邻接表初始化(<strong>先将h数组都置为-1再插入节点</strong>)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// N代表点的个数，M代表边的条数</span><br>  <span class="hljs-comment">// n个结点的树最多有n - 1条边，如果考虑无向边需要开两倍的n - 1来存储</span><br><span class="hljs-type">int</span> h[N],e[<span class="hljs-number">2</span>*N],ne[<span class="hljs-number">2</span>*N],idx; <span class="hljs-comment">//有n个单链表就有n个头节点</span><br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h)); <span class="hljs-comment">//所有头节点都指向-1</span><br>  <span class="hljs-comment">// h[i]：第 i 个节点的第一条邻边的 idx</span><br>  <span class="hljs-comment">// e[idx]：存储 idx 这条边的终点，也就是与第 i 个节点相连的某一个点</span><br>  <span class="hljs-comment">// ne[idx]：存储 与第 idx 条边 同起点的 下一条边的 idx，也就是邻接表中的下一个节点</span><br>  <span class="hljs-comment">// idx：用于标识每条边的下标，存的是边的编号</span><br></code></pre></td></tr></table></figure></li><li>邻接表插入元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//有一条a-&gt;b的边 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a]; <span class="hljs-comment">// 新插入的边是插到链表头（头插法）</span><br>    h[a] = idx; <span class="hljs-comment">//更新链表头</span><br>    idx++;<br>&#125;<br><span class="hljs-comment">//树的边数等于节点数减1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-built_in">add</span>(a,b); <span class="hljs-built_in">add</span>(b,a); <span class="hljs-comment">//无向图</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="树和图的遍历"><a href="#树和图的遍历" class="headerlink" title="树和图的遍历"></a>树和图的遍历</h2><blockquote><p>对于树和图的遍历，不管是DFS还是BFS，因为每个点只会被遍历一次，所以时间复杂度与点和边的数量成线性关系，为<strong>O(n + m)</strong></p></blockquote><p><strong>dfs 和 bfs 的不同</strong><br><strong>不同：</strong></p><ol><li><p>参数上：</p><ul><li>void dfs(int u) &#x2F;&#x2F;u代表层数  调用: dfs(1);</li><li>int bfs() &#x2F;&#x2F;没有参数  调用：cout &lt;&lt; bfs(); &#x2F;&#x2F;在函数里面会返回需要的答案</li></ul></li><li><p>变量上<br>bfs 多了一个距离数组，初始时要将其置为-1 <code>memset(d,-1,sizeof(d))</code><br>dfs 用st[N] 当作状态数组 ，bfs可以使用距离数组 d 来充当状态数组 ; </p></li><li><p>代码结构<br>dfs: 递归结构<br>bfs: <strong>初始化 + while(队列非空)的循环</strong></p></li></ol><p><strong>相同：</strong></p><ol><li>初始化上<br>要在开始时将当前正在访问的点设置为true</li></ol><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><p>从节点编号1开始遍历，沿着节点的邻接表一路深搜</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> st[N]; <span class="hljs-comment">//状态数组,标记某个点是否被遍历到</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//遍历点u的所有出边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> b = e[i]; <span class="hljs-comment">//b是该边终点</span><br>        <span class="hljs-keyword">if</span>(!st[b])&#123;<br>            <span class="hljs-built_in">dfs</span>(b);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.acwing.com/problem/content/description/4965/">景区导游</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//https://www.acwing.com/file_system/file/content/whole/index/content/11514015/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,k,a[N];<br><span class="hljs-type">int</span> h[N],e[<span class="hljs-number">2</span>*N],ne[<span class="hljs-number">2</span>*N],idx;<br><span class="hljs-type">int</span> w[<span class="hljs-number">2</span>*N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> s[N]; <span class="hljs-comment">//前缀和数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> t)</span><span class="hljs-comment">//表示u-&gt;v 距离是t 把v添加到u里去</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u]; i!=<span class="hljs-number">-1</span>; i=ne[i]) &#123;<span class="hljs-comment">//这里要判断一下有没有边重复加</span><br>        <span class="hljs-keyword">if</span>(e[i]==v) <span class="hljs-keyword">return</span>; <br>    &#125;<br>    e[idx]=v;ne[idx]=h[u];h[u]=idx;w[idx]=t;idx++;<span class="hljs-comment">//idx是v的下标 w[idx]表示u-&gt;v的距离</span><br>&#125;<br><span class="hljs-comment">//求u-&gt;v的距离 u起点 v终点 d是起点到当前点的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> d)</span></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//先将起点设置为访问过了</span><br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span> d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])&#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//不能d += w[i] 再dfs(j,v,j,d)</span><br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">dfs</span>(j,v,d+w[i]); <span class="hljs-comment">//更新起点</span><br>            <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ret;<br>            st[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(a,b,v); <span class="hljs-built_in">add</span>(b,a,v);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> st);<span class="hljs-comment">//每次dfs前都要清空一下st数组</span><br>        s[i] = s[i<span class="hljs-number">-1</span>] + <span class="hljs-built_in">dfs</span>(a[i],a[i+<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>        cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><p>距离从小到大来遍历，取第一次遍历到的结果（每个点只遍历一次）。<br>遍历框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">队列初始化<br><span class="hljs-keyword">while</span>(queue 不空)<br>&#123;<br>    取出队头<br>    拓展队头所有邻点<span class="hljs-function">x</span><br><span class="hljs-function">    <span class="hljs-title">if</span><span class="hljs-params">(x未遍历)</span></span><br><span class="hljs-function">    </span>&#123;<br>        x入队<br>        d[x]=d[队头]+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[n];<br></code></pre></td></tr></table></figure><p>数组模拟队列常见操作 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//入队</span><br>q[++tt] = &#123;&#125; ; q.<span class="hljs-built_in">push</span>()<br><span class="hljs-comment">//取队头</span><br>t = q[hh] ; q.<span class="hljs-built_in">top</span>()<br><span class="hljs-comment">//出队</span><br>hh++ ; q.<span class="hljs-built_in">pop</span>()<br><span class="hljs-comment">//判断是否非空</span><br><span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;&#125; ; q.<span class="hljs-built_in">empty</span>()<br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.acwing.com/problem/content/description/849/">图中点的层次</a><br>每条边长度都为1的最短路问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//要把距离 数组初始为-1</span><br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    <span class="hljs-comment">//队列初始化</span><br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    q[++tt] = <span class="hljs-number">1</span>;<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh];<br>        hh++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">//编号为i的边 的终点</span><br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">-1</span>)&#123;<br>                q[++tt] = j;<br>                <span class="hljs-comment">// pre[j] = t;</span><br>                d[j] = d[t] + <span class="hljs-number">1</span>; <span class="hljs-comment">//此处是d[t] + 1 ,不是d[i] + 1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// int x = n;</span><br>    <span class="hljs-comment">// while(x!=1)&#123;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; x &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">//     x = pre[x];</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><blockquote><p>定义：在有根树上，两点的祖先有公共部分，这些点叫做他们的公共祖先，而其中深度最深的点，叫作它们的最近公共祖先（LCA ，Lowest Common Ancestors）</p></blockquote><p>求树上两个点距离的时候，可以预处理出每个点到根节点的距离，然后两点间最短距离公式为：dist[a-&gt;b] &#x3D; dist[a]+dist[b]-2*dist[p]</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote><p>元素先进先出，<strong>从队尾入队，从队首出队</strong>。只允许在最后面添加元素，只允许在最前面删除元素。</p></blockquote><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><ol><li>初始化队列<br><code>queue&lt;int&gt; q</code></li><li>返回队首和队尾元素<br><code>q.front()</code> <code>q.back()</code></li><li>尾部增加和删除一个元素<br> <code>q.push()</code> <code>q.pop()</code></li><li>队列长度和是否为空<br><code>q.size()</code> <code>q.empty</code></li></ol><h2 id="队列模拟"><a href="#队列模拟" class="headerlink" title="队列模拟"></a>队列模拟</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> q[N]; <span class="hljs-comment">//队列数组</span><br><span class="hljs-comment">//队列区间为[hh,tt]</span><br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>; tt = <span class="hljs-number">-1</span>; <span class="hljs-comment">//队头和队尾指针</span><br><br>初始时tt = <span class="hljs-number">-1</span>,队列为空，当 ++tt 之后 tt = hh = <span class="hljs-number">0</span>,给q[<span class="hljs-number">0</span>]赋值，hh指向该队头元素<br><br>之后新元素入队，++tt往后移，元素出队，hh++,队头指针往后移。队列区间为[hh,tt]<br><br>q[++tt] = &#123;&#125; <span class="hljs-comment">//入队 </span><br><br>hh ++ <span class="hljs-comment">//出队，队首向后移动一格（本来指向队头元素，）</span><br><br>q[hh] <span class="hljs-comment">//取队头元素</span><br><br><span class="hljs-comment">//是否为空的判断，因为队列区间为[hh,tt],当hh &lt;= tt 时代表队列中有元素为非空</span><br><span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="priority-queue（优先队列）"><a href="#priority-queue（优先队列）" class="headerlink" title="priority_queue（优先队列）"></a>priority_queue（优先队列）</h2><blockquote><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。底层是通过堆（小根堆、大根堆）来实现的。</p></blockquote><ol><li>初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//默认是大根堆，每次取出的元素是队列中的最大值</span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,great&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><br>第一个参数：就是优先队列中存储的数据类型<br>第二个参数：vector&lt;<span class="hljs-type">int</span>&gt; 是用来承载底层数据结构堆的容器，若优先队列中存放的是<span class="hljs-type">double</span>型数据，就要填vector&lt; <span class="hljs-type">double</span> &gt;，总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。<br><br>less&lt;<span class="hljs-type">int</span>&gt; 表示数字大的优先级大，堆顶为最大的数字<br>greater&lt;<span class="hljs-type">int</span>&gt;表示数字小的优先级大，堆顶为最小的数字<br><br>如果存储pair<br>默认先对pair的first进行降序排序，然后再对second降序排序<br></code></pre></td></tr></table></figure><ol start="2"><li>访问队头元素 ： <code>q.top()</code><br>优先队列只能通过top()访问队首元素（优先级最高的元素）</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
      <category>队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dfs(爆搜)</title>
    <link href="/2024/04/03/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-%E7%88%86%E6%90%9C/"/>
    <url>/2024/04/03/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-%E7%88%86%E6%90%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs-爆搜-和-全排列"><a href="#dfs-爆搜-和-全排列" class="headerlink" title="dfs(爆搜) 和 全排列"></a>dfs(爆搜) 和 全排列</h1><h2 id="dfs递归"><a href="#dfs递归" class="headerlink" title="dfs递归"></a>dfs递归</h2><p><a href="https://www.acwing.com/solution/content/87387/" title="图解">图解</a></p><ol><li>递归就是把一个大问题变成中问题再变成一个很小的问题进行解决</li><li>如果在分解问题时，可能出现一个大问题包括很多个中问题的情况，此时就要在递归外面加上for循环</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> path[N];<br><span class="hljs-type">int</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(u&gt;n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//空位上可以选择的数字为:1 ~ n</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            path[u] = i; <span class="hljs-comment">//此处为u，代表第u个位置需要填</span><br>            st[i] = <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">/*dfs(u+1)展开： </span><br><span class="hljs-comment">            if(u==n)&#123;&#125; </span><br><span class="hljs-comment">            for(int i=1;i&lt;=n;++)&#123;</span><br><span class="hljs-comment">            //由于这里有个状态数组，i=1已经被访问过了，所以会把没访问过的 i=2 填入path数组中（真妙！） </span><br><span class="hljs-comment">        if(!state[i])&#123;</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">dfs(u+1)</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">            */</span><br>            st[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="next-permutation-函数"><a href="#next-permutation-函数" class="headerlink" title="next_permutation() 函数"></a>next_permutation() 函数</h2><blockquote><p>全排列函数 next_permutation(num,num+n) 是对数组num中的前n个元素进行全排列，同时并改变num数组的值。</p></blockquote><ol><li><p>另外，需要强调的是，next_permutation（）在<strong>使用前需要对欲排列数组按升序排序</strong>(此时才能找全)，否则只能找出该序列之后的全排列数</p></li><li><p>next_permutation（node,node+n,cmp）可以对结构体num按照自定义的排序方式cmp进行排序</p></li><li><p>常用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span>&#123;<br><br>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a,a+n));<br><br></code></pre></td></tr></table></figure></li></ol><p><strong>dfs例题：</strong><br><a href="https://www.acwing.com/problem/content/description/4960/" title="飞机降落问题">飞机降落问题</a></p><p>使用全排列函数对所有情况进行枚举，判断在所有的情况下是否能够满足条件。<br>使用方式：</p><ol><li>初始化一个全排列数组 a[n] ，通过a[i] &#x3D; i对其赋值（初始时其为1，2，…,n）</li><li>下面每种情况其循环时的下标应当为 a[i]</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> flag;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> t,d,l;<br>&#125;p[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin &gt;&gt; m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> a[n]; <span class="hljs-comment">//全排列数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i] = i; <span class="hljs-comment">//初始排列数组为 1,2,3</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; p[i].t &gt;&gt; p[i].d &gt;&gt; p[i].l;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-comment">//初始化操作</span><br>          flag = <span class="hljs-literal">true</span>;<br>          <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上一架飞机的降落时间，在此事件后开始降落的飞机都是合法的</span><br>          <br>          <span class="hljs-comment">//循环某个排序</span><br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> j = a[i]; <span class="hljs-comment">//代表此次排列顺序的下标</span><br><br>            start = <span class="hljs-built_in">max</span>(start , p[j].t) ; <span class="hljs-comment">// 和飞机到达时间取max,因为有可能上个飞机已经降落完成但下个飞机还没到</span><br>            <span class="hljs-keyword">if</span>(p[j].t + p[j].d &gt;= start)&#123;<br>              start += p[j].l;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>              flag = <span class="hljs-literal">false</span>;<br>              <span class="hljs-keyword">break</span>;<br>            &#125;<br>          &#125;<br>          <br>          <span class="hljs-keyword">if</span>(flag)&#123;<br>              <span class="hljs-comment">//只要有一组排列满足条件即可判定为yes</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>));<br>             <br>        <span class="hljs-comment">//只有所有排列都不满足条件才判定为no</span><br>        <span class="hljs-keyword">if</span>(!flag) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2024/04/02/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/04/02/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="二分算法解析"><a href="#二分算法解析" class="headerlink" title="二分算法解析"></a>二分算法解析</h2><p>二分的判断条件通常是通过列出有关要二分的量和其他变量之间的关系方程：</p><ol><li>暴力解放要循环所有可能的边长值</li><li>通过二分来一步步得缩小查找的区间</li><li>二分的核心就是通过某些性质使得可以缩小查找区间来减少时间复杂度</li></ol><p><strong>二分步骤：</strong></p><ol><li>先写一个check函数(判断条件要具有二段性，并且答案一定是二段性的分界点)</li><li>判定在check的情况下（true和false的情况下），如何更新区间。</li><li>在check(m) &#x3D;&#x3D; true的分支下是:<ul><li>l &#x3D; mid的情况，中间点的更新方式是m &#x3D; (l+r+1)&#x2F;2</li><li>r &#x3D; mid的情况，中间点的更新方式是m &#x3D; (l+r)&#x2F;2</li></ul></li></ol><p>这种方法保证了：</p><ol><li>最后的 l &#x3D;&#x3D; r</li><li>搜索到达的答案是闭区间的，即 a[l] 是满足check()条件的。</li></ol><p><strong>二分模板</strong><br>模板1就是在满足chek()的区间内找到左边界，模板2在满足check()的区间内找到右边界。然后无论是左边界还是右边界，都应该是整个区间中某一段满足某性质（如单调不降）与另一段不满足该性质的分界点</p><p><strong>口诀：左加右减</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//查找左边界 SearchLeft 简写SL</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SL</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid; <br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>; <br>    &#125;   <br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">//查找右边界 SearchRight 简写SR </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SR</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;                   <br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//需要+1 防止死循环</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> r; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><ol><li>浮点数二分不需要判断边界</li><li>题目要求保留6位小数的时候，就要求l和r的差值小于10的负8次方比较保险<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 浮点数二分</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;n);<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-10000</span>,r=<span class="hljs-number">10000</span>;<br>    <span class="hljs-comment">//保留6位小数的时候，就要求l和r的差值小于10的负8次方比较保险</span><br>    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-8</span>)&#123;<br>        <span class="hljs-type">double</span> mid = (l+r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid*mid &gt;= n)&#123;<br>            r = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            l = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="STL中的有关二分的函数"><a href="#STL中的有关二分的函数" class="headerlink" title="STL中的有关二分的函数"></a>STL中的有关二分的函数</h2><p>tip:这些关于二分的stl函数，都<strong>只会查找指定元素后面的值</strong>，所以要在排好序的数组中进行查找</p><ol><li><code>binary_search()</code>函数，作用：对一个<strong>不降序列</strong>进行二分查找，如果所查找的值在序列中出现了，返回true，没有出现，返回false。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-type">bool</span> flag = <span class="hljs-built_in">binary_search</span>(a,a+<span class="hljs-number">5</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//返回的是布尔值</span><br>cout &lt;&lt; flag;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>lower_bound()</code>函数，作用：对一个<strong>不降序列</strong>进行二分查找，返回第一个<strong>大于等于</strong>所查找的值的元素下标，<strong>注意返回的是指针变量！！！</strong> 如果所有元素都小于val，则返回last的位置，且last的位置是越界的</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>upper_bound()</code>函数，作用：对一个不降序列进行二分查找，返回第一个<strong>大于</strong>所查找的值的元素下标，注意返回的是指针变量！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-keyword">auto</span> pos = <span class="hljs-built_in">upper_bound</span>(a,a+<span class="hljs-number">5</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//返回的是指针变量</span><br><span class="hljs-keyword">auto</span> index =  pos-a; <span class="hljs-comment">//对应元素下标(从0开始)</span><br>cout &lt;&lt; index &lt;&lt; endl &lt;&lt; *pos &lt;&lt; endl &lt;&lt; a[index];<br></code></pre></td></tr></table></figure></li><li><p>如果查找第一个小于某个元素的下标，则加上<code>greater&lt;int&gt;()</code></p></li></ol><p><strong>例题：数的范围</strong></p><blockquote><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。<br>如果数组中不存在该元素，则返回 -1 -1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,q;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> k;<br>        cin &gt;&gt; k;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">binary_search</span>(a,a+n,k))&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">lower_bound</span>(a,a+n,k) - a;<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">upper_bound</span>(a,a+n,k) - a;<br>        cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r<span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/2024/04/02/stl/String/"/>
    <url>/2024/04/02/stl/String/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><h2 id="stl函数方法"><a href="#stl函数方法" class="headerlink" title="stl函数方法"></a>stl函数方法</h2><ol><li><p>获取字符串长度<br><code>s.size()</code> 和 <code>s.length()</code></p></li><li><p>插入<br><code>s.push_back()</code> 在末尾插入<br><code>s.insert(pos,&#39;c&#39;)</code> 在指定位置插入<br><code>s.append(str)</code> 在s字符串结尾添加str字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>(),<span class="hljs-string">&#x27;1&#x27;</span>)<br>s.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;abc&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>删除<br><code>erase(iterator first, iterator last)</code><br>删除字符串中迭代器区间[first,last)上所有字符</p><p><code>erase(pos, len)</code><br>删除字符串中从索引位置pos开始的len个字符</p></li><li><p>字符替换<br><code>s.replace(pos,n,str)</code> 把当前字符串从索引pos开始的n个字符替换为str<br><code>s.replace(it1,it2,str)</code> 把当前字符串[it1,it2)区间替换为str it1 ,it2为迭代器哦<br><code>tolower(s[i]) \ toupper(s[i])</code>  转换为小写 \ 大写</p></li><li><p>分割<br><code>s.substr(pos,n)</code> 截取从pos索引开始的n个字符</p></li><li><p>查找</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;<br><span class="hljs-comment">//字符串查找-----找到后返回首字母在字符串中的下标</span><br><span class="hljs-comment">// 1. 查找一个字符串</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">6</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：11</span><br>    <br><span class="hljs-comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 4. 从字符串的末尾开始查找字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&#x27;i&#x27;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符</span><br>    <br><span class="hljs-comment">// 5. 在该字符串中查找第一个属于字符串s的字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;13br98&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：4---b</span><br>    <br><span class="hljs-comment">// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_not_of</span>(<span class="hljs-string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl; <span class="hljs-comment">// 结果是：4</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_not_of</span>(<span class="hljs-string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;  <span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 7. 在该字符串最后中查找第一个属于字符串s的字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&quot;13r98&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：19</span><br><br><span class="hljs-comment">// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&quot;teac&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：21</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符比较"><a href="#字符比较" class="headerlink" title="字符比较"></a>字符比较</h2><p>使用 <strong>单引号</strong> 包括单个字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;s&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符串变字符数组"><a href="#字符串变字符数组" class="headerlink" title="字符串变字符数组"></a>字符串变字符数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">string s = <span class="hljs-string">&quot;xing ma qi&quot;</span>;<br><span class="hljs-type">char</span> s2[] = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure><h2 id="将数字转换成字符串"><a href="#将数字转换成字符串" class="headerlink" title="将数字转换成字符串"></a>将数字转换成字符串</h2><blockquote><p><code>to_string(num)</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">12345678</span>;<br>cout &lt;&lt; <span class="hljs-built_in">to_string</span>(a) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="将字符串变成数字"><a href="#将字符串变成数字" class="headerlink" title="将字符串变成数字"></a>将字符串变成数字</h2><blockquote><p><code>atoi(const char *)</code> 将<strong>字符数组</strong>转换为int类型<br><code>stoi(const string*)</code> 将<strong>字符串</strong>转换为int类型</p></blockquote><p>关于输出数字的范围：<br>atoi不做范围检查，如果超出上界，输出上界，超出下界，输出下界。<br>stoi会做范围检查，默认必须在int范围内，如果超出范围，会出现RE（Runtime Error）错误。</p><h2 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h2><p><a href="https://www.xdull.cn/kmp.html">彻底搞懂 KMP 算法原理</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>字符串操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索</title>
    <link href="/2024/04/02/dp/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2024/04/02/dp/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="记忆化数组"><a href="#记忆化数组" class="headerlink" title="记忆化数组"></a>记忆化数组</h1><blockquote><p>核心思想：设置一个记忆化数组f[N][N]，保存每种情况的（最优）解<br>并且如果这个点 f[i][j] 已经计算过了，直接返回即可，这就是记忆化搜索</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,m,g[N][N]; <span class="hljs-comment">//数组g存储每个点高度</span><br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">//记忆化数组，保存每个(i,j)为起点的最优解</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">//以i，j为起点的滑雪长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个点已经计算过了，直接返回即可，这就是记忆化搜索</span><br>    <span class="hljs-keyword">if</span>(f[i][j] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[i][j]; <br>    f[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">//长度最短至少为1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;<span class="hljs-number">4</span>;a++)&#123;<br>        <span class="hljs-type">int</span> x = i + dx[a]; <span class="hljs-type">int</span> y = j + dy[a];<br>        <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="hljs-number">1</span> &amp;&amp; y&lt;= m &amp;&amp; g[i][j] &gt; g[x][y])&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">dp</span>(x,y)+<span class="hljs-number">1</span>); <span class="hljs-comment">//(i,j) 为当前位置，(x,y)为下一个要访问的位置</span><br>        &#125;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> f[i][j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(f));<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//循环枚举起始位置(i,j)的所有可能，找出最大值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dp</span>(i,j)); <span class="hljs-comment">//dp(x,y)返回以位置(i,j)为起点能延申的最长长度</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>记忆化搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2024/04/02/dp/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2024/04/02/dp/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>树形dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>树形dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector</title>
    <link href="/2024/04/01/stl/vector/"/>
    <url>/2024/04/01/stl/vector/</url>
    
    <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="vector索引"><a href="#vector索引" class="headerlink" title="vector索引"></a>vector索引</h2><p><strong>vector只有在指定长度时,才能用下标索引的方法修改元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = a.<span class="hljs-built_in">begin</span>();p != a.<span class="hljs-built_in">end</span>(); p++)&#123;<br>cout &lt;&lt; *p;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>下标访问</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>cout &lt;&lt; vi[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>迭代器访问</strong><br>迭代器类似指针，迭代器在vector中就是充当指针的作用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it = vi.<span class="hljs-built_in">begin</span>(); it != vi.<span class="hljs-built_in">end</span>();it ++)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>返回首尾部的元素</strong></p><ol><li><code>front()</code> 返回第一个元素</li><li><code>back()</code>  返回最后一个元素</li></ol><h2 id="vector-插入-删除-元素"><a href="#vector-插入-删除-元素" class="headerlink" title="vector 插入&#x2F;删除 元素"></a>vector 插入&#x2F;删除 元素</h2><ol><li>在尾部进行插入&#x2F;删除<ul><li><code>push_back()</code></li><li><code>pop_back()</code></li></ul></li><li>指定位置的插入&#x2F;删除<ul><li><code>insert()</code>  c.insert(it, x) : 向任意迭代器it插入一个元素x ，O(N)</li><li><code>erase()</code>  c.erase(first,last) 删除[first,last)的所有元素，first,last都为迭代器指针 ，O(N)</li></ul></li></ol><h2 id="vector去重"><a href="#vector去重" class="headerlink" title="vector去重"></a>vector去重</h2><ol><li>先进行 sort() 排序，这样重复元素就会堆一起了</li><li>调用 unique() 函数将<strong>相邻且重复</strong> （因此要先排序） 的元素放到vector的尾部 然后返回指向第一个重复元素的迭代器</li><li>再用erase函数擦除从迭代器所指元素到最后元素的所有的元素</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()), vec.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h2 id="vector截取"><a href="#vector截取" class="headerlink" title="vector截取"></a>vector截取</h2><p>void assign(const_iterator first,const_iterator last); &#x2F;&#x2F;两个指针，分别指向开始和结束的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//通过vector的迭代器截取数组</span><br><span class="hljs-keyword">auto</span> first = a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> end = a.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>;<br>a.<span class="hljs-built_in">assign</span>(first,end);<br></code></pre></td></tr></table></figure><h2 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a>第k小数</h2><blockquote><p>寻找序列第k小的值 <code>nth_element(beg, nth, end)</code><br><code>nth_element(a,a+k,a+n)</code>，函数只是把下标为k的元素放在了正确位置<br>求第k大时,我们可以转化成求第n+1-k小，此时下标应该是n - k,所以为 <code>nth_element(a,a+n-k,a+n)</code> 也可以用cmp自定义比较函数，<code>greater&lt;int&gt;()</code></p></blockquote><p>nth为一个迭代器，指向序列中的一个元素。第n小的值恰好在nth位置上</p><p>执行nth_element()之后，序列中的元素会围绕nth进行划分：<strong>nth之前的元素都小于等于它，而之后的元素都大于等于它</strong></p><h2 id="哈希表-vector"><a href="#哈希表-vector" class="headerlink" title="哈希表 + vector"></a>哈希表 + vector</h2><p><img src="/../../img/347.png"></p><ol><li><code>unordered_map&lt;int,int&gt; st;</code> <strong>哈希表统计数据</strong></li><li><code>vector&lt;pair&lt;int,int&gt;&gt; a;</code>   <strong>vector的sort来排序</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">//哈希表统计数据</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; a; <span class="hljs-comment">//vector的sort来排序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            st[nums[i]] ++;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> it = st.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it != st.<span class="hljs-built_in">end</span>()) &#123;<br>            a.<span class="hljs-built_in">push_back</span>(&#123;it-&gt;second,it-&gt;first&#125;);<br>            it ++;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            res.<span class="hljs-built_in">push_back</span>(a[i].second);<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>stl</category>
      
      <category>vector</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>stl</tag>
      
      <tag>vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性dp</title>
    <link href="/2024/04/01/dp/%E7%BA%BF%E6%80%A7dp/"/>
    <url>/2024/04/01/dp/%E7%BA%BF%E6%80%A7dp/</url>
    
    <content type="html"><![CDATA[<h1 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h1><blockquote><p>线性DP，是较常见的一类动态规划问题，其是在线性结构上进行状态转移，这类问题不像背包问题、区间DP等有固定的模板</p><p>线性动态规划的目标函数为特定变量的线性函数，约束是这些变量的线性不等式或等式，目的是求目标函数的最大值或最小值</p></blockquote><h2 id="LCS问题——最长公共子序列"><a href="#LCS问题——最长公共子序列" class="headerlink" title="LCS问题——最长公共子序列"></a>LCS问题——最长公共子序列</h2><blockquote><p><code>子序列</code> : 指的是字符串中<strong>不一定连续</strong>但先后顺序一致的n个字符<br><code>字符子串</code>：指的是字符串中连续的n个字符<br><code>最长公共子序列</code>，英文缩写为LCS（Longest Common Subsequence）。其定义是: 一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。</p></blockquote><blockquote><p>问题描述：给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p></blockquote><p><strong>状态表示</strong></p><ol><li>集合表示：所有 $ A[1,n] $和 $ B[1,m] $ 的公共子序列的集合</li><li><strong>dp[i][j]代表以s1[i]，s2[j]结尾的LCS的长度</strong></li><li>属性：公共子序列长度的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>找集合中所有情况的共同点和不同点来划分集合</li><li>该公共子序列分为四种情况：包括a[n] , b[m] ，不包括a[n] ,包括b[m] ，不包括a[n] , b[m] ，包括a[n] ,不包括b[m] （可以用二进制0 1来表示）</li><li>$ f[i][j] $：A前i个字符，B前j个字符的公共子序列 的集合<br>属性：maxlen</li><li>集合划分情况（假定）<ul><li>(1) $ f[i-1][j-1] + 1 $  同时包括 a[n] 和 b[m] （前提是a[n] &#x3D;&#x3D; a[m]）</li><li>(2) $ f[i-1][j] $  不包括a[n] ,包括b[m]</li><li>(3) $ f[i][j-1] $  包括a[n] ,不包括b[m]</li><li>(4) $ f[i-1][j-1] $ a[n] 和 b[m] 都不包括</li></ul></li><li>集合划分情况（实际）<ul><li>f[i-1][j-1]+1 可以表示情况1    –&gt; a</li><li>f[i][j-1]&#x3D;max(情况2,情况4)    –&gt; b</li><li>f[i-1][j]&#x3D;max(情况3,情况4)    –&gt; c<br>所以我们最终只需要 求 max(a,b,c) 即可</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++">\\最长公共子序列<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-comment">//注意题目中是字符</span><br><span class="hljs-type">char</span> a[N],b[N];  <br><br><span class="hljs-type">int</span> n,m,f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    cin &gt;&gt; b[i];<br>&#125;<br><span class="hljs-comment">//状态计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-1</span>][j]);<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br>    cout &lt;&lt; f[n][m];<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="LIS问题——最长上升子序列"><a href="#LIS问题——最长上升子序列" class="headerlink" title="LIS问题——最长上升子序列"></a>LIS问题——最长上升子序列</h2><blockquote><p><code>最长上升子序列</code>（Longest  Increasing Subsequence），简称LIS，也有些情况求的是最长非降序子序列，二者区别就是序列中是否可以有相等的数，对于固定的数组，虽然LIS序列不一定唯一，但LIS的<strong>长度是唯一的</strong></p></blockquote><ol><li><p>状态设计：$dp[i]$ 代表以 $a[i]$ 结尾的LIS的长度</p></li><li><p>状态转移：$dp[i]&#x3D;max{dp[j]+1，dp[i]} (1&lt;&#x3D;j&lt; i，a[j]&lt;a[i])$</p></li><li><p>边界处理：$dp[i]&#x3D;1(1&lt;&#x3D;i&lt;&#x3D;n)$</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> a[N],n;<br><span class="hljs-type">int</span> f[N]; <span class="hljs-comment">//f[i]: 以 a[i] 为结尾的上升子序列的最大长度</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>        f[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">//用1去初始化dp数组，因为最短的递增子序列的长度为1</span><br>    &#125;<br>    <span class="hljs-comment">//循环整个数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//从前往后循环比那里之前的元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="hljs-built_in">max</span>(f[i],f[j]+<span class="hljs-number">1</span>);<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans,f[i]);<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求最长子序列的路径"><a href="#求最长子序列的路径" class="headerlink" title="求最长子序列的路径"></a>求最长子序列的路径</h3><p>核心思想：使用g数组存储序列中每个元素下标的上一个元素的下标<br><code>g[i] = j;</code> : 最长子序列中下标为 i 的元素 的 上一个元素下标为 j</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,a[N],g[N],f[N]; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        g[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123;<br>                f[i] = <span class="hljs-built_in">max</span>(f[i],f[j]+<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//如果f[i]更新了，则说明最长子序列中 下标为i的元素的上一个元素下标为j</span><br>                <span class="hljs-keyword">if</span>(f[i] == f[j]+<span class="hljs-number">1</span>)&#123;<br>                    g[i] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> k; <span class="hljs-comment">//最长子序列的最后一个元素的下标</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(f[i] &gt; res)&#123;<br>            res = f[i];<br>            k = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//res为最长子序列的长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;res;t++)&#123;<br>        cout &lt;&lt; a[k] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        k = g[k]; <span class="hljs-comment">//g[k]存储着 下标为k的元素 的上一个元素下标</span><br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; res;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p><img src="/../../img/%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><p>题目链接：<a href="https://www.acwing.com/problem/content/description/1224/">密码脱落</a></p><p><img src="/../../img/%E6%98%9F%E7%90%83%E8%84%B1%E8%90%BD.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// f[i][j] 区间[i，j] 之间的最长 回文 子序列 长度</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">状态划分：</span><br><span class="hljs-comment">1. 字符 s[i]和s[j] 都在子序列中</span><br><span class="hljs-comment">2. 字符 s[i]在，s[j]不在</span><br><span class="hljs-comment">3. 字符 s[i]不在，s[j]在</span><br><span class="hljs-comment">4. 字符 s[i]和s[j] 都不在子序列中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">char</span> s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)&#123;<br>        <span class="hljs-comment">//r-l+1 = len</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>; len+l<span class="hljs-number">-1</span> &lt; n; l++)&#123;<br>            <span class="hljs-type">int</span> r = len+l<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>                f[l][r] = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// continue;</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                f[l][r] = <span class="hljs-built_in">max</span>(f[l][r<span class="hljs-number">-1</span>],f[l+<span class="hljs-number">1</span>][r]);<br>                <span class="hljs-keyword">if</span>(s[l] == s[r]) f[l][r] = <span class="hljs-built_in">max</span>(f[l][r],f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; n - f[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>得到具体的回文字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        <span class="hljs-comment">// 初始化二维动态规划表</span><br>        <span class="hljs-type">bool</span> f[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 填充对角线为true，因为单个字符总是回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            f[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最长回文串的起始位置和长度</span><br><br>        <span class="hljs-comment">// 填充动态规划表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; ++len) &#123; <span class="hljs-comment">// 长度从2开始</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + len - <span class="hljs-number">1</span> &lt; n; ++i) &#123; <span class="hljs-comment">// i是子串的起始位置,j是右端点小于n</span><br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>; <span class="hljs-comment">// j是子串的结束位置</span><br>                <span class="hljs-comment">// 如果首尾字符相同，并且中间部分也是回文，则整个序列是回文</span><br>                <span class="hljs-keyword">if</span> (s[i] == s[j] &amp;&amp; (len &lt; <span class="hljs-number">3</span> || f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>                    f[i][j] = <span class="hljs-literal">true</span>;<br>                    maxLen = len;<br>                    start = i;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最长的回文子串</span><br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start, maxLen);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>线性dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间dp</title>
    <link href="/2024/04/01/dp/%E5%8C%BA%E9%97%B4dp/"/>
    <url>/2024/04/01/dp/%E5%8C%BA%E9%97%B4dp/</url>
    
    <content type="html"><![CDATA[<h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><blockquote><p>定义：区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。</p><p>令状态 $f(i,j) $表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 $f(i,j)&#x3D;\max{f(i,k)+f(k+1,j)+cost}$，$cost $为将这两组元素合并起来的价值</p></blockquote><p><strong>性质</strong></p><ol><li><strong>合并：</strong> 即将两个或多个部分进行整合，当然也可以反过来</li><li><strong>特征</strong> 能将问题分解为能两两合并的形式</li><li><strong>求解</strong> 对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值</li></ol><p><strong>解题模板</strong><br>区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len &#x3D; 1 时用来初始化，枚举从 len &#x3D; 2 开始；第二维枚举起点 i （右端点 j 自动获得，j &#x3D; i + len - 1）</p><p>模板代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len++) &#123;         <span class="hljs-comment">// 区间长度</span><br>    <span class="hljs-comment">//终止条件代表右端点要小于n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) &#123; <span class="hljs-comment">// 枚举起点</span><br>        <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 区间终点</span><br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            dp[i][j] = 初始值<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//或者在下方加上else</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) &#123;        <span class="hljs-comment">// 枚举分割点，构造状态转移方程</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + w[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h2><blockquote><p>问题描述：设有 N 堆石子排成一排，其编号为 1,2,3,…,N。每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。<br>每次<strong>只能合并相邻的两堆</strong>，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。<br>找出一种合理的方法，使总的代价最小，输出最小代价</p></blockquote><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示将 [i,j] 这段区间的物品合并在一起的方案集合</li><li>属性：最小代价</li><li>集合划分，最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并，将集合划分成某一堆是由区间 $ [i,i] ，[i,i+1] ，[i,i+2] ，… ， [i,i + j-1] $ 这些情况中之一所合并而成（即所有方案中，最后一次合并时，其中的某一堆一定是由上述某个区间所合并而成，满足不重不漏的原则）</li><li>除了最后一次以外前面每次合并的和即为该次合并所产生的代价，因此最小总代价 &#x3D; $ f(i,k) + f(k+1,j) + s[j] - s[i-1] $</li><li>$ f(i,j) $</li></ol><p><strong>状态计算</strong></p><p>1.<br>2. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> f[N][N],s[N],n,w[N]; <span class="hljs-comment">//dp数组；前缀和数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        s[i] = s[i<span class="hljs-number">-1</span>] + w[i];<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f); <span class="hljs-comment">//由于是求最小值，因此先把dp数组设置成最大值</span><br>    <span class="hljs-comment">// 区间 DP 枚举套路：长度+左端点 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)&#123; <span class="hljs-comment">//len表示[i, j]的元素个数</span><br>        <span class="hljs-comment">// 右端点j小于0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=n;i++)&#123; <br>            <span class="hljs-type">int</span> j = i+len<span class="hljs-number">-1</span>; <span class="hljs-comment">// 自动得到右端点</span><br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>                f[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 边界初始化</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;k++)&#123;<br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i][j],f[i][k] + f[k+<span class="hljs-number">1</span>][j] + s[j] - s[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for(int len=2;len&lt;=n;len++)&#123;</span><br><span class="hljs-comment">        //右端点j小于0</span><br><span class="hljs-comment">        for(int i=1;len+i-1 &lt;= n;i++)&#123;</span><br><span class="hljs-comment">            //j-i+1 = len</span><br><span class="hljs-comment">            int j = len+i-1;</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">            //初始化f[i][j]为一个较大值（题目要求最小代价）</span><br><span class="hljs-comment">            f[i][j] = 1e9;</span><br><span class="hljs-comment">            //枚举合并点</span><br><span class="hljs-comment">            for(int k=i;k&lt;=j-1;k++)&#123;</span><br><span class="hljs-comment">                f[i][j] = min( f[i][j] , f[i][k] + f[k+1][j] + s[j] - s[i-1]);</span><br><span class="hljs-comment">                // cout &lt;&lt; f[i][j] &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;    </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>区间dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>区间dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划（背包问题）</title>
    <link href="/2024/03/30/dp/dp/"/>
    <url>/2024/03/30/dp/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="dp问题"><a href="#dp问题" class="headerlink" title="dp问题"></a>dp问题</h1><ol><li>要将$f[0][0]$ 等特殊的点进行初始化操作</li><li></li></ol><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><blockquote><p>问题描述：有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i件物品的体积是$ v_i $，价值是$ w_i $ 。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大</p></blockquote><p>针对0-1背包问题，每个物品有选与不选两种选择，则暴力枚举的时间复杂度为 $ O(2^n) $</p><p><strong>状态表示</strong> </p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品只能<strong>选一次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>将状态集合将所有选法划分成第 i 个物品 选 或者 不选 的方案（该划分方式不重不漏）</li><li>第 i 个物品不选时：$ f(i,j) &#x3D; f(i-1,j) $</li><li>第 i 个物品被选择时，为了方便计算，则先假设不选第 i 个物品，则此时 $ f(i,j) &#x3D; f(i-1,j-v[i]) + w[i] $ ,此时前提条件是 $ j &gt; v[i] $</li><li>状态属性是求最大值，则用max函数求出上述情况下的价值最大值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,m,ans;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-comment">//动态计算</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j], d[i<span class="hljs-number">-1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一维优化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> d[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) d[j] = <span class="hljs-built_in">max</span>(d[j], d[j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品能选<strong>无数次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>该集合的所有选法可以划分成第 i 个物品被选了0次,1次, … , n次（不重不漏）</li><li>划分依据:找最后一个不同点；最后一个物品选几个</li><li>$ f(i-1,j) $ 和 $ f(i-1,j-n*v_i) $ 这些方案的最大值</li><li>$ f(i,j) &#x3D; max( f(i-1,j), f(i-1,j-1<em>v[i])+1</em>w[i], f(i-1,j-2<em>v[i])+2</em>w[i], … , f(i-1,j-n<em>v[i])+n</em>w[i] ) $</li><li>$ f(i,j-v) &#x3D; max( f(i-1,j-v), f(i-1,j-2<em>v[i])+1</em>w[i], f(i-1,j-3<em>v[i])+2</em>w[i], … , f(i-1,j-(n+1)<em>v[i])+n</em>w[i] ) $</li><li>$ f(i,v) &#x3D; f(i,j-v) + w $</li></ol><p><strong>未优化版本，会超时</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;(k*v[i])&lt;=j;k++)&#123;<br>                <span class="hljs-keyword">if</span>(j&gt;=k*v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j],d[i][j-k*v[i]]+k*w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二维优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span>(j&gt;=v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j],d[i][j-v[i]] + w[i]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>一维优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[j] = d[j];<br>        <span class="hljs-keyword">if</span>(j&gt;=v[i]) d[j] = <span class="hljs-built_in">max</span>(d[j],d[j-v[i]] + w[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品能选<strong>有限n次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>集合的选法包括第i个物品不被选，或者选1个，2个…n个.</li><li>多重背包可以转换成0-1背包</li><li>将s个物品的体积看成一个个单独的物品</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将s个物品看成一个个单独的物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>    <span class="hljs-keyword">while</span>(s--)&#123;<br>        t++; <span class="hljs-comment">//t从1开始</span><br>        v[t] = a;<br>        w[t] = b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拆分后直接套用0-1背包板子</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>        f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二进制优化版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-keyword">while</span>(k&lt;=s)&#123;<br>            t++;<br>            v[t] = k*a;<br>            w[t] = k*b;<br>            s -= k; <span class="hljs-comment">//s代表目前还未分配的，每次要减去已经分配</span><br>            k*=<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果还有没分配的，再进行最后一次分配</span><br>        <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>)&#123;<br>            t++;<br>            v[t] = a*s;<br>            w[t] = b*s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>            f[j] = f[j];<br>            <span class="hljs-keyword">if</span>(v[i] &lt;= j) f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[m]; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><blockquote><p>问题描述：有 N 组物品和一个容量是 V 的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是$ v_{ij} $，价值是$ w_{ij} $，其中$ i $是组号，$ j $ 是组内编号。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p></blockquote><p><strong>状态计算</strong></p><ol><li>体积和价值表示为$ v[i][k] w[i][k] $ $ i $代表物品组，k 代表物品组里的第k个物品<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> d[S][M]; <span class="hljs-comment">//从前s组选，体积不超过m</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; s[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=s[i];j++)&#123;<br>            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>对每个物品组进行循环，将其转换成0-1背包<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=s[i];k++)<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i][k]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j], d[i<span class="hljs-number">-1</span>][j-v[i][k]] + w[i][k]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>背包问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2024/03/29/algorithm_know/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/29/algorithm_know/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><blockquote><p>定义：贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解</p></blockquote><ol><li>类似于二分，将大集合进行划分，得出最优解所在的小集合</li><li>与动态规划的不同: 在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能</li></ol><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><blockquote><p>给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)</p></blockquote><p><strong>实现手段：</strong><br>通过一个小根堆<code>(priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;)</code>，每次取出队列顶部的两个元素进行合并，同时将这两个元素出队，将合并之后得到的新元素入队<br>直到队列中只剩下一个元素为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">// 优先队列头文件</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// 大根堆 + 大于号 = 小根堆</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        q.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">// 加入节点</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// res: 结果</span><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// 模拟哈夫曼树生成过程</span><br>    &#123;<br>        <span class="hljs-comment">// 挑两个最小的数</span><br>        <span class="hljs-type">int</span> a = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> b = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        res += a + b; <span class="hljs-comment">// 把他们之和加到答案里</span><br>        q.<span class="hljs-built_in">push</span>(a + b); <span class="hljs-comment">// 合并节点</span><br>    &#125;<br><br>    cout &lt;&lt; res;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>math</title>
    <link href="/2024/03/29/algorithm_know/math/"/>
    <url>/2024/03/29/algorithm_know/math/</url>
    
    <content type="html"><![CDATA[<h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><h2 id="约数-因数-个数"><a href="#约数-因数-个数" class="headerlink" title="约数(因数)个数"></a>约数(因数)个数</h2><ol><li>因数总是成对出现的,一个在开根号左边，一个在右边，此时因数个数加二</li><li>特殊情况：有可能刚好等于开根号之后的数字，此时因数个数只加一<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*j&lt;=a[i];j++)&#123;<br>            <span class="hljs-comment">//因数总是成对出现的,一个在开根号左边，一个在右边，此时因数个数加二</span><br>            <span class="hljs-comment">//特殊情况：有可能刚好等于开根号之后的数字，此时因数个数只加一</span><br>            <span class="hljs-keyword">if</span>(a[i] % j == <span class="hljs-number">0</span> &amp;&amp; j*j != a[i]) cnt+=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(a[i] % j == <span class="hljs-number">0</span> &amp;&amp; j*j == a[i]) cnt+=<span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/869/">分解质因数</a></p><p><img src="/../../img/%E8%B4%A8%E5%9B%A0%E6%95%B0.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-type">int</span> m = x;<br>        <span class="hljs-comment">//循环到平方根</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;i++)&#123;<br>            <span class="hljs-keyword">if</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>                    x /= i;<br>                    cnt++;<br>                &#125;<br>                cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; 1&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>$ gcd(a, b) &#x3D; gcd(b, a mod b) $</p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p><strong>互质数：</strong></p><blockquote><p>两个数的公因数只有1的两个非零自然数,叫做互质数<br>1与任何数都互斥，自身与自身不互斥（公约数包括1和自身）</p></blockquote><p>性质一：两个不同的质数是互质的。<br>性质二：一个质数，另一个不为它的倍数，这两个数为互质数。（较大数是质数的两个数是互质数）<br>性质三：相邻的两个自然数是互质数。<br>性质四：相邻的两个奇数是互质数。<br>性质五：最大公约数是1，两个数互质。</p><p><strong>欧拉函数</strong></p><blockquote><p>定义：对于一个正整数n，n的欧拉函数ϕ(n)表示<strong>小于等于</strong>n中，与n互质的<strong>正整数</strong>的个数</p></blockquote><p>分解质因数：N &#x3D; $ p_1^{a_1} * p_2^{a_2} * …*p_n^{a_n} $</p><p>$ ϕ(N) &#x3D; N(1- \frac{1}{p_1})(1- \frac{1}{p_2})…(1- \frac{1}{p_n}) $</p><p>用代码表示该公式时为了防止出现小数，用以下方式表示：<br>$ ϕ(N) &#x3D; (\frac{N}{p_1})*(p_1 - 1) $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=t/i;i++)&#123;<br>    <span class="hljs-comment">//判断i是不是t的质因子</span><br>    <span class="hljs-keyword">if</span>(t%i == <span class="hljs-number">0</span>)&#123;<br>        res = (res/i)*(i<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span>(t%i == <span class="hljs-number">0</span>)&#123;<br>            t /= i;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//有没除尽的</span><br><span class="hljs-keyword">if</span>(t &gt; <span class="hljs-number">1</span>) res = (res/t)*(t<span class="hljs-number">-1</span>);<br>cout &lt;&lt; res &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>性质1：如果<strong>n是质数</strong>，那么<strong>ϕ(n) &#x3D; n−1</strong>,因为只有n本身与它不互质。</p><p>性质2：如果p，q都是质数，那么$ ϕ ( p ∗ q ) &#x3D; ϕ ( p ) ∗ ϕ ( q ) &#x3D; ( p − 1 ) ∗ ( q − 1 ) $.</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂，二进制取幂，在O(logn)下求$ a^n $的方法</p><blockquote><p>求 $ {a^b} % {p} $ 的值</p></blockquote><p>做这个题前首先我们需要了解一下关于取余的公式<br>(a + b) % p &#x3D; (a % p + b % p) % p<br>(a - b) % p &#x3D; (a % p - b % p ) % p<br>(a * b) % p &#x3D; (a % p * b % p) % p</p><p><strong>$ a^b &#x3D; a^{2^0+2^1+…+2^n(中的某几项)} $</strong><br>ex. $ a^{10} &#x3D; a^{(1010)_2} &#x3D; a^{2^1+2^3} $</p><p><strong>注意下述式子</strong></p><blockquote><p>$ a^{2^3} &#x3D; (a^{2^2})^2 \ a^{2^0} &#x3D; a $</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL a,b;<br><span class="hljs-type">int</span> p,n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;p);<br>        LL res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// cout &lt;&lt; b;</span><br>            <span class="hljs-comment">//求数末尾为1还是0</span><br>            <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)&#123;<br>                res = res * a % p;<br>            &#125;<br>            a = a*a % p;<br>            b = b &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//注意这里要把移位后的值赋给b</span><br>        &#125;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数学知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pair</title>
    <link href="/2024/03/29/stl/pair/"/>
    <url>/2024/03/29/stl/pair/</url>
    
    <content type="html"><![CDATA[<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><blockquote><p>pair&lt;int,int&gt; p[N];</p></blockquote><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><blockquote><p>和结构体类似，first代表第一个元素，second代表第二个元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="索引元素"><a href="#索引元素" class="headerlink" title="索引元素"></a>索引元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cout &lt;&lt; p[i].first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p[i].second;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>stl</category>
      
      <category>pair</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>stl</tag>
      
      <tag>pair</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手做操作系统</title>
    <link href="/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA408/OS/"/>
    <url>/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA408/OS/</url>
    
    <content type="html"><![CDATA[<h1 id="动手做操作系统"><a href="#动手做操作系统" class="headerlink" title="动手做操作系统"></a>动手做操作系统</h1><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ol><li>在Windows下编写代码，使用vscode、记事本等编辑器。</li><li>使用Linux的虚拟机编译内核和生成操作软盘映像。（img软盘也可以直接在window11环境下使用bximage.exe生成，但需要在虚拟机里进行格式化）</li><li>必要时使用安装了DOS的虚拟机来调试程序以及操作软盘映像。</li><li>安装一个Bochs,必要的时候用它来调试。</li><li>使用其他必要的工具，比如版本控制工具(VSS或者CVS)。</li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>软盘是从A盘启动的</li></ol><h2 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h2><p>在操作系统中，实模式（Real Mode）和保护模式（Protected Mode）是两种不同的工作模式，特别是在x86架构的计算机上常见。</p><p><strong>实模式：</strong></p><ul><li>实模式是早期IBM PC兼容计算机上的一种工作模式。在实模式下，CPU可以访问1MB范围内的内存。</li><li>内存管理采用分段机制，内存地址由一个16位段地址和一个16位偏移地址组成，共20位地址空间。</li><li>实模式下，没有内存保护机制，任何程序都可以访问系统的所有内存和硬件设备，因此容易导致系统的稳定性问题。<br><strong>保护模式：</strong></li><li>保护模式是后来引入的一种工作模式，提供了更为复杂和强大的内存管理和保护机制。</li><li>在保护模式下，CPU可以访问超过1MB的内存，并且支持虚拟内存和分页机制。</li><li>内存管理采用分段和分页结合的方式，可以实现更灵活的内存保护和隔离，不同程序之间不会相互影响。</li><li>保护模式下，操作系统可以对内存和硬件设备进行更精细的控制和管理，提高了系统的稳定性和安全性。</li></ul><p>总的来说，实模式和保护模式是操作系统在x86架构下的两种不同的工作模式，保护模式相比实模式具有更多的功能和优势，是现代操作系统常用的工作模式。</p><h2 id="全局描述符表（GDT）"><a href="#全局描述符表（GDT）" class="headerlink" title="全局描述符表（GDT）"></a>全局描述符表（GDT）</h2><p>全局描述符表（Global Descriptor Table，GDT）是x86架构下一种用于管理内存的数据结构，它在操作系统中扮演着重要的角色。GDT定义了内存分段的策略，包括内存段的起始地址、段的大小、访问权限等信息。</p><p>在x86架构中，内存被分成多个段（segment），每个段都有自己的起始地址和大小。GDT就是用来管理这些段的数据结构。每个段都由一个描述符（descriptor）来描述，而GDT就是存放这些描述符的表格。描述符包含了段的各种属性，比如基地址、段限长、访问权限等。</p><p>通过GDT，操作系统可以实现对内存的灵活管理和保护。例如，操作系统可以将代码、数据、堆栈等不同类型的信息放在不同的段中，并且对每个段设置不同的访问权限，从而提高系统的安全性和稳定性。此外，GDT还支持虚拟内存和分页机制，可以实现更高效的内存管理和地址转换。</p><p>总的来说，全局描述符表（GDT）是x86架构下一种重要的内存管理数据结构，它定义了内存分段的策略，为操作系统提供了灵活的内存管理和保护机制。</p><h2 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h2><p>(1) 准备GDT </p><p>(2) 用 lgdt 加载 gdtr.<br><code>lgdt [GdtPtr]</code></p><p>(3) 关中断<br><code>cli</code></p><p>(4) 打开 A20地址线.<br><code>inal, 92h </code><br><code>oral, 00000010b</code><br><code>out92h, al</code></p><p>(5)置cr0的PE位（第0位）为1.<br><code>moveax, cr0</code><br><code>oreax, 1</code><br><code>movcr0, eax</code></p><p>(6)跳转，进入保护模式.<br><code>jmpdword SelectorCode32:0</code></p><h2 id="运行一个-com程序的步骤"><a href="#运行一个-com程序的步骤" class="headerlink" title="运行一个.com程序的步骤"></a>运行一个.com程序的步骤</h2><ol><li>使用bximage.exe生成一个软盘</li><li>将软盘插入到xp虚拟机中，进行格式化（选择带ms-dos启动盘的格式化）</li><li>将需要运行的.com程序放入软盘中，之后将软盘取出（防止软盘被占用而出错）</li><li>编辑bochsrc.bxrc，将软盘名称改成自己软盘的名称，将启动盘改成A</li><li>运行<code>C:\Bochs-2.6.9\dos</code> 里的 <code>bchsrc.bxrc</code>即可进入到软盘中，之后在窗口中输入test1.com即可运行</li></ol><h2 id="保护模式下的特点"><a href="#保护模式下的特点" class="headerlink" title="保护模式下的特点"></a>保护模式下的特点</h2><ol><li>地址用 SEG:OFFSET 表示 ; 段值仍然由原来16位的cs、ds 等寄存器表示，但此时它仅仅变成了一个索引，这个索引指向一个数据结构的一个表项，表项中详细定义了段的起始地址、界限、属性等内容。这个数据结构，就是GDT（实际上还可能是LDT，这个以后再介绍)。GDT 中的表项也有一个专门的名字，叫做描述符（Descriptor)。</li><li>也就是说，GDT的作用是用来提供段式存储机制，这种机制是通过段寄存器和GDT中的描述符共同提供的。</li><li>GDT中的每一个描述符定义一个段</li><li>不难理解，当TI和RPL都为零时，选择子就变成了对应描述符相对于GDT 基址的偏移</li></ol><h2 id="建立新段的步骤"><a href="#建立新段的步骤" class="headerlink" title="建立新段的步骤"></a>建立新段的步骤</h2><ol><li>建立一个段</li><li>在段表中建立一个条目写进去</li><li>给定一个选择子（指向段表的索引）</li><li>初始化时，把起始地址填入到Desc</li><li>使用该段</li></ol>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举算法</title>
    <link href="/2024/03/28/algorithm_know/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/28/algorithm_know/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举算法"><a href="#枚举算法" class="headerlink" title="枚举算法"></a>枚举算法</h1><h2 id="结题步骤"><a href="#结题步骤" class="headerlink" title="结题步骤"></a>结题步骤</h2><p>采用枚举算法解题的一般思路如下：</p><ol><li>确定枚举对象、枚举范围和判断条件，并判断条件设立的正确性。</li><li>一一枚举可能的情况，并验证是否是问题的解。</li><li>考虑提高枚举算法的效率。</li></ol><p><strong>提高算法效率方法</strong></p><ol><li>抓住问题状态的本质，尽可能缩小问题状态空间的大小。</li><li>加强约束条件，缩小枚举范围。</li><li>根据某些问题特有的性质，例如对称性等，避免对本质相同的状态重复求解。</li></ol><h2 id="递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。"><a href="#递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。" class="headerlink" title="递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。"></a>递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。</h2><h3 id="指数型枚举"><a href="#指数型枚举" class="headerlink" title="指数型枚举"></a>指数型枚举</h3><p>从 1∼n 这 n个整数中随机选取任意多个，输出所有可能的选择方案。<br>由于每个数都存在选与不选两种状态，所以总共会有2^n 种情况<br>选与不选可以使用dfs来递归表示<br>因此递归函数中会用到两个dfs()函数分别表示选与不选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> st[<span class="hljs-number">20</span>]; <span class="hljs-comment">//结果数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">1</span>) <br>                cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    st[u] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>    <br>    st[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排列型枚举"><a href="#排列型枚举" class="headerlink" title="排列型枚举"></a>排列型枚举</h3><p>可以使用stl函数 next_permutation </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//时间复杂度 N!</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> a[N],n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="组合型枚举"><a href="#组合型枚举" class="headerlink" title="组合型枚举"></a>组合型枚举</h3><blockquote><p>从 1∼n 这 n 个整数中随机选出 k 个，输出所有可能的选择方案</p></blockquote><p>可以使用stl函数 <strong>prev_permutation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) a[i]=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span>(a[i]) cout&lt;&lt; i &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">prev_permutation</span>(a+<span class="hljs-number">1</span>, a+<span class="hljs-number">1</span>+n));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>枚举算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>枚举算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将数据集分成训练集和测试集</title>
    <link href="/2024/03/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/data-set-spilt/"/>
    <url>/2024/03/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/data-set-spilt/</url>
    
    <content type="html"><![CDATA[<h1 id="将数据集分成训练集和测试集"><a href="#将数据集分成训练集和测试集" class="headerlink" title="将数据集分成训练集和测试集"></a>将数据集分成训练集和测试集</h1><h2 id="具体代码（带详细注释）"><a href="#具体代码（带详细注释）" class="headerlink" title="具体代码（带详细注释）"></a>具体代码（带详细注释）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">假设数据集文件夹中有三类</span><br><span class="hljs-string">class_indices.json</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;0&quot;: &quot;AD&quot;,</span><br><span class="hljs-string">    &quot;1&quot;: &quot;CN&quot;,</span><br><span class="hljs-string">    &quot;2&quot;: &quot;MCI&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_split_data</span>(<span class="hljs-params">root: <span class="hljs-built_in">str</span>, val_rate: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.2</span></span>):<br>    random.seed(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 保证随机结果可复现</span><br>    <span class="hljs-keyword">assert</span> os.path.exists(root), <span class="hljs-string">&quot;dataset root: &#123;&#125; does not exist.&quot;</span>.<span class="hljs-built_in">format</span>(root)<br><br>    <span class="hljs-comment"># 遍历文件夹，一个文件夹对应一个类别</span><br>    data_class = [cla <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> os.listdir(root) <span class="hljs-keyword">if</span> os.path.isdir(os.path.join(root, cla))]<br>    <span class="hljs-comment"># 排序，保证各平台顺序一致</span><br>    data_class.sort()  <span class="hljs-comment"># [&#x27;AD&#x27;, &#x27;CN&#x27;, &#x27;MCI&#x27;]</span><br>    <span class="hljs-comment"># 生成类别名称以及对应的数字索引</span><br>    class_indices = <span class="hljs-built_in">dict</span>((k, v) <span class="hljs-keyword">for</span> v, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_class))<br>    json_str = json.dumps(<span class="hljs-built_in">dict</span>((val, key) <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> class_indices.items()), indent=<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;class_indices.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> json_file:<br>        json_file.write(json_str)<br><br>    train_images_path = []  <span class="hljs-comment"># 存储训练集的所有图片路径</span><br>    train_images_label = []  <span class="hljs-comment"># 存储训练集图片对应索引信息</span><br>    val_images_path = []  <span class="hljs-comment"># 存储验证集的所有图片路径</span><br>    val_images_label = []  <span class="hljs-comment"># 存储验证集图片对应索引信息</span><br>    every_class_num = []  <span class="hljs-comment"># 存储每个类别的样本总数</span><br>    supported = [<span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-string">&quot;.JPG&quot;</span>, <span class="hljs-string">&quot;.png&quot;</span>, <span class="hljs-string">&quot;.PNG&quot;</span>]  <span class="hljs-comment"># 支持的文件后缀类型</span><br>    <span class="hljs-comment"># 遍历每个文件夹下的文件</span><br>    <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> data_class:<br>        cla_path = os.path.join(root, cla) <span class="hljs-comment"># 类别文件夹的具体路径</span><br>        <span class="hljs-comment"># 遍历获取supported支持的所有文件路径</span><br>        images = [os.path.join(root, cla, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> os.listdir(cla_path)<br>                  <span class="hljs-keyword">if</span> os.path.splitext(i)[-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> supported]<br>        <span class="hljs-comment"># 排序，保证各平台顺序一致</span><br>        images.sort() <span class="hljs-comment"># 该类别文件夹下的所有图片 按名称字典顺序排列</span><br>        <span class="hljs-comment"># 获取该类别对应的索引</span><br>        image_class = class_indices[cla]<br>        <span class="hljs-comment"># 记录该类别的样本数量</span><br>        every_class_num.append(<span class="hljs-built_in">len</span>(images))<br>        <span class="hljs-comment"># 按比例随机采样验证样本</span><br>        val_path = random.sample(images, k=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(images) * val_rate))<br><br>        <span class="hljs-keyword">for</span> img_path <span class="hljs-keyword">in</span> images:<br>            <span class="hljs-keyword">if</span> img_path <span class="hljs-keyword">in</span> val_path:  <span class="hljs-comment"># 如果该路径在采样的验证集样本中则存入验证集</span><br>                val_images_path.append(img_path)<br>                val_images_label.append(image_class)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 否则存入训练集</span><br>                train_images_path.append(img_path)<br>                train_images_label.append(image_class)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images were found in the dataset.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">sum</span>(every_class_num)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for training.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(train_images_path)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for validation.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(val_images_path)))<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(train_images_path) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;number of training images must greater than 0.&quot;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(val_images_path) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;number of validation images must greater than 0.&quot;</span><br><br>    plot_image = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> plot_image:<br>        <span class="hljs-comment"># 绘制每种类别个数柱状图</span><br>        plt.bar(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data_class)), every_class_num, align=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 将横坐标0,1,2,3,4替换为相应的类别名称</span><br>        plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data_class)), data_class)<br>        <span class="hljs-comment"># 在柱状图上添加数值标签</span><br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(every_class_num):<br>            plt.text(x=i, y=v + <span class="hljs-number">5</span>, s=<span class="hljs-built_in">str</span>(v), ha=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 设置x坐标</span><br>        plt.xlabel(<span class="hljs-string">&#x27;image class&#x27;</span>)<br>        <span class="hljs-comment"># 设置y坐标</span><br>        plt.ylabel(<span class="hljs-string">&#x27;number of images&#x27;</span>)<br>        <span class="hljs-comment"># 设置柱状图的标题</span><br>        plt.title(<span class="hljs-string">&#x27;data class distribution&#x27;</span>)<br>        plt.show()<br><br>    <span class="hljs-keyword">return</span> train_images_path, train_images_label, val_images_path, val_images_label<br><br>data_path = <span class="hljs-string">&quot;D:\data_set&quot;</span> <span class="hljs-comment"># 数据集所在（绝对/相对）路径</span><br>train_images_path, train_images_label, val_images_path, val_images_label = read_split_data(data_path)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>数据集处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>数据集处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2024/03/25/algorithm_know/tree-arr/"/>
    <url>/2024/03/25/algorithm_know/tree-arr/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>首要用途：维护序列的前缀和</p><blockquote><p>对一个序列a，建立一个数组c，其中c[x]保存序列a的区间(x-lowbit(x)+1,x]中所有数的和(前开后必)。</p></blockquote><h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>1.每一个节点x，有c[x]保存着以x为根节点的所有叶节点的和</p><p>2.每个内部节点c[x]的子节点个数等于lowbit（x）的位数</p><p>3.除了树根以外的每个子节点的父节点都是c[x+lowbit(x)];</p><p>4.数的深度为log(N)  &#x2F;&#x2F;N为序列a的长度</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>O(logN)的时间复杂度去实现单点修改和区间查询</li><li>数组下标一定要从1开始</li><li>一个数的二进制表示中末尾有几个0就在第几层</li></ol><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><blockquote><p><code>x &amp; (-x)</code> : 假设 x的二进制数表示 的从右向左数的第一个1所在位为k，则lowbit(x) &#x3D; 2^(k-1)</p></blockquote><blockquote><p>tip: 求 n 的二进制表示的第 k 位(从0开始)数字：<code>n &gt;&gt; k &amp; 1</code></p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>实现单点修改</li><li>实现求前缀和</li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造树状数组的方法</span><br><span class="hljs-comment">// 可以假设原序列a为全0，依次通过“单点修改”操作把每个数加进去，最后就可以形成树状数组了</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> t[N],tr[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-comment">//在原数组的第x个数加上v</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-comment">//注意这里的i是从x开始得</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123; <br>        tr[i] += v; <span class="hljs-comment">//在树状数组第i个位置上加上一个值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//返回原数组前x个数的前缀和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x; i&gt;<span class="hljs-number">0</span>; i-=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        sum += tr[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; t[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">add</span>(i,t[i]); <span class="hljs-comment">//在第i个位置上加上原数组t[i] 构造树状数组</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x<span class="hljs-number">-1</span>) &lt;&lt; endl; <span class="hljs-comment">//求的是[a,b]的必区间</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">add</span>(x,y);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树状数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法 树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>algorithm_know</title>
    <link href="/2024/03/25/algorithm_know/algorithm-know/"/>
    <url>/2024/03/25/algorithm_know/algorithm-know/</url>
    
    <content type="html"><![CDATA[<h1 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h1><h2 id="降低时间复杂度的方法（降低运行时间防止超时）"><a href="#降低时间复杂度的方法（降低运行时间防止超时）" class="headerlink" title="降低时间复杂度的方法（降低运行时间防止超时）"></a>降低时间复杂度的方法（降低运行时间防止超时）</h2><h3 id="使用平方根去约束数的循环范围"><a href="#使用平方根去约束数的循环范围" class="headerlink" title="使用平方根去约束数的循环范围"></a>使用平方根去约束数的循环范围</h3><blockquote><p>应用场景：完全数，质数</p></blockquote><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h2 id="得到某一段数组-l-r-的和，常规循环计算的复杂度为-O-n-，使用前缀和就可以直接使用-S-r-S-l-1-，复杂度为O-1"><a href="#得到某一段数组-l-r-的和，常规循环计算的复杂度为-O-n-，使用前缀和就可以直接使用-S-r-S-l-1-，复杂度为O-1" class="headerlink" title="得到某一段数组 [l,r] 的和，常规循环计算的复杂度为 O(n) ，使用前缀和就可以直接使用 S(r) - S(l-1) ，复杂度为O(1)"></a>得到某一段数组 [l,r] 的和，常规循环计算的复杂度为 O(n) ，使用前缀和就可以直接使用 S(r) - S(l-1) ，复杂度为O(1)</h2><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ol><li>O(log)的时间复杂度去实现单点修改和区间查询</li><li>数组下标一定要从1开始</li><li>一个数的二进制表示中末尾有几个0就在第几层</li></ol><h1 id="2-17"><a href="#2-17" class="headerlink" title="2.17"></a>2.17</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote><p>求 n 的二进制表示的第 k+1 位（计数从1开始）数字：<code>n &gt;&gt; k &amp; 1</code><br><code>n &amp; 1</code> 判断第1位的数字</p></blockquote><p><a href="https://www.acwing.com/problem/content/description/803/">二进制中1的个数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(a[i])&#123;<br>        <span class="hljs-keyword">if</span>((a[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) res++;<br>        a[i] = a[i] &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>返回 n 的最后一位1所对应的值：lowbit(n) &#x3D; n &amp; -n &#x3D; n &amp; (n^(n-1))<br>假设一个数的二进制最低位的1在从右往左数的第k位，那么它的lowbit值就是2^(k-1)<br>树状数组C[x] &#x3D; [x-lowbit(n) , x] 原数组中这段区间的和</p></blockquote><h1 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h1><h2 id="n次方幂"><a href="#n次方幂" class="headerlink" title="n次方幂"></a>n次方幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//负数要先转换成正数去计算n次方根</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-literal">true</span>; <br>        n = -n;<br>    &#125;<br>    <span class="hljs-type">double</span> res = <span class="hljs-built_in">pow</span>(n,(<span class="hljs-type">double</span>)<span class="hljs-number">1</span>/<span class="hljs-number">3</span>); <span class="hljs-comment">//使用求n次幂函数，来求n次方根</span><br></code></pre></td></tr></table></figure><h1 id="3-26"><a href="#3-26" class="headerlink" title="3.26"></a>3.26</h1><h1 id="线段数组"><a href="#线段数组" class="headerlink" title="线段数组"></a>线段数组</h1><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>线段树是一棵平衡二叉树。母结点代表整个区间的和，越往下区间越小</li><li>每个节点p的左右子节点的编号分别为 2p 和 2p+1</li><li>节点p存储区间[l,r]的和，设 mid &#x3D; floor(l+r&#x2F;2) ; 左节点存储[l,mid]的和， 左节点存储[mid+1,r]的和</li></ol><h2 id="建立线段数组"><a href="#建立线段数组" class="headerlink" title="建立线段数组"></a>建立线段数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> sum;<br>&#125;tr[N*<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">//u位节点编号，l和r为区间左右端点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> tr[u] = &#123;l,r,w[l]&#125;; <span class="hljs-comment">//抵达叶子节点，为其赋值</span><br>    <span class="hljs-type">int</span> mid = (l+r) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//向下取整</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u, l, mid); <span class="hljs-comment">//向左子树递归</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//向右子树递归</span><br>    tr[u].sum = tr[<span class="hljs-number">2</span>*u].sum + tr[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].sum <span class="hljs-comment">//递归完左右子树后向上回溯</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><blockquote><p>把区间内的叶子节点相加</p></blockquote><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><blockquote></blockquote><h1 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a>第k小数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> t, n, k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br><span class="hljs-keyword">while</span> (t--) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        list[i] = <span class="hljs-built_in">read</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 将第k小的数放在 k-1 位置，左边的数都比它小，右边的数都比它大，但都是无序的</span><br>    <span class="hljs-built_in">nth_element</span>(list, list + k - <span class="hljs-number">1</span>, list + n);<br>    <span class="hljs-comment">// 由于数据量太大，下面两种方法会超时</span><br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-comment">// sort(list, list + n);</span><br>    <span class="hljs-comment">// 将第k小的数放在 k-1 位置，左边的数都比它小，而且是有序的，右边的数都比它大，但右边是无序的</span><br>    <span class="hljs-comment">// partial_sort(list, list + k - 1, list + n);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, list[k - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>首先，binary_search()函数，作用：对一个不降序列进行二分查找，如果所查找的值在序列中出现了，返回true，没有出现，返回false。</p><p>然后，lower_bound()函数，作用：对一个不降序列进行二分查找，返回第一个大于等于所查找的值的元素下标，注意返回的是指针变量！！！</p><p>最后，upper_bound()函数，作用：对一个不降序列进行二分查找，返回第一个大于所查找的值的元素下标，注意返回的是指针变量！！！</p><h1 id="无穷大和无穷小"><a href="#无穷大和无穷小" class="headerlink" title="无穷大和无穷小"></a>无穷大和无穷小</h1><p>指定一个数为无穷大或无穷小：INT_MIX INT_MAX<br>要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))<br>要把一段内存全部置为无穷小，我们只需要memset(a,0xc0,sizeof(a))</p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map[key] &#x3D; value</p><h2 id="查找map中某个key是否存在-具体位置"><a href="#查找map中某个key是否存在-具体位置" class="headerlink" title="查找map中某个key是否存在&#x2F;具体位置"></a>查找map中某个key是否存在&#x2F;具体位置</h2><blockquote><p>mp.count(key)<br>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0<br>mp.find(key)<br>返回键为key的映射的迭代器 $O(logN) $ 注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()</p></blockquote><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set里面的元素<strong>不重复</strong> 且 <strong>有序</strong></p><h1 id="如何将字符串转换成数字"><a href="#如何将字符串转换成数字" class="headerlink" title="如何将字符串转换成数字"></a>如何将字符串转换成数字</h1><p>String str&#x3D;“2019”;<br>char s[]&#x3D;str.toCharArray();<br>int x&#x3D;0;<br>for(int i&#x3D;0;i&lt;s.length;i++){<br>x&#x3D;x*10+str[i]-‘0’;<br>}</p><h1 id="结构体数组排序"><a href="#结构体数组排序" class="headerlink" title="结构体数组排序"></a>结构体数组排序</h1><p><strong>当数组是从1开始赋值时，sort函数也要加1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin &gt;&gt; a[i].t &gt;&gt; a[i].d &gt;&gt; a[i].l;<br>&#125;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp); <span class="hljs-comment">//由于数组是从1开始赋值的，因此排序函数也要加1 </span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">11</span>];<br>    <span class="hljs-type">int</span> solve;<br>    <span class="hljs-type">int</span> time;<br>&#125;p[<span class="hljs-number">10000</span>];<br><br><span class="hljs-comment">//按照题数，再罚时间，再名字（名字按字典序排列）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; a, <span class="hljs-type">const</span> Student&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.solve != b.solve)<br>     &#123; <br>        <span class="hljs-keyword">if</span> (a.solve &gt; b.solve)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.time != b.time)<br>           <span class="hljs-keyword">return</span> a.time &lt; b.time;<br>    <span class="hljs-keyword">else</span><br>          <span class="hljs-built_in">return</span> (<span class="hljs-built_in">strcmp</span>(a.name, b.name) &lt; <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>      cin&gt;&gt;p[i].name&gt;&gt;p[i].solve&gt;&gt;p[i].time;<br>    <span class="hljs-built_in">sort</span>(p,p+n,cmp);<span class="hljs-comment">//在主函数中调用，结构体排序；</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>      cout&lt;&lt;p[i].name;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="max-element-min-element"><a href="#max-element-min-element" class="headerlink" title="max_element+min_element"></a>max_element+min_element</h2><blockquote><p>返回最大最小值的下标所对应的地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数都是返回地址，需要加*取值</span><br><span class="hljs-type">int</span> indx = <span class="hljs-built_in">max_element</span>(a, a + n) - a;<br><span class="hljs-type">int</span> mx = *<span class="hljs-built_in">max_element</span>(a, a + n);<br><span class="hljs-type">int</span> mn = *<span class="hljs-built_in">min_element</span>(a, a + n);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法小知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>算法小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第三章</title>
    <link href="/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-3/"/>
    <url>/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-3/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第三章"><a href="#计算机网络复习第三章" class="headerlink" title="计算机网络复习第三章"></a>计算机网络复习第三章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>数据链路层的功能是：实现在两个通信实体之间传送数据（以 帧为单位），并通过差错控制方法，使有差错的物理线路变成无差错数据链路。数据链路层使用的信道有2种：广播信道和点对点信道。 数据链路层需要解决的三个基本问题是：封装成帧. 透明传输（如在数据中出现控制字符时加入转义字符）和差错检测（如CRC技术）。</p></li><li><p>10Mbps以太网是基带编码，使用的曼彻斯特编码，是一种自同步的数字信号编码方式，编码效率是50%；通常采用RJ45（非屏蔽双绞线）。</p></li><li><p>虚拟局域网（VLAN）技术是建立在网络交换机之上的，以硬件方式实现逻辑工作组的划分与管理，通常可以根据端口. MAC地址. IP地址等划分VLAN。同一层交换机上不同VLAN之间不能直接通信（需要使用路由器才能通信）</p></li><li><p>网络互联时使用中继器或集线器完成物理层功能，使用网桥或二层交换机完成数据链路层的功能，使用路由器或三层交换机完成网络层的功能。</p></li><li><p>常用的IEEE802协议有802.2—LLC   802.3—10Mbps CSMA&#x2F;CD以太网  802.4—令牌总线 802.5—令牌环，这些协议都属于数据链路层。以太网使用10BASE-T规定从集线器到网卡的最大距离是100米。</p></li><li><p>总线型网络和使用HUB的星型网络，任意时刻只能有一台电脑发送信息；使用SWITCH的星型网络，任意时刻可以有多台电脑发送信息。</p></li><li><p>CSMA&#x2F;CD的中文是多路载波侦听&#x2F;冲突检测，掌握其工作原理并重点掌握：用于在10Mbps以标准太网的信道访问控制，要求数据帧的发送时间是传播时间的2倍，其帧长为64–1518B，其碰撞窗口为51.2us ，总线型以太网可以检测冲突却不能避免冲突，交换型以太网可以避免冲突。发生第K次冲突后，需要等待r*51.2us之后再侦听以决定是否发送，其中r&#x3D;Min（10，x）(x取(0,1,2,3,…2k-1)中任意随机值),最多传送16次。 </p></li><li><p>通常数据在各个层次的名称不同，一般物理层称为比特. 数据链路层称为帧. 网络层称为分组. 传输层称为报文. 余下各层统称为文本。OSI&#x2F;RM协议的层次名称. 上下层次关系，TCP&#x2F;IP协议的层次名称. 上下层关系，以及OSI&#x2F;RM各层次与TCP&#x2F;IP各层次对应关系。VLAN(虚拟局域网)使用的核心设备是二层交换机。</p></li><li><p>教材图3-10的PPP格式（P75）。教材图3-22的以太网格式（P92）</p></li><li><p>CRC计算（教材 图3-8）（P71）</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>数据链路层需要解决的三个基本问题是：封装成帧. 透明传输和差错检测，其中在数据中出现控制字符时加入转义字符属于(   )。<br>2. 完善以太网的MAC帧格式 。</p><ol start="3"><li>以太网中采用的CSMA&#x2F;CD协议是一种能避免冲突的协议。</li><li>在一个二层交换机内划分为3个虚拟网络后，虚拟网络之间不可在本交换机内通信。</li><li>在802.3局域网中，当使用了交换技术后，可避免冲突产生。</li><li>10M以太网的碰撞窗口为51.2us  </li><li>10M以太网的标准是IEEE802.5 。</li><li>10BASE-T标准中使用的电缆为双绞线</li><li>802.3协议中源地址为（）。<br>A. 1字节  B. 4字节    C. 6字节   D. 8字节</li><li>符合OSI参考模型第二层功能的设备，均有一个MAC地址，以太网MAC地址是（）位二进制。<br>A.    64     B. 48     C. 32    D. 8<br>11.交换机是对应OSI参考模型（）的设备。<br>A. 物理层    B. 传输层    C. 网络层  D. 数据链路层<br>12目前局域网中的高端交换机使用双绞线时能适应10M&#x2F;S，100M&#x2F;S，1000M&#x2F;S的速率，依靠（  ）技术。<br>A. 线路交换    B. 令牌控制<br>C. 自动侦测    D. VLAN技术</li><li>以太网交换机不具有的功能是（）。<br>A. 地址学习    B. 数据帧转发<br>C. 路由选择    D. 回路避免</li><li>以下MAC地址哪个是正确的（）<br>A. 004         B.  00DA45<br>C. 210.47.2.34   D. 00AABB0034CC</li><li>虚拟局域网中的核心设备是（）<br>A. 高端交换机   B. 路由器<br>C. 集线器       D. 中继器</li><li>虚拟局域网的技术基础是（）。<br>A. 交换    B. 路由    C.  带宽分配    D. 冲突检测</li><li>在一个数字化的语音系统中，采用256个量化级时，编码时采用（）位。<br>A. 8           B. 7          C. 6        D. 10</li><li>具有冲突检测载波监听多路访问CSMA&#x2F;CD技术，不适用于（）。<br>A. 总线型网络    B. 星型网络<br>C. 树型网络      D. 环型网络</li><li>IEEE802.3标准中，MAC帧的帖起始定界符是（）。<br>A.  01111111（左低右高）  B. 11101011（左低右高）<br>C.  01111110（左低右高）  D. 10101011（左低右高）</li><li>CSMA&#x2F;CD协议只适用于（）。<br>A. 局域网  B. 广域网    C. 城域网    D. 以上全部</li><li>IEEE802.3中10BASE-T规定从集线器到网卡的最大距离是（）。<br>A. 50米     B. 100米      C. 200米     D. 500米</li><li>数据链路层需要解决的三个基本问题是：封装成帧. 透明传输和差错检测，其中CRC技术属于（  ）。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>透明传输</li><li>类型</li><li>T</li><li>T</li><li>T</li><li>T</li><li>F</li><li>T</li><li>C</li><li>B</li><li>D</li><li>C</li><li>C</li><li>D</li><li>A</li><li>A</li><li>A</li><li>C</li><li>D</li><li>A</li><li>B</li><li>差错检测</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第二章</title>
    <link href="/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-2/"/>
    <url>/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-2/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第二章"><a href="#计算机网络复习第二章" class="headerlink" title="计算机网络复习第二章"></a>计算机网络复习第二章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>物理层确定与传输媒体的接口有关的特性是机械特性.电气特性.功能特性和过程特性。</p></li><li><p>根据信号中代表消息的参数的取值方式不同，信号可以分为2大类，模拟信号和数字信号。从通信的双方信息的交互方式来区分，可以有三种基本方式：单工通信（只能有一个方向的通信而没有反方向的交互）.半双工通信（通信的双方都可以发送信息，但不能双方同时发送）和全双工通信（通信的双方都可以发送信息，而且双方能同时发送）。</p></li><li><p>复用方式有：频分复用（FDM）.时分复用(TDM).码分复用(CDM)和波分复用(WDM)多种，在一根光纤上复用多路光载波信号称为波分复用，利用信号频率的不同来实现电路复用的方法是频分复用，利用信号的不同时间发送来实现电路复用的方法是时分复用。</p></li><li><p>10Mbps以太网是基带编码，使用的曼彻斯特编码，是一种自同步的数字信号编码方式，编码效率是50%；通常采用RJ45（非屏蔽双绞线）。</p></li><li><p>在脉码调制PCM过程中要经过采样.量化.编码三个过程。T1和E1技术都是基本的将模拟信号转为数字信号的方法，目前我国使用的是欧洲的E1标准，E1速率是2.048Mbps，T1的速率是1.544Mbps，这两种方法都使用时分复用。</p></li><li><p>传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。一个数据通信系统包括三大部分：源系统（或发送端.发送方）.传输系统（或传输网络）和目的系统（或接收端.接收方）。</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>通常一个通信系统可以划分为三大部分，即源系统（或发送端.发送方）.(   )和目的系统（或接收方.接收端）。</p></li><li><p>从通信的双方信息的交互方式来区分，可以有三种基本方式：单工通信.半双工通信和(   )。</p></li><li><p>传输媒体是数据传输系统中在发送器和接收器之间的物理通道，可以分为导向传输媒体和非导向传输媒体。无线电波属于(   )。</p></li><li><p>多个通信设备共享一个信道进行通信称为信道复用，不同的用户占用不同的带宽资源称为(   )。</p></li><li><p>在PCM调制过程中要经过量化.采样.编码三个过程。</p></li><li><p>在数据传输过程中，差错主要是由通信过程中的噪声引起的。</p></li><li><p>ADSL技术中，上行通道和下行通道的传输速率不对称。</p></li><li><p>在电路交换.分组交换与报文交换方式中，都要经过线路建立.数据传输.线路释放这3个过程。</p></li><li><p>两台计算机通过电话网通信时必须使用的设备是（）。<br>A. 调制解调器  B.网线.C.中继器    D.集线器</p></li><li><p>常用的传输介质中，带宽最大.信号传输衰减最小.抗干扰能力最强的是（）。<br>A.光纤    B.双绞线     C.同轴电缆     D.无线信道</p></li><li><p>利用信号频率的不同来实现电路复用的方法是（）。<br>A.频分多路复用   B.时分多路复用<br>C.码分多路复用   D.以上都不对</p></li><li><p>在物理层中，指明在接口电缆的各条线上出现的电压范围，属于（）。<br>A.机械特性   B.电气特性  C.功能特性   D.过程特性</p></li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>传输系统</li><li>全双工通信</li><li>非导向传输媒体</li><li>频分复用</li><li>F</li><li>T</li><li>T</li><li>F</li><li>A</li><li>A</li><li>A</li><li>B</li></ol>]]></content>
    
    
    <categories>
      
      <category>期末复习</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>期末复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第一章</title>
    <link href="/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-1/"/>
    <url>/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-1/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第一章"><a href="#计算机网络复习第一章" class="headerlink" title="计算机网络复习第一章"></a>计算机网络复习第一章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>为网络中的数据交换而建立的规则.标准或约定称为网络协议，网络协议由三部分组成：语法（数据与控制信息的结构或格式）.语义（需要发出何种控制信息，完成何种动作以及做出何种响应）.同步（事件实现顺序的详细说明）。</p></li><li><p>Arpanet是Internet的前身，对因特网发展起到很大作用。Internet是通过路由器将多个LAN或WAN相连接形成。</p></li><li><p>计算机网络向用户提供的最重要的功能有2个：连通性和共享</p></li><li><p>所有因特网标准都是以RFC形式在因特网上发表。RFC的意思是“请求评论”</p></li><li><p>因特网从其工作方式上看，可以划分为2大块：边缘部分（由连接在因特网上的主机组成，这部分是用户直接使用的，用来进行通信和资源共享）和核心部分（由大量网络和连接这些网络的路由器组成，这部分为边缘部分提供服务，提供连通性和交换）</p></li><li><p>三网合一是指电信语音 .有线电视网和计算机网络的结合。</p></li><li><p>常用的交换方式有电路.报文和分组。在电路交换方式中要经过线路建立.数据传输.线路释放三个过程。而分组交换和报文交换不需要，因为每个分组都需要被独立进行确定“路由”处理，所以可能存在“后发先至”的现象。计算机网络通常采用分组交换方式。</p></li><li><p>网络通信常用的3种交换方式是电路交换（整个报文的比特流连续地从源点直达终点，好像在一个管道中传送）.报文交换（整个报文先送到相邻节点，全部存储下来后查找转发表，转发到下一节点）和分组交换（单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一节点）。计算机网络采用的交换方式属于分组交换。</p></li><li><p>时延是计算机网络的性能指标之一，指的是数据从网络的一端传输到另一端所需的时间，通常包括发送时延（主机或路由器发送数据帧所需要的时间，也称为传输时延。发送时延&#x3D;数据帧长度&#x2F;发送速率）.传播时延（电磁波在信道中传播一定的距离所需要的时间，在自由空间的传播速率约为3.0<em>105km&#x2F;s，在铜线电缆中的传播速率约为2.3</em>105km&#x2F;s, 在光纤中的传播速率约为2.0*105km&#x2F;s。传播时延&#x3D;信道长度&#x2F;电磁波在信道上传输速率）.处理时延（主机或路由器在收到分组是需要花费一定的时间进行处理）和排队时延（分组在进入路由器后在输入队列中等待处理）。</p></li><li><p>OSI的体系结构由7层组成，从上到下分别是：应用层.表示层.会话层.运输层.网络层.数据链路层.物理层。TCP&#x2F;IP协议由4层组成，从上向下分别为应用层.运输层.网际层（IP）和网络接口层。掌握OSI&#x2F;RM协议的各层次名称.顺序及与TCP&#x2F;IP协议的对应关系。教材图1-18</p></li><li><p>按距离进行分类，可将网络分为广域网.城域网和局域网，掌握其距离范围</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>假定有一个10MB的数据块，在带宽为1Mb&#x2F;s的信道上连续发送，其发送时延是_____s。</li><li>因特网从其工作方式上看，可以划分为2大块：用来进行通信和资源共享属于边缘部分。提供连通性和交换的属于(   )。</li><li>网络通信有3种交换方式。其中【单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一节点】属于(   )（请说明名称，不能说第一种、第二种或第三种）。</li><li>时延是计算机网络的性能指标之一，指的是数据从网络的一端传输到另一端所需的时间。其中的传播时延是指电磁波在信道中传播一定的距离所需要的时间，通常在铜线电缆中其传播速率约为(   )km&#x2F;s。</li><li>所有因特网标准都是以(   )形式在因特网上发表。其意思是“请求评论”。</li><li>网络协议由三部分组成：语法、语义和同步，其中需要发出何种控制信息，完成何种动作以及做出何种响应属于(   )。</li><li>OSI的体系结构由7层组成，从下向上，第六层是(   )。</li><li>TCP&#x2F;IP协议由4层组成，从上向下，UDP是属于(   )。</li><li>电磁波在光纤中传播的速率大约为2.0*105km&#x2F;s,长度为1000km的光纤传播时延是（    ）s。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>83.89</li><li>核心部分</li><li>分组交换</li><li>2.3*105km&#x2F;s</li><li>RFC</li><li>语义</li><li>表示层</li><li>运输层</li><li>0.005</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first-test-blog</title>
    <link href="/2024/03/25/first-test-blog/"/>
    <url>/2024/03/25/first-test-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一个测试博客"><a href="#这是一个测试博客" class="headerlink" title="这是一个测试博客"></a>这是一个测试博客</h1><h1 id="浅浅许个愿：保研上岸"><a href="#浅浅许个愿：保研上岸" class="headerlink" title="浅浅许个愿：保研上岸"></a>浅浅许个愿：保研上岸</h1>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>保研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>保研</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
