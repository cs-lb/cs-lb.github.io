<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>注意力机制</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><blockquote><p>通道注意力（Channel Attention），空间注意力（Spatial Attention），分支注意力（Branch Attention），自注意力（Self Attention）和交叉注意力（Cross Attention）</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>激活函数</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习超参数的介绍</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B6%85%E5%8F%82%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B6%85%E5%8F%82%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习超参数的介绍"><a href="#深度学习超参数的介绍" class="headerlink" title="深度学习超参数的介绍"></a>深度学习超参数的介绍</h1><h2 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习模型微调</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习模型微调（Fine-tuning）"><a href="#深度学习模型微调（Fine-tuning）" class="headerlink" title="深度学习模型微调（Fine-tuning）"></a>深度学习模型微调（Fine-tuning）</h1><p>由于在很多任务场景下，所能够使用到的数据集往往样本较少，这个时候就会思考能不能使用一些在较大数据集（如ImageNet）上训练好的模型，对其进行微调，进而运用在自己的领域任务上，即迁移学习和模型微调</p><ol><li>微调时通常使用更强的正则化、更小的学习率、更少的数据迭代</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><ol><li>矩阵SVD分解</li><li>矩阵能够相似对角化的充要条件</li><li>讲一讲SVM的原理</li><li>对特征值和特征向量的理解</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch</title>
    <link href="/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/"/>
    <url>/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/</url>
    
    <content type="html"><![CDATA[<h1 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h1><h2 id="两大法宝"><a href="#两大法宝" class="headerlink" title="两大法宝"></a>两大法宝</h2><ol><li>dir 打卡工具箱 <code>dir(torch.cuda)</code></li><li>help 查看具体函数的使用方式 <code>help(torch.cuda.is_available)</code></li></ol><h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><blockquote><p>提供一种方式去获取数据及其label，以及数据集的大小</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image <span class="hljs-comment"># 图像操作（open、show）</span><br><span class="hljs-keyword">import</span> os  <span class="hljs-comment">#文件操作</span><br><br><span class="hljs-comment"># 继承Dataset类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-comment"># 通过定义一个特殊的__init__方法，在创建实例的时候，把所需要的属性绑上去</span><br>    <span class="hljs-comment"># 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self</span><br>    <span class="hljs-comment"># __init__方法的第一个参数永远是self，表示创建的实例本身</span><br>    <span class="hljs-comment"># 因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,root_dir,label_dir</span>):<br>        self.root_dir = root_dir<br>        self.label_dir = label_dir<br>        self.path = os.path.join(root_dir,label_dir)<br>        self.img_path = os.listdir(self.path) <span class="hljs-comment">#返回指定path路径文件夹中图片名称组成的列表</span><br><br>    <span class="hljs-comment"># 当实例对象做P[key]运算时，就会调用类中的__getitem__()方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        img_name = self.img_path[idx]<br>        img_item_path = os.path.join(root_dir,label_dir,img_name)<br>        <span class="hljs-built_in">print</span>(img_item_path)<br>        img = Image.<span class="hljs-built_in">open</span>(img_item_path)<br>        img.show()<br>        label = self.label_dir<br>        <span class="hljs-keyword">return</span> img, label<br><br>    <span class="hljs-comment"># 当使用len(p)时，就会调用类中的__len__()方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_path)<br><span class="hljs-comment"># 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去</span><br><br>root_dir = <span class="hljs-string">&#x27;D:\ADNI_classify _v-3.0\ADCNMCI\\train&#x27;</span><br>label_dir = <span class="hljs-string">&#x27;AD&#x27;</span><br>ad_dataset = MyData(root_dir,label_dir)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(ad_dataset))<br><br></code></pre></td></tr></table></figure><h3 id="tensorboard"><a href="#tensorboard" class="headerlink" title="tensorboard"></a>tensorboard</h3><blockquote><p>可视化训练过程的数据</p></blockquote><ol><li><code>add_image()</code></li><li><code>add_scalar</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 参数：title；y轴数值；x轴数值</span><br>writer.add_scalar(<span class="hljs-string">&quot;y=2x&quot;</span>, <span class="hljs-number">2</span>*i, i)<br><br><span class="hljs-comment"># tag：是保存图的标题</span><br><span class="hljs-comment"># img_tensor：图片变量名,图片的类型要是torch.Tensor, numpy.array, or string这三种</span><br><span class="hljs-comment"># global_step：第几张图片</span><br><span class="hljs-comment"># dataformats=‘CHW’，默认CHW，tensor是CHW，numpy是HWC</span><br>writer.add_image(tag,img_tensor,global_step,dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="Dataloader"><a href="#Dataloader" class="headerlink" title="Dataloader"></a>Dataloader</h3><blockquote><p>为后面的网络提供不同的数据形式</p></blockquote><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h2 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h2><ol><li><code>torchvision.transforms.ToTensor()</code><br>在使用 transforms.ToTensor() 进行图片数据<strong>转换过程中会对图像的像素值进行正则化</strong>，即一般读取的图片像素值都是8 bit 的二进制，那么它的十进制的范围为 [0, 255]，而正则化会对每个像素值除以255，也就是把像素值正则化成 [0.0, 1.0]的范围<br><strong>意义：</strong>将图片表示为数字化的数据，方便神经网络进行处理和学习</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库学习</title>
    <link href="/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库学习"><a href="#数据库学习" class="headerlink" title="数据库学习"></a>数据库学习</h1><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><ol><li>数据库作用是组织并存储数据</li><li>数据组织形式：库 -&gt; 表 -&gt; 数据</li></ol><h2 id="SQL学习"><a href="#SQL学习" class="headerlink" title="SQL学习"></a>SQL学习</h2><p>sql密码： 123456</p><ol><li><p>登录本地的数据库 mysql -u（用户名） -p（密码）<br><code>MySQL -uroot -p123456</code></p></li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/23/%E8%AE%BA%E6%96%87/"/>
    <url>/2024/04/23/%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="AD论文"><a href="#AD论文" class="headerlink" title="AD论文"></a>AD论文</h1><h2 id="方法部分："><a href="#方法部分：" class="headerlink" title="方法部分："></a>方法部分：</h2><p>（1）数据预处理阶段：</p><ol><li><p>使用freesufer进行去颅骨</p></li><li><p>灰度图变RGB图：将输入的灰度图像张量 t 沿着通道维度重复三次<code>repeat(3,1,1)</code>，从而得到一个 RGB 图像张量</p></li><li><p>将输入图像调整大小为 256x256 像素，然后，对调整大小后的图像进行中心裁剪，保留图像中心区域 224x224 像素，最后，将图像数据转换为 PyTorch 的 Tensor 格式并对图像进行标准化处理。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">transforms.RandomResizedCrop(<span class="hljs-number">224</span>)<br><span class="hljs-comment">#这个操作会随机裁剪输入图像至指定大小（这里是224x224）。它通过在训练过程中随机裁剪和调整图像大小来进行数据增强。</span><br><br>transforms.RandomHorizontalFlip()<br><span class="hljs-comment">#这个操作以0.5的概率随机水平翻转输入图像。水平翻转是一种常见的数据增强技术，有助于提高模型的泛化能力。</span><br><br>transforms.ToTensor()<br><span class="hljs-comment">#这个操作将输入图像转换为PyTorch张量。神经网络通常使用张量作为输入数据。</span><br><br>transforms.Lambda(duplicate_channels)<br><span class="hljs-comment">#这个操作将自定义的lambda函数duplicate_channels应用于输入图像。该函数很可能在代码的其他地方定义，并用于复制通道或重塑张量。</span><br><br>transforms.Normalize([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br><span class="hljs-comment">#这个操作将张量进行归一化处理，通过减去每个通道的均值[0.5, 0.5, 0.5]并除以标准差[0.5, 0.5, 0.5]。归一化是一种常见的预处理步骤，有助于稳定训练并改善收敛性。</span><br></code></pre></td></tr></table></figure><p>（2）进入到LP阶段：</p><ol><li>输入图像先卷积，池化得到小维度特征图，然后再展平再转置得到一个token向量</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">self.LP = nn.Sequential(<br>    nn.Conv2d(in_c, in_c, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>),<br>    nn.BatchNorm2d(in_c),<br>    nn.ReLU(),<br>    nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>), <span class="hljs-comment"># 8,3,112,112</span><br>    nn.Conv2d(in_c, embed_dim, kernel_size=patch_size, stride=patch_size), <span class="hljs-comment"># h=16=(112-F)/s+1</span><br>)<br><br>self.proj = nn.Conv2d(in_c, embed_dim, kernel_size=patch_size, stride=patch_size) <span class="hljs-comment"># 创建一个 nn.Conv2d 的实例，作为嵌入层，用于将输入图像进行卷积处理</span><br>self.norm = norm_layer(embed_dim) <span class="hljs-keyword">if</span> norm_layer <span class="hljs-keyword">else</span> nn.Identity() <span class="hljs-comment"># 归一化层 norm，通过传入 embed_dim 的参数作为通道数，进行归一化操作</span><br></code></pre></td></tr></table></figure><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><ol><li><p>评价指标</p><ul><li>准确度（accuary）</li><li><strong>灵敏度&#x2F;召回率（sensitivity&#x2F;recall）</strong>，即模型正确识别出的正例占所有实际正例的比例 （TP &#x2F; TP + FN）</li><li><strong>特异性（specificity）</strong>，即模型正确识别出的负例占所有实际负例的比例 （TN &#x2F; TN + FP）</li><li>精确率（precise），即模型正确预测正例的概率（TP &#x2F; FP + TP）</li><li>漏诊（FN），也叫假阴性</li><li>误诊（FP），也叫假阳性</li><li>漏诊对应着模型的灵敏度（Sensitivity&#x2F;Recall），而误诊对应着模型的特异性（Specificity）。提高灵敏度有助于减少漏诊的风险，而提高特异性有助于减少误诊的风险。</li><li>综合度量评估精确率和召回率，使用F1评估</li><li>ROC（Receiver Operating Characteristic）Curve，受试者工作特征曲线。不同分类阈值下的真正类率（TPR）和假正类率（FPR）构成的曲线</li><li>AUC（Area Under the ROC Curve），ROC曲线下的面积。AUC越大，分类模型效果越好。</li></ul></li><li><p>实验设置<br>我们使用Python 3.11.2和Pytorch 2.1.1来实现所提出的方法。<br>采用随机梯度下降（SGD）方法对训练参数进行更新，动量设置为0.9，权值衰减参数设置为0.00005。<br>训练周期和批处理大小被设置为100和8。我们将初始学习率设置为0.001，并使用余弦退火算法进行训练，该算法使用余弦函数调整每个epoch内学习率的大小。<br>所有的实验都是在使用NVIDIA GeForce GTX 1080Ti图形和64GB内存的计算机上进行的。</p></li><li><p>数据集<br> 220 CN participants, 310 MCI patients, and 255 AD patients from the ADNI</p></li></ol><p><strong>对准确度的影响</strong></p><ol><li><p>删除权重会提高准确度 ???</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">del_keys = [<span class="hljs-string">&#x27;head.weight&#x27;</span>, <span class="hljs-string">&#x27;head.bias&#x27;</span>] <span class="hljs-keyword">if</span> model.has_logits \<br>    <span class="hljs-keyword">else</span> [<span class="hljs-string">&#x27;head.weight&#x27;</span>, <span class="hljs-string">&#x27;head.bias&#x27;</span>]<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> del_keys:<br>    <span class="hljs-keyword">del</span> weights_dict[k]<br><br></code></pre></td></tr></table></figure></li><li><p>不进行权重冻结，其准确度会高一点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">parser.add_argument(<span class="hljs-string">&#x27;--freeze-layers&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bool</span>, default=<span class="hljs-literal">False</span>)<br><br><span class="hljs-keyword">if</span> args.freeze_layers:<br>    <span class="hljs-keyword">for</span> name, para <span class="hljs-keyword">in</span> model.named_parameters():<br>        <span class="hljs-comment"># 除head, pre_logits外，其他权重全部冻结</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;head&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> name <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;pre_logits&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> name:<br>            para.requires_grad_(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;training &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name))<br></code></pre></td></tr></table></figure></li></ol><h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><h4 id="卷积层和transfomer在提取特征上的区别"><a href="#卷积层和transfomer在提取特征上的区别" class="headerlink" title="卷积层和transfomer在提取特征上的区别"></a>卷积层和transfomer在提取特征上的区别</h4><ol><li><p>卷积层</p><ul><li><p><strong>特征提取原理</strong>：卷积层通过卷积操作<strong>在局部感受野内</strong>提取特征。卷积操作是一种有效的<strong>局部连接操作</strong>，它通过滤波器（卷积核）在输入数据上滑动，将输入数据与滤波器进行卷积运算，从而提取出局部特征。</p></li><li><p>卷积层在图像处理等领域表现出色，因为图像数据具有<strong>局部相关性</strong>和<strong>平移不变性</strong>，卷积操作可以有效地捕捉这些特征。</p><ul><li>局部相关性：相邻像素之间具有较高的相关性，这意味着在图像的局部区域内，像素之间的数值变化不会太大</li><li>平移不变性：无论图像中的物体位置如何变化，我们仍然能够正确地识别和理解图像中的内容</li></ul></li><li><p>其<strong>参数共享</strong>和<strong>局部连接</strong>的特性使得模型具有较少的参数量和更强的泛化能力。</p><ul><li>参数共享：在整个输入数据的不同位置使用相同的滤波器（卷积核参数）参数。这样可以大大减少模型的参数量，使得模型更加轻量化，同时也有利于提高模型的泛化能力，因为参数共享使得模型可以从不同位置学习到相似的特征。</li><li>滤波器只与输入数据的局部区域进行卷积计算，而不是与整个输入数据进行计算。这种局部连接的方式能够捕捉到输入数据中的局部特征，也有利于减少计算量</li></ul></li></ul></li><li><p>transformer</p><ul><li>Transformer是一种基于自注意力机制（Self-Attention Mechanism）的模型，它<strong>通过对输入序列中各个位置之间的关系进行建模来提取特征</strong>。Transformer中的自注意力机制可以捕捉序列中任意两个位置之间的长程依赖关系，从而有效地提取序列特征</li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>联系导师经验总结</title>
    <link href="/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%81%94%E7%B3%BB%E5%AF%BC%E5%B8%88%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%81%94%E7%B3%BB%E5%AF%BC%E5%B8%88%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>夏令营经验贴总结</title>
    <link href="/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="夏令营经验贴总结"><a href="#夏令营经验贴总结" class="headerlink" title="夏令营经验贴总结"></a>夏令营经验贴总结</h1><h1 id="面试经验"><a href="#面试经验" class="headerlink" title="面试经验"></a>面试经验</h1><ol><li>引导性面试<blockquote><p>把老师往自己会的方向去引</p></blockquote></li><li></li></ol><h1 id="生物医学工程"><a href="#生物医学工程" class="headerlink" title="生物医学工程"></a>生物医学工程</h1><p><a href="https://graduate.pumc.edu.cn/zsw/info/1006/1802.htm">夏令营通知</a></p><ol><li>北京协和医学院生物医学工程研究所 （弱com）<br>协和也是笔试面试两个环节。笔试分两部分，一部分是简答，一部分是文献翻译。简答是中文的，6道题选3个作答，有生物也有ai。比如会问ai如何跟生物医学结合这种问题。面试是先抽一篇短文进行翻译，然后就是常规的问项目，计算机专业的不用太担心不懂医学，老师们有做ai的，一般都是会结合你的项目问你本专业的知识，跟其他面试差别不大。然后会问你未来的规划这种开放性问题。<strong>协和要求夏令营面试必须填意向导师</strong></li></ol><h1 id="投递参考"><a href="#投递参考" class="headerlink" title="投递参考"></a>投递参考</h1><p><img src="/../../img/%E6%8A%95%E9%80%92%E5%8F%82%E8%80%83%E8%A1%A8.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小程序开发问题汇总</title>
    <link href="/2024/04/22/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/22/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="小程序开发遇到的问题"><a href="#小程序开发遇到的问题" class="headerlink" title="小程序开发遇到的问题"></a>小程序开发遇到的问题</h1><blockquote><ul><li>通过slider改变自动播放的间隔时间时，即使没有打开自动播放，也会使得轮播图开始自动播放</li></ul></blockquote><h2 id="页面下拉刷新"><a href="#页面下拉刷新" class="headerlink" title="页面下拉刷新"></a>页面下拉刷新</h2><blockquote><p>1.开启下拉刷新 ，在页面的<code>.json</code>文件中将enablePullDownRefresh 设置为true<br>2.监听页面的下拉刷新事件：onPullDownRefresh<br>3.停止下拉刷新效果：调用wx.stopPullDownRefresh()函数即可</p></blockquote><h2 id="页面上拉触底"><a href="#页面上拉触底" class="headerlink" title="页面上拉触底"></a>页面上拉触底</h2><blockquote><p>1.下拉触底刷新事件：onReachBottom<br>2.通过.json文件的<code>onReachBottomDistance</code>属性来配置上拉触底的距离（默认是50px）</p></blockquote><h2 id="小程序生命周期"><a href="#小程序生命周期" class="headerlink" title="小程序生命周期"></a>小程序生命周期</h2><blockquote><p>onLoad-&gt;onShow-&gt;onReady-&gt;onHide-&gt;onUnLoad</p></blockquote><h2 id="小程序常用API"><a href="#小程序常用API" class="headerlink" title="小程序常用API"></a>小程序常用API</h2><blockquote><p>显示消息提示框 wx.showToast({title:’ ‘, icon:’ ‘,duration:’ ‘})<br>显示对话框： wx.showModel<br>显示loading提示框：wx.showLoading, 关闭loading提示框：wx.hideLoading<br>页面路由API</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++内存分区</title>
    <link href="/2024/04/22/C-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    <url>/2024/04/22/C-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="C-内存分区模型"><a href="#C-内存分区模型" class="headerlink" title="C++内存分区模型"></a>C++内存分区模型</h2><p><strong>程序运行前划分为代码区和全局区，程序运行后分为栈区和堆区</strong></p><blockquote><ul><li>全局区：全局变量，静态变量（static关键字），常量（字符串常量 和 const修饰的全局常量）</li><li>栈区：由编译器自动分配释放，存放着函数的参数值，局部变量等，注意不要返回局部变量的地址</li><li>堆区：由程序员分配释放，若程序员不释放，程序结束后将由操作系统回收</li></ul></blockquote><h3 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h3><blockquote><ul><li>利用new运算符可以将数据开辟到堆区：<code>int *p = new int(10)</code></li><li>new运算符返回的是数据在栈中的地址</li><li>利用 <code>delete</code>  可以释放堆区数据（<code>delete p</code> ）</li></ul></blockquote><p>开辟数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">let* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>    arr[ i ] = i + <span class="hljs-number">100</span>;<br> &#125;<br> <span class="hljs-comment">//释放数组</span><br> <span class="hljs-keyword">delete</span>[ ] arr<br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h3><blockquote><ul><li>作用：给变量起别名</li><li>基本语法：数据类型 &amp;别名 &#x3D; 原名（ int &amp;b &#x3D; a ）</li><li>引用一定要初始化，且之后不能再更改了</li><li>函数参数的引用传递，形参也会修饰实参</li></ul></blockquote><h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h3><blockquote><p>类的默认访问权限是private</p></blockquote><table><thead><tr><th>权限名</th><th>描述</th></tr></thead><tbody><tr><td>public</td><td>类的内外都可以访问</td></tr><tr><td>protected</td><td>只有类内可以访问，且可以被继承</td></tr><tr><td>private</td><td>只有类内可以访问，且不可以被继承</td></tr></tbody></table><p><strong>成员属性私有化</strong><br>1.可以自己控制读写权限<br>2.对于写可以检测数据的有效性</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>构造函数语法：<code>名（）&#123; &#125;</code></p><blockquote><ul><li>1.构造函数，没有返回值也不写void</li><li>2.构造函数名称应与类名相同</li><li>3.构造函数可以有参数，也可以重载</li><li>4.程序在调用对象时会自动调用构造函数</li></ul></blockquote><p>析构函数语法：<code>（）&#123; &#125;</code></p><blockquote><ul><li>1.析构函数，没有返回值也不写void</li><li>2.析构函数名称应与类名相同，在名称前加上 ~</li><li>3.析构函数不可以有参数</li><li>4.程序在对象被销毁时会自动调用析构函数</li></ul></blockquote><h2 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝&amp;浅拷贝"></a>深拷贝&amp;浅拷贝</h2><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><blockquote><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外访问</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/2024/04/22/Vue/"/>
    <url>/2024/04/22/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><strong>初识Vue：</strong><br>1.想要Vue工作，就必须要创建一个Vue实例，且要传入一个配置对象<br>2.demo容器里的代码任然符合html规范，只不过加入了一些Vue语法<br>3.demo容器里的代码被称为【Vue模板】<br>4.Vue实例和容器是一一对应的<br>5.真实开发中只会有一个Vue实例，并且会配合着组件一起使用<br>6.中的xxx要写js表达式，且xxx会自动读取到data里的所有属性<br>7.一旦data中的数据发生改变，那么页面中用到该数据的地方都会自动更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;初识Vue&lt;/title&gt;<br>    &lt;!-- 修改页签icon logo --&gt;<br>    &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;../images/vue.png&quot;&gt;&lt;/link&gt;<br>    &lt;!-- 引入vue --&gt;<br>    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    // 准备一个容器<br>    &lt;div class=&quot;demo&quot;&gt;<br>        &lt;h1&gt;今天是&#123;&#123;date&#125;&#125;,这是&#123;&#123;name&#125;&#125;的第一个vue程序&lt;/h1&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示<br>        console.log(Vue.config)<br>            //创建Vue实例<br>        new Vue(&#123;<br>            el: &#x27;.demo&#x27;,<br>            data: &#123;<br>                date: &#x27;2022/8/11&#x27;,<br>                name: &#x27;jyd&#x27;<br>            &#125;<br>        &#125;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h3><blockquote><p>用于解析标签体内容<br>写法：,xxx是js表达式，且xxx会自动读取到data里的所有属性</p></blockquote><h3 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h3><blockquote><p>用于解析标签（包括：标签属性，标签体内容，绑定事件…）<br>举例：v-bind:href&#x3D;”xxx” 或 简写为 <strong>:href&#x3D;”xxx”</strong> ,xxx同样要写出js表达式的形式<br>Vue中有很多指令，都是v-xxx</p></blockquote><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>Vue中有两种数据绑定的方式：<br>1.单向绑定（v-bind）：数据只能从 data 流向页面<br>2.双向绑定（v-model）：数据不仅能从data流向页面，还可以从页面流向 data</p><blockquote><p>双向绑定一般只应用在表单类元素上（如：input, select）<br>v-model:value 可以简写成 <strong>v-model</strong> ，因为v-model默认收集的就是value值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-<span class="hljs-attr">model</span>:value=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="el和data的两种写法"><a href="#el和data的两种写法" class="headerlink" title="el和data的两种写法"></a>el和data的两种写法</h2><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><blockquote><p>通过一个对象代理对另一个对象中的属性的操作（读&#x2F;写）<br>1.Vue中的数据代理：通过 vm 对象来代理data中属性的操作<br>2.Vue中数据代理的好处：更加方便地操作data中的数据<br>3.基本原理：<br>    通过<strong>Object.defineProperty()</strong> 把data对象中的所有属性都添加到vm上<br>    为每一个添加到vm上的属性，都指定一个getter&#x2F;setter<br>    在getter&#x2F;setter 内部去操作（读&#x2F;写）data中对应的属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>何为数据代理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">let</span> obj2 = &#123;<span class="hljs-attr">y</span>:<span class="hljs-number">200</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 给obj2添加了x属性，实际指向obj.x</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 通过修改obj2.x的值达到修改obj.x的值</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 这就是数据代理，obj2成为了obj的代理对象</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj2,<span class="hljs-string">&#x27;x&#x27;</span>,&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-keyword">return</span> obj.<span class="hljs-property">x</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    obj.<span class="hljs-property">x</span> = value</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><blockquote><p>事件的基本使用：</p><ul><li>1.使用v-on:xxx 或 <strong>@xxx 绑定事件</strong> ，其中xxx是事件名</li><li>2.事件的回调需要配置在 <strong>methods 对象</strong>中，最终会在vm上</li><li>3.methods 中配置的函数 ，不要用箭头函数！ 否则this就不是vm了</li><li>4.methods 中配置的函数 ，都是被Vue所管理的对象，this的指向是vm 或 组件实例对象</li><li>5.@click&#x3D;”demo” 和 @click&#x3D;”demo($event)” 效果一致，但后者可以传参</li></ul></blockquote><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><table><thead><tr><th>事件修饰符</th><th>作用</th></tr></thead><tbody><tr><td>prevent</td><td>阻止默认事件</td></tr><tr><td>stop</td><td>阻止冒泡</td></tr><tr><td>once</td><td>事件只触发一次</td></tr><tr><td>capture</td><td>使用时间的捕获机制</td></tr><tr><td>self</td><td>只有event.target是当前元素时才触发事件</td></tr><tr><td>passive</td><td>事件的默认行为立即执行，无需等待事件回调执行完毕</td></tr></tbody></table><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>1.Vue常用按键别名：</p><table><thead><tr><th>按键</th><th>别名</th></tr></thead><tbody><tr><td>回车</td><td>enter</td></tr><tr><td>删除</td><td>delete</td></tr><tr><td>退出</td><td>esc</td></tr><tr><td>空格</td><td>space</td></tr><tr><td>换行</td><td>tab</td></tr><tr><td>上</td><td>up</td></tr><tr><td>下</td><td>down</td></tr><tr><td>左</td><td>left</td></tr><tr><td>右</td><td>right</td></tr><tr><td>2.Vue中未提供别名的按键，可以使用原始的key值去绑定，但是部分键位要把key值转换为kebab-case（短横线命名），如（CapsLock &#x3D;&gt; caps-lock）</td><td></td></tr><tr><td>3.系统修饰键（用法特殊）：cltr、alt、shift、meta</td><td></td></tr><tr><td>(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发</td><td></td></tr><tr><td>(2).配合keydown使用：正常触发事件</td><td></td></tr><tr><td>4.Vue.config.keyCodes.自定义键名 &#x3D; 键码，可以自定义按键别名</td><td></td></tr></tbody></table><h2 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a>计算属性与监视</h2><h3 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性(computed)"></a>计算属性(computed)</h3><blockquote><ul><li>定义：通过已有属性计算得来</li><li>原理：底层借助了Object.defineProperty()方法提供的getter和setter</li><li>getter函数执行时机：初次读取执行一次 和 当依赖的数据发生改变时会被再次调用</li><li>优势：与methods相比内部有缓存机制（复用），效率更高，调试方便</li><li><ul><li>计算属性最终会出现在 vm 上，直接读取即可</li></ul></li><li><ul><li>如果计算属性要被修改，那必须写set函数去响应修改，在set中将计算属性所依赖的那些data数据进行相应改变</li></ul></li></ul></blockquote><h3 id="监视属性-watch"><a href="#监视属性-watch" class="headerlink" title="监视属性(watch)"></a>监视属性(watch)</h3><blockquote><ul><li>当被监视的属性变化时，回调函数handler自动调用，进行相关操作</li><li>监视的属性必须存在，才能进行监视</li><li>监视的两种方法</li><li><ul><li>new Vue()时传入 watch 配置</li></ul></li><li><ul><li>通过 vm.$watch 监视（<strong>要加引号</strong>）</li></ul></li></ul></blockquote><table><thead><tr><th>配置对象</th><th>作用</th></tr></thead><tbody><tr><td>immediate</td><td>初始化时回调函数自动调用一次</td></tr><tr><td>deep</td><td>深度监视</td></tr></tbody></table><h3 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h3><blockquote><ul><li>Vue自身可以监视对象内部值的改变，但Vue提供的watch默认不可以</li><li>在监视对象中配置 deep:true 可以监视对象内部值改变</li></ul></blockquote><h3 id="计算属性与监视的区别"><a href="#计算属性与监视的区别" class="headerlink" title="计算属性与监视的区别"></a>计算属性与监视的区别</h3><p>1.computed能完成的功能，watch都可以完成<br>2.watch可以完成异步操作（如定时器），但computed不行（因为computed要有return返回值，而return不能写在回调函数里）</p><h3 id="Vue中的this"><a href="#Vue中的this" class="headerlink" title="Vue中的this"></a>Vue中的this</h3><p>1.所有被Vue管理的函数，最好写成普通函数，这样this的指向才是Vue 或 组件实例对象<br>2.所有不被Vue管理的函数（定时器函数、ajax的回调函数、Promise的回调函数）最好写成箭头函数，这样this的指向才是Vue 或 组件实例对象</p><h2 id="绑定CSS样式"><a href="#绑定CSS样式" class="headerlink" title="绑定CSS样式"></a>绑定CSS样式</h2><p><strong>1.class样式：</strong></p><blockquote><p>:calss&#x3D;”xxx” ,xxx可以是字符串，对象，数组</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;style&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;changeMood&#x27;</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//阻止 vue 在启动时生成生产提示</span></span><br><span class="language-javascript">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.demo&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">mood</span>: <span class="hljs-string">&#x27;happy&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">style</span>: &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">border</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">text</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">position</span>: <span class="hljs-literal">true</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">changeMood</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;happy&#x27;</span>, <span class="hljs-string">&#x27;sad&#x27;</span>, <span class="hljs-string">&#x27;upset&#x27;</span>]</span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">3</span>)</span><br><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mood</span> = arr[index]</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.style样式</strong></p><blockquote><p>:style&#x3D;”{fontSize:xxx}”,xxx是动态值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleArr&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;changeMood&#x27;</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.demo&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">mood</span>: <span class="hljs-string">&#x27;happy&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">styleObj</span>: &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;40px&#x27;</span> <span class="hljs-comment">//这里对象里的key要用驼峰写法</span></span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                <span class="hljs-attr">styleArr</span>: [&#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;20px&#x27;</span></span><br><span class="language-javascript">                &#125;, &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;orange&#x27;</span></span><br><span class="language-javascript">                &#125;]</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br></code></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><strong>1.v-if</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;n===1&quot;</span>&gt;</span>html<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;n===2&quot;</span>&gt;</span>css<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;n===3&quot;</span>&gt;</span>javascript<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><blockquote><p>v-if可以和v-else-if、v-else 一起使用，但要求结构不能打乱<br>v-if：不展示的DOM元素直接被移除，适用于切换频率较低的场景<br><strong>2.v-show</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div v-show=<span class="hljs-string">&#x27;n===1&#x27;</span>&gt;v-show&lt;/div&gt;<br></code></pre></td></tr></table></figure><blockquote><p>v-show：不展示的DOM元素不会被移除，仅仅是样式被隐藏，适用于切换频率较高的场景</p></blockquote><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><blockquote><p>v-for用于展示列表数据<br>语法：v-for&#x3D;”(item,index) of xxx” :key&#x3D;”yyy”<br>可遍历：数组，对象，字符串，指定次数</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) of filPersons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>    &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="key作用与原理"><a href="#key作用与原理" class="headerlink" title="key作用与原理"></a>key作用与原理</h2><h2 id="列表过滤"><a href="#列表过滤" class="headerlink" title="列表过滤"></a>列表过滤</h2><h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><h2 id="Vue监视数据原理"><a href="#Vue监视数据原理" class="headerlink" title="Vue监视数据原理"></a>Vue监视数据原理</h2><p>Vue会监视data中所有层级的数据<br><strong>监测对象中的数据：</strong></p><blockquote><ul><li>Vue是通过setter实现的监视，且默认Vue只监视new Vue()时传入的数据</li><li>Vue 不允许动态添加根级响应式属性</li><li>如需给后加的属性做响应式，需要使用如下API：</li><li><ul><li>Vue.set(target, propertyName&#x2F;index, value)</li></ul></li><li><ul><li>vm.$set(target, propertyName&#x2F;index, value)<br>三个参数如下：<br>{Object | Array} target<br>{string | number} propertyName&#x2F;index<br>{any} value</li></ul></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.$set(vm.<span class="hljs-property">userProfile</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">27</span>)<br>vm.$set(app.<span class="hljs-property">list</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;lemon&quot;</span>)<br><br></code></pre></td></tr></table></figure><p><strong>Vue.set()&amp;vm.$set() 不能给vm 或 vm的根数据对象（vm._data）添加属性</strong><br><strong>监测数组中的数据：</strong></p><blockquote><ul><li>Vue2是通过object.defineproperty()来劫持数据，无法直接劫持数组</li><li>数组中的每一项是没有自己的get，set的</li><li>通过包裹数组更新方法实现，本质上就是做了两件事：</li><li><ul><li>调用原生所对应的数组方法对数组进行更新</li></ul></li><li><ul><li>重新解析模板，进而更新页面</li></ul></li><li>Vue修改数组的方法：</li><li><ul><li>push()、pop()、shift()、unshift()、splice()、sort()、reverse() （这些数组方法会对原数组进行改变）</li></ul></li><li><ul><li>Vue.set()&amp;vm.$set()</li></ul></li></ul></blockquote><h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">&gt; - 对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）<br>&gt; - 注册过滤器：<br>&gt; - - 全局：Vue.filter(name,callback)<br>&gt; - - 局部：new Vue(filters:&#123;&#125;)<br>&gt; - 使用过滤器：<br>&gt; - - &#123;&#123;xxx | 过滤器名 | ...&#125;&#125; 或 v-bind:属性=&quot;xxx | 过滤器名&quot;<br>&gt; - 过滤器可以接受额外参数，但第一个参数永远是要处理的value值（xxx），多个过滤器也可以串联<br>&gt; - 过滤器不改变原来的数据，是产生新的对应的数据<br></code></pre></td></tr></table></figure><h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><blockquote><p>向其所在的节点中渲染文本内容<br>与插值语法的区别：v-text会替换掉节点中的内容，而不会</p></blockquote><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><blockquote><p>向指定节点中渲染包含html结构的内容<br>v-html有安全性问题，在网站上动态渲染任意HTML是非常危险的，容易遭到xss攻击</p></blockquote><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><blockquote><p>本质是一个没有值的特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性<br>使用css属性配合v-cloak可以解决网速慢页面展示出的问题</p></blockquote><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><blockquote><p>v-once 所在节点在初次动态渲染后，就视为静态内容了<br>以后数据的改变不会引起v-once所在结构的更新，可用于性能优化</p></blockquote><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><blockquote><p>可以跳过所在节点的编译过程<br>可利用它跳过没有使用指令语法和插值语法的节点，会加快编译</p></blockquote><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p><strong>函数式：</strong></p><blockquote><ul><li>函数式指令调用时机：</li><li><ul><li>指令与元素成功绑定时（一上来）</li></ul></li><li><ul><li>指令所在模板被重新解析时<br>参数为（DOM元素，绑定对象）</li></ul></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>放大10倍的值: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-big</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;n++&quot;</span>&gt;</span>n++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.demo&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">data</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">n</span>: <span class="hljs-number">1</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">directives</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">big</span>(<span class="hljs-params">e, binding</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, binding)<span class="hljs-comment">//e是DOM元素，binding是</span></span></span><br><span class="language-javascript"><span class="language-xml">                    e.<span class="hljs-property">innerText</span> = binding.<span class="hljs-property">value</span> * <span class="hljs-number">10</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>对象式：</strong><br>配置对象中常用的三个回调函数<br>(1).bind:指令与元素成功绑定时调用<br>(2).inserted:指令所在元素被插入页面时调用<br>(3).update:指令所在模板结构被重新解析时调用<br><strong>总结：</strong></p><blockquote><p>函数式即为对象式的简写<br>分为全局指令和局部指令 Vue.directive(指令名，回调函数&#x2F;配置对象)<br>指令定义时不加v-,但使用时要加v-<br>自定义指令里的 this 是 window<br>指令名如果是多个单词，要使用kebab-case命名，不要用camelCase命名</p></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote><p>Vue 在关键时候调用的一些特殊名称的函数<br>生命周期函数的名字不可更改，其中的 this 指向是vm 或 组件实例对象<br>常见的生命周期钩子：<br>1.mounted：发生ajax请求，启动定时器，绑定自定义事件，订阅消息【初始化操作】<br>2.beforeDestroy：清除定时器，解绑自定义事件，取消订阅消息【收尾工作】</p></blockquote><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>Vue中使用组件的三大步骤：</p><blockquote><ul><li>1.定义组件（创建组件）</li><li>2.注册组件</li><li>3.使用组件（写组件标签）<br>一、如何定义组件？</li><li>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别：</li><li>区别如下：<br>   - 1.el 不要写 —— 因为最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器<br>   - data 必须写成函数 —— 避免组件被复用时，数据存在引用关系，防止data中的数据被修改时会引起所有引用该组件的模板里的数据都被修改<br>简写方式：const 组件名 &#x3D; options（配置对象）<br>二、如何注册组件？<br>1.局部注册：靠new Vue 的时候传入components选项<br>2.全局注册：靠Vue.components(‘组件名’,组件)<br>三、编写组件标签    <br>    &lt;组件名&gt;&lt;&#x2F;组件名&gt;<br>    &lt;组件名&#x2F;&gt;</li></ul></blockquote><h3 id="VueComponent-构造函数"><a href="#VueComponent-构造函数" class="headerlink" title="VueComponent 构造函数"></a>VueComponent 构造函数</h3><h3 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系"></a>一个重要的内置关系</h3><blockquote><p>VueComponent.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Vue.prototype<br>让组件实例对象（vc）可以访问到 Vue原型对象上的属性，方法</p></blockquote><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><h1 id="vue-脚手架笔记"><a href="#vue-脚手架笔记" class="headerlink" title="vue 脚手架笔记"></a>vue 脚手架笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><p> |—— node_modules<br> |—— public<br> |   |—— favicon.ico: 页签图标<br> |   |—— index.html: 主页面<br> |—— src<br> |   |—— assets: 存放静态资源<br> |   |   ㆐—— logo.png<br> |   |—— components: 存放组件<br> |   |   ㆐—— HelloWorld.vue<br> |   |—— App.vue: 汇总所有组件<br> |   |—— main.js: 入口文件<br> |—— .gitignore: git版本管制忽略的配置<br> |—— babel.config.js: babel的配置文件<br> |—— package.json: 应用包配置文件<br> |—— README.md: 应用描述文件<br> |—— package-lock.json: 包版本控制文件</p><h2 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><span class="hljs-title function_">render</span>(<span class="hljs-params">createElement</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;html标签&#x27;</span>,<span class="hljs-string">&#x27;标签里的内容&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><blockquote><ul><li>1.被用来给元素或子组件注册引用信息（id的替代者）</li><li>2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;h1 v-text=<span class="hljs-string">&quot;msg&quot;</span> ref=<span class="hljs-string">&quot;title&quot;</span>&gt;&lt;/h1&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showDom&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点我输出ref属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SchoolName</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sch&quot;</span>/&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><blockquote><p>让组件接受外部传过来的数据<br>一、传递数据<br><Demo name="xxx"><br>如果是数字传入时要用 :age&#x3D;””(数据绑定的写法，<strong>这样的形式代表将引号中的东西看作一个js表达式来处理</strong>)<br>二、接收数据<br>1.只接收<br>props:[‘name’]<br>2.限制类型<br>props:{<br>    name:String<br>}<br>3.限制类型、限制必要性、指定默认值<br>props:{<br>    name:{<br>        type:String, &#x2F;&#x2F;类型<br>        required:true, &#x2F;&#x2F;必要性<br>        default:’jyd’ &#x2F;&#x2F;默认值<br>    }<br>}<br><strong>props是只读的</strong>，若确需修改，那么将props中的内容复制到data中一份，然后去改造data中的数据。</p></blockquote><h2 id="mixin（混入）"><a href="#mixin（混入）" class="headerlink" title="mixin（混入）"></a>mixin（混入）</h2><blockquote><p>可以帮多个组件共用的配置提取成一个混入对象<br>一、定义混合（在一个新的js文件中）<br>{<br>    data(){<br>    },<br>    methods(){<br>    }<br>}<br>二、使用混入<br>(1).全局混入：Vue.mixin(xxx)<br>(2).局部混入: mixins:[xxx]</p></blockquote><h2 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h2><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><p>1.组件化编码流程</p><blockquote><ul><li>(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突</li><li>(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：<br>  - 一个组件在用：放在组件自身即可<br>  - 一些组件在用：放在他们共同的父组件上（状态提升）</li><li>(3).实现交互：从绑定事件开始<br>2.props适用于：<br>(1).父组件&#x3D;&#x3D;&gt; 子组件 通信<br>(1).子组件&#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）<br>3.使用v-model时要切记: v-model绑定的值不能是props传过来的值，因为props是不可以修改的<br>4.props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做</li></ul></blockquote><h2 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h2><p>sessionStorage&#x2F;localStorage 的常用方法和属性：</p><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>setItem()</td><td>保存数据</td></tr><tr><td>getItem()</td><td>读取数据</td></tr><tr><td>removeItem()</td><td>删除数据</td></tr><tr><td>clear()</td><td>清除数据</td></tr><tr><td>length</td><td>数据长度</td></tr><tr><td>注意事项：</td><td></td></tr></tbody></table><blockquote><p>localStorage需要手动清除才消失，sessionStorage随着浏览器的关闭而消失<br>如果getItem(xxx)对应的value获取不到，返回值为null<br>JSON.parse(null)的结果为null</p></blockquote><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li>一种组件间通信的方式，适用于：子组件 &#x3D;&#x3D;&gt; 父组件</li><li>适用场景：A是父组件，B是子组件，B要给A传数据，那么就在A中给B绑定自定义事件（回调函数写在A中 ）</li><li>绑定自定义事件：</li><li>触发自定义事件：</li><li>解绑自定义事件：</li><li>组件上也可以绑定原生DOM事件，需要使用native修饰符</li><li>注意，通过 <code>this.$refs.std.$on('jyd',callback)</code> 绑定自定义事件时,回调函数要么配置在methos中，要么使用箭头函数，否则this指向会出问题</li></ol><h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><blockquote><ul><li>一种组件间通信的方式，适用于任意组件通信</li><li>全局事件总线是一个独立存在的部分，要想实现组件间的相互通信，又是自定义事件，那就要满足两个条件<br>  - 满足所有组件都能访问得到全局事件总线<br>  - 可以调用 $on ,和 $off 和 $emit<br>一、实现全局事件总线<br><code>main.js：</code></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span>h (<span class="hljs-title class_">App</span>)<br>    <span class="hljs-comment">//beforeCreate中模板未解析，且this是vm</span><br>    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span> <span class="hljs-comment">//安装全局事件总线</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>二、绑定全局事件总线</p><blockquote><p>谁要接收数据，自定义事件就绑定在谁身上</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;自定义事件名&#x27;</span>,callback)<br>&#125;,<br></code></pre></td></tr></table></figure><p>三、触发全局事件总线</p><blockquote><p>谁要传递数据，谁就触发事件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">methods：&#123;<br>    触发事件方法名()&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$emit(<span class="hljs-string">&#x27;自定义事件名&#x27;</span>,传递参数)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>四、在销毁前解绑事件，提高性能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 销毁对应自定义事件</span><br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$off(<span class="hljs-string">&#x27;自定义事件名&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><p>1.语法: <code>this.$nextTick(callback)</code><br>2.作用: 在下一次DOM更新结束后执行其回调函数<br>3.例子：使得input框在创建的时候自动获得焦点</p><h2 id="过渡和动画"><a href="#过渡和动画" class="headerlink" title="过渡和动画"></a>过渡和动画</h2><h2 id="Vue配置跨域"><a href="#Vue配置跨域" class="headerlink" title="Vue配置跨域"></a>Vue配置跨域</h2><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p><strong>1.概念</strong><br>在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信<br><strong>2.作用</strong><br>多个组件需要共享数据时<br><strong>3.搭建vuex环境</strong><br><strong>4.流程</strong><br><img src="https://vuex.vuejs.org/vuex.png" alt="流程图"><br>5.getter(类似于计算属性)</p><blockquote><p>用于将state中的数据加工<br>注意要使用其前要先在 new Vuex.Store 中添加</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getters = &#123;<br>    <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>) &#123;<br>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6.mapState &amp; mapGetters</strong></p><blockquote><p>写在计算属性里，用于简便快速生成计算属性的<br>使用前要在组件中<strong>先引用</strong> (<code>import &#123;mapState&#125; from 'vuex'</code>)<br>key-value形式：<strong>key指的是模板中的写法，value指的是store中的写法</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-comment">//传统写法</span><br>    <span class="hljs-comment">/*sum()&#123;</span><br><span class="hljs-comment">        return this.$store.state.sum</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">//对象写法</span><br>   <br>    ...<span class="hljs-title function_">mapState</span>(&#123;<span class="hljs-attr">sum</span>:<span class="hljs-string">&#x27;sum&#x27;</span>&#125;)<br>    <span class="hljs-comment">//数组写法</span><br>    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;sum&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>7.mapActions &amp; mapMutations</strong></p><blockquote><p>mapActions 用于生成于actions对话的方法<br>mapMutations用于生成于mutations对话的方法<br><strong>8.namespace</strong></p></blockquote><h2 id="route路由"><a href="#route路由" class="headerlink" title="route路由"></a>route路由</h2><blockquote><p>vue-router:vue的一个插件库，专门实现SPA（单页）应用<br>一、对SPA的理解：<br>1.整个应用只有一个完整的页面<br>2.点击页面中的导航链接不会刷新页面，只会做页面的局部更新<br>3.数据需要通过AJAX请求获取<br>二、路由的理解：<br>1.一个路由就是一组 key-value 的映射关系<br>2.key 为路径，value 可能是component（前端，用于展示页面内容）&#x2F; function（后端，用于处理客户端请求）<br>三、路由的注意点：<br>1.路由组件通常存放在pages文件夹，一般组件通常放在components文件夹<br>2.通过切换，”隐藏”了的路由组件，默认是被销毁的，需要的时候再去挂载<br>3.每个组件都有自己的 <strong>$route</strong> 属性，里面存储着自己的路由信息<br>4.整个应用只有一个router，可以通过组件的 $router属性获取<br>四、路由在模板中的使用：<br><router-link>路由的组件名</router-link> :路由的跳装链接<br><router-view></router-view> :路由在模板中的位置</p></blockquote><h3 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由"></a>多级路由</h3><blockquote><p>在父路由中使用children配置项</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [&#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/subject&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Subject</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/students&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span>,<br>            <span class="hljs-attr">children</span>: [&#123; <span class="hljs-comment">//在路由中通过children配置子路由</span><br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;lb&#x27;</span>, <span class="hljs-comment">//此处一定不要加&#x27;/&#x27;</span><br>                    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Lb</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;jyd&#x27;</span>, <span class="hljs-comment">//此处一定不要加&#x27;/&#x27;</span><br>                    <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Jyd&#x27;</span><br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>命名路由</strong></p><blockquote><p>作用：简化路由的跳转路径<br>1.给路由命名</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/students&#x27;</span><br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.简化跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;router-link to=<span class="hljs-string">&quot;/students&quot;</span>&gt;&lt;/router-link&gt;<br> ==&gt;<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span> （此时这里面不要再写path）<br></code></pre></td></tr></table></figure><h3 id="路由的-query-参数"><a href="#路由的-query-参数" class="headerlink" title="路由的 query 参数"></a>路由的 query 参数</h3><p>1.传递参数<br><strong>to 要加 ：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in p&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;`/students/lb/msg?id=$&#123;item.id&#125;&amp;title=$&#123;item.title&#125;`&quot;</span>&gt;</span><br>          &#123;&#123; item.title &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 对象写法 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;router-link</span><br><span class="hljs-comment">        :to=&quot;&#123;</span><br><span class="hljs-comment">            path:&#x27;/students/lb/msg&#x27;</span><br><span class="hljs-comment">            query:&#123;</span><br><span class="hljs-comment">              id:item.id</span><br><span class="hljs-comment">              title:item.title</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;&quot;&gt;</span><br><span class="hljs-comment">        &#123;&#123;item.title&#125;&#125;</span><br><span class="hljs-comment">        &lt;/router-link&gt; --&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.接收参数</p><blockquote><p>$route.query.属性</p></blockquote><h3 id="路由的params参数"><a href="#路由的params参数" class="headerlink" title="路由的params参数"></a>路由的params参数</h3><p>1.配置路由声明接收参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/students/:id/:title&#x27;</span>, <span class="hljs-comment">//使用占位符  </span><br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>2.传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;router-link to=<span class="hljs-string">&quot;/students/666/你好&quot;</span>&gt;&lt;/router-link&gt;<br> <span class="hljs-comment">//对象写法</span><br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span></span><br><span class="hljs-tag"><span class="language-xml"> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">    name:&#x27;hello&#x27; //当使用的是params参数时，对象写法里只能写成name属性，不能使用path</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">    params:&#123;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">        id:666,</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">        title:&#x27;你好&#x27;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">    &#125;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml"> &#125;&quot;</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><blockquote><p><strong>让路由组件更方便的收到参数</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/students/:id/:title&#x27;</span>,  <br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span>,<br>    <span class="hljs-comment">//第一种写法(不常用)：会把对象中的每一组key-value值通过props传给组件</span><br>    <span class="hljs-attr">props</span>:&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">900</span>&#125;<br>    <span class="hljs-comment">//第二种写法：props为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给组件</span><br>    <span class="hljs-comment">//（只有params能用）</span><br>    <span class="hljs-attr">props</span>:<span class="hljs-literal">true</span><br>    <span class="hljs-comment">//第三种写法：props为函数，会把函数返回的对象中的每一组key-value值通过props传给组件</span><br>    <span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">id</span>:route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>,<br>            <span class="hljs-attr">title</span>:route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h3><blockquote><p>作用：控制路由跳转时操作浏览器历史记录的模式<br>历史记录有push和replace两种写入方式，push是追加（默认），replace是替换当前记录<br>如何开启replace模式：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link replace to=<span class="hljs-string">&quot;/students&quot;</span>&gt;&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><h3 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h3><blockquote><p>作用：让不展示的路由组件保持挂载，不被销毁</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果有多个——  :include=&#x27;[&#x27;组件名&#x27;,&#x27;&#x27;]&#x27;</span><br>&lt;keep-alive include=<span class="hljs-string">&#x27;组件名&#x27;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><p>这段代码写在不想被销毁的组件的父路由上</p><h3 id="路由中的生命周期钩子"><a href="#路由中的生命周期钩子" class="headerlink" title="路由中的生命周期钩子"></a>路由中的生命周期钩子</h3><blockquote><p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态<br>1.<code>activated</code>:路由组件激活时触发<br>2.<code>deactivated</code>:路由组件失活时触发</p></blockquote><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><h3 id="hash-history"><a href="#hash-history" class="headerlink" title="hash &amp; history"></a>hash &amp; history</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署</title>
    <link href="/2024/04/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/2024/04/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="前端程序员如何在宝塔面板部署Vue-nodejs前后端项目"><a href="#前端程序员如何在宝塔面板部署Vue-nodejs前后端项目" class="headerlink" title="前端程序员如何在宝塔面板部署Vue+nodejs前后端项目"></a>前端程序员如何在宝塔面板部署Vue+nodejs前后端项目</h1><p><img src="https://www.bigneck.top/#/article/ca66d3b6-ac5c-44d7-b1a8-464def149ff5" alt="前端程序员如何在宝塔面板部署Vue+nodejs前后端项目"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>卷积神经网络</title>
    <link href="/2024/04/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/04/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p><strong>从输入层 -&gt; 中间隐藏层 -&gt;  输出层</strong><br>一个神经网络也可以分为两块，前一块是特征抽取，从输入中提取到容易线性分割的提取，后一块使用线性分类器来做分类</p><p>中间隐藏层 包括 卷积层、全连接层、 分类层 、批量归一化层（BN）、残差连接层 等</p><p>最简单结构是 输入层 -&gt; 卷积层 -&gt; 全连接层 -&gt; 输出层 </p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><blockquote><p>主要用于处理图像数据或具有类似结构的数据，通过卷积操作<strong>提取局部特征</strong>，例如边缘、纹理等<br>前面的层通常负责提取低级别的特征，随着网络的深度增加，特征提取的层次也逐渐升高，从低级别的特征到高级别的抽象特征<br>单个卷积核在原图上能够计算的响应区域被我们称为该<strong>卷积的感受野</strong>, 小的像素区域是难以得到关于图像的高阶语义信息的，因为感受野太小了。随着网络层次深入，最终神经元感受野通常会涵盖整个输入图像</p></blockquote><h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><blockquote><p>也称为密集连接层，是一种常见的神经网络层结构，其中每个神经元都与前一层的所有神经元连接。<br>全连接层通常出现在网络的最后几层，用于<strong>将前面层提取到的特征进行组合和分类</strong>。</p></blockquote><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><blockquote><p>用于<strong>降低特征图的空间维度，减少参数数量，同时保留重要的特征信息</strong><br>常见的池化操作包括最大池化和平均池化</p></blockquote><h3 id="批量归一化层（BN）"><a href="#批量归一化层（BN）" class="headerlink" title="批量归一化层（BN）"></a>批量归一化层（BN）</h3><blockquote><p><strong>用于加速训练并增强网络的稳定性</strong>。在深度神经网络中，随着网络层数的增加，训练过程中可能出现梯度消失或梯度爆炸的问题，导致网络收敛困难或训练不稳定。</p></blockquote><blockquote><p>批量归一化通过<strong>对每个批次的输入</strong>进行归一化，即将每个特征维度的数据都减去均值并除以标准差，然后再乘以一个可学习的缩放因子和平移因子，使得网络的输入在训练过程中保持一定的分布，有利于梯度的传播和网络的收敛。</p></blockquote><blockquote><p><strong>归一化概念：</strong>使得数据的分布范围或者特征值范围在一定范围内，以便更好地适应模型的训练和提高模型的稳定性</p></blockquote><h3 id="残差连接层"><a href="#残差连接层" class="headerlink" title="残差连接层"></a>残差连接层</h3><blockquote><p>用于<strong>解决深度网络训练过程中的梯度消失问题</strong>。<br>在深度神经网络中，随着网络层数的增加，传统的前向传播和反向传播容易导致梯度逐渐减小，使得网络难以训练。<br>残差连接通过在网络中添加跨层连接，即将某一层的输入直接与后续层的输出相加，将原始的输入信息保留并传递给后续层，有助于减轻梯度消失问题，加速网络的训练和收敛。</p></blockquote><h3 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h3><blockquote><p>网络的最后一层，负责产生网络的输出，其结构通常根据具体任务的需求而定。<br>例如，在分类任务中，输出层可能采用softmax函数来输出每个类别的概率；在回归任务中，输出层可能直接输出连续值</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vision transformer</title>
    <link href="/2024/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/vision-transformer/"/>
    <url>/2024/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/vision-transformer/</url>
    
    <content type="html"><![CDATA[<ol><li>每个Patche数据通过映射得到一个长度为768的token向量，即[16, 16, 3] -&gt; [768]</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习"><a href="#数据结构复习" class="headerlink" title="数据结构复习"></a>数据结构复习</h1>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>408</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理复习"><a href="#计算机组成原理复习" class="headerlink" title="计算机组成原理复习"></a>计算机组成原理复习</h1><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><ol><li>计算机硬件系统由<strong>运算器、存储器、控制器、输入设备和输出设备</strong>5 大部件组成</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h1>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习"><a href="#计算机网络复习" class="headerlink" title="计算机网络复习"></a>计算机网络复习</h1><h2 id="计算机网络参考模型"><a href="#计算机网络参考模型" class="headerlink" title="计算机网络参考模型"></a>计算机网络参考模型</h2><p><img src="/../../img/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1.png"></p><p><strong>5层模型</strong></p><blockquote><p>方便用于知识点讲解的模型</p></blockquote><p>物理层、数据链路层、网络层、传输层、应用层</p><p><strong>TCP&#x2F;IP模型</strong></p><blockquote><p>只有四层，<strong>将物理层和数据链路层合并合并为网络接口层</strong></p></blockquote><p><strong>OSI模型</strong></p><ol><li>由 物理层、数据链路层、网络层、传输层、（会话层）、（表示层）、应用层 组成</li><li>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理</li></ol><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><blockquote><p>考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异</p></blockquote><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><blockquote><p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。<br>（封装成帧、差错控制、流量控制、传输管理）</p></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><blockquote><p>为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。<br>（流量控制、拥塞控制、差错控制、网际互联）</p></blockquote><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><blockquote><p>为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。<br>运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。<br>TCP 主要提供完整性服务，UDP 主要提供及时性服务。<br>（流量控制、差错控制、服务质量、数据传输管理、端到端）</p></blockquote><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p><strong>三次握手建立连接</strong></p><p><strong>四次握手释放连接</strong></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><blockquote><p>为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p></blockquote><ol><li>DNS 域名解析协议<br>域名和IP地址的相互映射，以UDP数据报传输</li><li>FTP文件传输协议（file Transfer Protocol）<br>使用TCP可靠传输</li><li>SMTP简单邮件传输协议（Simple Mail Transfer Protocol）<br>邮件通信三个阶段：(1) 连接建立(2) 邮件传送 (3)连接释放</li><li>POP邮局协议(Post Office Protocol)<br>是一个非常简单但功能有限的邮件读取协议</li><li>HTTP超文本传输协议<br>HTTP 是面向事务的(Transaction-oriented) 应用层协<br>议，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</li></ol><p>访问网页的事件顺序<br>（1）DNS将用户输入的网页域名解析成IP地址<br>（2）DNS解析出域名后的服务器的IP地址<br>（3）浏览器与该服务器建立TCP连接<br>（4）浏览器发出HTTP请求<br>（5）服务器通过HTTP响应将用户所需要访问的页面发送给浏览器<br>（6）TCP连接释放<br>（7）浏览器解析index.html，将内容展示给用户 </p>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>408</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习知识点汇总</title>
    <link href="/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习知识点汇总"><a href="#深度学习知识点汇总" class="headerlink" title="深度学习知识点汇总"></a>深度学习知识点汇总</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 定义模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Net, self).__init__()<br>        self.fc1 = nn.Linear(input_size, hidden_units)<br>        self.dropout = nn.Dropout(dropout_rate)<br>        self.fc2 = nn.Linear(hidden_units, num_classes)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = torch.relu(self.fc1(x))<br>        x = self.dropout(x)<br>        x = self.fc2(x)<br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># 创建模型实例</span><br>model = Net()<br><br><span class="hljs-comment"># 定义损失函数和优化器</span><br>criterion = nn.CrossEntropyLoss()<br>optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)<br><br><span class="hljs-comment"># 训练模型</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> i, (images, labels) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        images = images.reshape(-<span class="hljs-number">1</span>, input_size)<br>        <br>        <span class="hljs-comment"># 前向传播</span><br>        outputs = model(images)<br>        loss = criterion(outputs, labels)<br>        <br>        <span class="hljs-comment"># 反向传播和优化</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br>        <br>        <span class="hljs-comment"># 打印训练信息</span><br>        <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % display_step == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;&#x27;</span><br>                  .<span class="hljs-built_in">format</span>(epoch+<span class="hljs-number">1</span>, num_epochs, i+<span class="hljs-number">1</span>, total_steps, loss.item()))<br><br><span class="hljs-comment"># 在测试集上评估模型</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    correct = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> test_loader:<br>        images = images.reshape(-<span class="hljs-number">1</span>, input_size)<br>        outputs = model(images)<br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs.data, <span class="hljs-number">1</span>)<br>        total += labels.size(<span class="hljs-number">0</span>)<br>        correct += (predicted == labels).<span class="hljs-built_in">sum</span>()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test Accuracy: &#123;&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">100</span> * correct / total))<br></code></pre></td></tr></table></figure><h1 id="12-1"><a href="#12-1" class="headerlink" title="12.1"></a>12.1</h1><h2 id="过拟合和欠拟合（Overfitting-and-underfitting）"><a href="#过拟合和欠拟合（Overfitting-and-underfitting）" class="headerlink" title="过拟合和欠拟合（Overfitting and underfitting）"></a>过拟合和欠拟合（Overfitting and underfitting）</h2><p>过拟合和欠拟合是导致模型泛化能力不高的两种常见原因，都是模型学习能力与数据复杂度之间失配的结果。<br><strong>“欠拟合”</strong>常常在模型学习能力较弱，而数据复杂度较高的情况出现，此时模型由于学习能力不足，无法学习到数据集中的“一般规律”，因而导致泛化能力弱。<br><strong>“过拟合”</strong>常常在模型学习能力过强的情况中出现，此时的模型学习能力太强，以至于将训练集单个样本自身的特点都能捕捉到，并将其认为是“一般规律”，同样这种情况也会导致模型泛化能力下降。</p><h3 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h3><p>过拟合（over-fitting）也称为过学习，它的直观表现是算法在训练集上表现好，但在测试集上表现不好，泛化性能差<br><strong>cause</strong></p><blockquote><ul><li>训练集的数据太少或者缺乏代表性；</li><li>训练集样本存在的噪音干扰过大，导致模型拟合了噪音的特征，反而忽略了真实的输入输出间的关系；</li><li>参数太多，模型复杂度过高；</li></ul></blockquote><p><strong>method</strong></p><p>1.增加数据量  </p><ul><li>从数据源头获取更多数据；</li><li>通过数据增强对数据进行扩充：对图像进行翻转、裁剪、缩放、平移、添加噪声等。</li></ul><p>2.正则化<br>在进行目标函数或代价函数（损失函数）优化时，在函数后面加上一个正则项，一般有L1正则、L2正则等。</p><blockquote><ul><li><strong>L1正则化：</strong> L1正则化是通过在目标函数中加入L1范数惩罚项来实现的。L1范数是指权重向量W中的各个元素绝对值之和，因此L1正则化的目的是使模型参数尽可能地稀疏。L1正则化可以促使模型参数向零值收缩，进而减少特征的数量。</li><li><strong>L2正则化：</strong> L2正则化是通过在目标函数中加入L2范数惩罚项来实现的。L2范数是指权重向量W中的各个元素的平方和开根号，因此L2正则化的目的是通过约束模型参数的平方和，使得它们的值不会过大。L2正则化可以帮助避免模型的权值过拟合，并使得模型更具有鲁棒性和泛化能力。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加L2正则化项</span><br>l2_reg = torch.tensor(<span class="hljs-number">0.</span>) <span class="hljs-comment"># 创建一个初始值为零的 torch.Tensor 对象，用于累加模型参数的 L2 范数。</span><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.parameters():<br>    l2_reg += torch.norm(param, <span class="hljs-number">2</span>)<br>loss += l2_penalty * l2_reg <span class="hljs-comment">#  L2 正则化的惩罚系数（penalty coefficient），用于控制正则化的强度。它是一个超参数，需要根据具体问题进行调整(交叉验证)。</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>区别：</strong> L1正则化减少的是一个常量，L2正则化减少的是权重的固定比例；使用L1可以得到稀疏的权值，使用L2可以得到平滑的权值；实践中L2正则化通常优于L1正则化。</p></blockquote><p>3.Dropout<br>Dropout 是一种常用的正则化技术，用于减少深度神经网络的过拟合现象。Dropout 在训练过程中随机地丢弃一部分神经元的输出，从而强制模型去学习其他特征的表示。</p><blockquote><p><code>self.dropout = nn.Dropout(dropout_rate)</code></p></blockquote><p>具体来说，Dropout 在前向传播的过程中，以一定的概率 p（通常设置为0.5）将某个神经元的输出设为0，即丢弃该神经元。这样做的结果是，每个神经元在训练过程中都有一定概率暂时被“关闭”，从而迫使网络去考虑其他神经元的贡献，减少了对特定神经元的依赖性。同时，在前向传播过程中，通过保留每个神经元输出的比例，可以确保网络的总体期望值不变。</p><h1 id="12-2"><a href="#12-2" class="headerlink" title="12.2"></a>12.2</h1><h2 id="Triplet-Loss-和-Center-Loss"><a href="#Triplet-Loss-和-Center-Loss" class="headerlink" title="Triplet Loss 和 Center Loss"></a>Triplet Loss 和 Center Loss</h2><blockquote><p><code>https://blog.csdn.net/weixin_40671425/article/details/98068190</code></p></blockquote><h2 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h2><p>梯度消失和梯度爆炸的根源主要是因为<strong>深度神经网络结构</strong>以及**激活函数选择不当(函数的导数数值过小会导致梯度消失)**，目前优化神经网络的方法都是基于反向传播的思想，即根据损失函数计算的误差通过反向传播的方式，指导深度网络权值的更新。<br>在反向传播时对激活函数进行求导。如果在此部分大于1，那么随着层数的增加，求出的梯度的更新将以指数形式增加，发生梯度爆炸。如果此部分小于1，那么随着层数的增加求出的梯度更新的信息会以指数形式衰减，发生梯度消失。</p><p><strong>梯度消失：</strong> 即在反向传播过程中，由于梯度值逐层传递时逐渐变小，导致较靠近输入层的层难以有效地学习到输入数据的特征和模式。</p><p><strong>梯度爆炸</strong> 在深度神经网络训练过程中，梯度值逐层传递时逐渐增大，并且可能超出网络的数值范围的问题。当梯度值变得非常大时，参数更新的幅度也会变得非常大，导致模型变得不稳定，甚至无法收敛。</p><p><strong>method</strong><br>1.正则化：通过 L1 或 L2 正则化来控制参数的大小，防止梯度值过大。<br>2.梯度剪裁（Gradient Clipping）：限制梯度值的范围，将超出阈值的梯度进行裁剪。<br>3.预训练：可以先使用无监督学习或其他方式进行预训练，提供一个比较好的初始参数，从而减小梯度消失和爆炸的可能性。<br>4.层标准化（Layer Normalization）或批标准化（Batch Normalization）：对层输出进行标准化，使其均值为0、方差为1，有助于缓解梯度消失情况。<br>5.参数初始化：合理选择参数的初始化方法，如使用 Xavier 或 He 等初始化方法，可以减小梯度消失和爆炸的概率。<br>6.更稳定的激活函数：使用 ReLU、Leaky ReLU 或其变体等激活函数，可以避免梯度消失，并且有助于缓解梯度爆炸。<br>7.Residual Connections（残差连接）：在网络中增加跨层连接，可以传递较浅层的梯度信息，缓解梯度消失和爆炸。</p><p><strong>Residual Connections</strong></p><blockquote><p>残差连接引入了一种跨层传递的机制，即在网络的某些层中，将前一层的输出直接加到后一层的输入中去。这种机制可以有效地传递一定的梯度信息，避免了网络深度增加时出现的梯度消失问题，同时也能够克服一些非凸优化问题，使得网络更容易优化。<br>具体而言，假设某一层的输入为 x，输出为 y，则残差连接的实现形式可以表示为：<br><code>y=F(x)+x</code><br>其中 F(x) 表示该层的非线性变换操作，即前向传播过程。在反向传播梯度计算时，则会将损失函数 L 反向传播到该层，生成梯度 ∂L&#x2F;∂y，并将该梯度传递到 x，从而计算 ∂L&#x2F;∂x，即该层输入 x 对损失函数的梯度。</p></blockquote><h1 id="12-2-1"><a href="#12-2-1" class="headerlink" title="12.2"></a>12.2</h1><blockquote><p><code>https://zhuanlan.zhihu.com/p/438085414</code></p></blockquote><h1 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h1><p>Tensor（张量）是一个多维数组，它是深度学习中最基本的数据结构之一，也是基于计算图的深度学习框架的核心组成部分。Tensor 可以存储和表示任意维度的数据，支持各种数值和数据类型，并提供了类似于 numpy 的数据操作接口，例如加、减、乘、除、运算、矩阵乘法、转置等。在深度学习中，我们使用 Tensor 来存储训练样本和模型参数，并对它们进行线性和非线性的运算。</p><p>Tensor 的维度通常被称作“阶”，例如，阶为 0 的 Tensor 又被称作“标量”（scalar），表示一个单独的数值；阶为 1 的 Tensor 又被称作“向量”（vector），表示一列数值；阶为 2 的 Tensor 又被称作“矩阵”（matrix），表示一个二维的表格。在深度学习中，我们通常会使用阶数更高的 Tensor，例如 3 阶、4 阶或更高阶的 Tensor，以表示更复杂的数据结构，如图像、视频或音频数据等。</p><h2 id="1-张量的创建"><a href="#1-张量的创建" class="headerlink" title="1.张量的创建"></a>1.张量的创建</h2><h3 id="1-1-通过列表或者元组"><a href="#1-1-通过列表或者元组" class="headerlink" title="1.1 通过列表或者元组"></a>1.1 通过列表或者元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t = torch([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]) / t = torch((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(t)<br><span class="hljs-comment"># tensor([1, 2])</span><br></code></pre></td></tr></table></figure><h3 id="1-2-通过numpy创建"><a href="#1-2-通过numpy创建" class="headerlink" title="1.2 通过numpy创建"></a>1.2 通过numpy创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>n = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>t = torch.tensor(n)<br><span class="hljs-built_in">print</span>(t)<br><span class="hljs-comment"># tensor([1, 2])</span><br></code></pre></td></tr></table></figure><h3 id="1-3-tensor-type-and-convert"><a href="#1-3-tensor-type-and-convert" class="headerlink" title="1.3 tensor-type and convert"></a>1.3 tensor-type and convert</h3><p>type()不能识别出Tensor内部的数据类型，只能识别出变量的基本类型是Tensor，而dtype方法可以识别出变量具体为哪种类型的Tensor。<br>可以使用.float()、.int()等方法对张量类型进行转化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">i = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>f = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(i), i.dtype, sep = <span class="hljs-string">&#x27; , &#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(f), f.dtype, sep = <span class="hljs-string">&#x27; , &#x27;</span>)<br><span class="hljs-comment"># &lt;class &#x27;torch.Tensor&#x27;&gt; , torch.int64</span><br><span class="hljs-comment"># &lt;class &#x27;torch.Tensor&#x27;&gt; , torch.float32</span><br><br>t = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>f = t.<span class="hljs-built_in">float</span>()<br><span class="hljs-built_in">print</span>(f)<br><span class="hljs-built_in">print</span>(t) <span class="hljs-comment"># 并不会改变原来t的数据类型</span><br><span class="hljs-comment"># tensor([1., 2.])</span><br><span class="hljs-comment"># tensor([1, 2])</span><br></code></pre></td></tr></table></figure><h2 id="tensor—shape"><a href="#tensor—shape" class="headerlink" title="tensor—shape"></a>tensor—shape</h2><p>张量的维度中，我们使用的张量如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一维向量</span><br>t1 = torch.tensor((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-comment"># 二维向量</span><br>t2 = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-comment"># 三维向量</span><br>t3 = torch.tensor([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]],[[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]])<br><br><span class="hljs-comment"># ndim查看张量维度</span><br><span class="hljs-built_in">print</span>(t1.ndim, t2.ndim, t3.ndim, sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># 1, 2, 3</span><br><span class="hljs-comment"># t1为1维向量</span><br><span class="hljs-comment"># t2为2维矩阵</span><br><span class="hljs-comment"># t3为3维张量</span><br><br><span class="hljs-comment"># shape&amp;size查看向量的形状</span><br><span class="hljs-built_in">print</span>(t1.shape, t2.shape, t3.shape, sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># torch.Size([2]), torch.Size([2, 3]), torch.Size([2, 2, 2])</span><br><br><span class="hljs-built_in">print</span>(t1.size(), t2.size(), t3.size(), sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># torch.Size([2]), torch.Size([2, 3]), torch.Size([2, 2, 2])</span><br><br><span class="hljs-comment"># numel查看张量中的元素个数</span><br><span class="hljs-built_in">print</span>(t1.numel(), t2.numel(), t3.numel(), sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># 2, 6, 8</span><br><span class="hljs-comment"># t1向量中共有2个元素</span><br><span class="hljs-comment"># t2矩阵中共有6个元素</span><br><span class="hljs-comment"># t3张量中共有8个元素</span><br><br><span class="hljs-comment"># flatten将任意维度张量转为一维张量</span><br>t2.flatten()<br><span class="hljs-comment"># tensor([1, 2, 3, 4, 5, 6])</span><br><br>t3.flatten()<br><span class="hljs-comment"># tensor([1, 2, 3, 4, 5, 6, 7, 8])</span><br><br><br></code></pre></td></tr></table></figure><blockquote><ul><li>t1向量torch.Size([2])的理解：向量的形状是1行2列。</li><li>t2矩阵torch.Size([2, 3])的理解：二维矩阵的形状是2行3列。</li><li>t3矩阵torch.Size([2, 2, 2])的理解：包含两个二维矩阵，每个二维矩阵的形状是2行2列。</li></ul></blockquote><h3 id="reshape任意变形"><a href="#reshape任意变形" class="headerlink" title="reshape任意变形"></a>reshape任意变形</h3><p><strong>形变维度的乘积需要等于张量元素的个数。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将`t3`变成2×4的矩阵</span><br>t3.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment">#tensor([[1, 2, 3, 4],[5, 6, 7, 8]])</span><br><br><span class="hljs-comment"># 将`t3`变成1×4×2的矩阵</span><br>t3.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># tensor([[[1, 2], [3, 4], [5, 6], [7, 8]]])</span><br></code></pre></td></tr></table></figure><h3 id="squeeze-unsqueeze"><a href="#squeeze-unsqueeze" class="headerlink" title="squeeze&amp;unsqueeze"></a>squeeze&amp;unsqueeze</h3><ul><li>squeeze的作用是压缩张量，去掉维数为1位置的维度</li><li>unsqueeze的作用是解压张量，给<strong>指定位置</strong>加上维数为一的维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将t3的维度变为2×1×4</span><br>t_214 = t3.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(t_214)<br><span class="hljs-comment"># tensor([[[1, 2, 3, 4]], [[5, 6, 7, 8]]])</span><br><br><span class="hljs-comment"># 使用squeeze将其变成2×4，去掉维度为1位置的维度</span><br>t_24 = t_214.squeeze(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t_24)<br><span class="hljs-comment"># tensor([[1, 2, 3, 4], [5, 6, 7, 8]])</span><br><br><span class="hljs-comment"># 将2×4的维度再转换成2×1×4，在第二个维度上加一维</span><br><span class="hljs-comment"># 索引是从0开始的。参数0代表第一维，参数1代表第二维，以此类推</span><br><span class="hljs-built_in">print</span>(t_24.unsqueeze(<span class="hljs-number">1</span>))<br>tensor([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]], [[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]])<br></code></pre></td></tr></table></figure><h3 id="tensor-——-value"><a href="#tensor-——-value" class="headerlink" title="tensor ——&gt; value"></a>tensor ——&gt; value</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n = torch.tensor(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(n) <span class="hljs-comment"># tensor(1)</span><br><br><span class="hljs-comment"># 使用.item()方法将张量转为python中的数值</span><br>n.item() <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><h2 id="张量的索引"><a href="#张量的索引" class="headerlink" title="张量的索引"></a>张量的索引</h2><p>张量是有序序列，我们可以根据每个元素在系统内的顺序位置，来找出特定的元素，也就是索引。</p><p>一维张量索引与Python中的索引一样是是从左到右，从0开始的，遵循格式为[start: end: step]。</p><h2 id="张量的合并与分割"><a href="#张量的合并与分割" class="headerlink" title="张量的合并与分割"></a>张量的合并与分割</h2><blockquote><p>当对一个张量进行切割时，返回的是原始张量的一个视图（view）或子集，而不是创建一个新的张量。这意味着切片返回的是原始张量的一个引用，并与原始张量共享数据存储，<strong>所以在修改切片返回的张量时，会同时修改原始张量中相应的元素。</strong> 需要注意的是，如果我们希望创建一个拷贝而非共享内存的切片，可以使用 .copy() 方法，这样操作切片将不会对原始张量产生影响。</p></blockquote><h3 id="张量的分割-chunk-split"><a href="#张量的分割-chunk-split" class="headerlink" title="张量的分割 chunk &amp; split"></a>张量的分割 chunk &amp; split</h3><p>chunk(tensor, chunks, dim)能够按照某个维度(dim)对张量进行均匀切分(chunks)，并且返回结果是原张量的视图。</p><h3 id="张量的合并-cat"><a href="#张量的合并-cat" class="headerlink" title="张量的合并 cat"></a>张量的合并 cat</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.zeros(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[0., 0., 0.],</span><br><span class="hljs-comment">#         [0., 0., 0.]])</span><br><br>b = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]])</span><br><br><br>因为在张量a与b中，shape的第一个位置是代表向量维度，所以当dim取<span class="hljs-number">0</span>时，就是将向量进行合并，向量中的标量数不变：<br>torch.cat([a, b], dim = <span class="hljs-number">0</span>) <br><span class="hljs-comment"># tensor([[0., 0., 0.],</span><br><span class="hljs-comment">#         [0., 0., 0.],</span><br><span class="hljs-comment">#         [1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]])</span><br><br>当dim取<span class="hljs-number">1</span>时，shape的第二个位置是代表列，即标量数，就是在列上（标量维度）进行拼接，行数（向量数）不变：<br>torch.cat([a, b], dim = <span class="hljs-number">1</span>)<br><span class="hljs-comment"># tensor([[0., 0., 0., 1., 1., 1.],</span><br><span class="hljs-comment">##        [0., 0., 0., 1., 1., 1.]])</span><br></code></pre></td></tr></table></figure><h3 id="张量的堆叠-stack"><a href="#张量的堆叠-stack" class="headerlink" title="张量的堆叠 stack"></a>张量的堆叠 stack</h3><p>和拼接不同，堆叠不是将元素拆分重装，而是将各参与堆叠的对象分装到一个更高维度的张量里。<br>和 cat 的区别：拼接之后维度不变，堆叠之后维度升高。拼接是把一个个元素单独提取出来之后再放到二维张量里，而堆叠则是直接将两个二维向量封装到一个三维张量中。因此，堆叠的要求更高，参与堆叠的张量必须形状完全相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.zeros(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[0., 0., 0.],</span><br><span class="hljs-comment">#         [0., 0., 0.]])</span><br><br>b = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]])</span><br><br>torch.stack([a, b], dim = <span class="hljs-number">0</span>)<br><span class="hljs-comment"># tensor([[[0., 0., 0.],</span><br><span class="hljs-comment">#          [0., 0., 0.]],</span><br><span class="hljs-comment">#         [[1., 1., 1.],</span><br><span class="hljs-comment">#          [1., 1., 1.]]])</span><br><br>torch.stack([a, b], dim = <span class="hljs-number">0</span>).shape<br><span class="hljs-comment"># torch.Size([2, 2, 3])</span><br></code></pre></td></tr></table></figure><h1 id="12-3"><a href="#12-3" class="headerlink" title="12.3"></a>12.3</h1><h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><blockquote><p>通道注意力（Channel Attention），空间注意力（Spatial Attention），分支注意力（Branch Attention），自注意力（Self Attention）和交叉注意力（Cross Attention）</p></blockquote><h1 id="12-8"><a href="#12-8" class="headerlink" title="12.8"></a>12.8</h1><h1 id="vision-transformer"><a href="#vision-transformer" class="headerlink" title="vision transformer"></a>vision transformer</h1><h1 id="grad-cam"><a href="#grad-cam" class="headerlink" title="grad-cam"></a>grad-cam</h1><h1 id="Vit-Grad-Cam"><a href="#Vit-Grad-Cam" class="headerlink" title="Vit + Grad-Cam"></a>Vit + Grad-Cam</h1><blockquote><p><code>https://zhuanlan.zhihu.com/p/640450435</code><br>Grad-CAM 对 ViT 的输出进行可视化的原理是利用 ViT 的最后一个注意力块的输出和梯度，计算出每个 token 对分类结果的贡献度，然后将这些贡献度映射回原始图像的空间位置，形成一张热力图。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>损失函数</title>
    <link href="/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><blockquote><p>用来量化模型预测值和真实标签之间的差异</p></blockquote><h2 id="0-1损失函数"><a href="#0-1损失函数" class="headerlink" title="0-1损失函数"></a>0-1损失函数</h2><blockquote><p>模型在训练集上的错误率</p></blockquote><h2 id="平方损失函数"><a href="#平方损失函数" class="headerlink" title="平方损失函数"></a>平方损失函数</h2><blockquote><p>用来预测标签 y 为实数值的任务，一般不适用于分类任务</p></blockquote><h2 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h2><blockquote><p>一般用于分类任务<br>计算：比如三分类问题，一个样本标签的one-hot向量为 $y &#x3D; [0,0,1]^T$ , 模型预测的标签分布为 $[0.3,0.3,0.4]^T$ , 则它们的交叉熵为 $-(0 * log(0.3) + 0 * log(0.3) + 1 * log(0.4)) &#x3D; -log(0.4)$</p></blockquote><h1 id="过-欠拟合"><a href="#过-欠拟合" class="headerlink" title="过&#x2F;欠拟合"></a>过&#x2F;欠拟合</h1><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><ol><li>批量梯度下降法（BGD）在每次迭代时要计算每个样本上损失函数的梯度并求和</li><li>随机梯度下降法（SGD）为了减少每次迭代的</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>表示学习</title>
    <link href="/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h1><blockquote><p>在深度学习中，前面的层为表示学习，最后一层为预测学习</p></blockquote><ol><li><strong>自动地学习出有效的特征</strong>，并最终提高机器学习模型的性能的算法就叫做表示学习。</li><li>表示学习关键是解决语义鸿沟问题————是指输入数据的底层特征表示和高层的抽象语义特征不一致性。（对于一些不同颜色和形状的车来说，它们在像素级别的表示（底层特征表示）上相差很大，但我们认为它们都是车是建立在高层语义特征上的）</li><li>表示学习的两个核心问题：<br><strong>什么是一个好的表示</strong><br><strong>如何学习到好的表示</strong></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="局部表示"><a href="#局部表示" class="headerlink" title="局部表示"></a>局部表示</h3><p>也叫离散表示或符号表示，通常用<strong>one-hot向量</strong>表示，假设所有颜色构成一个词表，词表长度为|V|,可以用一个v维的向量来表示特征，在第i种颜色所对应的one-hot向量中的第 i 维为1，其他维为0</p><p><strong>优点：</strong></p><ol><li>离散的表示方式具有好的解释性</li><li>这种特征表示通常是稀疏的二值向量，计算效率高</li></ol><p><strong>缺点：</strong></p><ol><li>维数高，不易扩展</li><li>不同特征之间的相似度都为0（按理来说红色与粉红色的相似度肯定比 红色和黑色高）</li></ol><h3 id="分布式表示"><a href="#分布式表示" class="headerlink" title="分布式表示"></a>分布式表示</h3><p>用RGB三个数值来表示颜色</p><p>优点：</p><ol><li>向量维度要低，更容易扩展</li><li>不同颜色的相似度也容易计算</li></ol><p><strong>嵌入</strong></p><blockquote><p>使用神经网络将高维的局部表示空间映射到一个低维的分布式表示空间，这个过程被称为嵌入</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>浅层学习，不涉及特征学习，特征来源于人工提取</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li><code>Sklearn</code> python的机器学习库</li></ol><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol><li><strong>数据预处理</strong>（去掉一些有缺失特征的样本；去掉一些冗余的数据特征；对数值特征进行缩放和归一化；）</li><li><strong>特征提取：</strong>从数据的原始特征中提取一些对特定机器学习任务有用的高质量特征（比如在图像分类中提取边缘）</li><li><strong>特征转换：</strong>对特征进行进一步的加工，比如降维和升维，降维包括特征抽取和特征选择。常用特征转换方法有主成分分析（PCA）和线性判别（LDA）</li><li><strong>预测：</strong>学习一个函数并进行预测</li></ol><h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><blockquote><p>线性模型是机器学习中应用最广泛的模型，指通过样本特征的线性组合来进行预测的模型，给定一个D维样本 $x &#x3D; [x_1,…,x_D]^T$ , 其<strong>线性组合(判别)函数</strong>为 </p></blockquote><p>$$<br>f(x;w) &#x3D; w_1x_1 + w_2x_2 + … + w_Dx_D + b<br>       &#x3D; w^Tx + b<br>$$</p><p>其中 $w &#x3D; [w_1,…,w_D]$ 为 D维的权重向量，b为偏置<br>对于分类问题，要在线性组合函数的基础上引入<strong>非线性的决策函数</strong> $g()$ 来预测输出目标<br>$$<br>y &#x3D; g(f(x;w))<br>$$</p><ol><li><p><strong>一个 线性分类模型 主要由 一个或多个线性的判别函数 和 非线性的决策函数 组成</strong></p></li><li><p>接下来介绍四种不同的线性分类模型（线性分类器）：Logistic回归、Softmax回归、感知机、支持向量机。主要区别在于<strong>使用了不同的损失函数</strong></p></li></ol><h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><p>机器学习算法分类：监督学习、无监督学习、强化学习</p><ol><li>**监督学习算法 (Supervised Algorithms）:**在监督学习训练过程中，可以由训练数据集学到或建立一个模式（函数 &#x2F; learning model），并依此模式推测新的实例。该算法要求特定的输入&#x2F;输出，首先需要决定使用哪种数据作为范例。例如，文字识别应用中一个手写的字符，或一行手写文字。主要算法包括神经网络、支持向量机、最近邻居法、朴素贝叶斯法、决策树等。</li><li>**无监督学习算法 (Unsupervised Algorithms):**这类算法没有特定的目标输出，算法将数据集分为不同的组。</li><li>**强化学习算法 (Reinforcement Algorithms):**强化学习普适性强，主要基于决策进行训练，算法根据输出结果（决策）的成功或错误来训练自己，通过大量经验训练优化后的算法将能够给出较好的预测。类似有机体在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。在运筹学和控制论的语境下，强化学习被称作“近似动态规划”</li></ol><p>基本的机器学习算法：线性回归、支持向量机(SVM)、最近邻居(KNN)、逻辑回归、决策树、k平均、随机森林、朴素贝叶斯、降维、梯度增强</p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归算法（Linear Regression）的建模过程就是使用数据点来寻找最佳拟合线</p><ol><li>多元线性回归<br>多元线性回归是回归分析中的一种复杂模型，它考虑了多个输入变量对输出变量的影响。与一元线性回归不同，多元线性回归通过引入多个因素，更全面地建模了系统关系。</li></ol><p>多元线性回归模型的表达式为：$f ( x ) &#x3D;\mathbf{k^T}\mathbf{x}+b$<br>其中，$\mathbf{x}$为输入向量，包含多个特征（自变量）；$f(\mathbf{x})$为模型的输出或响应（预测的目标变量）；$\mathbf{k^T}$ 为特征权重；$b$为是模型的截距或偏置；我们的目标是通过学习$\mathbf{k^T}$ 和 $b$ 使得 $f(\mathbf{x})$ 尽可能的接近真实观测值 $\mathbf{y}$</p><p>直白点说：首先求出当前模型的 所有采样点上的预测值𝑤𝑥(𝑖) +𝑏与真实值𝑦(𝑖)之间的差的平方和作为总误差ℒ，然后搜索一组参数𝑤∗,𝑏∗使得ℒ最小，对应的直线就是我们要寻找的最优直线</p><ol start="2"><li>实现方式</li></ol><p><strong>全局梯度下降</strong><br>梯度下降法是一种迭代算法。选取适当的初值x(0)，不断迭代，更新x的值，进行<strong>目标函数(也是线性回归的损失函数)的极小化</strong>，直到收敛。（它从一个初始点开始，反复使用某种规则从移动到下一个点，构造这样一个数列，直到<strong>收敛到梯度为0的点处</strong>，即梯度下降算法）<br>由于负梯度方向时使函数值下降最快的方向，在迭代的每一步，<strong>以负梯度方向更新x的值</strong>，从而达到减少函数值的目的</p><p>线性回归一般选择的是MSE（均方误差）<br><strong>均方误差</strong>是预测值与真实值之间差值的平方的平均值</p><p><strong>学习率在梯度下降法中的作用</strong><br>我们可以通过 𝜼 来控制每一步走的距离</p><ol><li>以保证不要走的太快，错过了最低点</li><li>同时也要保证收敛速度不要太慢</li></ol><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p><strong>逻辑回归和线性回归区别：</strong></p><p>逻辑回归：</p><ol><li>逻辑回归是一种用于分类问题的模型，而不是回归问题。它用于预测二元分类或多元分类的概率。</li><li>损失函数通常是对数损失函数（log loss），也称为交叉熵损失函数（cross-entropy loss）。</li><li>目标是最大化似然函数或最小化损失函数，通常通过梯度下降等方法实现。</li><li>相比较线性回归的连续值直接求解，在逻辑回归中，还需要<strong>使用Sigmoid函数将回归方程映射成概率进行分类</strong></li></ol><p>线性回归：</p><ol><li>线性回归用于预测连续型变量的值，是一种回归模型。</li><li>损失函数通常是均方误差（Mean Squared Error，MSE）。</li><li>目标是最小化损失函数，通过梯度下降等方法实现。</li></ol><h3 id="KNN算法（最近邻居-k-近邻算法）"><a href="#KNN算法（最近邻居-k-近邻算法）" class="headerlink" title="KNN算法（最近邻居&#x2F;k-近邻算法）"></a>KNN算法（最近邻居&#x2F;k-近邻算法）</h3><p>KNN算法是一种基于实例的学习，或者是局部近似和将所有计算推迟到分类之后的惰性学习。KNN主要用于分类问题</p><p>用最近的邻居（k）来预测未知数据点。k 值是预测精度的一个关键因素，无论是分类还是回归，衡量邻居的权重都非常有用，较近邻居的权重比较远邻居的权重大</p><p>ex. 假设k &#x3D; 5，代表用周围5个点来估计未知数据点的类别，这5个点中比例最高的类别即为该预测类别</p><ol><li><p>需要想办法来计算两个样本之间的距离或者相似度，之后才能选出最相近的样本。<strong>欧氏距离</strong>是一个最简单常用的方法</p></li><li><p>怎么确定K值<br>确定KNN算法的K值通常需要通过<strong>交叉验证</strong></p></li></ol><ul><li>将数据集分成K份（通常K取5或10），每次选择其中一份作为验证集，剩下的K-1份作为训练集。</li><li>对于每个K值，重复K次交叉验证，计算模型在验证集上的性能指标（如准确率、F1分数等）的平均值。</li><li>根据性能指标的表现选择最优的K值。</li></ul><h3 id="决策树（Decision-Tress）"><a href="#决策树（Decision-Tress）" class="headerlink" title="决策树（Decision Tress）"></a>决策树（Decision Tress）</h3><ol><li>决策树（Decision tree）是一种特殊的树结构，由一个决策图和可能的结果（例如成本和风险）组成，用来辅助决策。</li><li>机器学习中，决策树是一个预测模型，树中每个节点表示某个对象，而每个分叉路径则代表某个可能的属性值，而每个叶节点则对应从根节点到该叶节点所经历的路径所表示的对象的值。</li><li>决策树仅有单一输出，通常该算法用于解决分类问题。</li></ol><p><strong>决策树节点的划分</strong><br>熵：代表一个系统的混乱程度，越混乱熵越高<br>划分依据：<strong>最大化信息增益（熵）</strong><br>比较多个特征的信息增益，选择信息增益最大的特征作为根节点进行划分。然后，重复这个过程，对每个子节点进行划分，直到满足停止条件（如节点包含的样本数小于预定义阈值）为止</p><p>信息增益的计算步骤：</p><ol><li>计算每个类别的信息熵</li><li>求离散的特征属性值 a 对数据集 D 的条件信息熵</li><li>计算信息增益</li></ol><p><img src="/../../img/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A.png"></p><h2 id="损失函数、代价函数、目标函数"><a href="#损失函数、代价函数、目标函数" class="headerlink" title="损失函数、代价函数、目标函数"></a>损失函数、代价函数、目标函数</h2><ul><li><strong>损失函数</strong> Loss Function 通常是<strong>针对单个训练样本而言</strong>，给定一个模型输出 $\hat{y}$ 和一个真实 $y$ ，损失函数输出一个实值损失 $L&#x3D;f(y_i, \hat{y_i})$</li><li><strong>代价函数</strong> Cost Function 通常是<strong>针对整个训练集</strong>（或者在使用 mini-batch gradient descent 时一个 mini-batch）的总损失 $J&#x3D;\sum_{i&#x3D;1}^{N} f(y_i,\hat{y_i})$</li><li><strong>目标函数</strong> Objective Function 是一个更通用的术语，表示任意<strong>希望被优化的函数</strong>，用于机器学习领域和非机器学习领域（比如运筹优化）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和和差分</title>
    <link href="/2024/04/12/algorithm_know/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2024/04/12/algorithm_know/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h1><p><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">前缀和和差分</a></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><blockquote><p>给定两个序列，要求将其中一个序列变成另一个序列，我们都可以将其转化到差分数组上，让两个序列的差分数组相同 <code>A ——&gt; B 相当于从 A-B ——&gt; 0</code></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dfs/bfs练习题</title>
    <link href="/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-bfs%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-bfs%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs-bfs练习题"><a href="#dfs-bfs练习题" class="headerlink" title="dfs&#x2F;bfs练习题"></a>dfs&#x2F;bfs练习题</h1><h2 id="母亲的牛奶"><a href="#母亲的牛奶" class="headerlink" title="母亲的牛奶"></a>母亲的牛奶</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/1357/">母亲的牛奶</a></p><p><img src="/../../img/%E6%AF%8D%E4%BA%B2%E7%9A%84%E7%89%9B%E5%A5%B6.png"></p><p><strong>步骤：</strong></p><ol><li>分析题目，找出总共有多少种状态，从而得出队列数组的内存空间</li><li>每种状态相当于一个点，状态与状态之间的转变相当于一条边</li><li>bfs遍历，将每种状态都存在队列中。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//A，B，C最大为20升</span><br><span class="hljs-comment">//状态个数为20^3</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>;<br><span class="hljs-type">int</span> A,B,C;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>&#125;q[N*N*N]; <span class="hljs-comment">//关键点，队列数组q有N^3个状态</span><br> <br><span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br><br><span class="hljs-type">bool</span> st[N][N][N];<br><span class="hljs-type">int</span> s[N]; <span class="hljs-comment">//记录当 A桶是空的时候，C桶中可能包含多少升牛奶</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!st[a][b][c])&#123;<br>        q[++tt] = &#123;a,b,c&#125;;<br>        st[a][b][c] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    q[++tt] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,C&#125;;<br>    st[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][C] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        node t = q[hh];<br>        hh++;<br>        <span class="hljs-type">int</span> a = t.a; <span class="hljs-type">int</span> b = t.b; <span class="hljs-type">int</span> c = t.c;<br>        <span class="hljs-comment">//由当前状态可以得到2*3 = 6 种状态</span><br>        <span class="hljs-comment">//从A开始转移</span><br>        <span class="hljs-built_in">insert</span>(a-<span class="hljs-built_in">min</span>(a,B-b), <span class="hljs-built_in">min</span>(a+b,B), c);<br>        <span class="hljs-built_in">insert</span>(a-<span class="hljs-built_in">min</span>(a,C-c), b, <span class="hljs-built_in">min</span>(a+c,C));<br>        <span class="hljs-comment">//从B开始转移</span><br>        <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">min</span>(a+b,A), b-<span class="hljs-built_in">min</span>(b,A-a), c);<br>        <span class="hljs-built_in">insert</span>(a, b-<span class="hljs-built_in">min</span>(b,C-c), <span class="hljs-built_in">min</span>(b+c,C));<br>        <span class="hljs-comment">//从C开始转移</span><br>        <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">min</span>(a+c,A), b, c-<span class="hljs-built_in">min</span>(c,A-a));<br>        <span class="hljs-built_in">insert</span>(a, <span class="hljs-built_in">min</span>(b+c,B), c-<span class="hljs-built_in">min</span>(c,B-b));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;<br>    <span class="hljs-built_in">bfs</span>();<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;hh;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q[i].a == <span class="hljs-number">0</span>)&#123;<br>            s[cnt] = q[i].c;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(s,s+cnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连通图的遍历</title>
    <link href="/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="连通图的遍历"><a href="#连通图的遍历" class="headerlink" title="连通图的遍历"></a>连通图的遍历</h1><blockquote><p>“连通块问题”，是基础搜索。用DFS或BFS都行：遍历一个连通块（找到这个连通块中所有的’#‘，并标记已经搜过，不用再搜）；再遍历下一个连通块…；遍历完所有连通块，统计有多少个连通块。</p></blockquote><h2 id="全球变暖"><a href="#全球变暖" class="headerlink" title="全球变暖"></a>全球变暖</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/1235/">全球变暖</a></p><p><img src="/../../img/%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96.png"></p><p><strong>步骤：</strong></p><ol><li>对图g[N][N]进行循环，每次从是陆地并且没有遍历过的点开始搜索</li><li>进入dfs函数，将当前搜到的点置为true</li><li>然后以此点为中心向四个方向遍历，直到周围没有满足条件（即是陆地又没遍历过的）的点</li><li>便会开始向上回溯直到一步步回溯到退出dfs函数</li><li>如果本次找到的连通块中有一个点其四个方向都是陆地，则这个岛屿不会被完全淹没，否则会被完全淹没。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> st[N][N];<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> d[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">//四个方向</span><br><span class="hljs-type">int</span> flag,ans=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    st[i][j] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;ij:&quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-keyword">if</span>(g[i+<span class="hljs-number">1</span>][j]==<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//继续DFS周围的陆地</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;<span class="hljs-number">4</span>;a++)&#123;<br>        <span class="hljs-type">int</span> x = i+dx[a]; <span class="hljs-type">int</span> y = j+dy[a];<br>        <span class="hljs-comment">//继续DFS未搜过的陆地，目的是标记它们   </span><br>        <span class="hljs-comment">//if(nx&gt;=1 &amp;&amp; nx&lt;=n &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=n &amp;&amp; vis[nx][ny]==0 &amp;&amp; a[nx][ny]==&#x27;#&#x27;) //题目说边上都是水，所以不用这么写了</span><br>        <span class="hljs-keyword">if</span>(!st[x][y] &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(x,y);<br>            <span class="hljs-comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; !st[i][j])&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(i,j);<br>                <span class="hljs-comment">// cout &lt;&lt; &quot;本次连通图查找完毕&quot; &lt;&lt; &quot;\n&quot;;</span><br>                <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//这个岛全部被淹</span><br>                    ans++; <span class="hljs-comment">//统计被淹的岛的数量</span><br>                    <br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈和单调队列</title>
    <link href="/2024/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h1><ol><li>先想暴力怎么做，再考虑把没有用的元素删掉，再看有没有单调性，有单调性的话再看怎么优化 </li><li>直接看逆序有没有用，若逆序没用，就有单调性！（在一个从小到大排列的数列中，若左边的数比右边的数大，就称作逆序数）</li></ol><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><blockquote><p>一段本不具有单调性的区间，用一个栈去维护使得其具有单调性（将元素入栈，如果其是逆序的，就让它出栈）</p></blockquote><p><img src="/../../img/%E5%8D%95%E8%B0%83%E6%A0%88.png"></p><p><strong>步骤：</strong></p><ol><li><strong>while循环</strong>判断栈顶元素是否大于 a[i]，如果大于则出栈</li><li>如果<strong>此时栈不空</strong>则将新的元素 a[i] 赋给答案数组ans</li><li>如果<strong>此时栈空</strong>则将 -1 赋给答案数组ans</li><li>将当前元素 a[i] 入栈</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,a[N];<br><span class="hljs-type">int</span> stk[N],tt; <span class="hljs-comment">//tt为0代表栈空</span><br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//这个地方是while</span><br>        <span class="hljs-keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= a[i]) tt--; <span class="hljs-comment">//出栈</span><br>        <span class="hljs-keyword">if</span>(tt) ans[i] = stk[tt];<br>        <span class="hljs-keyword">else</span> ans[i] = <span class="hljs-number">-1</span>;<br>        stk[++tt] = a[i]; <span class="hljs-comment">//入栈</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/156/">滑动窗口</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,k,a[N];<br><span class="hljs-type">int</span> q[N],hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//判断队头是否已经不在滑动窗口内了</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; i-k+<span class="hljs-number">1</span> &gt; q[hh]) hh++;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; <span class="hljs-comment">//不满足条件出队</span><br>        q[++tt] = i; <span class="hljs-comment">//新元素入队</span><br>        <br>        <span class="hljs-comment">//i指针到达滑动窗口末端,可以开始输出队头值</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出单调地址队列的队头，即最小值</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <br>    <span class="hljs-comment">//队列清空</span><br>    hh = <span class="hljs-number">0</span>; tt=<span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//判断队头是否已经不在滑动窗口内了</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; i-k+<span class="hljs-number">1</span> &gt; q[hh]) hh++;<br>        <span class="hljs-comment">//两个for循环只有 这里从 &gt;= 变成了 &lt;=</span><br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; <span class="hljs-comment">//不满足条件出队</span><br>        q[++tt] = i; <span class="hljs-comment">//新元素入队</span><br>        <br>        <span class="hljs-comment">//i指针到达滑动窗口末端,可以开始输出队头值</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出单调地址队列的队头，即最小值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的直径</title>
    <link href="/2024/04/10/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2024/04/10/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><blockquote><p>定义：树上任意两节点之间最长的简单路径即为树的「直径」<br>显然，一棵树可以有多条直径，他们的长度相等。<br>可以用两次 DFS 或者树形 DP 的方法在 O(n) 时间求出树的直径。</p></blockquote><p><strong>求树的直径的方法：</strong></p><ol><li><p>任取一点作为起始点k，找到距离该点最远的一个点v。</p></li><li><p>从点v开始搜，找到距离点v最远的一点u，则uv间的距离是树的直径。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//1KB=1024B（字节），1MB=1024KB，所以1MB大约等于100w字节（1e6）64MB = 6400w字节 （6*1e7）</span><br><span class="hljs-comment">//int 占四字节</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2</span>*N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx=<span class="hljs-number">1</span>,w[M]; <span class="hljs-comment">//</span><br><span class="hljs-type">bool</span> st[N];<br>LL s[<span class="hljs-number">10100</span>];<br>LL maxu,maxd;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    e[idx] = b; ne[idx] = h[a]; h[a] = idx; w[idx] = d; idx++; <span class="hljs-comment">//idx要最后再++</span><br>&#125;<br><br><span class="hljs-comment">//求距离某个点u最远的点maxu,以及距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])&#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(maxd &lt; d+w[i])&#123;<br>                <span class="hljs-comment">//maxu是距离u最远的点，maxd是 u和maxu 的距离</span><br>                maxd = d+w[i];<br>                maxu = j;<br>            &#125;<br>            <span class="hljs-built_in">dfs</span>(j,d+w[i]);<br>            st[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-comment">//这里是到n-1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,d;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;<br>        <span class="hljs-built_in">add</span>(a,b,d); <span class="hljs-built_in">add</span>(b,a,d);<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; s[4] &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">// int ans,max=0,pos;</span><br>    <span class="hljs-comment">// for(int i=2;i&lt;=n;i++)&#123;</span><br>    <span class="hljs-comment">//     memset(st,0,sizeof(st));</span><br>    <span class="hljs-comment">//     ans = dfs(1,i,0);</span><br>    <span class="hljs-comment">//     if(ans &gt; max)&#123;</span><br>    <span class="hljs-comment">//         max = ans;</span><br>    <span class="hljs-comment">//         pos = i;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <span class="hljs-built_in">dfs</span>(maxu,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; u &lt;&lt; pos;</span><br>    <span class="hljs-comment">// memset(st,0,sizeof(st));</span><br>    <span class="hljs-comment">// cout &lt;&lt; maxd; </span><br>    <span class="hljs-comment">//n(a1+an)/2</span><br>    cout &lt;&lt; ( <span class="hljs-number">11</span> + (<span class="hljs-number">11</span>+maxd<span class="hljs-number">-1</span>) )*maxd/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; s[maxd];</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2024/04/10/algorithm_know/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2024/04/10/algorithm_know/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p>步骤：</p><ol><li>将区间按照左端点进行排序</li><li>循环判断，如果下一个区间的左端点小于（等于）当前区间的右端点时则可以合并，并更新右端点的最大值</li><li>如果下一个区间的左端点大于当前区间的右端点时则不可以合并，则更新右端点的最大值为下一个区间的右端点</li></ol><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//t代表有人挤奶牛的区间的集合，f代表没有挤奶牛的区间的集合</span><br><span class="hljs-comment">//初始化</span><br>    LL maxr = a[<span class="hljs-number">1</span>].r;<br>    t[++<span class="hljs-type">num_t</span>] = a[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//循环遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>].l &lt;= maxr)&#123;<br>            maxr = <span class="hljs-built_in">max</span>(maxr,a[i+<span class="hljs-number">1</span>].r);<br>            t[<span class="hljs-type">num_t</span>].r = maxr;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            f[++num_f] = &#123;t[<span class="hljs-type">num_t</span>].r , a[i+<span class="hljs-number">1</span>].l&#125;; <span class="hljs-comment">//老区间的r和新区间的l</span><br>            t[++<span class="hljs-type">num_t</span>] = a[i+<span class="hljs-number">1</span>];<br>            maxr = a[i+<span class="hljs-number">1</span>].r;<br>            <span class="hljs-comment">// cnt++; 区间个数</span><br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>求区间合并之后区间的总个数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">int</span> n,cnt=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    LL l,r;<br>&#125;a[N],ans[N];<br><span class="hljs-comment">//左端点从小到大排列</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmd</span><span class="hljs-params">(node a, node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.l &lt; b.l;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        a[i] = &#123;l,r&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmd);<br>    <span class="hljs-comment">//从第二个区间开始判断</span><br>    LL maxr = a[<span class="hljs-number">1</span>].r;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>].l &lt;= maxr)&#123;<br>            maxr = <span class="hljs-built_in">max</span>(maxr,a[i+<span class="hljs-number">1</span>].r);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cnt++;<br>            maxr = a[i+<span class="hljs-number">1</span>].r;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="挤奶牛"><a href="#挤奶牛" class="headerlink" title="挤奶牛"></a>挤奶牛</h3><blockquote><p>求区间合并后各个区间的范围</p></blockquote><p><img src="/../../img/%E6%8C%A4%E5%A5%B6%E7%89%9B.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">int</span> n;<br>LL <span class="hljs-type">num_t</span>,num_f,<span class="hljs-type">max_t</span>,max_f;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    LL l,r;<br>&#125;a[N],t[N],f[N]; <span class="hljs-comment">//t代表有人挤奶牛的区间的集合，f代表没有挤奶牛的区间的集合</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmd</span><span class="hljs-params">(node a,node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.l &lt; b.l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmd);<br>    LL maxr = a[<span class="hljs-number">1</span>].r;<br>    t[++<span class="hljs-type">num_t</span>] = a[<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>].l &lt;= maxr)&#123;<br>            maxr = <span class="hljs-built_in">max</span>(maxr,a[i+<span class="hljs-number">1</span>].r);<br>            t[<span class="hljs-type">num_t</span>].r = maxr;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            f[++num_f] = &#123;t[<span class="hljs-type">num_t</span>].r , a[i+<span class="hljs-number">1</span>].l&#125;; <span class="hljs-comment">//老区间的r和新区间的l</span><br>            t[++<span class="hljs-type">num_t</span>] = a[i+<span class="hljs-number">1</span>];<br>            maxr = a[i+<span class="hljs-number">1</span>].r;<br>            <span class="hljs-comment">// cnt++; 区间个数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-type">num_t</span>;i++)&#123;<br>        <span class="hljs-comment">// cout &lt;&lt; t[i].l &lt;&lt; &quot; &quot; &lt;&lt; t[i].r &lt;&lt; &quot;\n&quot;;</span><br>        <span class="hljs-type">max_t</span> = <span class="hljs-built_in">max</span>(<span class="hljs-type">max_t</span>,t[i].r-t[i].l);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num_f;i++)&#123;<br>        <span class="hljs-comment">// cout &lt;&lt; f[i].l &lt;&lt; &quot; &quot; &lt;&lt; f[i].r &lt;&lt; &quot;\n&quot;;</span><br>        max_f = <span class="hljs-built_in">max</span>(max_f,f[i].r-f[i].l);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-type">max_t</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; max_f;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>区间合并</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>区间合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><ol><li>考预测分析法，不考梯度下降法</li></ol>]]></content>
    
    
    <categories>
      
      <category>期末复习</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>期末复习</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日期问题</title>
    <link href="/2024/04/10/algorithm_know/%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/10/algorithm_know/%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h1><h2 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h2><ol><li>是否是闰年来确定二月的天数</li><li>日期是否合理（month在1<del>12 day在1</del>28&#x2F;29&#x2F;30&#x2F;31（根据月份来判断））</li><li>日期的输出顺序是否合理</li><li>日期相同时只需要输出一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string c;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    string yy,mm,dd;<br>&#125;d[<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmd</span><span class="hljs-params">(<span class="hljs-type">const</span> node&amp; a, <span class="hljs-type">const</span> node&amp; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.yy != b.yy) <span class="hljs-keyword">return</span> a.yy &lt; b.yy;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.mm != b.mm) <span class="hljs-keyword">return</span> a.mm &lt; b.mm;<br>    <span class="hljs-keyword">else</span>&#123;<br>        a.dd &lt; b.dd;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; c;<br>    string yy,mm,dd;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> day[<span class="hljs-number">12</span>] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        string str = c;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>            yy = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>); mm = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); dd = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>            yy = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>); mm = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>); dd = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            yy = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>); mm = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); dd = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(yy &lt;= <span class="hljs-string">&quot;59&quot;</span>)&#123;<br>            yy = <span class="hljs-string">&quot;20&quot;</span> + yy;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            yy = <span class="hljs-string">&quot;19&quot;</span> + yy;<br>        &#125;<br>        <br>        string t = yy;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">stoi</span>(t);<br>        <br>        <span class="hljs-keyword">if</span>(mm &lt;= <span class="hljs-string">&quot;00&quot;</span> || mm &gt; <span class="hljs-string">&quot;12&quot;</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mm == <span class="hljs-string">&quot;02&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || (a % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; a % <span class="hljs-number">100</span> !=<span class="hljs-number">0</span> ))&#123;<br>                <span class="hljs-keyword">if</span>(dd &gt; <span class="hljs-string">&quot;29&quot;</span> || dd &lt;= <span class="hljs-string">&quot;00&quot;</span> ) <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(dd &gt; <span class="hljs-string">&quot;28&quot;</span> || dd &lt;= <span class="hljs-string">&quot;00&quot;</span> ) <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mm == <span class="hljs-string">&quot;01&quot;</span> || mm == <span class="hljs-string">&quot;03&quot;</span> || mm == <span class="hljs-string">&quot;05&quot;</span> || mm == <span class="hljs-string">&quot;07&quot;</span> || mm == <span class="hljs-string">&quot;08&quot;</span> || mm == <span class="hljs-string">&quot;10&quot;</span> || mm == <span class="hljs-string">&quot;12&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(dd &lt;= <span class="hljs-string">&quot;00&quot;</span> || dd &gt; <span class="hljs-string">&quot;31&quot;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(dd &lt;= <span class="hljs-string">&quot;00&quot;</span> || dd &gt; <span class="hljs-string">&quot;30&quot;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>            <span class="hljs-keyword">if</span>(yy == d[i].yy &amp;&amp; mm == d[i].mm &amp;&amp; dd == d[i].dd) flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//这个地方要用cnt，不能用i，因为i一直在循环中增加，但放入结构体数组中的数只有满足条件才会放入</span><br>        d[cnt] = &#123;yy,mm,dd&#125;;<br>        cnt ++;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(d,d+cnt,cmd);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        cout &lt;&lt; d[i].yy &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; d[i].mm &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; d[i].dd &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找练习题</title>
    <link href="/2024/04/08/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/08/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找练习题"><a href="#二分查找练习题" class="headerlink" title="二分查找练习题"></a>二分查找练习题</h1><h2 id="卡牌"><a href="#卡牌" class="headerlink" title="卡牌"></a>卡牌</h2><p>题目链接：<a href="https://www.lanqiao.cn/problems/2191/learning/?subject_code=1&group_code=4&match_num=13&match_flow=2&origin=cup">卡牌</a></p><p><img src="/../../img/%E5%8D%A1%E7%89%8C%E4%BA%8C%E5%88%86.png"></p><p><strong>tips:</strong></p><ol><li>记得开long long （最好把<strong>所有的数据都从 int 变成 long long</strong>）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e11</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL n,m,a[N],b[N];<br><br><span class="hljs-comment">//mid为能凑出的牌的套数</span><br><span class="hljs-comment">//m是全局变量，而每次判断 mid 是否满足条件时都要用到总空白牌数m这个值，因此 要用一个变量去代替 m 去操作 </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span>&#123;<br>  LL sum = m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(a[i] &gt;= mid) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(b[i]+a[i] &lt; mid || sum+a[i] &lt; mid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    sum = sum - (mid - a[i]); <br>  &#125;<br>  <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; b[i];<br>  &#125;<br>  LL l = <span class="hljs-number">0</span>, r = INT_MAX; <br>  <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    LL mid = (l+r+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>      l = mid;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      r = mid<span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; l;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp背包问题练习题</title>
    <link href="/2024/04/07/dp/dp%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/07/dp/dp%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="dp背包问题练习题"><a href="#dp背包问题练习题" class="headerlink" title="dp背包问题练习题"></a>dp背包问题练习题</h1><h2 id="货币系统（完全背包）"><a href="#货币系统（完全背包）" class="headerlink" title="货币系统（完全背包）"></a>货币系统（完全背包）</h2><p><strong>tips：</strong></p><ol><li>要将$f[0][0]$ 等特殊的点进行初始化操作</li><li>要将$f[N][N] $设置为 $long long$</li></ol><p><img src="/../../img/1371_%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//从前v种货币中选，凑出N元钱的方案的集合的长度</span><br><span class="hljs-comment">//第v种货币不选或者选一个/两个/...</span><br><span class="hljs-comment">//如果第v种货币选一个的方案数相当于从前v-1种货币中选凑出N-v[i]的方案数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL n,m;<br>LL v[N];<br>LL f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i];<br>    &#125;<br>    <span class="hljs-comment">//注意边界值要记得初始化</span><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-comment">// f[i][j] = f[i-1][j];</span><br>            <span class="hljs-comment">// for(int k=1;k*v[i]&lt;=j;k++)</span><br>            <span class="hljs-comment">//     f[i][j] += f[i-1][j-k*v[i]];</span><br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) f[i][j] += f[i][j - v[i]];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n][m];<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="包子凑数"><a href="#包子凑数" class="headerlink" title="包子凑数"></a>包子凑数</h2><blockquote><p>问题简化为：输入n个数，求整数域内共有多少个数无法被这n个数通过加法来表示；</p></blockquote><p><strong>tips：</strong></p><ol><li>要将$f[0][0]$ 等特殊的点进行初始化操作</li><li>输入n个数，求整数域内共有多少个数无法被这n个数通过加法来表示；</li><li>当这n个数<strong>最大公因数等于 1 的时候，个数有限</strong></li><li><strong>最大公因数大于 1 的时候，个数无限</strong></li><li>最大不能表示出来的数必定有个上界; 当两个数a,b（当gcd&#x3D;1时），最大不能表示的数为(a-1)(b-1)-1 ; 当数字更多的时候，这个上界必然更小（可选的数字变多了）; 而99和98是100内最大的互质的数，所以这个上界选择10000</li></ol><p><img src="/../../img/%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//f[i][j]: 从前 i 种蒸笼种选，使得这若干笼中恰好一共有 j 个包子的方案集合</span><br><span class="hljs-comment">//属性：集合是否非空</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,a[<span class="hljs-number">110</span>],f[N][N];<br><span class="hljs-type">int</span> d; <span class="hljs-comment">//所给的几个数的最大公因数</span><br><span class="hljs-comment">//输入n个数，求整数域内共有多少个数无法被这n个数通过加法来表示；</span><br><span class="hljs-comment">//最大公因数等于 1 的时候，个数有限</span><br><span class="hljs-comment">//最大公因数大于 1 的时候，个数无限</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>        d = <span class="hljs-built_in">gcd</span>(d,a[i]); <span class="hljs-comment">//0和a[i]的最大公因数为 a[i]</span><br>    &#125;<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1e4</span>;j++)&#123;<br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= a[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i][j-a[i]]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//最大不能表示出来的数必定有个上界</span><br>    <span class="hljs-comment">//当两个数a,b（当gcd=1时），最大不能表示的数为(a-1)(b-1)-1</span><br>    <span class="hljs-comment">//当数字更多的时候，这个上界必然更小（可选的数字变多了）</span><br>    <span class="hljs-comment">//而99和98是100内最大的互质的数，所以这个上界选择10000</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">1e4</span>;i++)&#123;<br>        <span class="hljs-comment">//方案数为0 代表其不可表示</span><br>        <span class="hljs-keyword">if</span>(f[n][i] == <span class="hljs-number">0</span>) cnt++;<br>    &#125;<br>    <span class="hljs-comment">//最大公因数大于 1 的时候，个数无限</span><br>    <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;INF&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h2><blockquote><p>从2022个物品中选择10个物品，并且物品总体积为2022的方案数</p></blockquote><p><img src="/../../img/2022.png"></p><p><strong>tips:</strong></p><ol><li>从 0到N 初始化 $f[i][0][0]$<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)&#123;<br>    f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2030</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-comment">//从2022个物品中选择10个物品，并且物品总体积为2022</span><br>LL f[N][<span class="hljs-number">15</span>][N]; <span class="hljs-comment">//f[i][j][k]表示从前i个物品中选择j个物品，物体的总体积为k </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a[N];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)&#123;<br>    a[i] = i;<br>    f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2022</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;j++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2022</span>;k++)&#123;<br>        <span class="hljs-comment">//如果没有选择第i个物品，那么当前的方案数就是前i-1个物品中选j </span><br>        f[i][j][k] =  f[i<span class="hljs-number">-1</span>][j][k];<br>        <span class="hljs-keyword">if</span>(k &gt;= a[i]) f[i][j][k] += f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>][k-a[i]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; f[<span class="hljs-number">2022</span>][<span class="hljs-number">10</span>][<span class="hljs-number">2022</span>];<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="砝码称重（0-1背包）"><a href="#砝码称重（0-1背包）" class="headerlink" title="砝码称重（0-1背包）"></a>砝码称重（0-1背包）</h2><blockquote><p>从前i个砝码中选，重量为 j 的方案数</p></blockquote><p><img src="/../../img/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//0-1背包</span><br><span class="hljs-comment">//从前i个砝码中选，重量为 j 的方案数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> w[N];<br><span class="hljs-type">int</span> n,sum;<br><span class="hljs-comment">//如果数据只有一个砝码，重量是1e5，那么当j=1e5，转移时的f[i][j+w[i]]就越界了，所以开了两倍</span><br><span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>*M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; w[i];<br>        sum+=w[i];<br>    &#125;<br>    <span class="hljs-comment">//初始化</span><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sum;j++)&#123;<br>            <span class="hljs-comment">// bool f[N][2*M]</span><br>            <span class="hljs-comment">// f[i][j]=f[i-1][j]||f[i-1][j+w[i]]||f[i-1][abs(j-w[i])];</span><br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            f[i][j] += f[i<span class="hljs-number">-1</span>][<span class="hljs-built_in">abs</span>(j-w[i])]; <span class="hljs-comment">//由于这里加了abs，所以不需要再判断j&gt;=w[i]了</span><br>            f[i][j] += f[i<span class="hljs-number">-1</span>][j+w[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sum;i++)&#123;<br>        <span class="hljs-keyword">if</span>(f[n][i]) cnt++;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>背包问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性dp练习题</title>
    <link href="/2024/04/07/dp/%E7%BA%BF%E6%80%A7dp%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/07/dp/%E7%BA%BF%E6%80%A7dp%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="线性dp练习题"><a href="#线性dp练习题" class="headerlink" title="线性dp练习题"></a>线性dp练习题</h1><h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/900/">数字三角形</a></p><p><img src="/../../img/900_%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2.png"></p><p><strong>tips</strong></p><ol><li>因为有些值为负数，因此要将所有$f[i][j]$初始为负无穷<br>如果初始化为0会导致部分$f[i][j]$的值大于 本不应该大于 的f$f[i-1][j-1]$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N][N],f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin &gt;&gt; a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 因为有些值为负数，因此要将所有f[i][j]初始为负无穷</span><br>    <span class="hljs-comment">//如果初始化为0会导致部分f[i][j]的值大于 本不应该大于 的f[i-1][j-1]</span><br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));<br>    <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j] + a[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> max_v = INT_MIN;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        max_v = <span class="hljs-built_in">max</span>(max_v,f[n][j]);<br>    &#125;<br>    cout &lt;&lt; max_v;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="松散子序列"><a href="#松散子序列" class="headerlink" title="松散子序列"></a>松散子序列</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/5409/">松散子序列</a></p><p><img src="/../../img/%E6%9D%BE%E6%95%A3%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><p><strong>dp 思路：</strong><br>以下标 $i$ (从1开始)结尾的松散子序列长度的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">char</span> s[N];<br>string str;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; str;<br>    <span class="hljs-type">int</span> n = str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        s[i] = str[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    f[<span class="hljs-number">1</span>] = s[<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) f[i] = <span class="hljs-built_in">max</span>(f[i],f[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">if</span>(i<span class="hljs-number">-2</span>&gt;=<span class="hljs-number">0</span>) f[i] = <span class="hljs-built_in">max</span>(f[i],f[i<span class="hljs-number">-2</span>] + s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;i++)&#123;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; f[i] &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    cout &lt;&lt; f[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>线性dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的最短路问题</title>
    <link href="/2024/04/07/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/07/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="图的最短路问题"><a href="#图的最短路问题" class="headerlink" title="图的最短路问题"></a>图的最短路问题</h1><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><h3 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h3><blockquote><p>适合稠密图<br>变量：dist[N] （距离源点的距离数组） , st[N]（某个点是否已经被更新为距离最短的点的集合中的状态数组）<br>重边与自环：在min中会循环找出最短距离的边<br>算法步骤：</p></blockquote><ol><li>初始化：dist 初始化为正无穷（0x3f）<code>memset(dist,0x3f,sizeof(dist));</code> st 初始化为0</li><li>更新已经得到最短距离的所有点所在集合；更新方法：遍历距离数组的所有点，将其中最小距离的点放入集合。</li><li>根据第二步最新得到那个点 t ，去更新其他点的最短距离<br><code>d[j] = min(d[j],d[t] + t-&gt;j的距离)</code></li></ol><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/1906644/">Dijkstra求最短路图解 </a></p><p><strong>邻接矩阵版</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>; <span class="hljs-comment">//数据范围（最大输入节点数）</span><br><br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// 节点/边数</span><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 图的邻接矩阵（稠密图用这个） ，算法复杂度为n^2</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">//用于记录每一个点距离第一个点的距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">//已经确定了最短路径的点为true</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist)); <span class="hljs-comment">//将距离矩阵初始化为正无穷</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 题目要求 求出 1号点到 n号点的最短距离，第一个点到自身的距离为0</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;   <span class="hljs-comment">//有n个点所以要进行n次 迭代</span><br>    <br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;         <span class="hljs-comment">//t存储着下方某轮次循环中找出的距离源点距离最近的点</span><br>        <br>        <span class="hljs-comment">//找到路径最短的点：</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;  <span class="hljs-comment">//此时的j代表从1号点开始,该处循环是找出此时距离源点距离最近的点</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t==<span class="hljs-number">-1</span> || dist[t]&gt;dist[j]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//t的最短路径确定好了</span><br>        <br>        <span class="hljs-comment">//对每个点的最短路径更新：</span><br>        <span class="hljs-comment">//当有新的被确定最短路径的点加入到集合中时，</span><br>        <span class="hljs-comment">//要对所有点（但实际只有剩余未被确定最短路径的点会被更新，因为最短路径的确定是由短到长的）距离源点的最短距离进行更新。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;    <span class="hljs-comment">//此处j&lt;=n 必须要有等于号 //依次更新每个点所到相邻的点路径值</span><br>            <span class="hljs-keyword">if</span>(!st[j])&#123;     <span class="hljs-comment">//跳过已经确定为最短路径的点</span><br>                dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<span class="hljs-comment">//初始化图（邻接矩阵）</span><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c); <span class="hljs-comment">//建图（邻接矩阵） ；当有重边时更新邻接矩阵中的权重为较小的那个权重。</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">dijkstra</span>();<br>    <br>    cout &lt;&lt; t &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],w[M],idx;<br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//堆里存储距离和节点编号</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    e[idx] = b;<br>    w[idx] = v;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="hljs-comment">//小根堆</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//插入距离和节点编号</span><br>    <span class="hljs-comment">//遍历n次，每次找出一个点的最短距离</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>; <span class="hljs-comment">//需要被放入集合的点t</span><br>        <span class="hljs-comment">//此时的j代表从1号点开始,该处循环是找出此时距离源点距离最近的点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[j] &lt; d[t]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        st[t] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=h[t];k!=<span class="hljs-number">-1</span>;k=ne[k])&#123;<br>            <span class="hljs-type">int</span> j = e[k];<br>            <span class="hljs-keyword">if</span>(st[j]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//如果该点已经被确定为了最短点集合中了就没必要再去更新它了</span><br>            d[j] = <span class="hljs-built_in">min</span>(d[j],d[t] + w[k]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(a,b,v);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(); <span class="hljs-comment">//找出所有点到源点的距离</span><br>    <span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; d[n];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化Dijkstra算法"><a href="#堆优化Dijkstra算法" class="headerlink" title="堆优化Dijkstra算法"></a>堆优化Dijkstra算法</h3><blockquote><p>适合稀疏图<br>使用小根堆：<code>priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2</span>*<span class="hljs-number">1e5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">3</span>*<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],w[M],idx;<br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//堆里存储距离和节点编号</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    e[idx] = b;<br>    w[idx] = v;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="hljs-comment">//小根堆</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//插入距离和节点编号</span><br>    <span class="hljs-comment">//此处有while循环</span><br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br>        PII t = heap.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-comment">//距离源点的距离dist，其节点编号为index</span><br>        <span class="hljs-type">int</span> dist = t.first; <span class="hljs-type">int</span> index = t.second;<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//如果该点已经被放入到最短路径集合中了的话就可以continue</span><br>        <span class="hljs-keyword">if</span>(st[index]) <span class="hljs-keyword">continue</span>;<br>        st[index] = <span class="hljs-literal">true</span>;<br>            <br>        <span class="hljs-comment">//更新index所指向的节点距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=h[index];k!=<span class="hljs-number">-1</span>;k=ne[k])&#123;<br>            <span class="hljs-type">int</span> j = e[k];<br>            d[j] = <span class="hljs-built_in">min</span>(d[j],dist + w[k]);<br>            heap.<span class="hljs-built_in">push</span>(&#123;d[j],j&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(a,b,v);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(); <span class="hljs-comment">//找出所有点到源点的距离</span><br>    <span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; d[n];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map</title>
    <link href="/2024/04/06/stl/map/"/>
    <url>/2024/04/06/stl/map/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>拓扑序列</title>
    <link href="/2024/04/05/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
    <url>/2024/04/05/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><blockquote><p>定义：拓扑序列是图中的顶点的线性排序，使得从顶点u到顶点v的每个有向边u-&gt;v ,在拓扑序列中u都在v前面</p></blockquote><ol><li><p>不是所有的有向图都是有拓扑序的，只有<strong>有向无环图才有拓扑序</strong>，所以有向无环图又被称为拓扑图</p></li><li><p>有向无环图的<strong>拓扑序不是唯一的</strong></p></li></ol><h2 id="拓扑序列的求法"><a href="#拓扑序列的求法" class="headerlink" title="拓扑序列的求法"></a>拓扑序列的求法</h2><blockquote><p>对于拓扑序列而言，入度为0的点一定是排在前面的<br>对一个图BFS一遍，BFS过程中更新每个点的入度，如果一个点的入度为0，那么就将其加入拓扑序，并且删除其与后继结点的所有边。</p></blockquote><p>1.入度的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">在建立邻接表时计算每个节点的入度<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    d[b] ++; <span class="hljs-comment">//节点b的入度加1</span><br>    <br>    ne[idx] = h[a];<br>    h[a] = idx;<br>    idx ++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>得到拓扑序列<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//先将目前入度为0的节点入队</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)&#123;<br>            q[++tt] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh];<br>        hh++;<br>        <span class="hljs-comment">//删除由节点t所指出的边（并不是真的删除，而是将节点入度减1）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            d[j] --; <span class="hljs-comment">//该边的终点入度减1</span><br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">0</span>)&#123;<br>                q[++tt] = j; <span class="hljs-comment">//让入度为0的节点入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是不是拓扑序列</span><br>    <span class="hljs-comment">//如果所有点都入队了（所有点的入度都为0）就是拓扑序列，反之就不是</span><br>    <span class="hljs-keyword">return</span> tt == n<span class="hljs-number">-1</span>; <span class="hljs-comment">//tt初始化时为-1，tt代表节点下标从0开始，因此是与n-1对比</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>判断是不是拓扑序列</strong><br>看队尾指针tt的值 加1 （下标从0开始）是不是等于节点个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//判断是不是拓扑序列</span><br><span class="hljs-comment">//如果所有点都入队了（所有点的入度都为0）就是拓扑序列，反之就不是</span><br><span class="hljs-keyword">return</span> tt == n<span class="hljs-number">-1</span>; <span class="hljs-comment">//tt初始化时为-1，tt代表节点下标从0开始，因此是与n-1对比</span><br><br></code></pre></td></tr></table></figure></li><li><strong>输出拓扑序列</strong><br>由于出队只是将指针向后移动，但前面入队的元素还在队列数组中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h2><ol><li>所需变量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> e[N],ne[N],idx<br><span class="hljs-comment">// head 代表头指针</span><br><span class="hljs-comment">// e[N] 代表节点元素的值</span><br><span class="hljs-comment">// ne[N] 代表节点元素的next指针，即其所指向的下一个节点的下标</span><br><span class="hljs-comment">// idx 代表目前已经已经用到哪个节点了</span><br><br></code></pre></td></tr></table></figure></li><li>初始化操作</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">head = <span class="hljs-number">-1</span>; <span class="hljs-comment">//初始时头指针指向NULL</span><br>idx = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>将x插到头节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">e[idx] = x;<br>ne[idx] = head;<br>head = idx;<br>idx++;<br></code></pre></td></tr></table></figure><ol start="4"><li>将x插到下标是k的点后面</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">e[idx] = x;<br>ne[idx] = ne[k];<br>ne[k] = idx;<br>idx++;<br></code></pre></td></tr></table></figure><ol start="5"><li>删除<strong>下标为k</strong>的数（即为第k-1个插入的数）后面的那一个节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">ne[k] = ne[ne[k]];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树和图的存储和遍历</title>
    <link href="/2024/04/04/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"/>
    <url>/2024/04/04/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="树和图的存储和遍历"><a href="#树和图的存储和遍历" class="headerlink" title="树和图的存储和遍历"></a>树和图的存储和遍历</h1><h2 id="树和图的存储"><a href="#树和图的存储" class="headerlink" title="树和图的存储"></a>树和图的存储</h2><ol><li>树是一种特殊的图（无环连通图），因此可以把树当作图来处理</li><li>图分为有向图(a-&gt;b)和无向图(a-b),但我们在算法题中如果<strong>遇到无向图，就直接（a-&gt;b）和（b-&gt;a）都建立</strong>，因此无向图就是特殊的有向图。</li><li>存储方式</li></ol><p>（1）邻接矩阵 g[N][N]</p><ul><li>g[a][b] &#x3D; 0 代表 节点a-&gt;b没有边 </li><li>g[a][b] &#x3D; 1 代表 a-&gt;b有边 </li><li>g[b][a] &#x3D; 1 代表 b-&gt;a有边</li><li>g[a][b] &#x3D; w 代表 a-&gt;b 该边的权重或者长度为w</li><li>空间复杂度为O(n²)，适合存储稠密图</li></ul><p>（2）邻接表 </p><blockquote><p>我们可以想一下对于任意一个结点u, 需要记录邻边的哪些信息。</p><p>这些信息应该包括这条邻边的终点，权重，以及下一条邻边的编号。</p></blockquote><ul><li>每个点上都有一个单链表，存的是这个点可以走到哪些点</li><li><strong>h数组的下标为结点的编号，e,ne数组的下标为边的编号，e数组的值为该边的终点，idx为边的编号</strong></li><li>邻接表初始化(<strong>先将h数组都置为-1再插入节点</strong>)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// N代表点的个数，M代表边的条数</span><br>  <span class="hljs-comment">// n个结点的树最多有n - 1条边，如果考虑无向边需要开两倍的n - 1来存储</span><br><span class="hljs-type">int</span> h[N],e[<span class="hljs-number">2</span>*N],ne[<span class="hljs-number">2</span>*N],idx; <span class="hljs-comment">//有n个单链表就有n个头节点</span><br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h)); <span class="hljs-comment">//所有头节点都指向-1</span><br>  <span class="hljs-comment">// h[i]：第 i 个节点的第一条邻边的 idx</span><br>  <span class="hljs-comment">// e[idx]：存储 idx 这条边的终点，也就是与第 i 个节点相连的某一个点</span><br>  <span class="hljs-comment">// ne[idx]：存储 与第 idx 条边 同起点的 下一条边的 idx，也就是邻接表中的下一个节点</span><br>  <span class="hljs-comment">// idx：用于标识每条边的下标，存的是边的编号</span><br></code></pre></td></tr></table></figure></li><li>邻接表插入元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//有一条a-&gt;b的边 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a]; <span class="hljs-comment">// 新插入的边是插到链表头（头插法）</span><br>    h[a] = idx; <span class="hljs-comment">//更新链表头</span><br>    idx++;<br>&#125;<br><span class="hljs-comment">//树的边数等于节点数减1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-built_in">add</span>(a,b); <span class="hljs-built_in">add</span>(b,a); <span class="hljs-comment">//无向图</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="树和图的遍历"><a href="#树和图的遍历" class="headerlink" title="树和图的遍历"></a>树和图的遍历</h2><blockquote><p>对于树和图的遍历，不管是DFS还是BFS，因为每个点只会被遍历一次，所以时间复杂度与点和边的数量成线性关系，为<strong>O(n + m)</strong></p></blockquote><p><strong>dfs 和 bfs 的不同</strong><br><strong>不同：</strong></p><ol><li><p>参数上：</p><ul><li>void dfs(int u) &#x2F;&#x2F;u代表层数  调用: dfs(1);</li><li>int bfs() &#x2F;&#x2F;没有参数  调用：cout &lt;&lt; bfs(); &#x2F;&#x2F;在函数里面会返回需要的答案</li></ul></li><li><p>变量上<br>bfs 多了一个距离数组，初始时要将其置为-1 <code>memset(d,-1,sizeof(d))</code><br>dfs 用st[N] 当作状态数组 ，bfs可以使用距离数组 d 来充当状态数组</p></li></ol><p><strong>相同：</strong></p><ol><li>初始化上<br>要在开始时将当前正在访问的点设置为true</li></ol><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><p>从节点编号1开始遍历，沿着节点的邻接表一路深搜</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> st[N]; <span class="hljs-comment">//状态数组,标记某个点是否被遍历到</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//遍历点u的所有出边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> b = e[i]; <span class="hljs-comment">//b是该边终点</span><br>        <span class="hljs-keyword">if</span>(!st[b])&#123;<br>            <span class="hljs-built_in">dfs</span>(b);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.acwing.com/problem/content/description/4965/">景区导游</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//https://www.acwing.com/file_system/file/content/whole/index/content/11514015/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,k,a[N];<br><span class="hljs-type">int</span> h[N],e[<span class="hljs-number">2</span>*N],ne[<span class="hljs-number">2</span>*N],idx;<br><span class="hljs-type">int</span> w[<span class="hljs-number">2</span>*N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> s[N]; <span class="hljs-comment">//前缀和数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> t)</span><span class="hljs-comment">//表示u-&gt;v 距离是t 把v添加到u里去</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u]; i!=<span class="hljs-number">-1</span>; i=ne[i]) &#123;<span class="hljs-comment">//这里要判断一下有没有边重复加</span><br>        <span class="hljs-keyword">if</span>(e[i]==v) <span class="hljs-keyword">return</span>; <br>    &#125;<br>    e[idx]=v;ne[idx]=h[u];h[u]=idx;w[idx]=t;idx++;<span class="hljs-comment">//idx是v的下标 w[idx]表示u-&gt;v的距离</span><br>&#125;<br><span class="hljs-comment">//求u-&gt;v的距离 u起点 v终点 d是起点到当前点的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> d)</span></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//先将起点设置为访问过了</span><br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span> d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])&#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//不能d += w[i] 再dfs(j,v,j,d)</span><br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">dfs</span>(j,v,d+w[i]); <span class="hljs-comment">//更新起点</span><br>            <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ret;<br>            st[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(a,b,v); <span class="hljs-built_in">add</span>(b,a,v);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> st);<span class="hljs-comment">//每次dfs前都要清空一下st数组</span><br>        s[i] = s[i<span class="hljs-number">-1</span>] + <span class="hljs-built_in">dfs</span>(a[i],a[i+<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>        cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><p>距离从小到大来遍历，取第一次遍历到的结果（每个点只遍历一次）。<br>遍历框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">队列初始化<br><span class="hljs-keyword">while</span>(queue 不空)<br>&#123;<br>    取出队头<br>    拓展队头所有邻点<span class="hljs-function">x</span><br><span class="hljs-function">    <span class="hljs-title">if</span><span class="hljs-params">(x未遍历)</span></span><br><span class="hljs-function">    </span>&#123;<br>        x入队<br>        d[x]=d[队头]+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[n];<br></code></pre></td></tr></table></figure><p>数组模拟队列常见操作 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//入队</span><br>q[++tt] = &#123;&#125; ; q.<span class="hljs-built_in">push</span>()<br><span class="hljs-comment">//取队头</span><br>t = q[hh] ; q.<span class="hljs-built_in">top</span>()<br><span class="hljs-comment">//出队</span><br>hh++ ; q.<span class="hljs-built_in">pop</span>()<br><span class="hljs-comment">//判断是否非空</span><br><span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;&#125; ; q.<span class="hljs-built_in">empty</span>()<br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.acwing.com/problem/content/description/849/">图中点的层次</a><br>每条边长度都为1的最短路问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//要把距离 数组初始为-1</span><br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    <span class="hljs-comment">//队列初始化</span><br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    q[++tt] = <span class="hljs-number">1</span>;<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh];<br>        hh++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">//编号为i的边 的终点</span><br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">-1</span>)&#123;<br>                q[++tt] = j;<br>                <span class="hljs-comment">// pre[j] = t;</span><br>                d[j] = d[t] + <span class="hljs-number">1</span>; <span class="hljs-comment">//此处是d[t] + 1 ,不是d[i] + 1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// int x = n;</span><br>    <span class="hljs-comment">// while(x!=1)&#123;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; x &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">//     x = pre[x];</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><blockquote><p>定义：在有根树上，两点的祖先有公共部分，这些点叫做他们的公共祖先，而其中深度最深的点，叫作它们的最近公共祖先（LCA ，Lowest Common Ancestors）</p></blockquote><p>求树上两个点距离的时候，可以预处理出每个点到根节点的距离，然后两点间最短距离公式为：dist[a-&gt;b] &#x3D; dist[a]+dist[b]-2*dist[p]</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote><p>元素先进先出，<strong>从队尾入队，从队首出队</strong>。只允许在最后面添加元素，只允许在最前面删除元素。</p></blockquote><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><ol><li>初始化队列<br><code>queue&lt;int&gt; q</code></li><li>返回队首和队尾元素<br><code>q.front()</code> <code>q.back()</code></li><li>尾部增加和删除一个元素<br> <code>q.push()</code> <code>q.pop()</code></li><li>队列长度和是否为空<br><code>q.size()</code> <code>q.empty</code></li></ol><h2 id="队列模拟"><a href="#队列模拟" class="headerlink" title="队列模拟"></a>队列模拟</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> q[N]; <span class="hljs-comment">//队列数组</span><br><span class="hljs-comment">//队列区间为[hh,tt]</span><br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>; tt = <span class="hljs-number">-1</span>; <span class="hljs-comment">//队头和队尾指针</span><br><br>初始时tt = <span class="hljs-number">-1</span>,队列为空，当 ++tt 之后 tt = hh = <span class="hljs-number">0</span>,给q[<span class="hljs-number">0</span>]赋值，hh指向该队头元素<br><br>之后新元素入队，++tt往后移，元素出队，hh++,队头指针往后移。队列区间为[hh,tt]<br><br>q[++tt] = &#123;&#125; <span class="hljs-comment">//入队 </span><br><br>hh ++ <span class="hljs-comment">//出队，队首向后移动一格（本来指向队头元素，）</span><br><br>q[hh] <span class="hljs-comment">//取队头元素</span><br><br><span class="hljs-comment">//是否为空的判断，因为队列区间为[hh,tt],当hh &lt;= tt 时代表队列中有元素为非空</span><br><span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="priority-queue（优先队列）"><a href="#priority-queue（优先队列）" class="headerlink" title="priority_queue（优先队列）"></a>priority_queue（优先队列）</h2><blockquote><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。底层是通过堆（小根堆、大根堆）来实现的。</p></blockquote><ol><li>初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//默认是大根堆，每次取出的元素是队列中的最大值</span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,great&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><br>第一个参数：就是优先队列中存储的数据类型<br>第二个参数：vector&lt;<span class="hljs-type">int</span>&gt; 是用来承载底层数据结构堆的容器，若优先队列中存放的是<span class="hljs-type">double</span>型数据，就要填vector&lt; <span class="hljs-type">double</span> &gt;，总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。<br><br>less&lt;<span class="hljs-type">int</span>&gt; 表示数字大的优先级大，堆顶为最大的数字<br>greater&lt;<span class="hljs-type">int</span>&gt;表示数字小的优先级大，堆顶为最小的数字<br><br>如果存储pair<br>默认先对pair的first进行降序排序，然后再对second降序排序<br></code></pre></td></tr></table></figure><ol start="2"><li>访问队头元素 ： <code>q.top()</code><br>优先队列只能通过top()访问队首元素（优先级最高的元素）</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
      <category>队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dfs(爆搜)</title>
    <link href="/2024/04/03/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-%E7%88%86%E6%90%9C/"/>
    <url>/2024/04/03/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-%E7%88%86%E6%90%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs-爆搜-和-全排列"><a href="#dfs-爆搜-和-全排列" class="headerlink" title="dfs(爆搜) 和 全排列"></a>dfs(爆搜) 和 全排列</h1><h2 id="dfs递归"><a href="#dfs递归" class="headerlink" title="dfs递归"></a>dfs递归</h2><p><a href="https://www.acwing.com/solution/content/87387/" title="图解">图解</a></p><ol><li>递归就是把一个大问题变成中问题再变成一个很小的问题进行解决</li><li>如果在分解问题时，可能出现一个大问题包括很多个中问题的情况，此时就要在递归外面加上for循环</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> path[N];<br><span class="hljs-type">int</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(u&gt;n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//空位上可以选择的数字为:1 ~ n</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            path[u] = i; <span class="hljs-comment">//此处为u，代表第u个位置需要填</span><br>            st[i] = <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">/*dfs(u+1)展开： </span><br><span class="hljs-comment">            if(u==n)&#123;&#125; </span><br><span class="hljs-comment">            for(int i=1;i&lt;=n;++)&#123;</span><br><span class="hljs-comment">            //由于这里有个状态数组，i=1已经被访问过了，所以会把没访问过的 i=2 填入path数组中（真妙！） </span><br><span class="hljs-comment">        if(!state[i])&#123;</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">dfs(u+1)</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">            */</span><br>            st[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="next-permutation-函数"><a href="#next-permutation-函数" class="headerlink" title="next_permutation() 函数"></a>next_permutation() 函数</h2><blockquote><p>全排列函数 next_permutation(num,num+n) 是对数组num中的前n个元素进行全排列，同时并改变num数组的值。</p></blockquote><ol><li><p>另外，需要强调的是，next_permutation（）在<strong>使用前需要对欲排列数组按升序排序</strong>(此时才能找全)，否则只能找出该序列之后的全排列数</p></li><li><p>next_permutation（node,node+n,cmp）可以对结构体num按照自定义的排序方式cmp进行排序</p></li><li><p>常用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span>&#123;<br><br>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a,a+n));<br><br></code></pre></td></tr></table></figure></li></ol><p><strong>dfs例题：</strong><br><a href="https://www.acwing.com/problem/content/description/4960/" title="飞机降落问题">飞机降落问题</a></p><p>使用全排列函数对所有情况进行枚举，判断在所有的情况下是否能够满足条件。<br>使用方式：</p><ol><li>初始化一个全排列数组 a[n] ，通过a[i] &#x3D; i对其赋值（初始时其为1，2，…,n）</li><li>下面每种情况其循环时的下标应当为 a[i]</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> flag;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> t,d,l;<br>&#125;p[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin &gt;&gt; m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> a[n]; <span class="hljs-comment">//全排列数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i] = i; <span class="hljs-comment">//初始排列数组为 1,2,3</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; p[i].t &gt;&gt; p[i].d &gt;&gt; p[i].l;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-comment">//初始化操作</span><br>          flag = <span class="hljs-literal">true</span>;<br>          <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上一架飞机的降落时间，在此事件后开始降落的飞机都是合法的</span><br>          <br>          <span class="hljs-comment">//循环某个排序</span><br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> j = a[i]; <span class="hljs-comment">//代表此次排列顺序的下标</span><br><br>            start = <span class="hljs-built_in">max</span>(start , p[j].t) ; <span class="hljs-comment">// 和飞机到达时间取max,因为有可能上个飞机已经降落完成但下个飞机还没到</span><br>            <span class="hljs-keyword">if</span>(p[j].t + p[j].d &gt;= start)&#123;<br>              start += p[j].l;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>              flag = <span class="hljs-literal">false</span>;<br>              <span class="hljs-keyword">break</span>;<br>            &#125;<br>          &#125;<br>          <br>          <span class="hljs-keyword">if</span>(flag)&#123;<br>              <span class="hljs-comment">//只要有一组排列满足条件即可判定为yes</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>));<br>             <br>        <span class="hljs-comment">//只有所有排列都不满足条件才判定为no</span><br>        <span class="hljs-keyword">if</span>(!flag) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2024/04/02/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/04/02/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="二分算法解析"><a href="#二分算法解析" class="headerlink" title="二分算法解析"></a>二分算法解析</h2><p>二分的判断条件通常是通过列出有关要二分的量和其他变量之间的关系方程：</p><ol><li>暴力解放要循环所有可能的边长值</li><li>通过二分来一步步得缩小查找的区间</li><li>二分的核心就是通过某些性质使得可以缩小查找区间来减少时间复杂度</li></ol><p><strong>二分步骤：</strong></p><ol><li>先写一个check函数</li><li>判定在check的情况下（true和false的情况下），如何更新区间。</li><li>在check(m) &#x3D;&#x3D; true的分支下是:<ul><li>l &#x3D; mid的情况，中间点的更新方式是m &#x3D; (l+r+1)&#x2F;2</li><li>r &#x3D; mid的情况，中间点的更新方式是m &#x3D; (l+r)&#x2F;2</li></ul></li></ol><p>这种方法保证了：</p><ol><li>最后的 l &#x3D;&#x3D; r</li><li>搜索到达的答案是闭区间的，即 a[l] 是满足check()条件的。</li></ol><p><strong>二分模板</strong><br>模板1就是在满足chek()的区间内找到左边界，模板2在满足check()的区间内找到右边界。然后无论是左边界还是右边界，都应该是整个区间中某一段满足某性质（如单调不降）与另一段不满足该性质的分界点</p><p><strong>口诀：左加右减</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//查找左边界 SearchLeft 简写SL</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SL</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid; <br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>; <br>    &#125;   <br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">//查找右边界 SearchRight 简写SR </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SR</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;                   <br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//需要+1 防止死循环</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> r; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL中的有关二分的函数"><a href="#STL中的有关二分的函数" class="headerlink" title="STL中的有关二分的函数"></a>STL中的有关二分的函数</h2><p>tip:这些关于二分的stl函数，都<strong>只会查找指定元素后面的值</strong>，所以要在排好序的数组中进行查找</p><ol><li><code>binary_search()</code>函数，作用：对一个<strong>不降序列</strong>进行二分查找，如果所查找的值在序列中出现了，返回true，没有出现，返回false。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-type">bool</span> flag = <span class="hljs-built_in">binary_search</span>(a,a+<span class="hljs-number">5</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//返回的是布尔值</span><br>cout &lt;&lt; flag;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>lower_bound()</code>函数，作用：对一个<strong>不降序列</strong>进行二分查找，返回第一个<strong>大于等于</strong>所查找的值的元素下标，<strong>注意返回的是指针变量！！！</strong> 如果所有元素都小于val，则返回last的位置，且last的位置是越界的</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>upper_bound()</code>函数，作用：对一个不降序列进行二分查找，返回第一个<strong>大于</strong>所查找的值的元素下标，注意返回的是指针变量！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-keyword">auto</span> pos = <span class="hljs-built_in">upper_bound</span>(a,a+<span class="hljs-number">5</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//返回的是指针变量</span><br><span class="hljs-keyword">auto</span> index =  pos-a; <span class="hljs-comment">//对应元素下标(从0开始)</span><br>cout &lt;&lt; index &lt;&lt; endl &lt;&lt; *pos &lt;&lt; endl &lt;&lt; a[index];<br></code></pre></td></tr></table></figure></li><li><p>如果查找第一个小于某个元素的下标，则加上<code>greater&lt;int&gt;()</code></p></li></ol><p><strong>例题：数的范围</strong></p><blockquote><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。<br>如果数组中不存在该元素，则返回 -1 -1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,q;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> k;<br>        cin &gt;&gt; k;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">binary_search</span>(a,a+n,k))&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">lower_bound</span>(a,a+n,k) - a;<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">upper_bound</span>(a,a+n,k) - a;<br>        cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r<span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/2024/04/02/stl/String/"/>
    <url>/2024/04/02/stl/String/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><h2 id="stl函数方法"><a href="#stl函数方法" class="headerlink" title="stl函数方法"></a>stl函数方法</h2><ol><li><p>获取字符串长度<br><code>s.size()</code> 和 <code>s.length()</code></p></li><li><p>插入<br><code>s.push_back()</code> 在末尾插入<br><code>s.insert(pos,&#39;c&#39;)</code> 在指定位置插入<br><code>s.append(str)</code> 在s字符串结尾添加str字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>(),<span class="hljs-string">&#x27;1&#x27;</span>)<br>s.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;abc&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>删除<br><code>erase(iterator first, iterator last)</code><br>删除字符串中迭代器区间[first,last)上所有字符</p><p><code>erase(pos, len)</code><br>删除字符串中从索引位置pos开始的len个字符</p></li><li><p>字符替换<br><code>s.replace(pos,n,str)</code> 把当前字符串从索引pos开始的n个字符替换为str<br><code>s.replace(it1,it2,str)</code> 把当前字符串[it1,it2)区间替换为str it1 ,it2为迭代器哦<br><code>tolower(s[i]) \ toupper(s[i])</code>  转换为小写 \ 大写</p></li><li><p>分割<br><code>s.substr(pos,n)</code> 截取从pos索引开始的n个字符</p></li><li><p>查找</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;<br><span class="hljs-comment">//字符串查找-----找到后返回首字母在字符串中的下标</span><br><span class="hljs-comment">// 1. 查找一个字符串</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">6</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：11</span><br>    <br><span class="hljs-comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 4. 从字符串的末尾开始查找字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&#x27;i&#x27;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符</span><br>    <br><span class="hljs-comment">// 5. 在该字符串中查找第一个属于字符串s的字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;13br98&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：4---b</span><br>    <br><span class="hljs-comment">// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_not_of</span>(<span class="hljs-string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl; <span class="hljs-comment">// 结果是：4</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_not_of</span>(<span class="hljs-string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;  <span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 7. 在该字符串最后中查找第一个属于字符串s的字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&quot;13r98&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：19</span><br><br><span class="hljs-comment">// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&quot;teac&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：21</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符比较"><a href="#字符比较" class="headerlink" title="字符比较"></a>字符比较</h2><p>使用 <strong>单引号</strong> 包括单个字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;s&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符串变字符数组"><a href="#字符串变字符数组" class="headerlink" title="字符串变字符数组"></a>字符串变字符数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">string s = <span class="hljs-string">&quot;xing ma qi&quot;</span>;<br><span class="hljs-type">char</span> s2[] = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure><h2 id="将数字转换成字符串"><a href="#将数字转换成字符串" class="headerlink" title="将数字转换成字符串"></a>将数字转换成字符串</h2><blockquote><p><code>to_string(num)</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">12345678</span>;<br>cout &lt;&lt; <span class="hljs-built_in">to_string</span>(a) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="将字符串变成数字"><a href="#将字符串变成数字" class="headerlink" title="将字符串变成数字"></a>将字符串变成数字</h2><blockquote><p><code>atoi(const char *)</code> 将<strong>字符数组</strong>转换为int类型<br><code>stoi(const string*)</code> 将<strong>字符串</strong>转换为int类型</p></blockquote><p>关于输出数字的范围：<br>atoi不做范围检查，如果超出上界，输出上界，超出下界，输出下界。<br>stoi会做范围检查，默认必须在int范围内，如果超出范围，会出现RE（Runtime Error）错误。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>字符串操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索</title>
    <link href="/2024/04/02/dp/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2024/04/02/dp/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="记忆化数组"><a href="#记忆化数组" class="headerlink" title="记忆化数组"></a>记忆化数组</h1><blockquote><p>核心思想：设置一个记忆化数组f[N][N]，保存每种情况的（最优）解<br>并且如果这个点 f[i][j] 已经计算过了，直接返回即可，这就是记忆化搜索</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,m,g[N][N]; <span class="hljs-comment">//数组g存储每个点高度</span><br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">//记忆化数组，保存每个(i,j)为起点的最优解</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">//以i，j为起点的滑雪长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个点已经计算过了，直接返回即可，这就是记忆化搜索</span><br>    <span class="hljs-keyword">if</span>(f[i][j] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[i][j]; <br>    f[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">//长度最短至少为1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;<span class="hljs-number">4</span>;a++)&#123;<br>        <span class="hljs-type">int</span> x = i + dx[a]; <span class="hljs-type">int</span> y = j + dy[a];<br>        <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="hljs-number">1</span> &amp;&amp; y&lt;= m &amp;&amp; g[i][j] &gt; g[x][y])&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">dp</span>(x,y)+<span class="hljs-number">1</span>); <span class="hljs-comment">//(i,j) 为当前位置，(x,y)为下一个要访问的位置</span><br>        &#125;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> f[i][j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(f));<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//循环枚举起始位置(i,j)的所有可能，找出最大值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dp</span>(i,j)); <span class="hljs-comment">//dp(x,y)返回以位置(i,j)为起点能延申的最长长度</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>记忆化搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2024/04/02/dp/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2024/04/02/dp/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>树形dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>树形dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector</title>
    <link href="/2024/04/01/stl/vector/"/>
    <url>/2024/04/01/stl/vector/</url>
    
    <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="vector索引"><a href="#vector索引" class="headerlink" title="vector索引"></a>vector索引</h2><p><strong>vector只有在指定长度时,才能用下标索引的方法修改元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = a.<span class="hljs-built_in">begin</span>();p != a.<span class="hljs-built_in">end</span>(); p++)&#123;<br>cout &lt;&lt; *p;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>下标访问</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>cout &lt;&lt; vi[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>迭代器访问</strong><br>迭代器类似指针，迭代器在vector中就是充当指针的作用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it = vi.<span class="hljs-built_in">begin</span>(); it != vi.<span class="hljs-built_in">end</span>();it ++)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>返回首尾部的元素</strong></p><ol><li><code>front()</code> 返回第一个元素</li><li><code>bakc()</code>  返回最后一个元素</li></ol><h2 id="vector-插入-删除-元素"><a href="#vector-插入-删除-元素" class="headerlink" title="vector 插入&#x2F;删除 元素"></a>vector 插入&#x2F;删除 元素</h2><ol><li>在尾部进行插入&#x2F;删除<ul><li><code>push_back()</code></li><li><code>pop_back()</code></li></ul></li><li>指定位置的插入&#x2F;删除<ul><li><code>insert()</code>  c.insert(it, x) : 向任意迭代器it插入一个元素x ，O(N)</li><li><code>erase()</code>  c.erase(first,last) 删除[first,last)的所有元素，first,last都为迭代器指针 ，O(N)</li></ul></li></ol><h2 id="vector去重"><a href="#vector去重" class="headerlink" title="vector去重"></a>vector去重</h2><ol><li>先进行 sort() 排序，这样重复元素就会堆一起了</li><li>调用 unique() 函数将<strong>相邻且重复</strong> （因此要先排序） 的元素放到vector的尾部 然后返回指向第一个重复元素的迭代器</li><li>再用erase函数擦除从迭代器所指元素到最后元素的所有的元素</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()), vec.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h2 id="vector截取"><a href="#vector截取" class="headerlink" title="vector截取"></a>vector截取</h2><p>void assign(const_iterator first,const_iterator last); &#x2F;&#x2F;两个指针，分别指向开始和结束的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//通过vector的迭代器截取数组</span><br><span class="hljs-keyword">auto</span> first = a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> end = a.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>;<br>a.<span class="hljs-built_in">assign</span>(first,end);<br></code></pre></td></tr></table></figure><h2 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a>第k小数</h2><blockquote><p>寻找序列第k小的值 <code>nth_element(beg, nth, end)</code><br><code>nth_element(a,a+k,a+n)</code>，函数只是把下标为k的元素放在了正确位置<br>求第k大时,我们可以转化成求第n+1-k小，此时下标应该是n - k,所以为 <code>nth_element(a,a+n-k,a+n)</code> 也可以用cmp自定义比较函数，<code>greater&lt;int&gt;()</code></p></blockquote><p>nth为一个迭代器，指向序列中的一个元素。第n小的值恰好在nth位置上</p><p>执行nth_element()之后，序列中的元素会围绕nth进行划分：<strong>nth之前的元素都小于等于它，而之后的元素都大于等于它</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>stl</category>
      
      <category>vector</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>stl</tag>
      
      <tag>vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性dp</title>
    <link href="/2024/04/01/dp/%E7%BA%BF%E6%80%A7dp/"/>
    <url>/2024/04/01/dp/%E7%BA%BF%E6%80%A7dp/</url>
    
    <content type="html"><![CDATA[<h1 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h1><blockquote><p>线性DP，是较常见的一类动态规划问题，其是在线性结构上进行状态转移，这类问题不像背包问题、区间DP等有固定的模板</p><p>线性动态规划的目标函数为特定变量的线性函数，约束是这些变量的线性不等式或等式，目的是求目标函数的最大值或最小值</p></blockquote><h2 id="LCS问题——最长公共子序列"><a href="#LCS问题——最长公共子序列" class="headerlink" title="LCS问题——最长公共子序列"></a>LCS问题——最长公共子序列</h2><blockquote><p><code>子序列</code> : 指的是字符串中<strong>不一定连续</strong>但先后顺序一致的n个字符<br><code>字符子串</code>：指的是字符串中连续的n个字符<br><code>最长公共子序列</code>，英文缩写为LCS（Longest Common Subsequence）。其定义是: 一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。</p></blockquote><blockquote><p>问题描述：给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p></blockquote><p><strong>状态表示</strong></p><ol><li>集合表示：所有 $ A[1,n] $和 $ B[1,m] $ 的公共子序列的集合</li><li><strong>dp[i][j]代表以s1[i]，s2[j]结尾的LCS的长度</strong></li><li>属性：公共子序列长度的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>找集合中所有情况的共同点和不同点来划分集合</li><li>该公共子序列分为四种情况：包括a[n] , b[m] ，不包括a[n] ,包括b[m] ，不包括a[n] , b[m] ，包括a[n] ,不包括b[m] （可以用二进制0 1来表示）</li><li>$ f[i][j] $：A前i个字符，B前j个字符的公共子序列 的集合<br>属性：maxlen</li><li>集合划分情况（假定）<ul><li>(1) $ f[i-1][j-1] + 1 $  同时包括 a[n] 和 b[m] （前提是a[n] &#x3D; a[m]）</li><li>(2) $ f[i-1][j] $  不包括a[n] ,包括b[m]</li><li>(3) $ f[i][j-1] $  包括a[n] ,不包括b[m]</li><li>(4) $ f[i-1][j-1] $ a[n] 和 b[m] 都不包括</li></ul></li><li>集合划分情况（实际）<ul><li>f[i-1][j-1]+1 可以表示情况1    –&gt; a</li><li>f[i][j-1]&#x3D;max(情况2,情况4)    –&gt; b</li><li>f[i-1][j]&#x3D;max(情况3,情况4)    –&gt; c<br>所以我们最终只需要 求 max(a,b,c) 即可</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">\\最长公共子序列<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">char</span> a[N],b[N];<br><span class="hljs-type">int</span> n,m,f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    cin &gt;&gt; b[i];<br>&#125;<br><span class="hljs-comment">//状态计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-1</span>][j]);<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br>    cout &lt;&lt; f[n][m];<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="LIS问题——最长上升子序列"><a href="#LIS问题——最长上升子序列" class="headerlink" title="LIS问题——最长上升子序列"></a>LIS问题——最长上升子序列</h2><blockquote><p><code>最长上升子序列</code>（Longest  Increasing Subsequence），简称LIS，也有些情况求的是最长非降序子序列，二者区别就是序列中是否可以有相等的数，对于固定的数组，虽然LIS序列不一定唯一，但LIS的<strong>长度是唯一的</strong></p></blockquote><ol><li><p>状态设计：$dp[i]$ 代表以 $a[i]$ 结尾的LIS的长度</p></li><li><p>状态转移：$dp[i]&#x3D;max{dp[j]+1，dp[i]} (1&lt;&#x3D;j&lt; i，a[j]&lt;a[i])$</p></li><li><p>边界处理：$dp[i]&#x3D;1(1&lt;&#x3D;i&lt;&#x3D;n)$</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> a[N],n;<br><span class="hljs-type">int</span> f[N]; <span class="hljs-comment">//f[i]: 以 a[i] 为结尾的上升子序列的最大长度</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>        f[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">//用1去初始化dp数组，因为最短的递增子序列的长度为1</span><br>    &#125;<br>    <span class="hljs-comment">//循环整个数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//从前往后循环比那里之前的元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="hljs-built_in">max</span>(f[i],f[j]+<span class="hljs-number">1</span>);<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans,f[i]);<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/1224/">星球坠落</a></p><p><img src="/../../img/%E6%98%9F%E7%90%83%E8%84%B1%E8%90%BD.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// f[i][j] 区间[i，j] 之间的最长 回文 子序列 长度</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">状态划分：</span><br><span class="hljs-comment">1. 字符 s[i]和s[j] 都在子序列中</span><br><span class="hljs-comment">2. 字符 s[i]在，s[j]不在</span><br><span class="hljs-comment">3. 字符 s[i]不在，s[i]在</span><br><span class="hljs-comment">4. 字符 s[i]和s[j] 都不在子序列中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">char</span> s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)&#123;<br>        <span class="hljs-comment">//r-l+1 = len</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>; len+l<span class="hljs-number">-1</span> &lt; n; l++)&#123;<br>            <span class="hljs-type">int</span> r = len+l<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>                f[l][r] = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// continue;</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                f[l][r] = <span class="hljs-built_in">max</span>(f[l][r<span class="hljs-number">-1</span>],f[l+<span class="hljs-number">1</span>][r]);<br>                <span class="hljs-keyword">if</span>(s[l] == s[r]) f[l][r] = <span class="hljs-built_in">max</span>(f[l][r],f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; n - f[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>线性dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间dp</title>
    <link href="/2024/04/01/dp/%E5%8C%BA%E9%97%B4dp/"/>
    <url>/2024/04/01/dp/%E5%8C%BA%E9%97%B4dp/</url>
    
    <content type="html"><![CDATA[<h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><blockquote><p>定义：区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。</p><p>令状态 $f(i,j) $表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 $f(i,j)&#x3D;\max{f(i,k)+f(k+1,j)+cost}$，$cost $为将这两组元素合并起来的价值</p></blockquote><p><strong>性质</strong></p><ol><li><strong>合并：</strong> 即将两个或多个部分进行整合，当然也可以反过来</li><li><strong>特征</strong> 能将问题分解为能两两合并的形式</li><li><strong>求解</strong> 对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值</li></ol><p><strong>解题模板</strong><br>区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len &#x3D; 1 时用来初始化，枚举从 len &#x3D; 2 开始；第二维枚举起点 i （右端点 j 自动获得，j &#x3D; i + len - 1）</p><p>模板代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len++) &#123;         <span class="hljs-comment">// 区间长度</span><br>    <span class="hljs-comment">//终止条件代表右端点要小于n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) &#123; <span class="hljs-comment">// 枚举起点</span><br>        <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 区间终点</span><br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            dp[i][j] = 初始值<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//或者在下方加上else</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) &#123;        <span class="hljs-comment">// 枚举分割点，构造状态转移方程</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + w[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h2><blockquote><p>问题描述：设有 N 堆石子排成一排，其编号为 1,2,3,…,N。每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。<br>每次<strong>只能合并相邻的两堆</strong>，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。<br>找出一种合理的方法，使总的代价最小，输出最小代价</p></blockquote><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示将 [i,j] 这段区间的物品合并在一起的方案集合</li><li>属性：最小代价</li><li>集合划分，最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并，将集合划分成某一堆是由区间 $ [i,i] ，[i,i+1] ，[i,i+2] ，… ， [i,i + j-1] $ 这些情况中之一所合并而成（即所有方案中，最后一次合并时，其中的某一堆一定是由上述某个区间所合并而成，满足不重不漏的原则）</li><li>除了最后一次以外前面每次合并的和即为该次合并所产生的代价，因此最小总代价 &#x3D; $ f(i,k) + f(k+1,j) + s[j] - s[i-1] $</li><li>$ f(i,j) $</li></ol><p><strong>状态计算</strong></p><p>1.<br>2. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> f[N][N],s[N],n,w[N]; <span class="hljs-comment">//dp数组；前缀和数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        s[i] = s[i<span class="hljs-number">-1</span>] + w[i];<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f); <span class="hljs-comment">//由于是求最小值，因此先把dp数组设置成最大值</span><br>    <span class="hljs-comment">// 区间 DP 枚举套路：长度+左端点 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)&#123; <span class="hljs-comment">//len表示[i, j]的元素个数</span><br>        <span class="hljs-comment">// 右端点j小于0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=n;i++)&#123; <br>            <span class="hljs-type">int</span> j = i+len<span class="hljs-number">-1</span>; <span class="hljs-comment">// 自动得到右端点</span><br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>                f[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 边界初始化</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;k++)&#123;<br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i][j],f[i][k] + f[k+<span class="hljs-number">1</span>][j] + s[j] - s[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for(int len=2;len&lt;=n;len++)&#123;</span><br><span class="hljs-comment">        //右端点j小于0</span><br><span class="hljs-comment">        for(int i=1;len+i-1 &lt;= n;i++)&#123;</span><br><span class="hljs-comment">            //j-i+1 = len</span><br><span class="hljs-comment">            int j = len+i-1;</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">            //初始化f[i][j]为一个较大值（题目要求最小代价）</span><br><span class="hljs-comment">            f[i][j] = 1e9;</span><br><span class="hljs-comment">            //枚举合并点</span><br><span class="hljs-comment">            for(int k=i;k&lt;=j-1;k++)&#123;</span><br><span class="hljs-comment">                f[i][j] = min( f[i][j] , f[i][k] + f[k+1][j] + s[j] - s[i-1]);</span><br><span class="hljs-comment">                // cout &lt;&lt; f[i][j] &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;    </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>区间dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>区间dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划（背包问题）</title>
    <link href="/2024/03/30/dp/dp/"/>
    <url>/2024/03/30/dp/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="dp问题"><a href="#dp问题" class="headerlink" title="dp问题"></a>dp问题</h1><ol><li>要将$f[0][0]$ 等特殊的点进行初始化操作</li><li></li></ol><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><blockquote><p>问题描述：有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i件物品的体积是$ v_i $，价值是$ w_i $ 。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大</p></blockquote><p>针对0-1背包问题，每个物品有选与不选两种选择，则暴力枚举的时间复杂度为 $ O(2^n) $</p><p><strong>状态表示</strong> </p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品只能<strong>选一次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>将状态集合将所有选法划分成第 i 个物品 选 或者 不选 的方案（该划分方式不重不漏）</li><li>第 i 个物品不选时：$ f(i,j) &#x3D; f(i-1,j) $</li><li>第 i 个物品被选择时，为了方便计算，则先假设不选第 i 个物品，则此时 $ f(i,j) &#x3D; f(i-1,j-v[i]) + w[i] $ ,此时前提条件是 $ j &gt; v[i] $</li><li>状态属性是求最大值，则用max函数求出上述情况下的价值最大值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,m,ans;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-comment">//动态计算</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j], d[i<span class="hljs-number">-1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一维优化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> d[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) d[j] = <span class="hljs-built_in">max</span>(d[j], d[j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品能选<strong>无数次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>该集合的所有选法可以划分成第 i 个物品被选了0次,1次, … , n次（不重不漏）</li><li>划分依据:找最后一个不同点；最后一个物品选几个</li><li>$ f(i-1,j) $ 和 $ f(i-1,j-n*v_i) $ 这些方案的最大值</li><li>$ f(i,j) &#x3D; max( f(i-1,j), f(i-1,j-1<em>v[i])+1</em>w[i], f(i-1,j-2<em>v[i])+2</em>w[i], … , f(i-1,j-n<em>v[i])+n</em>w[i] ) $</li><li>$ f(i,j-v) &#x3D; max( f(i-1,j-v), f(i-1,j-2<em>v[i])+1</em>w[i], f(i-1,j-3<em>v[i])+2</em>w[i], … , f(i-1,j-(n+1)<em>v[i])+n</em>w[i] ) $</li><li>$ f(i,v) &#x3D; f(i,j-v) + w $</li></ol><p><strong>未优化版本，会超时</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;(k*v[i])&lt;=j;k++)&#123;<br>                <span class="hljs-keyword">if</span>(j&gt;=k*v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j],d[i][j-k*v[i]]+k*w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二维优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span>(j&gt;=v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j],d[i][j-v[i]] + w[i]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>一维优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[j] = d[j];<br>        <span class="hljs-keyword">if</span>(j&gt;=v[i]) d[j] = <span class="hljs-built_in">max</span>(d[j],d[j-v[i]] + w[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品能选<strong>有限n次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>集合的选法包括第i个物品不被选，或者选1个，2个…n个.</li><li>多重背包可以转换成0-1背包</li><li>将s个物品的体积看成一个个单独的物品</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将s个物品看成一个个单独的物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>    <span class="hljs-keyword">while</span>(s--)&#123;<br>        t++; <span class="hljs-comment">//t从1开始</span><br>        v[t] = a;<br>        w[t] = b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拆分后直接套用0-1背包板子</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>        f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><blockquote><p>问题描述：有 N 组物品和一个容量是 V 的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是$ v_{ij} $，价值是$ w_{ij} $，其中$ i $是组号，$ j $ 是组内编号。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p></blockquote><p><strong>状态计算</strong></p><ol><li>体积和价值表示为$ v[i][k] w[i][k] $ $ i $代表物品组，k 代表物品组里的第k个物品<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; s[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=s[i];j++)&#123;<br>        cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>对每个物品组进行循环，将其转换成0-1背包<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=s[i];k++)<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i][k]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j], d[i<span class="hljs-number">-1</span>][j-v[i][k]] + w[i][k]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>背包问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2024/03/29/algorithm_know/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/29/algorithm_know/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><blockquote><p>定义：贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解</p></blockquote><ol><li>类似于二分，将大集合进行划分，得出最优解所在的小集合</li><li>与动态规划的不同: 在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能</li></ol><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><blockquote><p>给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)</p></blockquote><p><strong>实现手段：</strong><br>通过一个小根堆<code>(priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;)</code>，每次取出队列顶部的两个元素进行合并，同时将这两个元素出队，将合并之后得到的新元素入队<br>直到队列中只剩下一个元素为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">// 优先队列头文件</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// 大根堆 + 大于号 = 小根堆</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        q.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">// 加入节点</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// res: 结果</span><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// 模拟哈夫曼树生成过程</span><br>    &#123;<br>        <span class="hljs-comment">// 挑两个最小的数</span><br>        <span class="hljs-type">int</span> a = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> b = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        res += a + b; <span class="hljs-comment">// 把他们之和加到答案里</span><br>        q.<span class="hljs-built_in">push</span>(a + b); <span class="hljs-comment">// 合并节点</span><br>    &#125;<br><br>    cout &lt;&lt; res;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>math</title>
    <link href="/2024/03/29/algorithm_know/math/"/>
    <url>/2024/03/29/algorithm_know/math/</url>
    
    <content type="html"><![CDATA[<h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><h2 id="约数-因数-个数"><a href="#约数-因数-个数" class="headerlink" title="约数(因数)个数"></a>约数(因数)个数</h2><ol><li>因数总是成对出现的,一个在开根号左边，一个在右边，此时因数个数加二</li><li>特殊情况：有可能刚好等于开根号之后的数字，此时因数个数只加一<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*j&lt;=a[i];j++)&#123;<br>            <span class="hljs-comment">//因数总是成对出现的,一个在开根号左边，一个在右边，此时因数个数加二</span><br>            <span class="hljs-comment">//特殊情况：有可能刚好等于开根号之后的数字，此时因数个数只加一</span><br>            <span class="hljs-keyword">if</span>(a[i] % j == <span class="hljs-number">0</span> &amp;&amp; j*j != a[i]) cnt+=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(a[i] % j == <span class="hljs-number">0</span> &amp;&amp; j*j == a[i]) cnt+=<span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/869/">分解质因数</a></p><p><img src="/../../img/%E8%B4%A8%E5%9B%A0%E6%95%B0.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-type">int</span> m = x;<br>        <span class="hljs-comment">//循环到平方根</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;i++)&#123;<br>            <span class="hljs-keyword">if</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>                    x /= i;<br>                    cnt++;<br>                &#125;<br>                cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; 1&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>$ gcd(a, b) &#x3D; gcd(b, a mod b) $</p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p><strong>互质数：</strong></p><blockquote><p>两个数的公因数只有1的两个非零自然数,叫做互质数<br>1与任何数都互斥，自身与自身不互斥（公约数包括1和自身）</p></blockquote><p>性质一：两个不同的质数是互质的。<br>性质二：一个质数，另一个不为它的倍数，这两个数为互质数。（较大数是质数的两个数是互质数）<br>性质三：相邻的两个自然数是互质数。<br>性质四：相邻的两个奇数是互质数。<br>性质五：最大公约数是1，两个数互质。</p><p><strong>欧拉函数</strong></p><blockquote><p>定义：对于一个正整数n，n的欧拉函数ϕ(n)表示<strong>小于等于</strong>n中，与n互质的<strong>正整数</strong>的个数</p></blockquote><p>分解质因数：N &#x3D; $ p_1^{a_1} * p_2^{a_2} * …*p_n^{a_n} $</p><p>$ ϕ(N) &#x3D; N(1- \frac{1}{p_1})(1- \frac{1}{p_2})…(1- \frac{1}{p_n}) $</p><p>用代码表示该公式时为了防止出现小数，用以下方式表示：<br>$ ϕ(N) &#x3D; (\frac{N}{p_1})*(p_1 - 1) $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=t/i;i++)&#123;<br>    <span class="hljs-comment">//判断i是不是t的质因子</span><br>    <span class="hljs-keyword">if</span>(t%i == <span class="hljs-number">0</span>)&#123;<br>        res = (res/i)*(i<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span>(t%i == <span class="hljs-number">0</span>)&#123;<br>            t /= i;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//有没除尽的</span><br><span class="hljs-keyword">if</span>(t &gt; <span class="hljs-number">1</span>) res = (res/t)*(t<span class="hljs-number">-1</span>);<br>cout &lt;&lt; res &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>性质1：如果<strong>n是质数</strong>，那么<strong>ϕ(n) &#x3D; n−1</strong>,因为只有n本身与它不互质。</p><p>性质2：如果p，q都是质数，那么$ ϕ ( p ∗ q ) &#x3D; ϕ ( p ) ∗ ϕ ( q ) &#x3D; ( p − 1 ) ∗ ( q − 1 ) $.</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂，二进制取幂，在O(logn)下求$ a^n $的方法</p><blockquote><p>求 $ {a^b} % {p} $ 的值</p></blockquote><p>做这个题前首先我们需要了解一下关于取余的公式<br>(a + b) % p &#x3D; (a % p + b % p) % p<br>(a - b) % p &#x3D; (a % p - b % p ) % p<br>(a * b) % p &#x3D; (a % p * b % p) % p</p><p><strong>$ a^b &#x3D; a^{2^0+2^1+…+2^n(中的某几项)} $</strong><br>ex. $ a^{10} &#x3D; a^{(1010)_2} &#x3D; a^{2^1+2^3} $</p><p><strong>注意下述式子</strong></p><blockquote><p>$ a^{2^3} &#x3D; (a^{2^2})^2 \ a^{2^0} &#x3D; a $</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL a,b;<br><span class="hljs-type">int</span> p,n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;p);<br>        LL res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// cout &lt;&lt; b;</span><br>            <span class="hljs-comment">//求数末尾为1还是0</span><br>            <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)&#123;<br>                res = res * a % p;<br>            &#125;<br>            a = a*a % p;<br>            b = b &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//注意这里要把移位后的值赋给b</span><br>        &#125;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数学知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pair</title>
    <link href="/2024/03/29/stl/pair/"/>
    <url>/2024/03/29/stl/pair/</url>
    
    <content type="html"><![CDATA[<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><blockquote><p>pair&lt;int,int&gt; p[N];</p></blockquote><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><blockquote><p>和结构体类似，first代表第一个元素，second代表第二个元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="索引元素"><a href="#索引元素" class="headerlink" title="索引元素"></a>索引元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cout &lt;&lt; p[i].first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p[i].second;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>stl</category>
      
      <category>pair</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>stl</tag>
      
      <tag>pair</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手做操作系统</title>
    <link href="/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA408/OS/"/>
    <url>/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA408/OS/</url>
    
    <content type="html"><![CDATA[<h1 id="动手做操作系统"><a href="#动手做操作系统" class="headerlink" title="动手做操作系统"></a>动手做操作系统</h1><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ol><li>在Windows下编写代码，使用vscode、记事本等编辑器。</li><li>使用Linux的虚拟机编译内核和生成操作软盘映像。（img软盘也可以直接在window11环境下使用bximage.exe生成，但需要在虚拟机里进行格式化）</li><li>必要时使用安装了DOS的虚拟机来调试程序以及操作软盘映像。</li><li>安装一个Bochs,必要的时候用它来调试。</li><li>使用其他必要的工具，比如版本控制工具(VSS或者CVS)。</li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>软盘是从A盘启动的</li></ol><h2 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h2><p>在操作系统中，实模式（Real Mode）和保护模式（Protected Mode）是两种不同的工作模式，特别是在x86架构的计算机上常见。</p><p><strong>实模式：</strong></p><ul><li>实模式是早期IBM PC兼容计算机上的一种工作模式。在实模式下，CPU可以访问1MB范围内的内存。</li><li>内存管理采用分段机制，内存地址由一个16位段地址和一个16位偏移地址组成，共20位地址空间。</li><li>实模式下，没有内存保护机制，任何程序都可以访问系统的所有内存和硬件设备，因此容易导致系统的稳定性问题。<br><strong>保护模式：</strong></li><li>保护模式是后来引入的一种工作模式，提供了更为复杂和强大的内存管理和保护机制。</li><li>在保护模式下，CPU可以访问超过1MB的内存，并且支持虚拟内存和分页机制。</li><li>内存管理采用分段和分页结合的方式，可以实现更灵活的内存保护和隔离，不同程序之间不会相互影响。</li><li>保护模式下，操作系统可以对内存和硬件设备进行更精细的控制和管理，提高了系统的稳定性和安全性。</li></ul><p>总的来说，实模式和保护模式是操作系统在x86架构下的两种不同的工作模式，保护模式相比实模式具有更多的功能和优势，是现代操作系统常用的工作模式。</p><h2 id="全局描述符表（GDT）"><a href="#全局描述符表（GDT）" class="headerlink" title="全局描述符表（GDT）"></a>全局描述符表（GDT）</h2><p>全局描述符表（Global Descriptor Table，GDT）是x86架构下一种用于管理内存的数据结构，它在操作系统中扮演着重要的角色。GDT定义了内存分段的策略，包括内存段的起始地址、段的大小、访问权限等信息。</p><p>在x86架构中，内存被分成多个段（segment），每个段都有自己的起始地址和大小。GDT就是用来管理这些段的数据结构。每个段都由一个描述符（descriptor）来描述，而GDT就是存放这些描述符的表格。描述符包含了段的各种属性，比如基地址、段限长、访问权限等。</p><p>通过GDT，操作系统可以实现对内存的灵活管理和保护。例如，操作系统可以将代码、数据、堆栈等不同类型的信息放在不同的段中，并且对每个段设置不同的访问权限，从而提高系统的安全性和稳定性。此外，GDT还支持虚拟内存和分页机制，可以实现更高效的内存管理和地址转换。</p><p>总的来说，全局描述符表（GDT）是x86架构下一种重要的内存管理数据结构，它定义了内存分段的策略，为操作系统提供了灵活的内存管理和保护机制。</p><h2 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h2><p>(1) 准备GDT </p><p>(2) 用 lgdt 加载 gdtr.<br><code>lgdt [GdtPtr]</code></p><p>(3) 关中断<br><code>cli</code></p><p>(4) 打开 A20地址线.<br><code>inal, 92h </code><br><code>oral, 00000010b</code><br><code>out92h, al</code></p><p>(5)置cr0的PE位（第0位）为1.<br><code>moveax, cr0</code><br><code>oreax, 1</code><br><code>movcr0, eax</code></p><p>(6)跳转，进入保护模式.<br><code>jmpdword SelectorCode32:0</code></p><h2 id="运行一个-com程序的步骤"><a href="#运行一个-com程序的步骤" class="headerlink" title="运行一个.com程序的步骤"></a>运行一个.com程序的步骤</h2><ol><li>使用bximage.exe生成一个软盘</li><li>将软盘插入到xp虚拟机中，进行格式化（选择带ms-dos启动盘的格式化）</li><li>将需要运行的.com程序放入软盘中，之后将软盘取出（防止软盘被占用而出错）</li><li>编辑bochsrc.bxrc，将软盘名称改成自己软盘的名称，将启动盘改成A</li><li>运行<code>C:\Bochs-2.6.9\dos</code> 里的 <code>bchsrc.bxrc</code>即可进入到软盘中，之后在窗口中输入test1.com即可运行</li></ol><h2 id="保护模式下的特点"><a href="#保护模式下的特点" class="headerlink" title="保护模式下的特点"></a>保护模式下的特点</h2><ol><li>地址用 SEG:OFFSET 表示 ; 段值仍然由原来16位的cs、ds 等寄存器表示，但此时它仅仅变成了一个索引，这个索引指向一个数据结构的一个表项，表项中详细定义了段的起始地址、界限、属性等内容。这个数据结构，就是GDT（实际上还可能是LDT，这个以后再介绍)。GDT 中的表项也有一个专门的名字，叫做描述符（Descriptor)。</li><li>也就是说，GDT的作用是用来提供段式存储机制，这种机制是通过段寄存器和GDT中的描述符共同提供的。</li><li>GDT中的每一个描述符定义一个段</li><li>不难理解，当TI和RPL都为零时，选择子就变成了对应描述符相对于GDT 基址的偏移</li></ol><h2 id="建立新段的步骤"><a href="#建立新段的步骤" class="headerlink" title="建立新段的步骤"></a>建立新段的步骤</h2><ol><li>建立一个段</li><li>在段表中建立一个条目写进去</li><li>给定一个选择子（指向段表的索引）</li><li>初始化时，把起始地址填入到Desc</li><li>使用该段</li></ol>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举算法</title>
    <link href="/2024/03/28/algorithm_know/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/28/algorithm_know/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举算法"><a href="#枚举算法" class="headerlink" title="枚举算法"></a>枚举算法</h1><h2 id="结题步骤"><a href="#结题步骤" class="headerlink" title="结题步骤"></a>结题步骤</h2><p>采用枚举算法解题的一般思路如下：</p><ol><li>确定枚举对象、枚举范围和判断条件，并判断条件设立的正确性。</li><li>一一枚举可能的情况，并验证是否是问题的解。</li><li>考虑提高枚举算法的效率。</li></ol><p><strong>提高算法效率方法</strong></p><ol><li>抓住问题状态的本质，尽可能缩小问题状态空间的大小。</li><li>加强约束条件，缩小枚举范围。</li><li>根据某些问题特有的性质，例如对称性等，避免对本质相同的状态重复求解。</li></ol><h2 id="递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。"><a href="#递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。" class="headerlink" title="递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。"></a>递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。</h2><h3 id="指数型枚举"><a href="#指数型枚举" class="headerlink" title="指数型枚举"></a>指数型枚举</h3><p>从 1∼n 这 n个整数中随机选取任意多个，输出所有可能的选择方案。<br>由于每个数都存在选与不选两种状态，所以总共会有2^n 种情况<br>选与不选可以使用dfs来递归表示<br>因此递归函数中会用到两个dfs()函数分别表示选与不选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> st[<span class="hljs-number">20</span>]; <span class="hljs-comment">//结果数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">1</span>) <br>                cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    st[u] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>    <br>    st[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排列型枚举"><a href="#排列型枚举" class="headerlink" title="排列型枚举"></a>排列型枚举</h3><p>可以使用stl函数 next_permutation </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//时间复杂度 N!</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> a[N],n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="组合型枚举"><a href="#组合型枚举" class="headerlink" title="组合型枚举"></a>组合型枚举</h3><blockquote><p>从 1∼n 这 n 个整数中随机选出 k 个，输出所有可能的选择方案</p></blockquote><p>可以使用stl函数 <strong>prev_permutation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) a[i]=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span>(a[i]) cout&lt;&lt; i &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">prev_permutation</span>(a+<span class="hljs-number">1</span>, a+<span class="hljs-number">1</span>+n));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>枚举算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>枚举算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将数据集分成训练集和测试集</title>
    <link href="/2024/03/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/data-set-spilt/"/>
    <url>/2024/03/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/data-set-spilt/</url>
    
    <content type="html"><![CDATA[<h1 id="将数据集分成训练集和测试集"><a href="#将数据集分成训练集和测试集" class="headerlink" title="将数据集分成训练集和测试集"></a>将数据集分成训练集和测试集</h1><h2 id="具体代码（带详细注释）"><a href="#具体代码（带详细注释）" class="headerlink" title="具体代码（带详细注释）"></a>具体代码（带详细注释）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">假设数据集文件夹中有三类</span><br><span class="hljs-string">class_indices.json</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;0&quot;: &quot;AD&quot;,</span><br><span class="hljs-string">    &quot;1&quot;: &quot;CN&quot;,</span><br><span class="hljs-string">    &quot;2&quot;: &quot;MCI&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_split_data</span>(<span class="hljs-params">root: <span class="hljs-built_in">str</span>, val_rate: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.2</span></span>):<br>    random.seed(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 保证随机结果可复现</span><br>    <span class="hljs-keyword">assert</span> os.path.exists(root), <span class="hljs-string">&quot;dataset root: &#123;&#125; does not exist.&quot;</span>.<span class="hljs-built_in">format</span>(root)<br><br>    <span class="hljs-comment"># 遍历文件夹，一个文件夹对应一个类别</span><br>    data_class = [cla <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> os.listdir(root) <span class="hljs-keyword">if</span> os.path.isdir(os.path.join(root, cla))]<br>    <span class="hljs-comment"># 排序，保证各平台顺序一致</span><br>    data_class.sort()  <span class="hljs-comment"># [&#x27;AD&#x27;, &#x27;CN&#x27;, &#x27;MCI&#x27;]</span><br>    <span class="hljs-comment"># 生成类别名称以及对应的数字索引</span><br>    class_indices = <span class="hljs-built_in">dict</span>((k, v) <span class="hljs-keyword">for</span> v, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_class))<br>    json_str = json.dumps(<span class="hljs-built_in">dict</span>((val, key) <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> class_indices.items()), indent=<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;class_indices.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> json_file:<br>        json_file.write(json_str)<br><br>    train_images_path = []  <span class="hljs-comment"># 存储训练集的所有图片路径</span><br>    train_images_label = []  <span class="hljs-comment"># 存储训练集图片对应索引信息</span><br>    val_images_path = []  <span class="hljs-comment"># 存储验证集的所有图片路径</span><br>    val_images_label = []  <span class="hljs-comment"># 存储验证集图片对应索引信息</span><br>    every_class_num = []  <span class="hljs-comment"># 存储每个类别的样本总数</span><br>    supported = [<span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-string">&quot;.JPG&quot;</span>, <span class="hljs-string">&quot;.png&quot;</span>, <span class="hljs-string">&quot;.PNG&quot;</span>]  <span class="hljs-comment"># 支持的文件后缀类型</span><br>    <span class="hljs-comment"># 遍历每个文件夹下的文件</span><br>    <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> data_class:<br>        cla_path = os.path.join(root, cla) <span class="hljs-comment"># 类别文件夹的具体路径</span><br>        <span class="hljs-comment"># 遍历获取supported支持的所有文件路径</span><br>        images = [os.path.join(root, cla, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> os.listdir(cla_path)<br>                  <span class="hljs-keyword">if</span> os.path.splitext(i)[-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> supported]<br>        <span class="hljs-comment"># 排序，保证各平台顺序一致</span><br>        images.sort() <span class="hljs-comment"># 该类别文件夹下的所有图片 按名称字典顺序排列</span><br>        <span class="hljs-comment"># 获取该类别对应的索引</span><br>        image_class = class_indices[cla]<br>        <span class="hljs-comment"># 记录该类别的样本数量</span><br>        every_class_num.append(<span class="hljs-built_in">len</span>(images))<br>        <span class="hljs-comment"># 按比例随机采样验证样本</span><br>        val_path = random.sample(images, k=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(images) * val_rate))<br><br>        <span class="hljs-keyword">for</span> img_path <span class="hljs-keyword">in</span> images:<br>            <span class="hljs-keyword">if</span> img_path <span class="hljs-keyword">in</span> val_path:  <span class="hljs-comment"># 如果该路径在采样的验证集样本中则存入验证集</span><br>                val_images_path.append(img_path)<br>                val_images_label.append(image_class)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 否则存入训练集</span><br>                train_images_path.append(img_path)<br>                train_images_label.append(image_class)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images were found in the dataset.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">sum</span>(every_class_num)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for training.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(train_images_path)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for validation.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(val_images_path)))<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(train_images_path) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;number of training images must greater than 0.&quot;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(val_images_path) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;number of validation images must greater than 0.&quot;</span><br><br>    plot_image = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> plot_image:<br>        <span class="hljs-comment"># 绘制每种类别个数柱状图</span><br>        plt.bar(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data_class)), every_class_num, align=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 将横坐标0,1,2,3,4替换为相应的类别名称</span><br>        plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data_class)), data_class)<br>        <span class="hljs-comment"># 在柱状图上添加数值标签</span><br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(every_class_num):<br>            plt.text(x=i, y=v + <span class="hljs-number">5</span>, s=<span class="hljs-built_in">str</span>(v), ha=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 设置x坐标</span><br>        plt.xlabel(<span class="hljs-string">&#x27;image class&#x27;</span>)<br>        <span class="hljs-comment"># 设置y坐标</span><br>        plt.ylabel(<span class="hljs-string">&#x27;number of images&#x27;</span>)<br>        <span class="hljs-comment"># 设置柱状图的标题</span><br>        plt.title(<span class="hljs-string">&#x27;data class distribution&#x27;</span>)<br>        plt.show()<br><br>    <span class="hljs-keyword">return</span> train_images_path, train_images_label, val_images_path, val_images_label<br><br>data_path = <span class="hljs-string">&quot;D:\data_set&quot;</span> <span class="hljs-comment"># 数据集所在（绝对/相对）路径</span><br>train_images_path, train_images_label, val_images_path, val_images_label = read_split_data(data_path)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>数据集处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>数据集处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2024/03/25/algorithm_know/tree-arr/"/>
    <url>/2024/03/25/algorithm_know/tree-arr/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>首要用途：维护序列的前缀和</p><blockquote><p>对一个序列a，建立一个数组c，其中c[x]保存序列a的区间(x-lowbit(x)+1,x]中所有数的和(前开后必)。</p></blockquote><h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>1.每一个节点x，有c[x]保存着以x为根节点的所有叶节点的和</p><p>2.每个内部节点c[x]的子节点个数等于lowbit（x）的位数</p><p>3.除了树根以外的每个子节点的父节点都是c[x+lowbit(x)];</p><p>4.数的深度为log(N)  &#x2F;&#x2F;N为序列a的长度</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>O(logN)的时间复杂度去实现单点修改和区间查询</li><li>数组下标一定要从1开始</li><li>一个数的二进制表示中末尾有几个0就在第几层</li></ol><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><blockquote><p><code>x &amp; (-x)</code> : 假设 x的二进制数表示 的从右向左数的第一个1所在位为k，则lowbit(x) &#x3D; 2^(k-1)</p></blockquote><blockquote><p>tip: 求 n 的二进制表示的第 k 位(从0开始)数字：<code>n &gt;&gt; k &amp; 1</code></p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>实现单点修改</li><li>实现求前缀和</li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造树状数组的方法</span><br><span class="hljs-comment">// 可以假设原序列a为全0，依次通过“单点修改”操作把每个数加进去，最后就可以形成树状数组了</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> t[N],tr[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-comment">//在原数组的第x个数加上v</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-comment">//注意这里的i是从x开始得</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123; <br>        tr[i] += v; <span class="hljs-comment">//在树状数组第i个位置上加上一个值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//返回原数组前x个数的前缀和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x; i&gt;<span class="hljs-number">0</span>; i-=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        sum += tr[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; t[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">add</span>(i,t[i]); <span class="hljs-comment">//在第i个位置上加上原数组t[i] 构造树状数组</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x<span class="hljs-number">-1</span>) &lt;&lt; endl; <span class="hljs-comment">//求的是[a,b]的必区间</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">add</span>(x,y);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树状数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法 树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>algorithm_know</title>
    <link href="/2024/03/25/algorithm_know/algorithm-know/"/>
    <url>/2024/03/25/algorithm_know/algorithm-know/</url>
    
    <content type="html"><![CDATA[<h1 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h1><h2 id="降低时间复杂度的方法（降低运行时间防止超时）"><a href="#降低时间复杂度的方法（降低运行时间防止超时）" class="headerlink" title="降低时间复杂度的方法（降低运行时间防止超时）"></a>降低时间复杂度的方法（降低运行时间防止超时）</h2><h3 id="使用平方根去约束数的循环范围"><a href="#使用平方根去约束数的循环范围" class="headerlink" title="使用平方根去约束数的循环范围"></a>使用平方根去约束数的循环范围</h3><blockquote><p>应用场景：完全数，质数</p></blockquote><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h2 id="得到某一段数组-l-r-的和，常规循环计算的复杂度为-O-n-，使用前缀和就可以直接使用-S-r-S-l-1-，复杂度为O-1"><a href="#得到某一段数组-l-r-的和，常规循环计算的复杂度为-O-n-，使用前缀和就可以直接使用-S-r-S-l-1-，复杂度为O-1" class="headerlink" title="得到某一段数组 [l,r] 的和，常规循环计算的复杂度为 O(n) ，使用前缀和就可以直接使用 S(r) - S(l-1) ，复杂度为O(1)"></a>得到某一段数组 [l,r] 的和，常规循环计算的复杂度为 O(n) ，使用前缀和就可以直接使用 S(r) - S(l-1) ，复杂度为O(1)</h2><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ol><li>O(log)的时间复杂度去实现单点修改和区间查询</li><li>数组下标一定要从1开始</li><li>一个数的二进制表示中末尾有几个0就在第几层</li></ol><h1 id="2-17"><a href="#2-17" class="headerlink" title="2.17"></a>2.17</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote><p>求 n 的二进制表示的第 k 位数字：<code>n &gt;&gt; k &amp; 1</code><br>返回 n 的最后一位1所对应的值：lowbit(n) &#x3D; n &amp; -n &#x3D; n &amp; (n^(n-1))<br>假设一个数的二进制最低位的1在从右往左数的第k位，那么它的lowbit值就是2^(k-1)<br>树状数组C[x] &#x3D; [x-lowbit(n) , x] 原数组中这段区间的和</p></blockquote><h1 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h1><h2 id="n次方幂"><a href="#n次方幂" class="headerlink" title="n次方幂"></a>n次方幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//负数要先转换成正数去计算n次方根</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-literal">true</span>; <br>        n = -n;<br>    &#125;<br>    <span class="hljs-type">double</span> res = <span class="hljs-built_in">pow</span>(n,(<span class="hljs-type">double</span>)<span class="hljs-number">1</span>/<span class="hljs-number">3</span>); <span class="hljs-comment">//使用求n次幂函数，来求n次方根</span><br></code></pre></td></tr></table></figure><h1 id="3-26"><a href="#3-26" class="headerlink" title="3.26"></a>3.26</h1><h1 id="线段数组"><a href="#线段数组" class="headerlink" title="线段数组"></a>线段数组</h1><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>线段树是一棵平衡二叉树。母结点代表整个区间的和，越往下区间越小</li><li>每个节点p的左右子节点的编号分别为 2p 和 2p+1</li><li>节点p存储区间[l,r]的和，设 mid &#x3D; floor(l+r&#x2F;2) ; 左节点存储[l,mid]的和， 左节点存储[mid+1,r]的和</li></ol><h2 id="建立线段数组"><a href="#建立线段数组" class="headerlink" title="建立线段数组"></a>建立线段数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> sum;<br>&#125;tr[N*<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">//u位节点编号，l和r为区间左右端点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> tr[u] = &#123;l,r,w[l]&#125;; <span class="hljs-comment">//抵达叶子节点，为其赋值</span><br>    <span class="hljs-type">int</span> mid = (l+r) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//向下取整</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u, l, mid); <span class="hljs-comment">//向左子树递归</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//向右子树递归</span><br>    tr[u].sum = tr[<span class="hljs-number">2</span>*u].sum + tr[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].sum <span class="hljs-comment">//递归完左右子树后向上回溯</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><blockquote><p>把区间内的叶子节点相加</p></blockquote><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><blockquote></blockquote><h1 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a>第k小数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> t, n, k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br><span class="hljs-keyword">while</span> (t--) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        list[i] = <span class="hljs-built_in">read</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 将第k小的数放在 k-1 位置，左边的数都比它小，右边的数都比它大，但都是无序的</span><br>    <span class="hljs-built_in">nth_element</span>(list, list + k - <span class="hljs-number">1</span>, list + n);<br>    <span class="hljs-comment">// 由于数据量太大，下面两种方法会超时</span><br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-comment">// sort(list, list + n);</span><br>    <span class="hljs-comment">// 将第k小的数放在 k-1 位置，左边的数都比它小，而且是有序的，右边的数都比它大，但右边是无序的</span><br>    <span class="hljs-comment">// partial_sort(list, list + k - 1, list + n);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, list[k - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>首先，binary_search()函数，作用：对一个不降序列进行二分查找，如果所查找的值在序列中出现了，返回true，没有出现，返回false。</p><p>然后，lower_bound()函数，作用：对一个不降序列进行二分查找，返回第一个大于等于所查找的值的元素下标，注意返回的是指针变量！！！</p><p>最后，upper_bound()函数，作用：对一个不降序列进行二分查找，返回第一个大于所查找的值的元素下标，注意返回的是指针变量！！！</p><h1 id="无穷大和无穷小"><a href="#无穷大和无穷小" class="headerlink" title="无穷大和无穷小"></a>无穷大和无穷小</h1><p>指定一个数为无穷大或无穷小：INT_MIX INT_MAX<br>要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))<br>要把一段内存全部置为无穷小，我们只需要memset(a,0xc0,sizeof(a))</p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map[key] &#x3D; value</p><h2 id="查找map中某个key是否存在-具体位置"><a href="#查找map中某个key是否存在-具体位置" class="headerlink" title="查找map中某个key是否存在&#x2F;具体位置"></a>查找map中某个key是否存在&#x2F;具体位置</h2><blockquote><p>mp.count(key)<br>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0<br>mp.find(key)<br>返回键为key的映射的迭代器 $O(logN) $ 注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()</p></blockquote><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set里面的元素<strong>不重复</strong> 且 <strong>有序</strong></p><h1 id="如何将字符串转换成数字"><a href="#如何将字符串转换成数字" class="headerlink" title="如何将字符串转换成数字"></a>如何将字符串转换成数字</h1><p>String str&#x3D;“2019”;<br>char s[]&#x3D;str.toCharArray();<br>int x&#x3D;0;<br>for(int i&#x3D;0;i&lt;s.length;i++){<br>x&#x3D;x*10+str[i]-‘0’;<br>}</p><h1 id="结构体数组排序"><a href="#结构体数组排序" class="headerlink" title="结构体数组排序"></a>结构体数组排序</h1><p><strong>当数组是从1开始赋值时，sort函数也要加1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin &gt;&gt; a[i].t &gt;&gt; a[i].d &gt;&gt; a[i].l;<br>&#125;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp); <span class="hljs-comment">//由于数组是从1开始赋值的，因此排序函数也要加1 </span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">11</span>];<br>    <span class="hljs-type">int</span> solve;<br>    <span class="hljs-type">int</span> time;<br>&#125;p[<span class="hljs-number">10000</span>];<br><br><span class="hljs-comment">//按照题数，再罚时间，再名字（名字按字典序排列）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; a, <span class="hljs-type">const</span> Student&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.solve != b.solve)<br>     &#123; <br>        <span class="hljs-keyword">if</span> (a.solve &gt; b.solve)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.time != b.time)<br>           <span class="hljs-keyword">return</span> a.time &lt; b.time;<br>    <span class="hljs-keyword">else</span><br>          <span class="hljs-built_in">return</span> (<span class="hljs-built_in">strcmp</span>(a.name, b.name) &lt; <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>      cin&gt;&gt;p[i].name&gt;&gt;p[i].solve&gt;&gt;p[i].time;<br>    <span class="hljs-built_in">sort</span>(p,p+n,cmp);<span class="hljs-comment">//在主函数中调用，结构体排序；</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>      cout&lt;&lt;p[i].name;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="max-element-min-element"><a href="#max-element-min-element" class="headerlink" title="max_element+min_element"></a>max_element+min_element</h2><blockquote><p>返回最大最小值的下标所对应的地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数都是返回地址，需要加*取值</span><br><span class="hljs-type">int</span> indx = <span class="hljs-built_in">max_element</span>(a, a + n) - a;<br><span class="hljs-type">int</span> mx = *<span class="hljs-built_in">max_element</span>(a, a + n);<br><span class="hljs-type">int</span> mn = *<span class="hljs-built_in">min_element</span>(a, a + n);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法小知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>算法小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第三章</title>
    <link href="/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-3/"/>
    <url>/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-3/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第三章"><a href="#计算机网络复习第三章" class="headerlink" title="计算机网络复习第三章"></a>计算机网络复习第三章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>数据链路层的功能是：实现在两个通信实体之间传送数据（以 帧为单位），并通过差错控制方法，使有差错的物理线路变成无差错数据链路。数据链路层使用的信道有2种：广播信道和点对点信道。 数据链路层需要解决的三个基本问题是：封装成帧. 透明传输（如在数据中出现控制字符时加入转义字符）和差错检测（如CRC技术）。</p></li><li><p>10Mbps以太网是基带编码，使用的曼彻斯特编码，是一种自同步的数字信号编码方式，编码效率是50%；通常采用RJ45（非屏蔽双绞线）。</p></li><li><p>虚拟局域网（VLAN）技术是建立在网络交换机之上的，以硬件方式实现逻辑工作组的划分与管理，通常可以根据端口. MAC地址. IP地址等划分VLAN。同一层交换机上不同VLAN之间不能直接通信（需要使用路由器才能通信）</p></li><li><p>网络互联时使用中继器或集线器完成物理层功能，使用网桥或二层交换机完成数据链路层的功能，使用路由器或三层交换机完成网络层的功能。</p></li><li><p>常用的IEEE802协议有802.2—LLC   802.3—10Mbps CSMA&#x2F;CD以太网  802.4—令牌总线 802.5—令牌环，这些协议都属于数据链路层。以太网使用10BASE-T规定从集线器到网卡的最大距离是100米。</p></li><li><p>总线型网络和使用HUB的星型网络，任意时刻只能有一台电脑发送信息；使用SWITCH的星型网络，任意时刻可以有多台电脑发送信息。</p></li><li><p>CSMA&#x2F;CD的中文是多路载波侦听&#x2F;冲突检测，掌握其工作原理并重点掌握：用于在10Mbps以标准太网的信道访问控制，要求数据帧的发送时间是传播时间的2倍，其帧长为64–1518B，其碰撞窗口为51.2us ，总线型以太网可以检测冲突却不能避免冲突，交换型以太网可以避免冲突。发生第K次冲突后，需要等待r*51.2us之后再侦听以决定是否发送，其中r&#x3D;Min（10，x）(x取(0,1,2,3,…2k-1)中任意随机值),最多传送16次。 </p></li><li><p>通常数据在各个层次的名称不同，一般物理层称为比特. 数据链路层称为帧. 网络层称为分组. 传输层称为报文. 余下各层统称为文本。OSI&#x2F;RM协议的层次名称. 上下层次关系，TCP&#x2F;IP协议的层次名称. 上下层关系，以及OSI&#x2F;RM各层次与TCP&#x2F;IP各层次对应关系。VLAN(虚拟局域网)使用的核心设备是二层交换机。</p></li><li><p>教材图3-10的PPP格式（P75）。教材图3-22的以太网格式（P92）</p></li><li><p>CRC计算（教材 图3-8）（P71）</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>数据链路层需要解决的三个基本问题是：封装成帧. 透明传输和差错检测，其中在数据中出现控制字符时加入转义字符属于(   )。<br>2. 完善以太网的MAC帧格式 。</p><ol start="3"><li>以太网中采用的CSMA&#x2F;CD协议是一种能避免冲突的协议。</li><li>在一个二层交换机内划分为3个虚拟网络后，虚拟网络之间不可在本交换机内通信。</li><li>在802.3局域网中，当使用了交换技术后，可避免冲突产生。</li><li>10M以太网的碰撞窗口为51.2us  </li><li>10M以太网的标准是IEEE802.5 。</li><li>10BASE-T标准中使用的电缆为双绞线</li><li>802.3协议中源地址为（）。<br>A. 1字节  B. 4字节    C. 6字节   D. 8字节</li><li>符合OSI参考模型第二层功能的设备，均有一个MAC地址，以太网MAC地址是（）位二进制。<br>A.    64     B. 48     C. 32    D. 8<br>11.交换机是对应OSI参考模型（）的设备。<br>A. 物理层    B. 传输层    C. 网络层  D. 数据链路层<br>12目前局域网中的高端交换机使用双绞线时能适应10M&#x2F;S，100M&#x2F;S，1000M&#x2F;S的速率，依靠（  ）技术。<br>A. 线路交换    B. 令牌控制<br>C. 自动侦测    D. VLAN技术</li><li>以太网交换机不具有的功能是（）。<br>A. 地址学习    B. 数据帧转发<br>C. 路由选择    D. 回路避免</li><li>以下MAC地址哪个是正确的（）<br>A. 004         B.  00DA45<br>C. 210.47.2.34   D. 00AABB0034CC</li><li>虚拟局域网中的核心设备是（）<br>A. 高端交换机   B. 路由器<br>C. 集线器       D. 中继器</li><li>虚拟局域网的技术基础是（）。<br>A. 交换    B. 路由    C.  带宽分配    D. 冲突检测</li><li>在一个数字化的语音系统中，采用256个量化级时，编码时采用（）位。<br>A. 8           B. 7          C. 6        D. 10</li><li>具有冲突检测载波监听多路访问CSMA&#x2F;CD技术，不适用于（）。<br>A. 总线型网络    B. 星型网络<br>C. 树型网络      D. 环型网络</li><li>IEEE802.3标准中，MAC帧的帖起始定界符是（）。<br>A.  01111111（左低右高）  B. 11101011（左低右高）<br>C.  01111110（左低右高）  D. 10101011（左低右高）</li><li>CSMA&#x2F;CD协议只适用于（）。<br>A. 局域网  B. 广域网    C. 城域网    D. 以上全部</li><li>IEEE802.3中10BASE-T规定从集线器到网卡的最大距离是（）。<br>A. 50米     B. 100米      C. 200米     D. 500米</li><li>数据链路层需要解决的三个基本问题是：封装成帧. 透明传输和差错检测，其中CRC技术属于（  ）。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>透明传输</li><li>类型</li><li>T</li><li>T</li><li>T</li><li>T</li><li>F</li><li>T</li><li>C</li><li>B</li><li>D</li><li>C</li><li>C</li><li>D</li><li>A</li><li>A</li><li>A</li><li>C</li><li>D</li><li>A</li><li>B</li><li>差错检测</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第二章</title>
    <link href="/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-2/"/>
    <url>/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-2/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第二章"><a href="#计算机网络复习第二章" class="headerlink" title="计算机网络复习第二章"></a>计算机网络复习第二章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>物理层确定与传输媒体的接口有关的特性是机械特性.电气特性.功能特性和过程特性。</p></li><li><p>根据信号中代表消息的参数的取值方式不同，信号可以分为2大类，模拟信号和数字信号。从通信的双方信息的交互方式来区分，可以有三种基本方式：单工通信（只能有一个方向的通信而没有反方向的交互）.半双工通信（通信的双方都可以发送信息，但不能双方同时发送）和全双工通信（通信的双方都可以发送信息，而且双方能同时发送）。</p></li><li><p>复用方式有：频分复用（FDM）.时分复用(TDM).码分复用(CDM)和波分复用(WDM)多种，在一根光纤上复用多路光载波信号称为波分复用，利用信号频率的不同来实现电路复用的方法是频分复用，利用信号的不同时间发送来实现电路复用的方法是时分复用。</p></li><li><p>10Mbps以太网是基带编码，使用的曼彻斯特编码，是一种自同步的数字信号编码方式，编码效率是50%；通常采用RJ45（非屏蔽双绞线）。</p></li><li><p>在脉码调制PCM过程中要经过采样.量化.编码三个过程。T1和E1技术都是基本的将模拟信号转为数字信号的方法，目前我国使用的是欧洲的E1标准，E1速率是2.048Mbps，T1的速率是1.544Mbps，这两种方法都使用时分复用。</p></li><li><p>传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。一个数据通信系统包括三大部分：源系统（或发送端.发送方）.传输系统（或传输网络）和目的系统（或接收端.接收方）。</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>通常一个通信系统可以划分为三大部分，即源系统（或发送端.发送方）.(   )和目的系统（或接收方.接收端）。</p></li><li><p>从通信的双方信息的交互方式来区分，可以有三种基本方式：单工通信.半双工通信和(   )。</p></li><li><p>传输媒体是数据传输系统中在发送器和接收器之间的物理通道，可以分为导向传输媒体和非导向传输媒体。无线电波属于(   )。</p></li><li><p>多个通信设备共享一个信道进行通信称为信道复用，不同的用户占用不同的带宽资源称为(   )。</p></li><li><p>在PCM调制过程中要经过量化.采样.编码三个过程。</p></li><li><p>在数据传输过程中，差错主要是由通信过程中的噪声引起的。</p></li><li><p>ADSL技术中，上行通道和下行通道的传输速率不对称。</p></li><li><p>在电路交换.分组交换与报文交换方式中，都要经过线路建立.数据传输.线路释放这3个过程。</p></li><li><p>两台计算机通过电话网通信时必须使用的设备是（）。<br>A. 调制解调器  B.网线.C.中继器    D.集线器</p></li><li><p>常用的传输介质中，带宽最大.信号传输衰减最小.抗干扰能力最强的是（）。<br>A.光纤    B.双绞线     C.同轴电缆     D.无线信道</p></li><li><p>利用信号频率的不同来实现电路复用的方法是（）。<br>A.频分多路复用   B.时分多路复用<br>C.码分多路复用   D.以上都不对</p></li><li><p>在物理层中，指明在接口电缆的各条线上出现的电压范围，属于（）。<br>A.机械特性   B.电气特性  C.功能特性   D.过程特性</p></li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>传输系统</li><li>全双工通信</li><li>非导向传输媒体</li><li>频分复用</li><li>F</li><li>T</li><li>T</li><li>F</li><li>A</li><li>A</li><li>A</li><li>B</li></ol>]]></content>
    
    
    <categories>
      
      <category>期末复习</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>期末复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第一章</title>
    <link href="/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-1/"/>
    <url>/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-1/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第一章"><a href="#计算机网络复习第一章" class="headerlink" title="计算机网络复习第一章"></a>计算机网络复习第一章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>为网络中的数据交换而建立的规则.标准或约定称为网络协议，网络协议由三部分组成：语法（数据与控制信息的结构或格式）.语义（需要发出何种控制信息，完成何种动作以及做出何种响应）.同步（事件实现顺序的详细说明）。</p></li><li><p>Arpanet是Internet的前身，对因特网发展起到很大作用。Internet是通过路由器将多个LAN或WAN相连接形成。</p></li><li><p>计算机网络向用户提供的最重要的功能有2个：连通性和共享</p></li><li><p>所有因特网标准都是以RFC形式在因特网上发表。RFC的意思是“请求评论”</p></li><li><p>因特网从其工作方式上看，可以划分为2大块：边缘部分（由连接在因特网上的主机组成，这部分是用户直接使用的，用来进行通信和资源共享）和核心部分（由大量网络和连接这些网络的路由器组成，这部分为边缘部分提供服务，提供连通性和交换）</p></li><li><p>三网合一是指电信语音 .有线电视网和计算机网络的结合。</p></li><li><p>常用的交换方式有电路.报文和分组。在电路交换方式中要经过线路建立.数据传输.线路释放三个过程。而分组交换和报文交换不需要，因为每个分组都需要被独立进行确定“路由”处理，所以可能存在“后发先至”的现象。计算机网络通常采用分组交换方式。</p></li><li><p>网络通信常用的3种交换方式是电路交换（整个报文的比特流连续地从源点直达终点，好像在一个管道中传送）.报文交换（整个报文先送到相邻节点，全部存储下来后查找转发表，转发到下一节点）和分组交换（单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一节点）。计算机网络采用的交换方式属于分组交换。</p></li><li><p>时延是计算机网络的性能指标之一，指的是数据从网络的一端传输到另一端所需的时间，通常包括发送时延（主机或路由器发送数据帧所需要的时间，也称为传输时延。发送时延&#x3D;数据帧长度&#x2F;发送速率）.传播时延（电磁波在信道中传播一定的距离所需要的时间，在自由空间的传播速率约为3.0<em>105km&#x2F;s，在铜线电缆中的传播速率约为2.3</em>105km&#x2F;s, 在光纤中的传播速率约为2.0*105km&#x2F;s。传播时延&#x3D;信道长度&#x2F;电磁波在信道上传输速率）.处理时延（主机或路由器在收到分组是需要花费一定的时间进行处理）和排队时延（分组在进入路由器后在输入队列中等待处理）。</p></li><li><p>OSI的体系结构由7层组成，从上到下分别是：应用层.表示层.会话层.运输层.网络层.数据链路层.物理层。TCP&#x2F;IP协议由4层组成，从上向下分别为应用层.运输层.网际层（IP）和网络接口层。掌握OSI&#x2F;RM协议的各层次名称.顺序及与TCP&#x2F;IP协议的对应关系。教材图1-18</p></li><li><p>按距离进行分类，可将网络分为广域网.城域网和局域网，掌握其距离范围</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>假定有一个10MB的数据块，在带宽为1Mb&#x2F;s的信道上连续发送，其发送时延是_____s。</li><li>因特网从其工作方式上看，可以划分为2大块：用来进行通信和资源共享属于边缘部分。提供连通性和交换的属于(   )。</li><li>网络通信有3种交换方式。其中【单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一节点】属于(   )（请说明名称，不能说第一种、第二种或第三种）。</li><li>时延是计算机网络的性能指标之一，指的是数据从网络的一端传输到另一端所需的时间。其中的传播时延是指电磁波在信道中传播一定的距离所需要的时间，通常在铜线电缆中其传播速率约为(   )km&#x2F;s。</li><li>所有因特网标准都是以(   )形式在因特网上发表。其意思是“请求评论”。</li><li>网络协议由三部分组成：语法、语义和同步，其中需要发出何种控制信息，完成何种动作以及做出何种响应属于(   )。</li><li>OSI的体系结构由7层组成，从下向上，第六层是(   )。</li><li>TCP&#x2F;IP协议由4层组成，从上向下，UDP是属于(   )。</li><li>电磁波在光纤中传播的速率大约为2.0*105km&#x2F;s,长度为1000km的光纤传播时延是（    ）s。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>83.89</li><li>核心部分</li><li>分组交换</li><li>2.3*105km&#x2F;s</li><li>RFC</li><li>语义</li><li>表示层</li><li>运输层</li><li>0.005</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first-test-blog</title>
    <link href="/2024/03/25/first-test-blog/"/>
    <url>/2024/03/25/first-test-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一个测试博客"><a href="#这是一个测试博客" class="headerlink" title="这是一个测试博客"></a>这是一个测试博客</h1><h1 id="浅浅许个愿：保研上岸"><a href="#浅浅许个愿：保研上岸" class="headerlink" title="浅浅许个愿：保研上岸"></a>浅浅许个愿：保研上岸</h1>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>保研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>保研</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
