<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图的存储和遍历</title>
    <link href="/2024/04/04/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"/>
    <url>/2024/04/04/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2024/04/04/%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/04/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dfs(爆搜)</title>
    <link href="/2024/04/03/algorithm_know/dfs-%E7%88%86%E6%90%9C/"/>
    <url>/2024/04/03/algorithm_know/dfs-%E7%88%86%E6%90%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs-爆搜"><a href="#dfs-爆搜" class="headerlink" title="dfs(爆搜)"></a>dfs(爆搜)</h1><h2 id="dfs递归"><a href="#dfs递归" class="headerlink" title="dfs递归"></a>dfs递归</h2><p><a href="https://www.acwing.com/solution/content/87387/" title="图解">图解</a></p><ol><li>递归就是把一个大问题变成中问题再变成一个很小的问题进行解决</li><li>如果在分解问题时，可能出现一个大问题包括很多个中问题的情况，此时就要在递归外面加上for循环</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> path[N];<br><span class="hljs-type">int</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(u&gt;n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//空位上可以选择的数字为:1 ~ n</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            path[u] = i; <span class="hljs-comment">//此处为u，代表第u个位置需要填</span><br>            st[i] = <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">/*dfs(u+1)展开： </span><br><span class="hljs-comment">            if(u==n)&#123;&#125; </span><br><span class="hljs-comment">            for(int i=1;i&lt;=n;++)&#123;</span><br><span class="hljs-comment">            //由于这里有个状态数组，i=1已经被访问过了，所以会把没访问过的 i=2 填入path数组中（真妙！） </span><br><span class="hljs-comment">        if(!state[i])&#123;</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">dfs(u+1)</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">            */</span><br>            st[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="next-permutation-函数"><a href="#next-permutation-函数" class="headerlink" title="next_permutation() 函数"></a>next_permutation() 函数</h2><blockquote><p>全排列函数 next_permutation(num,num+n) 是对数组num中的前n个元素进行全排列，同时并改变num数组的值。</p></blockquote><ol><li><p>另外，需要强调的是，next_permutation（）在<strong>使用前需要对欲排列数组按升序排序</strong>(此时才能找全)，否则只能找出该序列之后的全排列数</p></li><li><p>next_permutation（node,node+n,cmp）可以对结构体num按照自定义的排序方式cmp进行排序</p></li><li><p>常用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span>&#123;<br><br>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a,a+n));<br><br></code></pre></td></tr></table></figure></li></ol><p><strong>dfs例题：</strong><br><a href="https://www.acwing.com/problem/content/description/4960/" title="飞机降落问题">飞机降落问题</a></p><p>使用全排列函数对所有情况进行枚举，判断在所有的情况下是否能够满足条件。<br>使用方式：</p><ol><li>初始化一个全排列数组 a[n] ，通过a[i] &#x3D; i对其赋值（初始时其为1，2，…,n）</li><li>下面每种情况其循环时的下标应当为 a[i]</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> flag;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> t,d,l;<br>&#125;p[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin &gt;&gt; m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> a[n]; <span class="hljs-comment">//全排列数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i] = i; <span class="hljs-comment">//初始排列数组为 1,2,3</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; p[i].t &gt;&gt; p[i].d &gt;&gt; p[i].l;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-comment">//初始化操作</span><br>          flag = <span class="hljs-literal">true</span>;<br>          <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上一架飞机的降落时间，在此事件后开始降落的飞机都是合法的</span><br>          <br>          <span class="hljs-comment">//循环某个排序</span><br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> j = a[i]; <span class="hljs-comment">//代表此次排列顺序的下标</span><br><br>            start = <span class="hljs-built_in">max</span>(start , p[j].t) ; <span class="hljs-comment">// 和飞机到达时间取max,因为有可能上个飞机已经降落完成但下个飞机还没到</span><br>            <span class="hljs-keyword">if</span>(p[j].t + p[j].d &gt;= start)&#123;<br>              start += p[j].l;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>              flag = <span class="hljs-literal">false</span>;<br>              <span class="hljs-keyword">break</span>;<br>            &#125;<br>          &#125;<br>          <br>          <span class="hljs-keyword">if</span>(flag)&#123;<br>              <span class="hljs-comment">//只要有一组排列满足条件即可判定为yes</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>));<br>             <br>        <span class="hljs-comment">//只有所有排列都不满足条件才判定为no</span><br>        <span class="hljs-keyword">if</span>(!flag) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2024/04/02/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/04/02/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="二分算法解析"><a href="#二分算法解析" class="headerlink" title="二分算法解析"></a>二分算法解析</h2><p>二分的判断条件通常是通过列出有关要二分的量和其他变量之间的关系方程：</p><ol><li>暴力解放要循环所有可能的边长值</li><li>通过二分来一步步得缩小查找的区间</li><li>二分的核心就是通过某些性质使得可以缩小查找区间来减少时间复杂度</li></ol><p><strong>二分步骤：</strong></p><ol><li>先写一个check函数</li><li>判定在check的情况下（true和false的情况下），如何更新区间。</li><li>在check(m) &#x3D;&#x3D; true的分支下是:<ul><li>l &#x3D; mid的情况，中间点的更新方式是m &#x3D; (l+r+1)&#x2F;2</li><li>r &#x3D; mid的情况，中间点的更新方式是m &#x3D; (l+r)&#x2F;2</li></ul></li></ol><p>这种方法保证了：</p><ol><li>最后的 l &#x3D;&#x3D; r</li><li>搜索到达的答案是闭区间的，即 a[l] 是满足check()条件的。</li></ol><p><strong>二分模板</strong><br>模板1就是在满足chek()的区间内找到左边界，模板2在满足check()的区间内找到右边界。然后无论是左边界还是右边界，都应该是整个区间中某一段满足某性质（如单调不降）与另一段不满足该性质的分界点</p><p><strong>口诀：左加右减</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//查找左边界 SearchLeft 简写SL</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SL</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid; <br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>; <br>    &#125;   <br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">//查找右边界 SearchRight 简写SR </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SR</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;                   <br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//需要+1 防止死循环</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> r; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL中的有关二分的函数"><a href="#STL中的有关二分的函数" class="headerlink" title="STL中的有关二分的函数"></a>STL中的有关二分的函数</h2><p>tip:这些关于二分的stl函数，都<strong>只会查找指定元素后面的值</strong>，所以要在排好序的数组中进行查找</p><ol><li><code>binary_search()</code>函数，作用：对一个<strong>不降序列</strong>进行二分查找，如果所查找的值在序列中出现了，返回true，没有出现，返回false。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-type">bool</span> flag = <span class="hljs-built_in">binary_search</span>(a,a+<span class="hljs-number">5</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//返回的是布尔值</span><br>cout &lt;&lt; flag;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>lower_bound()</code>函数，作用：对一个<strong>不降序列</strong>进行二分查找，返回第一个<strong>大于等于</strong>所查找的值的元素下标，<strong>注意返回的是指针变量！！！</strong> 如果所有元素都小于val，则返回last的位置，且last的位置是越界的</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>upper_bound()</code>函数，作用：对一个不降序列进行二分查找，返回第一个<strong>大于</strong>所查找的值的元素下标，注意返回的是指针变量！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-keyword">auto</span> pos = <span class="hljs-built_in">upper_bound</span>(a,a+<span class="hljs-number">5</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//返回的是指针变量</span><br><span class="hljs-keyword">auto</span> index =  pos-a; <span class="hljs-comment">//对应元素下标(从0开始)</span><br>cout &lt;&lt; index &lt;&lt; endl &lt;&lt; *pos &lt;&lt; endl &lt;&lt; a[index];<br></code></pre></td></tr></table></figure></li><li><p>如果查找第一个小于某个元素的下标，则加上<code>greater&lt;int&gt;()</code></p></li></ol><p><strong>例题：数的范围</strong></p><blockquote><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。<br>如果数组中不存在该元素，则返回 -1 -1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,q;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> k;<br>        cin &gt;&gt; k;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">binary_search</span>(a,a+n,k))&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">lower_bound</span>(a,a+n,k) - a;<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">upper_bound</span>(a,a+n,k) - a;<br>        cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r<span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/2024/04/02/String/"/>
    <url>/2024/04/02/String/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><h2 id="字符比较"><a href="#字符比较" class="headerlink" title="字符比较"></a>字符比较</h2><p>使用 <strong>单引号</strong> 包括单个字符</p><h2 id="字符串变数组"><a href="#字符串变数组" class="headerlink" title="字符串变数组"></a>字符串变数组</h2><h2 id="将数字转换成字符串"><a href="#将数字转换成字符串" class="headerlink" title="将数字转换成字符串"></a>将数字转换成字符串</h2><blockquote><p>to_string(num)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">12345678</span>;<br>cout &lt;&lt; <span class="hljs-built_in">to_string</span>(a) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索</title>
    <link href="/2024/04/02/dp/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2024/04/02/dp/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="记忆化数组"><a href="#记忆化数组" class="headerlink" title="记忆化数组"></a>记忆化数组</h1><blockquote><p>核心思想：设置一个记忆化数组f[N][N]，保存每种情况的（最优）解<br>并且如果这个点 f[i][j] 已经计算过了，直接返回即可，这就是记忆化搜索</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,m,g[N][N]; <span class="hljs-comment">//数组g存储每个点高度</span><br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">//记忆化数组，保存每个(i,j)为起点的最优解</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">//以i，j为起点的滑雪长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个点已经计算过了，直接返回即可，这就是记忆化搜索</span><br>    <span class="hljs-keyword">if</span>(f[i][j] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[i][j]; <br>    f[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">//长度最短至少为1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;<span class="hljs-number">4</span>;a++)&#123;<br>        <span class="hljs-type">int</span> x = i + dx[a]; <span class="hljs-type">int</span> y = j + dy[a];<br>        <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="hljs-number">1</span> &amp;&amp; y&lt;= m &amp;&amp; g[i][j] &gt; g[x][y])&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">dp</span>(x,y)+<span class="hljs-number">1</span>); <span class="hljs-comment">//(i,j) 为当前位置，(x,y)为下一个要访问的位置</span><br>        &#125;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> f[i][j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(f));<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//循环枚举起始位置(i,j)的所有可能，找出最大值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dp</span>(i,j)); <span class="hljs-comment">//dp(x,y)返回以位置(i,j)为起点能延申的最长长度</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2024/04/02/dp/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2024/04/02/dp/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vector</title>
    <link href="/2024/04/01/algorithm_know/vector/"/>
    <url>/2024/04/01/algorithm_know/vector/</url>
    
    <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="vector索引"><a href="#vector索引" class="headerlink" title="vector索引"></a>vector索引</h2><p><strong>vector只有在指定长度时,才能用下标索引的方法修改元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = a.<span class="hljs-built_in">begin</span>();p != a.<span class="hljs-built_in">end</span>(); p++)&#123;<br>cout &lt;&lt; *p;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>下标访问</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>cout &lt;&lt; vi[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>迭代器访问</strong><br>迭代器类似指针，迭代器在vector中就是充当指针的作用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it = vi.<span class="hljs-built_in">begin</span>(); it != vi.<span class="hljs-built_in">end</span>();it ++)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>返回首尾部的元素</strong></p><ol><li><code>front()</code> 返回第一个元素</li><li><code>bakc()</code>  返回最后一个元素</li></ol><h2 id="vector-插入-删除-元素"><a href="#vector-插入-删除-元素" class="headerlink" title="vector 插入&#x2F;删除 元素"></a>vector 插入&#x2F;删除 元素</h2><ol><li>在尾部进行插入&#x2F;删除<ul><li><code>push_back()</code></li><li><code>pop_back()</code></li></ul></li><li>指定位置的插入&#x2F;删除<ul><li><code>insert()</code>  c.insert(it, x) : 向任意迭代器it插入一个元素x ，O(N)</li><li><code>erase()</code>  c.erase(first,last) 删除[first,last)的所有元素，first,last都为迭代器指针 ，O(N)</li></ul></li></ol><h2 id="vector去重"><a href="#vector去重" class="headerlink" title="vector去重"></a>vector去重</h2><ol><li>先进行 sort() 排序，这样重复元素就会堆一起了</li><li>调用 unique() 函数将<strong>相邻且重复</strong> （因此要先排序） 的元素放到vector的尾部 然后返回指向第一个重复元素的迭代器</li><li>再用erase函数擦除从迭代器所指元素到最后元素的所有的元素</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()), vec.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h2 id="vector截取"><a href="#vector截取" class="headerlink" title="vector截取"></a>vector截取</h2><p>void assign(const_iterator first,const_iterator last); &#x2F;&#x2F;两个指针，分别指向开始和结束的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//通过vector的迭代器截取数组</span><br><span class="hljs-keyword">auto</span> first = a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> end = a.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>;<br>a.<span class="hljs-built_in">assign</span>(first,end);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性dp</title>
    <link href="/2024/04/01/dp/%E7%BA%BF%E6%80%A7dp/"/>
    <url>/2024/04/01/dp/%E7%BA%BF%E6%80%A7dp/</url>
    
    <content type="html"><![CDATA[<h1 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h1><blockquote><p>线性DP，是较常见的一类动态规划问题，其是在线性结构上进行状态转移，这类问题不像背包问题、区间DP等有固定的模板</p><p>线性动态规划的目标函数为特定变量的线性函数，约束是这些变量的线性不等式或等式，目的是求目标函数的最大值或最小值</p></blockquote><h2 id="LCS问题——最长公共子序列"><a href="#LCS问题——最长公共子序列" class="headerlink" title="LCS问题——最长公共子序列"></a>LCS问题——最长公共子序列</h2><blockquote><p><code>子序列</code> : 指的是字符串中<strong>不一定连续</strong>但先后顺序一致的n个字符<br><code>字符子串</code>：指的是字符串中连续的n个字符<br><code>最长公共子序列</code>，英文缩写为LCS（Longest Common Subsequence）。其定义是: 一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。</p></blockquote><blockquote><p>问题描述：给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p></blockquote><p><strong>状态表示</strong></p><ol><li>集合表示：所有 $ A[1,n] $和 $ B[1,m] $ 的公共子序列的集合</li><li><strong>dp[i][j]代表以s1[i]，s2[j]结尾的LCS的长度</strong></li><li>属性：公共子序列长度的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>找集合中所有情况的共同点和不同点来划分集合</li><li>该公共子序列分为四种情况：包括a[n] , b[m] ，不包括a[n] ,包括b[m] ，不包括a[n] , b[m] ，包括a[n] ,不包括b[m] （可以用二进制0 1来表示）</li><li>$ f[i][j] $：A前i个字符，B前j个字符的公共子序列 的集合<br>属性：maxlen</li><li>集合划分情况（假定）<ul><li>(1) $ f[i-1][j-1] + 1 $  同时包括 a[n] 和 b[m] （前提是a[n] &#x3D; a[m]）</li><li>(2) $ f[i-1][j] $  不包括a[n] ,包括b[m]</li><li>(3) $ f[i][j-1] $  包括a[n] ,不包括b[m]</li><li>(4) $ f[i-1][j-1] $ a[n] 和 b[m] 都不包括</li></ul></li><li>集合划分情况（实际）<ul><li>f[i-1][j-1]+1 可以表示情况1    –&gt; a</li><li>f[i][j-1]&#x3D;max(情况2,情况4)    –&gt; b</li><li>f[i-1][j]&#x3D;max(情况3,情况4)    –&gt; c<br>所以我们最终只需要 求 max(a,b,c) 即可</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">\\最长公共子序列<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">char</span> a[N],b[N];<br><span class="hljs-type">int</span> n,m,f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    cin &gt;&gt; b[i];<br>&#125;<br><span class="hljs-comment">//状态计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-1</span>][j]);<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br>    cout &lt;&lt; f[n][m];<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="LIS问题——最长上升子序列"><a href="#LIS问题——最长上升子序列" class="headerlink" title="LIS问题——最长上升子序列"></a>LIS问题——最长上升子序列</h2><blockquote><p><code>最长上升子序列</code>（Longest  Increasing Subsequence），简称LIS，也有些情况求的是最长非降序子序列，二者区别就是序列中是否可以有相等的数，对于固定的数组，虽然LIS序列不一定唯一，但LIS的<strong>长度是唯一的</strong></p></blockquote><ol><li><p>状态设计：dp[i]代表以a[i]结尾的LIS的长度</p></li><li><p>状态转移：dp[i]&#x3D;max{dp[j]+1，dp[i]} (1&lt;&#x3D;j&lt; i，a[j]&lt;a[i])</p></li><li><p>边界处理：dp[i]&#x3D;1(1&lt;&#x3D;i&lt;&#x3D;n)</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> a[N],n;<br><span class="hljs-type">int</span> f[N]; <span class="hljs-comment">//f[i]: 以 a[i] 为结尾的上升子序列的最大长度</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>        f[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">//用1去初始化dp数组，因为最短的递增子序列的长度为1</span><br>    &#125;<br>    <span class="hljs-comment">//循环整个数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//从前往后循环比那里之前的元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="hljs-built_in">max</span>(f[i],f[j]+<span class="hljs-number">1</span>);<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans,f[i]);<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>区间dp</title>
    <link href="/2024/04/01/dp/%E5%8C%BA%E9%97%B4dp/"/>
    <url>/2024/04/01/dp/%E5%8C%BA%E9%97%B4dp/</url>
    
    <content type="html"><![CDATA[<h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><p>区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len &#x3D; 1 时用来初始化，枚举从 len &#x3D; 2 开始；第二维枚举起点 i （右端点 j 自动获得，j &#x3D; i + len - 1）</p><p>模板代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len++) &#123;         <span class="hljs-comment">// 区间长度</span><br>    <span class="hljs-comment">//终止条件代表右端点要小于n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) &#123; <span class="hljs-comment">// 枚举起点</span><br>        <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 区间终点</span><br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            dp[i][j] = 初始值<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) &#123;        <span class="hljs-comment">// 枚举分割点，构造状态转移方程</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + w[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h2><blockquote><p>问题描述：设有 N 堆石子排成一排，其编号为 1,2,3,…,N。每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。<br>每次<strong>只能合并相邻的两堆</strong>，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。<br>找出一种合理的方法，使总的代价最小，输出最小代价</p></blockquote><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示将 [i,j] 这段区间的物品合并在一起的方案集合</li><li>属性：最小代价</li><li>集合划分，最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并，将集合划分成某一堆是由区间 $ [i,i] ，[i,i+1] ，[i,i+2] ，… ， [i,i + j-1] $ 这些情况中之一所合并而成（即所有方案中，最后一次合并时，其中的某一堆一定是由上述某个区间所合并而成，满足不重不漏的原则）</li><li>除了最后一次以外前面每次合并的和即为该次合并所产生的代价，因此最小总代价 &#x3D; $ f(i,k) + f(k+1,j) + s[j] - s[i-1] $</li><li>$ f(i,j) $</li></ol><p><strong>状态计算</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> f[N][N],s[N],n,w[N]; <span class="hljs-comment">//dp数组；前缀和数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        s[i] = s[i<span class="hljs-number">-1</span>] + w[i];<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f); <span class="hljs-comment">//由于是求最小值，因此先把dp数组设置成最大值</span><br>    <span class="hljs-comment">// 区间 DP 枚举套路：长度+左端点 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)&#123; <span class="hljs-comment">//len表示[i, j]的元素个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=n;i++)&#123; <br>            <span class="hljs-type">int</span> j = i+len<span class="hljs-number">-1</span>; <span class="hljs-comment">// 自动得到右端点</span><br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>                f[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 边界初始化</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;k++)&#123;<br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i][j],f[i][k] + f[k+<span class="hljs-number">1</span>][j] + s[j] - s[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划（背包问题）</title>
    <link href="/2024/03/30/dp/dp/"/>
    <url>/2024/03/30/dp/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><blockquote><p>问题描述：有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i件物品的体积是$ v_i $，价值是$ w_i $ 。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大</p></blockquote><p>针对0-1背包问题，每个物品有选与不选两种选择，则暴力枚举的时间复杂度为 $ O(2^n) $</p><p><strong>状态表示</strong> </p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品只能<strong>选一次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>将状态集合将所有选法划分成第 i 个物品 选 或者 不选 的方案（该划分方式不重不漏）</li><li>第 i 个物品不选时：$ f(i,j) &#x3D; f(i-1,j) $</li><li>第 i 个物品被选择时，为了方便计算，则先假设不选第 i 个物品，则此时 $ f(i,j) &#x3D; f(i-1,j-v[i]) + w[i] $ ,此时前提条件是 $ j &gt; v[i] $</li><li>状态属性是求最大值，则用max函数求出上述情况下的价值最大值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,m,ans;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-comment">//动态计算</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j], d[i<span class="hljs-number">-1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一维优化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> d[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) d[j] = <span class="hljs-built_in">max</span>(d[j], d[j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品能选<strong>无数次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>该集合的所有选法可以划分成第 i 个物品被选了0次,1次, … , n次（不重不漏）</li><li>划分依据:找最后一个不同点；因此假设先不选最后一个物品</li><li>$ f(i-1,j) $ 和 $ f(i-1,j-n*v_i) $ 这些方案的最大值</li><li>$ f(i,j) &#x3D; max( f(i-1,j), f(i-1,j-1<em>v[i])+1</em>w[i], f(i-1,j-2<em>v[i])+2</em>w[i], … , f(i-1,j-n<em>v[i])+n</em>w[i] ) $</li><li>$ f(i,j-v) &#x3D; max( f(i-1,j-v), f(i-1,j-2<em>v[i])+1</em>w[i], f(i-1,j-3<em>v[i])+2</em>w[i], … , f(i-1,j-(n+1)<em>v[i])+n</em>w[i] ) $</li><li>$ f(i-1,v) &#x3D; f(i,j-v) + w $</li></ol><p><strong>未优化版本，会超时</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;(k*v[i])&lt;=j;k++)&#123;<br>                <span class="hljs-keyword">if</span>(j&gt;=k*v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j],d[i][j-k*v[i]]+k*w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二维优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span>(j&gt;=v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j],d[i][j-v[i]] + w[i]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>一维优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[j] = d[j];<br>        <span class="hljs-keyword">if</span>(j&gt;=v[i]) d[j] = <span class="hljs-built_in">max</span>(d[j],d[j-v[i]] + w[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品能选<strong>有限n次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>集合的选法包括第i个物品不被选，或者选1个，2个…n个.</li><li>多重背包可以转换成0-1背包</li><li>将s个物品的体积看成一个个单独的物品</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将s个物品看成一个个单独的物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>    <span class="hljs-keyword">while</span>(s--)&#123;<br>        t++; <span class="hljs-comment">//t从1开始</span><br>        v[t] = a;<br>        w[t] = b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拆分后直接套用0-1背包板子</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>        f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><blockquote><p>问题描述：有 N 组物品和一个容量是 V 的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是$ v_{ij} $，价值是$ w_{ij} $，其中$ i $是组号，$ j $ 是组内编号。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p></blockquote><p><strong>状态计算</strong></p><ol><li>体积和价值表示为$ v[i][k] w[i][k] $ $ i $代表物品组，k 代表物品组里的第k个物品<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; s[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=s[i];j++)&#123;<br>        cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>对每个物品组进行循环，将其转换成0-1背包<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=s[i];k++)<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i][k]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j], d[i<span class="hljs-number">-1</span>][j-v[i][k]] + w[i][k]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
      <category>背包问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2024/03/29/algorithm_know/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/29/algorithm_know/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>实现手段：<br>通过一个小根堆，每次取出队列顶部的两个元素进行合并，同时将这两个元素出队，将合并之后得到的新元素入队<br>直到队列中只剩下一个元素为止</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>math</title>
    <link href="/2024/03/29/algorithm_know/math/"/>
    <url>/2024/03/29/algorithm_know/math/</url>
    
    <content type="html"><![CDATA[<h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>$ gcd(a, b) &#x3D; gcd(b, a mod b) $</p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p><strong>互质数：</strong></p><blockquote><p>两个数的公因数只有1的两个非零自然数,叫做互质数<br>1与任何数都互斥，自身与自身不互斥（公约数包括1和自身）</p></blockquote><p>性质一：两个不同的质数是互质的。<br>性质二：一个质数，另一个不为它的倍数，这两个数为互质数。（较大数是质数的两个数是互质数）<br>性质三：相邻的两个自然数是互质数。<br>性质四：相邻的两个奇数是互质数。<br>性质五：最大公约数是1，两个数互质。</p><p><strong>欧拉函数</strong></p><blockquote><p>定义：对于一个正整数n，n的欧拉函数ϕ(n)表示<strong>小于等于</strong>n中，与n互质的<strong>正整数</strong>的个数</p></blockquote><p>分解质因数：N &#x3D; $ p_1^{a_1} * p_2^{a_2} * …*p_n^{a_n} $</p><p>$ ϕ(N) &#x3D; N(1- \frac{1}{p_1})(1- \frac{1}{p_2})…(1- \frac{1}{p_n}) $</p><p>用代码表示该公式时为了防止出现小数，用以下方式表示：<br>$ ϕ(N) &#x3D; (\frac{N}{p_1})*(p_1 - 1) $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=t/i;i++)&#123;<br>    <span class="hljs-comment">//判断i是不是t的质因子</span><br>    <span class="hljs-keyword">if</span>(t%i == <span class="hljs-number">0</span>)&#123;<br>        res = (res/i)*(i<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span>(t%i == <span class="hljs-number">0</span>)&#123;<br>            t /= i;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//有没除尽的</span><br><span class="hljs-keyword">if</span>(t &gt; <span class="hljs-number">1</span>) res = (res/t)*(t<span class="hljs-number">-1</span>);<br>cout &lt;&lt; res &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>性质1：如果<strong>n是质数</strong>，那么<strong>ϕ(n) &#x3D; n−1</strong>,因为只有n本身与它不互质。</p><p>性质2：如果p，q都是质数，那么$ ϕ ( p ∗ q ) &#x3D; ϕ ( p ) ∗ ϕ ( q ) &#x3D; ( p − 1 ) ∗ ( q − 1 ) $.</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂，二进制取幂，在O(logn)下求$ a^n $的方法</p><blockquote><p>求 $ {a^b} % {p} $ 的值</p></blockquote><p>做这个题前首先我们需要了解一下关于取余的公式<br>(a + b) % p &#x3D; (a % p + b % p) % p<br>(a - b) % p &#x3D; (a % p - b % p ) % p<br>(a * b) % p &#x3D; (a % p * b % p) % p</p><p><strong>$ a^b &#x3D; a^{2^0+2^1+…+2^n(中的某几项)} $</strong><br>ex. $ a^{10} &#x3D; a^{(1010)_2} &#x3D; a^{2^1+2^3} $</p><p><strong>注意下述式子</strong></p><blockquote><p>$ a^{2^3} &#x3D; (a^{2^2})^2 \ a^{2^0} &#x3D; a $</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL a,b;<br><span class="hljs-type">int</span> p,n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;p);<br>        LL res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// cout &lt;&lt; b;</span><br>            <span class="hljs-comment">//求数末尾为1还是0</span><br>            <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)&#123;<br>                res = res * a % p;<br>            &#125;<br>            a = a*a % p;<br>            b = b &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//注意这里要把移位后的值赋给b</span><br>        &#125;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pair</title>
    <link href="/2024/03/29/algorithm_know/pair/"/>
    <url>/2024/03/29/algorithm_know/pair/</url>
    
    <content type="html"><![CDATA[<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><blockquote><p>pair&lt;int,int&gt; p[N];</p></blockquote><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><blockquote><p>和结构体类似，first代表第一个元素，second代表第二个元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="索引元素"><a href="#索引元素" class="headerlink" title="索引元素"></a>索引元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cout &lt;&lt; p[i].first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p[i].second;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动手做操作系统</title>
    <link href="/2024/03/28/OS/"/>
    <url>/2024/03/28/OS/</url>
    
    <content type="html"><![CDATA[<h1 id="动手做操作系统"><a href="#动手做操作系统" class="headerlink" title="动手做操作系统"></a>动手做操作系统</h1><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ol><li>在Windows下编写代码，使用vscode、记事本等编辑器。</li><li>使用Linux的虚拟机编译内核和生成操作软盘映像。（img软盘也可以直接在window11环境下使用bximage.exe生成，但需要在虚拟机里进行格式化）</li><li>必要时使用安装了DOS的虚拟机来调试程序以及操作软盘映像。</li><li>安装一个Bochs,必要的时候用它来调试。</li><li>使用其他必要的工具，比如版本控制工具(VSS或者CVS)。</li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>软盘是从A盘启动的</li></ol><h2 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h2><p>在操作系统中，实模式（Real Mode）和保护模式（Protected Mode）是两种不同的工作模式，特别是在x86架构的计算机上常见。</p><p><strong>实模式：</strong></p><ul><li>实模式是早期IBM PC兼容计算机上的一种工作模式。在实模式下，CPU可以访问1MB范围内的内存。</li><li>内存管理采用分段机制，内存地址由一个16位段地址和一个16位偏移地址组成，共20位地址空间。</li><li>实模式下，没有内存保护机制，任何程序都可以访问系统的所有内存和硬件设备，因此容易导致系统的稳定性问题。<br><strong>保护模式：</strong></li><li>保护模式是后来引入的一种工作模式，提供了更为复杂和强大的内存管理和保护机制。</li><li>在保护模式下，CPU可以访问超过1MB的内存，并且支持虚拟内存和分页机制。</li><li>内存管理采用分段和分页结合的方式，可以实现更灵活的内存保护和隔离，不同程序之间不会相互影响。</li><li>保护模式下，操作系统可以对内存和硬件设备进行更精细的控制和管理，提高了系统的稳定性和安全性。</li></ul><p>总的来说，实模式和保护模式是操作系统在x86架构下的两种不同的工作模式，保护模式相比实模式具有更多的功能和优势，是现代操作系统常用的工作模式。</p><h2 id="全局描述符表（GDT）"><a href="#全局描述符表（GDT）" class="headerlink" title="全局描述符表（GDT）"></a>全局描述符表（GDT）</h2><p>全局描述符表（Global Descriptor Table，GDT）是x86架构下一种用于管理内存的数据结构，它在操作系统中扮演着重要的角色。GDT定义了内存分段的策略，包括内存段的起始地址、段的大小、访问权限等信息。</p><p>在x86架构中，内存被分成多个段（segment），每个段都有自己的起始地址和大小。GDT就是用来管理这些段的数据结构。每个段都由一个描述符（descriptor）来描述，而GDT就是存放这些描述符的表格。描述符包含了段的各种属性，比如基地址、段限长、访问权限等。</p><p>通过GDT，操作系统可以实现对内存的灵活管理和保护。例如，操作系统可以将代码、数据、堆栈等不同类型的信息放在不同的段中，并且对每个段设置不同的访问权限，从而提高系统的安全性和稳定性。此外，GDT还支持虚拟内存和分页机制，可以实现更高效的内存管理和地址转换。</p><p>总的来说，全局描述符表（GDT）是x86架构下一种重要的内存管理数据结构，它定义了内存分段的策略，为操作系统提供了灵活的内存管理和保护机制。</p><h2 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h2><p>(1)准备GDT<br>(2)用 lgdt 加载 gdtr.<br>(3)打开 A20.<br>(4)置cr0的PE位.<br>(5)跳转，进入保护模式.</p><h2 id="运行一个-com程序的步骤"><a href="#运行一个-com程序的步骤" class="headerlink" title="运行一个.com程序的步骤"></a>运行一个.com程序的步骤</h2><ol><li>使用bximage.exe生成一个软盘</li><li>将软盘插入到xp虚拟机中，进行格式化（选择带ms-dos启动盘的格式化）</li><li>将需要运行的.com程序放入软盘中，之后将软盘取出（防止软盘被占用而出错）</li><li>编辑bochsrc.bxrc，将软盘名称改成自己软盘的名称，将启动盘改成A</li><li>运行bochsrc.bxrc即可进入到软盘中，之后在窗口中输入test1.com即可运行</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>枚举算法</title>
    <link href="/2024/03/28/algorithm_know/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/28/algorithm_know/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举算法"><a href="#枚举算法" class="headerlink" title="枚举算法"></a>枚举算法</h1><h2 id="结题步骤"><a href="#结题步骤" class="headerlink" title="结题步骤"></a>结题步骤</h2><p>采用枚举算法解题的一般思路如下：</p><ol><li>确定枚举对象、枚举范围和判断条件，并判断条件设立的正确性。</li><li>一一枚举可能的情况，并验证是否是问题的解。</li><li>考虑提高枚举算法的效率。</li></ol><p><strong>提高算法效率方法</strong></p><ol><li>抓住问题状态的本质，尽可能缩小问题状态空间的大小。</li><li>加强约束条件，缩小枚举范围。</li><li>根据某些问题特有的性质，例如对称性等，避免对本质相同的状态重复求解。</li></ol><h2 id="递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。"><a href="#递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。" class="headerlink" title="递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。"></a>递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。</h2><h3 id="指数型枚举"><a href="#指数型枚举" class="headerlink" title="指数型枚举"></a>指数型枚举</h3><p>从 1∼n 这 n个整数中随机选取任意多个，输出所有可能的选择方案。<br>由于每个数都存在选与不选两种状态，所以总共会有2^n 种情况<br>选与不选可以使用dfs来递归表示<br>因此递归函数中会用到两个dfs()函数分别表示选与不选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> st[<span class="hljs-number">20</span>]; <span class="hljs-comment">//结果数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">1</span>) <br>                cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    st[u] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>    <br>    st[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排列型枚举"><a href="#排列型枚举" class="headerlink" title="排列型枚举"></a>排列型枚举</h3><p>可以使用stl函数 next_permutation </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//时间复杂度 N!</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> a[N],n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="组合型枚举"><a href="#组合型枚举" class="headerlink" title="组合型枚举"></a>组合型枚举</h3><blockquote><p>从 1∼n 这 n 个整数中随机选出 k 个，输出所有可能的选择方案</p></blockquote><p>可以使用stl函数 <strong>prev_permutation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) a[i]=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span>(a[i]) cout&lt;&lt; i &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">prev_permutation</span>(a+<span class="hljs-number">1</span>, a+<span class="hljs-number">1</span>+n));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>将数据集分成训练集和测试集</title>
    <link href="/2024/03/26/data-set-spilt/"/>
    <url>/2024/03/26/data-set-spilt/</url>
    
    <content type="html"><![CDATA[<h1 id="将数据集分成训练集和测试集"><a href="#将数据集分成训练集和测试集" class="headerlink" title="将数据集分成训练集和测试集"></a>将数据集分成训练集和测试集</h1><h2 id="具体代码（带详细注释）"><a href="#具体代码（带详细注释）" class="headerlink" title="具体代码（带详细注释）"></a>具体代码（带详细注释）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">假设数据集文件夹中有三类</span><br><span class="hljs-string">class_indices.json</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;0&quot;: &quot;AD&quot;,</span><br><span class="hljs-string">    &quot;1&quot;: &quot;CN&quot;,</span><br><span class="hljs-string">    &quot;2&quot;: &quot;MCI&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_split_data</span>(<span class="hljs-params">root: <span class="hljs-built_in">str</span>, val_rate: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.2</span></span>):<br>    random.seed(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 保证随机结果可复现</span><br>    <span class="hljs-keyword">assert</span> os.path.exists(root), <span class="hljs-string">&quot;dataset root: &#123;&#125; does not exist.&quot;</span>.<span class="hljs-built_in">format</span>(root)<br><br>    <span class="hljs-comment"># 遍历文件夹，一个文件夹对应一个类别</span><br>    data_class = [cla <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> os.listdir(root) <span class="hljs-keyword">if</span> os.path.isdir(os.path.join(root, cla))]<br>    <span class="hljs-comment"># 排序，保证各平台顺序一致</span><br>    data_class.sort()  <span class="hljs-comment"># [&#x27;AD&#x27;, &#x27;CN&#x27;, &#x27;MCI&#x27;]</span><br>    <span class="hljs-comment"># 生成类别名称以及对应的数字索引</span><br>    class_indices = <span class="hljs-built_in">dict</span>((k, v) <span class="hljs-keyword">for</span> v, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_class))<br>    json_str = json.dumps(<span class="hljs-built_in">dict</span>((val, key) <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> class_indices.items()), indent=<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;class_indices.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> json_file:<br>        json_file.write(json_str)<br><br>    train_images_path = []  <span class="hljs-comment"># 存储训练集的所有图片路径</span><br>    train_images_label = []  <span class="hljs-comment"># 存储训练集图片对应索引信息</span><br>    val_images_path = []  <span class="hljs-comment"># 存储验证集的所有图片路径</span><br>    val_images_label = []  <span class="hljs-comment"># 存储验证集图片对应索引信息</span><br>    every_class_num = []  <span class="hljs-comment"># 存储每个类别的样本总数</span><br>    supported = [<span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-string">&quot;.JPG&quot;</span>, <span class="hljs-string">&quot;.png&quot;</span>, <span class="hljs-string">&quot;.PNG&quot;</span>]  <span class="hljs-comment"># 支持的文件后缀类型</span><br>    <span class="hljs-comment"># 遍历每个文件夹下的文件</span><br>    <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> data_class:<br>        cla_path = os.path.join(root, cla) <span class="hljs-comment"># 类别文件夹的具体路径</span><br>        <span class="hljs-comment"># 遍历获取supported支持的所有文件路径</span><br>        images = [os.path.join(root, cla, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> os.listdir(cla_path)<br>                  <span class="hljs-keyword">if</span> os.path.splitext(i)[-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> supported]<br>        <span class="hljs-comment"># 排序，保证各平台顺序一致</span><br>        images.sort() <span class="hljs-comment"># 该类别文件夹下的所有图片 按名称字典顺序排列</span><br>        <span class="hljs-comment"># 获取该类别对应的索引</span><br>        image_class = class_indices[cla]<br>        <span class="hljs-comment"># 记录该类别的样本数量</span><br>        every_class_num.append(<span class="hljs-built_in">len</span>(images))<br>        <span class="hljs-comment"># 按比例随机采样验证样本</span><br>        val_path = random.sample(images, k=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(images) * val_rate))<br><br>        <span class="hljs-keyword">for</span> img_path <span class="hljs-keyword">in</span> images:<br>            <span class="hljs-keyword">if</span> img_path <span class="hljs-keyword">in</span> val_path:  <span class="hljs-comment"># 如果该路径在采样的验证集样本中则存入验证集</span><br>                val_images_path.append(img_path)<br>                val_images_label.append(image_class)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 否则存入训练集</span><br>                train_images_path.append(img_path)<br>                train_images_label.append(image_class)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images were found in the dataset.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">sum</span>(every_class_num)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for training.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(train_images_path)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for validation.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(val_images_path)))<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(train_images_path) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;number of training images must greater than 0.&quot;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(val_images_path) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;number of validation images must greater than 0.&quot;</span><br><br>    plot_image = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> plot_image:<br>        <span class="hljs-comment"># 绘制每种类别个数柱状图</span><br>        plt.bar(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data_class)), every_class_num, align=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 将横坐标0,1,2,3,4替换为相应的类别名称</span><br>        plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data_class)), data_class)<br>        <span class="hljs-comment"># 在柱状图上添加数值标签</span><br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(every_class_num):<br>            plt.text(x=i, y=v + <span class="hljs-number">5</span>, s=<span class="hljs-built_in">str</span>(v), ha=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 设置x坐标</span><br>        plt.xlabel(<span class="hljs-string">&#x27;image class&#x27;</span>)<br>        <span class="hljs-comment"># 设置y坐标</span><br>        plt.ylabel(<span class="hljs-string">&#x27;number of images&#x27;</span>)<br>        <span class="hljs-comment"># 设置柱状图的标题</span><br>        plt.title(<span class="hljs-string">&#x27;data class distribution&#x27;</span>)<br>        plt.show()<br><br>    <span class="hljs-keyword">return</span> train_images_path, train_images_label, val_images_path, val_images_label<br><br>data_path = <span class="hljs-string">&quot;D:\data_set&quot;</span> <span class="hljs-comment"># 数据集所在（绝对/相对）路径</span><br>train_images_path, train_images_label, val_images_path, val_images_label = read_split_data(data_path)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2024/03/25/algorithm_know/tree-arr/"/>
    <url>/2024/03/25/algorithm_know/tree-arr/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>首要用途：维护序列的前缀和</p><blockquote><p>对一个序列a，建立一个数组c，其中c[x]保存序列a的区间[x-lowbit(x)+1,x]中所有数的和。</p></blockquote><h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>1.每一个节点x，有c[x]保存着以x为根节点的所有叶节点的和</p><p>2.每个内部节点c[x]的子节点个数等于lowbit（x）的位数</p><p>3.除了树根以外的每个子节点的父节点都是c[x+lowbit(x)];</p><p>4.数的深度为log(N)  &#x2F;&#x2F;N为序列a的长度</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>O(log)的时间复杂度去实现单点修改和区间查询</li><li>数组下标一定要从1开始</li><li>一个数的二进制表示中末尾有几个0就在第几层</li></ol><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><blockquote><p><code>x &amp; (-x)</code> : 假设 x的二进制数表示 的从右向左数的第一个1所在位为k，则lowbit(x) &#x3D; 2^(k-1)</p></blockquote><blockquote><p>tip: 求 n 的二进制表示的第 k 位(从0开始)数字：<code>n &gt;&gt; k &amp; 1</code></p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>实现单点修改</li><li>实现求前缀和</li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造树状数组的方法</span><br><span class="hljs-comment">// 可以假设原序列a为全0，依次通过“单点修改”操作把每个数加进去，最后就可以形成树状数组了</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> t[N],tr[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-comment">//在原数组的第x个数加上v</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-comment">//注意这里的i是从x开始得</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123; <br>        tr[i] += v; <span class="hljs-comment">//在树状数组第i个位置上加上一个值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//返回原数组前x个数的前缀和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x; i&gt;<span class="hljs-number">0</span>; i-=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        sum += tr[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; t[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">add</span>(i,t[i]); <span class="hljs-comment">//在第i个位置上加上原数组t[i] 构造树状数组</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x<span class="hljs-number">-1</span>) &lt;&lt; endl; <span class="hljs-comment">//求的是[a,b]的必区间</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">add</span>(x,y);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树状数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法 树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>algorithm_know</title>
    <link href="/2024/03/25/algorithm_know/algorithm-know/"/>
    <url>/2024/03/25/algorithm_know/algorithm-know/</url>
    
    <content type="html"><![CDATA[<h1 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h1><h2 id="降低时间复杂度的方法（降低运行时间防止超时）"><a href="#降低时间复杂度的方法（降低运行时间防止超时）" class="headerlink" title="降低时间复杂度的方法（降低运行时间防止超时）"></a>降低时间复杂度的方法（降低运行时间防止超时）</h2><h3 id="使用平方根去约束数的循环范围"><a href="#使用平方根去约束数的循环范围" class="headerlink" title="使用平方根去约束数的循环范围"></a>使用平方根去约束数的循环范围</h3><blockquote><p>应用场景：完全数，质数</p></blockquote><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h2 id="得到某一段数组-l-r-的和，常规循环计算的复杂度为-O-n-，使用前缀和就可以直接使用-S-r-S-l-1-，复杂度为O-1"><a href="#得到某一段数组-l-r-的和，常规循环计算的复杂度为-O-n-，使用前缀和就可以直接使用-S-r-S-l-1-，复杂度为O-1" class="headerlink" title="得到某一段数组 [l,r] 的和，常规循环计算的复杂度为 O(n) ，使用前缀和就可以直接使用 S(r) - S(l-1) ，复杂度为O(1)"></a>得到某一段数组 [l,r] 的和，常规循环计算的复杂度为 O(n) ，使用前缀和就可以直接使用 S(r) - S(l-1) ，复杂度为O(1)</h2><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ol><li>O(log)的时间复杂度去实现单点修改和区间查询</li><li>数组下标一定要从1开始</li><li>一个数的二进制表示中末尾有几个0就在第几层</li></ol><h1 id="2-17"><a href="#2-17" class="headerlink" title="2.17"></a>2.17</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote><p>求 n 的二进制表示的第 k 位数字：<code>n &gt;&gt; k &amp; 1</code><br>返回 n 的最后一位1所对应的值：lowbit(n) &#x3D; n &amp; -n &#x3D; n &amp; (n^(n-1))<br>假设一个数的二进制最低位的1在从右往左数的第k位，那么它的lowbit值就是2^(k-1)<br>树状数组C[x] &#x3D; [x-lowbit(n) , x] 原数组中这段区间的和</p></blockquote><h1 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h1><h2 id="n次方幂"><a href="#n次方幂" class="headerlink" title="n次方幂"></a>n次方幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//负数要先转换成正数去计算n次方根</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-literal">true</span>; <br>        n = -n;<br>    &#125;<br>    <span class="hljs-type">double</span> res = <span class="hljs-built_in">pow</span>(n,(<span class="hljs-type">double</span>)<span class="hljs-number">1</span>/<span class="hljs-number">3</span>); <span class="hljs-comment">//使用求n次幂函数，来求n次方根</span><br></code></pre></td></tr></table></figure><h1 id="3-26"><a href="#3-26" class="headerlink" title="3.26"></a>3.26</h1><h1 id="线段数组"><a href="#线段数组" class="headerlink" title="线段数组"></a>线段数组</h1><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>线段树是一棵平衡二叉树。母结点代表整个区间的和，越往下区间越小</li><li>每个节点p的左右子节点的编号分别为 2p 和 2p+1</li><li>节点p存储区间[l,r]的和，设 mid &#x3D; floor(l+r&#x2F;2) ; 左节点存储[l,mid]的和， 左节点存储[mid+1,r]的和</li></ol><h2 id="建立线段数组"><a href="#建立线段数组" class="headerlink" title="建立线段数组"></a>建立线段数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> sum;<br>&#125;tr[N*<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">//u位节点编号，l和r为区间左右端点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> tr[u] = &#123;l,r,w[l]&#125;; <span class="hljs-comment">//抵达叶子节点，为其赋值</span><br>    <span class="hljs-type">int</span> mid = (l+r) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//向下取整</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u, l, mid); <span class="hljs-comment">//向左子树递归</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//向右子树递归</span><br>    tr[u].sum = tr[<span class="hljs-number">2</span>*u].sum + tr[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].sum <span class="hljs-comment">//递归完左右子树后向上回溯</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><blockquote><p>把区间内的叶子节点相加</p></blockquote><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><blockquote></blockquote><h1 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a>第k小数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> t, n, k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br><span class="hljs-keyword">while</span> (t--) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        list[i] = <span class="hljs-built_in">read</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 将第k小的数放在 k-1 位置，左边的数都比它小，右边的数都比它大，但都是无序的</span><br>    <span class="hljs-built_in">nth_element</span>(list, list + k - <span class="hljs-number">1</span>, list + n);<br>    <span class="hljs-comment">// 由于数据量太大，下面两种方法会超时</span><br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-comment">// sort(list, list + n);</span><br>    <span class="hljs-comment">// 将第k小的数放在 k-1 位置，左边的数都比它小，而且是有序的，右边的数都比它大，但右边是无序的</span><br>    <span class="hljs-comment">// partial_sort(list, list + k - 1, list + n);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, list[k - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>首先，binary_search()函数，作用：对一个不降序列进行二分查找，如果所查找的值在序列中出现了，返回true，没有出现，返回false。</p><p>然后，lower_bound()函数，作用：对一个不降序列进行二分查找，返回第一个大于等于所查找的值的元素下标，注意返回的是指针变量！！！</p><p>最后，upper_bound()函数，作用：对一个不降序列进行二分查找，返回第一个大于所查找的值的元素下标，注意返回的是指针变量！！！</p><h1 id="无穷大和无穷小"><a href="#无穷大和无穷小" class="headerlink" title="无穷大和无穷小"></a>无穷大和无穷小</h1><p>指定一个数为无穷大或无穷小：INT_MIX INT_MAX<br>要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))<br>要把一段内存全部置为无穷小，我们只需要memset(a,0xc0,sizeof(a))</p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map[key] &#x3D; value</p><h2 id="查找map中某个key是否存在-具体位置"><a href="#查找map中某个key是否存在-具体位置" class="headerlink" title="查找map中某个key是否存在&#x2F;具体位置"></a>查找map中某个key是否存在&#x2F;具体位置</h2><blockquote><p>mp.count(key)<br>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0<br>mp.find(key)<br>返回键为key的映射的迭代器 $O(logN) $ 注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()</p></blockquote><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set里面的元素<strong>不重复</strong> 且 <strong>有序</strong></p><h1 id="如何将字符串转换成数字"><a href="#如何将字符串转换成数字" class="headerlink" title="如何将字符串转换成数字"></a>如何将字符串转换成数字</h1><p>String str&#x3D;“2019”;<br>char s[]&#x3D;str.toCharArray();<br>int x&#x3D;0;<br>for(int i&#x3D;0;i&lt;s.length;i++){<br>x&#x3D;x*10+str[i]-‘0’;<br>}</p><h1 id="结构体数组排序"><a href="#结构体数组排序" class="headerlink" title="结构体数组排序"></a>结构体数组排序</h1><p><strong>当数组是从1开始赋值时，sort函数也要加1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin &gt;&gt; a[i].t &gt;&gt; a[i].d &gt;&gt; a[i].l;<br>&#125;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp); <span class="hljs-comment">//由于数组是从1开始赋值的，因此排序函数也要加1 </span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">11</span>];<br>    <span class="hljs-type">int</span> solve;<br>    <span class="hljs-type">int</span> time;<br>&#125;p[<span class="hljs-number">10000</span>];<br><br><span class="hljs-comment">//按照题数，再罚时间，再名字（名字按字典序排列）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; a, <span class="hljs-type">const</span> Student&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.solve != b.solve)<br>     &#123; <br>        <span class="hljs-keyword">if</span> (a.solve &gt; b.solve)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.time != b.time)<br>           <span class="hljs-keyword">return</span> a.time &lt; b.time;<br>    <span class="hljs-keyword">else</span><br>          <span class="hljs-built_in">return</span> (<span class="hljs-built_in">strcmp</span>(a.name, b.name) &lt; <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>      cin&gt;&gt;p[i].name&gt;&gt;p[i].solve&gt;&gt;p[i].time;<br>    <span class="hljs-built_in">sort</span>(p,p+n,cmp);<span class="hljs-comment">//在主函数中调用，结构体排序；</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>      cout&lt;&lt;p[i].name;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法小知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第三章</title>
    <link href="/2024/03/25/cs_net/cs-net-3/"/>
    <url>/2024/03/25/cs_net/cs-net-3/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第三章"><a href="#计算机网络复习第三章" class="headerlink" title="计算机网络复习第三章"></a>计算机网络复习第三章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>数据链路层的功能是：实现在两个通信实体之间传送数据（以 帧为单位），并通过差错控制方法，使有差错的物理线路变成无差错数据链路。数据链路层使用的信道有2种：广播信道和点对点信道。 数据链路层需要解决的三个基本问题是：封装成帧. 透明传输（如在数据中出现控制字符时加入转义字符）和差错检测（如CRC技术）。</p></li><li><p>10Mbps以太网是基带编码，使用的曼彻斯特编码，是一种自同步的数字信号编码方式，编码效率是50%；通常采用RJ45（非屏蔽双绞线）。</p></li><li><p>虚拟局域网（VLAN）技术是建立在网络交换机之上的，以硬件方式实现逻辑工作组的划分与管理，通常可以根据端口. MAC地址. IP地址等划分VLAN。同一层交换机上不同VLAN之间不能直接通信（需要使用路由器才能通信）</p></li><li><p>网络互联时使用中继器或集线器完成物理层功能，使用网桥或二层交换机完成数据链路层的功能，使用路由器或三层交换机完成网络层的功能。</p></li><li><p>常用的IEEE802协议有802.2—LLC   802.3—10Mbps CSMA&#x2F;CD以太网  802.4—令牌总线 802.5—令牌环，这些协议都属于数据链路层。以太网使用10BASE-T规定从集线器到网卡的最大距离是100米。</p></li><li><p>总线型网络和使用HUB的星型网络，任意时刻只能有一台电脑发送信息；使用SWITCH的星型网络，任意时刻可以有多台电脑发送信息。</p></li><li><p>CSMA&#x2F;CD的中文是多路载波侦听&#x2F;冲突检测，掌握其工作原理并重点掌握：用于在10Mbps以标准太网的信道访问控制，要求数据帧的发送时间是传播时间的2倍，其帧长为64–1518B，其碰撞窗口为51.2us ，总线型以太网可以检测冲突却不能避免冲突，交换型以太网可以避免冲突。发生第K次冲突后，需要等待r*51.2us之后再侦听以决定是否发送，其中r&#x3D;Min（10，x）(x取(0,1,2,3,…2k-1)中任意随机值),最多传送16次。 </p></li><li><p>通常数据在各个层次的名称不同，一般物理层称为比特. 数据链路层称为帧. 网络层称为分组. 传输层称为报文. 余下各层统称为文本。OSI&#x2F;RM协议的层次名称. 上下层次关系，TCP&#x2F;IP协议的层次名称. 上下层关系，以及OSI&#x2F;RM各层次与TCP&#x2F;IP各层次对应关系。VLAN(虚拟局域网)使用的核心设备是二层交换机。</p></li><li><p>教材图3-10的PPP格式（P75）。教材图3-22的以太网格式（P92）</p></li><li><p>CRC计算（教材 图3-8）（P71）</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>数据链路层需要解决的三个基本问题是：封装成帧. 透明传输和差错检测，其中在数据中出现控制字符时加入转义字符属于(   )。<br>2. 完善以太网的MAC帧格式 。</p><ol start="3"><li>以太网中采用的CSMA&#x2F;CD协议是一种能避免冲突的协议。</li><li>在一个二层交换机内划分为3个虚拟网络后，虚拟网络之间不可在本交换机内通信。</li><li>在802.3局域网中，当使用了交换技术后，可避免冲突产生。</li><li>10M以太网的碰撞窗口为51.2us  </li><li>10M以太网的标准是IEEE802.5 。</li><li>10BASE-T标准中使用的电缆为双绞线</li><li>802.3协议中源地址为（）。<br>A. 1字节  B. 4字节    C. 6字节   D. 8字节</li><li>符合OSI参考模型第二层功能的设备，均有一个MAC地址，以太网MAC地址是（）位二进制。<br>A.    64     B. 48     C. 32    D. 8<br>11.交换机是对应OSI参考模型（）的设备。<br>A. 物理层    B. 传输层    C. 网络层  D. 数据链路层<br>12目前局域网中的高端交换机使用双绞线时能适应10M&#x2F;S，100M&#x2F;S，1000M&#x2F;S的速率，依靠（  ）技术。<br>A. 线路交换    B. 令牌控制<br>C. 自动侦测    D. VLAN技术</li><li>以太网交换机不具有的功能是（）。<br>A. 地址学习    B. 数据帧转发<br>C. 路由选择    D. 回路避免</li><li>以下MAC地址哪个是正确的（）<br>A. 004         B.  00DA45<br>C. 210.47.2.34   D. 00AABB0034CC</li><li>虚拟局域网中的核心设备是（）<br>A. 高端交换机   B. 路由器<br>C. 集线器       D. 中继器</li><li>虚拟局域网的技术基础是（）。<br>A. 交换    B. 路由    C.  带宽分配    D. 冲突检测</li><li>在一个数字化的语音系统中，采用256个量化级时，编码时采用（）位。<br>A. 8           B. 7          C. 6        D. 10</li><li>具有冲突检测载波监听多路访问CSMA&#x2F;CD技术，不适用于（）。<br>A. 总线型网络    B. 星型网络<br>C. 树型网络      D. 环型网络</li><li>IEEE802.3标准中，MAC帧的帖起始定界符是（）。<br>A.  01111111（左低右高）  B. 11101011（左低右高）<br>C.  01111110（左低右高）  D. 10101011（左低右高）</li><li>CSMA&#x2F;CD协议只适用于（）。<br>A. 局域网  B. 广域网    C. 城域网    D. 以上全部</li><li>IEEE802.3中10BASE-T规定从集线器到网卡的最大距离是（）。<br>A. 50米     B. 100米      C. 200米     D. 500米</li><li>数据链路层需要解决的三个基本问题是：封装成帧. 透明传输和差错检测，其中CRC技术属于（  ）。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>透明传输</li><li>类型</li><li>T</li><li>T</li><li>T</li><li>T</li><li>F</li><li>T</li><li>C</li><li>B</li><li>D</li><li>C</li><li>C</li><li>D</li><li>A</li><li>A</li><li>A</li><li>C</li><li>D</li><li>A</li><li>B</li><li>差错检测</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第二章</title>
    <link href="/2024/03/25/cs_net/cs-net-2/"/>
    <url>/2024/03/25/cs_net/cs-net-2/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第二章"><a href="#计算机网络复习第二章" class="headerlink" title="计算机网络复习第二章"></a>计算机网络复习第二章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>物理层确定与传输媒体的接口有关的特性是机械特性.电气特性.功能特性和过程特性。</p></li><li><p>根据信号中代表消息的参数的取值方式不同，信号可以分为2大类，模拟信号和数字信号。从通信的双方信息的交互方式来区分，可以有三种基本方式：单工通信（只能有一个方向的通信而没有反方向的交互）.半双工通信（通信的双方都可以发送信息，但不能双方同时发送）和全双工通信（通信的双方都可以发送信息，而且双方能同时发送）。</p></li><li><p>复用方式有：频分复用（FDM）.时分复用(TDM).码分复用(CDM)和波分复用(WDM)多种，在一根光纤上复用多路光载波信号称为波分复用，利用信号频率的不同来实现电路复用的方法是频分复用，利用信号的不同时间发送来实现电路复用的方法是时分复用。</p></li><li><p>10Mbps以太网是基带编码，使用的曼彻斯特编码，是一种自同步的数字信号编码方式，编码效率是50%；通常采用RJ45（非屏蔽双绞线）。</p></li><li><p>在脉码调制PCM过程中要经过采样.量化.编码三个过程。T1和E1技术都是基本的将模拟信号转为数字信号的方法，目前我国使用的是欧洲的E1标准，E1速率是2.048Mbps，T1的速率是1.544Mbps，这两种方法都使用时分复用。</p></li><li><p>传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。一个数据通信系统包括三大部分：源系统（或发送端.发送方）.传输系统（或传输网络）和目的系统（或接收端.接收方）。</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>通常一个通信系统可以划分为三大部分，即源系统（或发送端.发送方）.(   )和目的系统（或接收方.接收端）。</p></li><li><p>从通信的双方信息的交互方式来区分，可以有三种基本方式：单工通信.半双工通信和(   )。</p></li><li><p>传输媒体是数据传输系统中在发送器和接收器之间的物理通道，可以分为导向传输媒体和非导向传输媒体。无线电波属于(   )。</p></li><li><p>多个通信设备共享一个信道进行通信称为信道复用，不同的用户占用不同的带宽资源称为(   )。</p></li><li><p>在PCM调制过程中要经过量化.采样.编码三个过程。</p></li><li><p>在数据传输过程中，差错主要是由通信过程中的噪声引起的。</p></li><li><p>ADSL技术中，上行通道和下行通道的传输速率不对称。</p></li><li><p>在电路交换.分组交换与报文交换方式中，都要经过线路建立.数据传输.线路释放这3个过程。</p></li><li><p>两台计算机通过电话网通信时必须使用的设备是（）。<br>A. 调制解调器  B.网线.C.中继器    D.集线器</p></li><li><p>常用的传输介质中，带宽最大.信号传输衰减最小.抗干扰能力最强的是（）。<br>A.光纤    B.双绞线     C.同轴电缆     D.无线信道</p></li><li><p>利用信号频率的不同来实现电路复用的方法是（）。<br>A.频分多路复用   B.时分多路复用<br>C.码分多路复用   D.以上都不对</p></li><li><p>在物理层中，指明在接口电缆的各条线上出现的电压范围，属于（）。<br>A.机械特性   B.电气特性  C.功能特性   D.过程特性</p></li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>传输系统</li><li>全双工通信</li><li>非导向传输媒体</li><li>频分复用</li><li>F</li><li>T</li><li>T</li><li>F</li><li>A</li><li>A</li><li>A</li><li>B</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第一章</title>
    <link href="/2024/03/25/cs_net/cs-net-1/"/>
    <url>/2024/03/25/cs_net/cs-net-1/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第一章"><a href="#计算机网络复习第一章" class="headerlink" title="计算机网络复习第一章"></a>计算机网络复习第一章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>为网络中的数据交换而建立的规则.标准或约定称为网络协议，网络协议由三部分组成：语法（数据与控制信息的结构或格式）.语义（需要发出何种控制信息，完成何种动作以及做出何种响应）.同步（事件实现顺序的详细说明）。</p></li><li><p>Arpanet是Internet的前身，对因特网发展起到很大作用。Internet是通过路由器将多个LAN或WAN相连接形成。</p></li><li><p>计算机网络向用户提供的最重要的功能有2个：连通性和共享</p></li><li><p>所有因特网标准都是以RFC形式在因特网上发表。RFC的意思是“请求评论”</p></li><li><p>因特网从其工作方式上看，可以划分为2大块：边缘部分（由连接在因特网上的主机组成，这部分是用户直接使用的，用来进行通信和资源共享）和核心部分（由大量网络和连接这些网络的路由器组成，这部分为边缘部分提供服务，提供连通性和交换）</p></li><li><p>三网合一是指电信语音 .有线电视网和计算机网络的结合。</p></li><li><p>常用的交换方式有电路.报文和分组。在电路交换方式中要经过线路建立.数据传输.线路释放三个过程。而分组交换和报文交换不需要，因为每个分组都需要被独立进行确定“路由”处理，所以可能存在“后发先至”的现象。计算机网络通常采用分组交换方式。</p></li><li><p>网络通信常用的3种交换方式是电路交换（整个报文的比特流连续地从源点直达终点，好像在一个管道中传送）.报文交换（整个报文先送到相邻节点，全部存储下来后查找转发表，转发到下一节点）和分组交换（单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一节点）。计算机网络采用的交换方式属于分组交换。</p></li><li><p>时延是计算机网络的性能指标之一，指的是数据从网络的一端传输到另一端所需的时间，通常包括发送时延（主机或路由器发送数据帧所需要的时间，也称为传输时延。发送时延&#x3D;数据帧长度&#x2F;发送速率）.传播时延（电磁波在信道中传播一定的距离所需要的时间，在自由空间的传播速率约为3.0<em>105km&#x2F;s，在铜线电缆中的传播速率约为2.3</em>105km&#x2F;s, 在光纤中的传播速率约为2.0*105km&#x2F;s。传播时延&#x3D;信道长度&#x2F;电磁波在信道上传输速率）.处理时延（主机或路由器在收到分组是需要花费一定的时间进行处理）和排队时延（分组在进入路由器后在输入队列中等待处理）。</p></li><li><p>OSI的体系结构由7层组成，从上到下分别是：应用层.表示层.会话层.运输曾.网络层.数据链路层.物理层。TCP&#x2F;IP协议由4层组成，从上向下分别为应用层.运输层.网际层（IP）和网络接口层。掌握OSI&#x2F;RM协议的各层次名称.顺序及与TCP&#x2F;IP协议的对应关系。教材图1-18</p></li><li><p>按距离进行分类，可将网络分为广域网.城域网和局域网，掌握其距离范围</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>假定有一个10MB的数据块，在带宽为1Mb&#x2F;s的信道上连续发送，其发送时延是_____s。</li><li>因特网从其工作方式上看，可以划分为2大块：用来进行通信和资源共享属于边缘部分。提供连通性和交换的属于(   )。</li><li>网络通信有3种交换方式。其中【单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一节点】属于(   )（请说明名称，不能说第一种、第二种或第三种）。</li><li>时延是计算机网络的性能指标之一，指的是数据从网络的一端传输到另一端所需的时间。其中的传播时延是指电磁波在信道中传播一定的距离所需要的时间，通常在铜线电缆中其传播速率约为(   )km&#x2F;s。</li><li>所有因特网标准都是以(   )形式在因特网上发表。其意思是“请求评论”。</li><li>网络协议由三部分组成：语法、语义和同步，其中需要发出何种控制信息，完成何种动作以及做出何种响应属于(   )。</li><li>OSI的体系结构由7层组成，从下向上，第六层是(   )。</li><li>TCP&#x2F;IP协议由4层组成，从上向下，UDP是属于(   )。</li><li>电磁波在光纤中传播的速率大约为2.0*105km&#x2F;s,长度为1000km的光纤传播时延是（    ）s。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>83.89</li><li>核心部分</li><li>分组交换</li><li>2.3*105km&#x2F;s</li><li>RFC</li><li>语义</li><li>表示层</li><li>运输层</li><li>0.005</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first-test-blog</title>
    <link href="/2024/03/25/first-test-blog/"/>
    <url>/2024/03/25/first-test-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一个测试博客"><a href="#这是一个测试博客" class="headerlink" title="这是一个测试博客"></a>这是一个测试博客</h1><h1 id="浅浅许个愿：保研上岸"><a href="#浅浅许个愿：保研上岸" class="headerlink" title="浅浅许个愿：保研上岸"></a>浅浅许个愿：保研上岸</h1>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>保研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>保研</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
