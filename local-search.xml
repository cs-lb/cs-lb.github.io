<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mac电脑</title>
    <link href="/2024/10/09/mac%E7%94%B5%E8%84%91/"/>
    <url>/2024/10/09/mac%E7%94%B5%E8%84%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>保研经验贴</title>
    <link href="/2024/10/01/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
    <url>/2024/10/01/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="2024年（2025届）四非非rk1保研上岸中科大经验贴"><a href="#2024年（2025届）四非非rk1保研上岸中科大经验贴" class="headerlink" title="2024年（2025届）四非非rk1保研上岸中科大经验贴"></a>2024年（2025届）四非非rk1保研上岸中科大经验贴</h1><p><strong>现在是10.1国庆节，祝大家国庆节快乐，准备写个经验贴为自己曲折的保研之路划下一个圆满句号，也希望我下文的经验贴能帮助到大家。</strong></p><h2 id="个人背景"><a href="#个人背景" class="headerlink" title="个人背景"></a>个人背景</h2><ul><li>学校 ： 辽宁省四非</li><li>专业 ： 计算机科学与技术</li><li>排名 ： 2&#x2F;90</li><li>竞赛 ： 计设、蓝桥杯国三 + 某干省奖</li><li>科研 ： CCF-C 一作</li><li>offer ：计算所、浙大、中科大、成电、厦大、华师、中南、北邮、上科、东师</li><li>最终去向 ：<strong>中国科学技术大学</strong></li></ul><h2 id="夏令营记录"><a href="#夏令营记录" class="headerlink" title="夏令营记录"></a>夏令营记录</h2><p><strong>夏令营的门槛很高，对我而言主要是想刷面试经历，因此采用了海投策略，从清北到四非都有投递，接下来将按照时间线来对夏令营进行梳理</strong></p><table><thead><tr><th>学校</th><th>入营情况</th><th>参营情况</th><th>优营情况</th><th>备注</th></tr></thead><tbody><tr><td>清华大学生医工</td><td>&#10004;</td><td>&#10004;</td><td></td><td>线上宣讲营无考核，不评选优营，提供一个跟老师沟通的平台</td></tr><tr><td>同济大学卓工</td><td>&#10004;</td><td>&#10004;</td><td>&#10006;</td><td>参加的第一营，但表现不佳很遗憾没拿到优营</td></tr><tr><td>中国科学技术大学先研院</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>豪华的开营仪式、五星级酒店，体验感最好的一个营！！！也是最终去向</td></tr><tr><td>复旦大学工研院</td><td>&#10006;</td><td></td><td></td><td>联系了老师但是是强com、门槛比较高没进</td></tr><tr><td>南京大学软件学院</td><td>&#10006;</td><td></td><td></td><td>联系了老师但是推荐没有用是强com、据了解四非可以靠区域金直通</td></tr><tr><td>浙江大学软件学院</td><td>&#10004;</td><td>&#10004;</td><td>&#10006;</td><td>浙软是线上营，我参加的是 AI 营，项目没做好就没有优营</td></tr><tr><td>上海科技大学</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>参加的专硕项目，宣讲+考核，优营率应该挺高（豪华酒店、茶歇好吃）</td></tr><tr><td>电子科技大学信软学院</td><td>&#10004;</td><td>&#10004;</td><td>&#10006;</td><td>线上宣讲营无考核，但是根据跟老师的沟通情况发了部分优营，忙着期末就挂了下会议，因此没优</td></tr><tr><td>华东师范大学计算机学院</td><td>&#10006;</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="1、同济大学"><a href="#1、同济大学" class="headerlink" title="1、同济大学"></a>1、同济大学</h3><p>同济我参加的是卓工（工程硕博）项目，当时觉得这个门槛比较低就报名了，报的是电院的电子信息专业。<br>同济是我参加的第一个夏令营</p><h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h3><h2 id="预推免记录"><a href="#预推免记录" class="headerlink" title="预推免记录"></a>预推免记录</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习常见问题汇总</title>
    <link href="/2024/08/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/08/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习常见问题汇总"><a href="#深度学习常见问题汇总" class="headerlink" title="深度学习常见问题汇总"></a>深度学习常见问题汇总</h1><h2 id="深度学习与机器学习有什么区别"><a href="#深度学习与机器学习有什么区别" class="headerlink" title="深度学习与机器学习有什么区别"></a>深度学习与机器学习有什么区别</h2><p>人工智能包含机器学习；机器学习包含深度学习</p><ol><li><p>算法复杂度</p></li><li><p>可解释性；</p></li><li><p>数据需求</p></li><li><p>计算资源</p></li><li><p><strong>特征的提取</strong></p></li><li><p><strong>决策边界</strong>（线性&#x2F;非线性）</p></li></ol><h2 id="ANN（人工神经网络）的基本结构"><a href="#ANN（人工神经网络）的基本结构" class="headerlink" title="ANN（人工神经网络）的基本结构"></a>ANN（人工神经网络）的基本结构</h2><p>单个感知机（或神经元）可以想象为逻辑回归。ANN可以视为一组多层感知机&#x2F;神经元</p><p>ANN被称为前馈神经网络，因为输入只在正向处理</p><p>ANN结构由输入层，隐藏层，输出层构成</p><p>在分类任务中，我们通常<strong>在感知器的输出层中使用 Softmax 函数作为激活函数</strong>，以保证输出的是概率并且相加等于 1</p><h2 id="单层感知机和MLP"><a href="#单层感知机和MLP" class="headerlink" title="单层感知机和MLP"></a>单层感知机和MLP</h2><p>单层感知器——这是最简单的前馈神经网络，不包含任何隐藏层</p><p>多层感知器——多层感知器有至少一个隐藏层</p><p>单层感知器只能学习线性函数，而多层感知器也可以学习非线性函数</p><h2 id="激活函数的作用，常用的激活函数有哪些"><a href="#激活函数的作用，常用的激活函数有哪些" class="headerlink" title="激活函数的作用，常用的激活函数有哪些"></a>激活函数的作用，常用的激活函数有哪些</h2><p>为神经网络增强非线性变换，提高网络的特征提取能力和表达能力；</p><p>sigmoid；tanh；ReLU；softmax；</p><p>ReLU ：可以有效解决梯度消失和梯度爆炸的问题（导数为 1）；正则化作用（稀疏激活）；</p><p>ReLU变体：防止部分神经元一直无法激活（“死亡”ReLUs问题）</p><h2 id="前向传播和反向传播"><a href="#前向传播和反向传播" class="headerlink" title="前向传播和反向传播"></a>前向传播和反向传播</h2><p>前向传播目的：得到损失值</p><p><img src="/../../img/%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%BF%87%E7%A8%8B.png"></p><p>反向传播目的：为了让损失函数的值最小（利用梯度进行反向更新参数）</p><p>前向传播从输入到输出，逐层计算，目的是得到损失值；<br>反向传播则通过梯度下降，从输出往回层层求导，更新权重，以优化模型。</p><h2 id="解释梯度下降算法在深度学习中的应用"><a href="#解释梯度下降算法在深度学习中的应用" class="headerlink" title="解释梯度下降算法在深度学习中的应用"></a>解释梯度下降算法在深度学习中的应用</h2><p>梯度下降（Gradient Descent）是一种优化算法，用于寻找最小化损失函数（或成本函数）的参数值</p><p>损失函数衡量了模型预测值与真实值之间的差异，而梯度下降则是用于更新模型的参数（例如权重和偏置），以最小化这个差异。</p><p><strong>梯度下降算法的步骤：</strong></p><ol><li><p>初始化参数：随机初始化模型的参数（例如权重和偏置）。</p></li><li><p>计算梯度：使用当前参数计算损失函数关于这些参数的梯度。梯度是一个向量，指示了损失函数在每个参数上的局部变化率。</p></li><li><p>更新参数：将每个参数沿着梯度的反方向移动一小步，步长由学习率控制。学习率是一个超参数，决定了参数更新的幅度。</p></li><li><p>重复迭代：重复步骤2和3，直到满足某个停止条件（例如达到最大迭代次数、损失函数值足够小或梯度足够小）。</p></li></ol><h2 id="BGD（批量梯度下降）、SGD（随机梯度下降）、MBGD（小批量梯度下降）-有何不同"><a href="#BGD（批量梯度下降）、SGD（随机梯度下降）、MBGD（小批量梯度下降）-有何不同" class="headerlink" title="BGD（批量梯度下降）、SGD（随机梯度下降）、MBGD（小批量梯度下降） 有何不同"></a>BGD（批量梯度下降）、SGD（随机梯度下降）、MBGD（小批量梯度下降） 有何不同</h2><p>下面是一个表格，总结了批量梯度下降（BGD）、随机梯度下降（SGD）和小批量梯度下降（MBGD）的主要特点：</p><table><thead><tr><th>特性</th><th>批量梯度下降 (BGD)</th><th>随机梯度下降 (SGD)</th><th>小批量梯度下降 (MBGD)</th></tr></thead><tbody><tr><td><strong>梯度计算</strong></td><td>使用全部训练数据</td><td>使用单个样本</td><td>使用一小批样本</td></tr><tr><td><strong>内存需求</strong></td><td>高</td><td>低</td><td>中等</td></tr><tr><td><strong>计算成本</strong></td><td>高</td><td>低</td><td>中等</td></tr><tr><td><strong>收敛速度</strong></td><td>慢</td><td>快（震荡可能较大）</td><td>较快（通常比BGD快）</td></tr><tr><td><strong>梯度稳定性</strong></td><td>最稳定</td><td>最不稳定</td><td>较稳定</td></tr><tr><td><strong>适用场景</strong></td><td>小数据集</td><td>大数据集、在线学习</td><td>大数据集（常用）</td></tr><tr><td><strong>收敛到全局最小值</strong></td><td>可能性较高</td><td>可能性较低</td><td>可能性较高</td></tr><tr><td><strong>调整参数</strong></td><td>较少</td><td>需要调整学习率等</td><td>需要调整小批量大小</td></tr><tr><td><strong>特点</strong></td><td>梯度估计最准确</td><td>训练速度快，但可能震荡</td><td>计算效率和稳定性平衡</td></tr></tbody></table><h2 id="描述CNN的架构和在图像处理中的应用"><a href="#描述CNN的架构和在图像处理中的应用" class="headerlink" title="描述CNN的架构和在图像处理中的应用"></a>描述CNN的架构和在图像处理中的应用</h2><h2 id="池化层的作用是什么"><a href="#池化层的作用是什么" class="headerlink" title="池化层的作用是什么"></a>池化层的作用是什么</h2><h2 id="什么是RNN？它如何处理序列数据"><a href="#什么是RNN？它如何处理序列数据" class="headerlink" title="什么是RNN？它如何处理序列数据"></a>什么是RNN？它如何处理序列数据</h2><h2 id="LSTM（长短期记忆网络）-与-RNN-的主要区别"><a href="#LSTM（长短期记忆网络）-与-RNN-的主要区别" class="headerlink" title="LSTM（长短期记忆网络） 与 RNN 的主要区别"></a>LSTM（长短期记忆网络） 与 RNN 的主要区别</h2><h2 id="解释过拟合和欠拟合，如何防止过拟合"><a href="#解释过拟合和欠拟合，如何防止过拟合" class="headerlink" title="解释过拟合和欠拟合，如何防止过拟合"></a>解释过拟合和欠拟合，如何防止过拟合</h2><h2 id="正则化在深度学习中的作用是什么？常见的正则化技术有哪些？"><a href="#正则化在深度学习中的作用是什么？常见的正则化技术有哪些？" class="headerlink" title="正则化在深度学习中的作用是什么？常见的正则化技术有哪些？"></a>正则化在深度学习中的作用是什么？常见的正则化技术有哪些？</h2><h2 id="什么是数据增强？在深度学习中它为什么重要？"><a href="#什么是数据增强？在深度学习中它为什么重要？" class="headerlink" title="什么是数据增强？在深度学习中它为什么重要？"></a>什么是数据增强？在深度学习中它为什么重要？</h2><h2 id="Batch-Normalization（批归一化）的目的是什么"><a href="#Batch-Normalization（批归一化）的目的是什么" class="headerlink" title="Batch Normalization（批归一化）的目的是什么"></a>Batch Normalization（批归一化）的目的是什么</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java语法基础</title>
    <link href="/2024/08/15/Java/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/08/15/Java/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语法基础"><a href="#Java语法基础" class="headerlink" title="Java语法基础"></a>Java语法基础</h1><p><a href="https://www.cyc2018.xyz/">CS-Notes 面试笔记</a></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>数据类型介绍</strong><br><img src="/../../img/dataclass.png"></p><p><strong>数据类型转换</strong></p><p>小-&gt;大 ：自动转换<br>大-&gt;小 : 强制转换： (int)</p><ul><li>基本数据类型 ——&gt; String<ul><li><code>val + &quot;&quot;</code></li></ul></li><li>String ——&gt; 基本数据类型<ul><li>parsexx方法：如p<code>arseInt/Float</code></li></ul></li></ul><h2 id="参数重载-可变参数"><a href="#参数重载-可变参数" class="headerlink" title="参数重载&#x2F;可变参数"></a>参数重载&#x2F;可变参数</h2><p><strong>可变参数</strong><br>将传递的参数变成一个数组</p><p><code>void f(int...nums)</code></p><p>一个形参列表只能有一个可变参数<br>可变参数可以和普通参数在一起，但可变参数必须要放在最后</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/08/13/algorithm_know/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/08/13/algorithm_know/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> f[N],w[N]; <span class="hljs-comment">//w[i] 记录每个以节点i为根的集合中点的数量</span><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        f[i] = i;<br>        w[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == f[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> f[u] = <span class="hljs-built_in">find</span>(f[u]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    f[u] = v;<br>    w[v] += w[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求图是否连通"><a href="#求图是否连通" class="headerlink" title="求图是否连通"></a>求图是否连通</h2><p><a href="https://www.acwing.com/problem/content/3590/">连通图</a></p><p>由于如果都连通时，所有点的跟都是一样的，因此以该根的图的节点个数会等于总节点个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> fa = <span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(w[fa] == n) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//所有顶点都连通，即要求n个点都连通</span><br><span class="hljs-keyword">else</span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求连通块个数"><a href="#求连通块个数" class="headerlink" title="求连通块个数"></a>求连通块个数</h2><p><a href="https://www.acwing.com/problem/content/description/3722/">畅通工程</a></p><p>刚开始时所有节点的根都为本身，连通块个数为节点个数。</p><p>最后，计算有多少个节点的根不再为本身了，改变了一个连通块个数就减一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> cnt = n; <span class="hljs-comment">//连通块个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(f[i] != i)&#123;<br>        cnt --;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法适用条件</title>
    <link href="/2024/08/02/algorithm_know/%E7%AE%97%E6%B3%95%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6/"/>
    <url>/2024/08/02/algorithm_know/%E7%AE%97%E6%B3%95%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="算法适用条件"><a href="#算法适用条件" class="headerlink" title="算法适用条件"></a>算法适用条件</h1><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><ol><li>具有单调性</li><li>丛某个范围内查找某个数</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高等数学复习</title>
    <link href="/2024/07/20/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/07/20/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="高等数学复习"><a href="#高等数学复习" class="headerlink" title="高等数学复习"></a>高等数学复习</h1><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>在函数中，当自变量趋近于某个特定值时，函数的取值可能会逼近某个确定的数值，这个确定的数值就被称为函数的极限。</p><p>定义：给定一个函数f(x)，当自变量x趋近于某个特定值x0时，如果函数的取值f(x)随着x的趋近逼近一个确定的数A，那么我们称A是函数f(x)在x趋近于x0时的极限。</p><h2 id="三个中值定理"><a href="#三个中值定理" class="headerlink" title="三个中值定理"></a>三个中值定理</h2><p><strong>前提条件</strong>：函数( f(x) )在闭区间 $[ a, b ]$ 上连续，在开区间 $(a, b)$ 内可导。</p><ol><li><p><strong>罗尔中值定理</strong>（Rolle’s Theorem）：</p><ul><li><strong>结论</strong>：<strong>如果( f(a) &#x3D; f(b) )，</strong> 那么至少存在一点( c )在开区间(a, b)内，使得( f’(c) &#x3D; 0 )。</li><li><strong>几何意义</strong>：如果一个函数在区间的两端取相同的值，那么至少在区间内部有一点的导数为零，即函数在该点的切线是水平的。</li></ul></li><li><p><strong>拉格朗日中值定理</strong>（Lagrange’s Mean Value Theorem）：</p><ul><li><strong>前提条件</strong>：与罗尔中值定理相同。</li><li><strong>结论</strong>：存在至少一点( c )在开区间(a, b)内，使得<br>[<br>f’(c) &#x3D; \frac{f(b) - f(a)}{b - a}<br>]</li><li><strong>几何意义</strong>：函数在区间内的某点的导数等于连接函数在区间两端点的直线的斜率。</li></ul></li><li><p><strong>柯西中值定理</strong>（Cauchy’s Mean Value Theorem）：</p><ul><li><strong>前提条件</strong>：函数( f(x) )在闭区间 $[ a, b ]$ 上连续，在开区间 $(a, b)$ 内可导，并且( g’(x) )在开区间(a, b)内不为零。</li><li><strong>结论</strong>：存在至少一点( c )在开区间(a, b)内，使得<br>[<br>\frac{f’(c)}{g’(c)} &#x3D; \frac{f(b) - f(a)}{g(b) - g(a)}<br>]</li><li><strong>几何意义</strong>：如果两个函数在区间的两端取值不同，那么它们在区间内的某点的导数之比等于它们在区间两端点的函数值之比。</li></ul></li></ol><h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h2><p>泰勒公式的初衷是用多项式函数来近似表示函数在某点周围的情况。</p><p>泰勒公式可用于将一个函数在某个点附近展开成无穷级数的形式。</p><p>泰勒公式的一般形式如下：</p><p>f(x) &#x3D; f(a) + f’(a)(x - a)&#x2F;1! + f’’(a)(x - a)²&#x2F;2! + f’’’(a)(x - a)³&#x2F;3! + …</p><p>f(x) 是要近似的函数，a 是展开点。</p><h2 id="什么是方向导数和梯度"><a href="#什么是方向导数和梯度" class="headerlink" title="什么是方向导数和梯度"></a>什么是方向导数和梯度</h2><p>方向导数和梯度是多元微积分中的两个重要概念，它们描述了函数在多元空间中的变化情况。</p><ol><li><p><strong>方向导数</strong>（Directional Derivative）：</p><ul><li><strong>定义</strong>：方向导数是函数在某一点沿特定方向的变化率。如果( f )是在( \mathbb{R}^n )上的函数，( P )是( \mathbb{R}^n )中的一点，( \vec{v} )是单位向量，那么在点( P )沿向量( \vec{v} )的方向导数定义为：<br>[<br>D_{\vec{v}}f(P) &#x3D; \lim_{t \to 0} \frac{f(P + t\vec{v}) - f(P)}{t}<br>]</li><li><strong>几何意义</strong>：方向导数可以想象为在点( P )处，函数值沿着向量( \vec{v} )方向的瞬时变化率。</li></ul></li><li><p><strong>梯度</strong>（Gradient）：</p><ul><li><strong>定义</strong>：梯度是一个向量场，它由函数在多元空间中的偏导数构成。如果( f )是在( \mathbb{R}^n )上的可微函数，那么它的梯度( \nabla f )定义为：<br>[<br>\nabla f &#x3D; \left( \frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2}, \ldots, \frac{\partial f}{\partial x_n} \right)<br>]</li><li><strong>几何意义</strong>：梯度向量的方向是函数增长最快的方向，其大小是函数在该方向上的最大变化率。梯度向量的每个分量是函数在相应坐标轴上的偏导数。</li></ul></li></ol><p>方向导数和梯度在物理学、工程学和经济学等领域有广泛的应用，例如在最优化问题中，梯度向量可以指导我们找到函数的局部极值点。</p><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>傅里叶变换：可以处理非周期性信号（一个信号可以看成一个周期性无穷大T-&gt;∞的信号）。傅里叶变换将一个信号从时域转换到频域，得到该信号的频谱。</p><p>通过傅里叶变换，我们可以对信号进行滤波、降噪、压缩、频谱估计等操作。这些技术在音频处理、图像处理、视频压缩、通信系统等领域都有广泛应用。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/06/27/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/06/27/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集可以解决什么问题：<br><strong>两个节点是否在一个集合，也可以将两个节点添加到一个集合中</strong></p><p>并查集的核心思路在于，不管你是x-&gt;y，还是y-&gt;x，不管边什么方向。只要找到了他们的最根节点，并且连接起来。就相当于把两个不相连的图连接起来了，并且最妙的是这两个图连接起来后，根节点自动切换成同一个。这个数据结构真的是秒啊</p><h2 id="使用的tips"><a href="#使用的tips" class="headerlink" title="使用的tips"></a>使用的tips</h2><p><strong>注意一定要先初始化init()</strong></p><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>并查集初始化，所有节点的根指向本身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  father[i] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>tips: <code>join(u,v)</code> 不是将u和v相连，<strong>而是将它们的根相连</strong></p><p>即 <code>join(int u, int v)</code> 函数里 要分别对 u 和 v 寻根之后再进行关联</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>函数返回类型为 <code>int</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u; <span class="hljs-comment">// 如果根就是自己，直接返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 如果根不是自己，就根据数组下标一层一层向下找</span><br>&#125;<br></code></pre></td></tr></table></figure><p>路径压缩：将非根节点的所有节点直接指向根节点 ， 减少 下次查询的路径长度</p><p>我们只需要在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果。</p><p>因为 find 函数向上寻找根节点，father[u] 表述 u 的父节点，那么让 father[u] 直接获取 find函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 路径压缩后 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="isSame"><a href="#isSame" class="headerlink" title="isSame"></a>isSame</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// bool isSame(int u,int v)&#123;</span><br><span class="hljs-comment">//     return find(u) == find(v); </span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h2><blockquote><p>现给定一个拥有 n 个节点（节点编号从 1 到 n）和 n 条边的连通无向图，请找出一条可以删除的边，删除后图可以变成一棵树。</p></blockquote><p>一个树要是节点数量不变，硬加一条边，那一定会出现环</p><h2 id="并查集题目合集"><a href="#并查集题目合集" class="headerlink" title="并查集题目合集"></a>并查集题目合集</h2><h3 id="判断连通图"><a href="#判断连通图" class="headerlink" title="判断连通图"></a>判断连通图</h3><p>给定一个无向图和其中的所有边，判断这个图是否所有顶点都是连通的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    f[u] = v;<br>    w[v] += w[u];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            <span class="hljs-built_in">join</span>(x,y);<br>        &#125;<br>        <span class="hljs-type">int</span> fa = <span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(w[fa] == n) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//所有顶点都连通，即要求n个点都连通</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    f[u] = v;<br>    s[v] += s[u]; <span class="hljs-comment">//点个数相加</span><br>&#125;<br><br><span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;Q2&quot;</span>)&#123;<br>    cin &gt;&gt; a;<br>    cout &lt;&lt; s[<span class="hljs-built_in">find</span>(a)] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="连通块个数"><a href="#连通块个数" class="headerlink" title="连通块个数"></a>连通块个数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> cnt = n; <br><br><span class="hljs-comment">//for循环完所得到的cnt即为连通块个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(f[i] != i)&#123;<br>        cnt --;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//使全省任何两个城镇间都可以实现交通，即将目前分割开的连通块连接在一起</span><br><span class="hljs-comment">//需要新修的路 = 连通块个数 - 1</span><br>cout &lt;&lt; cnt<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2024/06/26/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA/"/>
    <url>/2024/06/26/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="图论习题"><a href="#图论习题" class="headerlink" title="图论习题"></a>图论习题</h1><h2 id="dfs和bfs-的岛屿问题"><a href="#dfs和bfs-的岛屿问题" class="headerlink" title="dfs和bfs 的岛屿问题"></a>dfs和bfs 的岛屿问题</h2><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> g[N][N],st[N][N];<br><span class="hljs-type">int</span> n,m,res;<br><br><span class="hljs-type">int</span> ax[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> ay[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;<span class="hljs-number">4</span>;t++)&#123;<br>        <span class="hljs-type">int</span> x = i+ax[t]; <span class="hljs-type">int</span> y = j+ay[t];<br>        <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;m &amp;&amp; !st[x][y] &amp;&amp; g[x][y])&#123;<br>            st[x][y] = <span class="hljs-number">1</span>; <span class="hljs-comment">//设置访问过</span><br>            <span class="hljs-built_in">dfs</span>(x,y);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[i][j] &amp;&amp; g[i][j])&#123;<br>                st[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">//设置访问过</span><br>                res ++;<br>                <span class="hljs-built_in">dfs</span>(i,j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="孤岛"><a href="#孤岛" class="headerlink" title="孤岛"></a>孤岛</h2><p>思路：先把图中的靠边的岛屿变成海洋，再进行遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">int</span> g[N][N],st[N][N];<br><span class="hljs-type">int</span> ax[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> ay[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    st[i][j] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>        <span class="hljs-type">int</span> x = i + ax[k];<br>        <span class="hljs-type">int</span> y = j + ay[k];<br>        <span class="hljs-keyword">if</span>(x &gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt; n &amp;&amp; y &gt;=<span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; !st[x][y] &amp;&amp; g[x][y])&#123;<br>            st[x][y] = <span class="hljs-number">1</span>;<br>            s ++;<br>            <span class="hljs-built_in">dfs</span>(x,y);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <br>    <span class="hljs-comment">//最左边和最右边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(g[i][<span class="hljs-number">0</span>]) <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(g[i][m<span class="hljs-number">-1</span>]) <span class="hljs-built_in">dfs</span>(i,m<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">//最上边和最下边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>        <span class="hljs-keyword">if</span>(g[<span class="hljs-number">0</span>][j]) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,j);<br>        <span class="hljs-keyword">if</span>(g[n<span class="hljs-number">-1</span>][j]) <span class="hljs-built_in">dfs</span>(n<span class="hljs-number">-1</span>,j);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[i][j] &amp;&amp; g[i][j])&#123;<br>                s = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">dfs</span>(i,j);<br>                res += s;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="沉没孤岛"><a href="#沉没孤岛" class="headerlink" title="沉没孤岛"></a>沉没孤岛</h2><p>思路：<br>通过st（标志状态） 和 g（存储图） 两个数组来控制岛屿的遍历 以及 变化（改变矩阵值）</p><ol><li><p>第一个 dfs 来找出那些以四条边有关的非孤岛的岛屿，通过st数组将他们标记成已遍历</p></li><li><p>第二个 dfs2 来对孤岛进行遍历并改变g数组的值</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> g[N][N],st[N][N];<br><span class="hljs-type">int</span> ax[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> ay[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    st[i][j] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>        <span class="hljs-type">int</span> x = i + ax[k];<br>        <span class="hljs-type">int</span> y = j + ay[k];<br>        <span class="hljs-keyword">if</span>(x &gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt; n &amp;&amp; y &gt;=<span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; !st[x][y] &amp;&amp; g[x][y])&#123;<br>            st[x][y] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(x,y);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    st[i][j] = <span class="hljs-number">1</span>;<br>    g[i][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>        <span class="hljs-type">int</span> x = i + ax[k];<br>        <span class="hljs-type">int</span> y = j + ay[k];<br>        <span class="hljs-keyword">if</span>(x &gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt; n &amp;&amp; y &gt;=<span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; !st[x][y] &amp;&amp; g[x][y])&#123;<br>            st[x][y] = <span class="hljs-number">1</span>;<br>            g[x][y] = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">dfs2</span>(x,y); <span class="hljs-comment">//这里也要写dfs2</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <br>    <span class="hljs-comment">//最左边和最右边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(g[i][<span class="hljs-number">0</span>]) <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(g[i][m<span class="hljs-number">-1</span>]) <span class="hljs-built_in">dfs</span>(i,m<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">//最上边和最下边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>        <span class="hljs-keyword">if</span>(g[<span class="hljs-number">0</span>][j]) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,j);<br>        <span class="hljs-keyword">if</span>(g[n<span class="hljs-number">-1</span>][j]) <span class="hljs-built_in">dfs</span>(n<span class="hljs-number">-1</span>,j);<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[i][j] &amp;&amp; g[i][j])&#123;<br>                <span class="hljs-built_in">dfs2</span>(i,j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cout &lt;&lt; g[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="建造最大岛屿"><a href="#建造最大岛屿" class="headerlink" title="建造最大岛屿"></a>建造最大岛屿</h2><p>求岛屿面积注意事项：</p><ol><li><code>s = 1; // 这里为 1 而不是 0，起点开始从1累加</code></li><li>要先计算一遍面积，再用两个fou循环去改变岛屿矩阵<br>防止出现如下样例答案为1，而输出为0<br>暴力：外层两个for循环嵌套内部两个for循环 ： n^4<br>优化：给每个岛屿进行编号（从2开始，矩阵值为1代表还未编号），然后对海水即矩阵值为0的地方开始遍历，将其周围的岛屿面积相加<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span> <br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200</span>;<br><br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">int</span> g[N][N],st[N][N];<br><br><span class="hljs-type">int</span> ax[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> ay[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>        <span class="hljs-type">int</span> x = i+ax[k];<br>        <span class="hljs-type">int</span> y = j+ay[k];<br>        <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;n &amp;&amp; y &gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;m &amp;&amp; !st[x][y] &amp;&amp; g[x][y])&#123;<br>            st[x][y] = <span class="hljs-number">1</span>;<br>            s++;<br>            <span class="hljs-built_in">dfs</span>(x,y);<br>        &#125;<br>        <br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> maxs = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[i][j] &amp;&amp; g[i][j])&#123;<br>                st[i][j] = <span class="hljs-number">1</span>;<br>                s = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">dfs</span>(i,j);<br>                maxs = <span class="hljs-built_in">max</span>(maxs,s);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;n;a++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;b&lt;m;b++)&#123;<br>            <span class="hljs-keyword">if</span>(g[a][b] == <span class="hljs-number">0</span>)&#123;<br>                g[a][b] = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                        <span class="hljs-keyword">if</span>(!st[i][j] &amp;&amp; g[i][j])&#123;<br>                            st[i][j] = <span class="hljs-number">1</span>;<br>                            s = <span class="hljs-number">1</span>;<br>                            <span class="hljs-built_in">dfs</span>(i,j);<br>                            maxs = <span class="hljs-built_in">max</span>(maxs,s);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                g[a][b] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; maxs;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有向图的可达性"><a href="#有向图的可达性" class="headerlink" title="有向图的可达性"></a>有向图的可达性</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    st[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])&#123;<br>            <span class="hljs-built_in">dfs</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag) cout &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2><p>思路：<br>遍历所有岛屿，判断其四周（上下左右四个方向）的情况，满足以下条件则周长加1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(g[x][y] == <span class="hljs-number">0</span><br>        || x &lt; <span class="hljs-number">0</span><br>        || x &gt;= n<br>        || y &lt; <span class="hljs-number">0</span><br>        || y &gt;= m<br>    )&#123;<br>    res++;        <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> ax[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> ay[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>                    <span class="hljs-type">int</span> x = i+ax[k];<br>                    <span class="hljs-type">int</span> y = j+ay[k];<br>                    <span class="hljs-keyword">if</span>(g[x][y] == <span class="hljs-number">0</span><br>                            || x &lt; <span class="hljs-number">0</span><br>                            || x &gt;= n<br>                            || y &lt; <span class="hljs-number">0</span><br>                            || y &gt;= m<br>                        )&#123;<br>                        res++;        <br>                    &#125;<br>                        <br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bfs-问题：小镇购物"><a href="#bfs-问题：小镇购物" class="headerlink" title="bfs 问题：小镇购物"></a>bfs 问题：小镇购物</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-type">int</span> n,m,k,s;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx;<br><span class="hljs-type">int</span> st[N];<br><br><span class="hljs-type">int</span> a[N]; <span class="hljs-comment">//a[i] = j 代表第i个商店的商品种类为j</span><br><span class="hljs-type">bool</span> buy[<span class="hljs-number">110</span>]; <span class="hljs-comment">//第i钟商品是否购买  1≤ k ≤ min(n,100)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <span class="hljs-built_in">memset</span>(buy,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buy));<br>    <br>    buy[a[u]] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//这里应该是 a[u] 去置为true，而不是buy[u] = true;</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">//起点直接就被算上</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    st[u] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(u); <span class="hljs-comment">// 节点</span><br>    <br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(st[j] == <span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-comment">// cout &lt;&lt; j &lt;&lt; &#x27; &#x27; &lt;&lt; d[j] &lt;&lt; endl; </span><br>                st[j] = st[t] + <span class="hljs-number">1</span>;<br>                <br>                q.<span class="hljs-built_in">push</span>(j);<br>                <br>                <br>                <span class="hljs-keyword">if</span>(!buy[a[j]])&#123;<br>                    buy[a[j]] = <span class="hljs-literal">true</span>;<br>                    cnt ++;<br>                    res += st[j];<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span>(cnt == s) <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s)&#123;<br><br>        <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>        <span class="hljs-comment">// memset(e,0,sizeof(e));</span><br>        <span class="hljs-comment">// memset(ne,0,sizeof(ne));</span><br>        <br>        <span class="hljs-comment">// memset(a,0,sizeof(a));</span><br>        <br>        idx = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cin &gt;&gt; a[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-type">int</span> a,b;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            <span class="hljs-built_in">add</span>(a,b); <span class="hljs-built_in">add</span>(b,a);<br>        &#125;       <br>        <br>        <span class="hljs-comment">//当只需要买一种商品时，此时所有的位置出发都不需要派遣队伍出去，即代价为0</span><br>        <span class="hljs-comment">//注意这种判断一定要得把改组所有测试数据都接收完在进行</span><br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                cout &lt;&lt; <span class="hljs-built_in">bfs</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pycharm 虚拟环境</title>
    <link href="/2024/06/11/pycharm-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/06/11/pycharm-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">创建虚拟环境  <br>conda create -n xxx<br>进入虚拟环境  <br>conda activate xxx<br>退出虚拟环境  <br>conda deactivate<br>删除虚拟环境  <br>conda remove --name xxx --<span class="hljs-built_in">all</span><br></code></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://gitcode.csdn.net/65e7d1081a836825ed789158.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MTQ2NTQ0NCwiZXhwIjoxNzE4NjkzNzk5LCJpYXQiOjE3MTgwODg5OTksInVzZXJuYW1lIjoibTBfNjEwNjgyNDEifQ.7259cLHEohi5dwSZaTtB5clG_2yNAySG-Y8P0_Jh5Uk">Anaconda+PyCharm创建环境及超详细配置指南</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2024/06/10/algorithm_know/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/06/10/algorithm_know/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><strong>树深度和高度</strong></p><ol><li>树的高度和深度是一样的</li><li>节点的深度和高度可能不一样</li><li>深度是从上到下数的，而高度是从下往上数</li><li>最大深度和最小深度（由题意而定）</li></ol><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p><strong>前中后序遍历</strong></p><p>前中后序遍历指的是中间节点的位置是在前还是中还是后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><p><strong>层次遍历</strong></p><ol><li>层次遍历使用队列这种数据结构  </li><li>要用 <strong>while</strong> 循环入队出队</li><li>if (root &#x3D;&#x3D; NULL) return a; <ul><li><strong>防止后续错误操作了为空的序列而报错</strong></li><li>剪枝，减少算法复杂度</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;TreeNode*&gt; q;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a; <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123; <br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> a; <span class="hljs-comment">//如果树为空就直接返回</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        a.<span class="hljs-built_in">push_back</span>(&#123;q.<span class="hljs-built_in">front</span>()-&gt;val&#125;);<br>        <span class="hljs-comment">//注意这里要用while</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; b;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//要遍历完当前整个队列的元素</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                TreeNode* t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(t-&gt;left != <span class="hljs-literal">NULL</span>)&#123;<br>                    q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                    b.<span class="hljs-built_in">push_back</span>(t-&gt;left-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(t-&gt;right != <span class="hljs-literal">NULL</span>)&#123;<br>                    q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>                    b.<span class="hljs-built_in">push_back</span>(t-&gt;right-&gt;val);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(b.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) a.<span class="hljs-built_in">push_back</span>(b);<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="树的叶子节点路径"><a href="#树的叶子节点路径" class="headerlink" title="树的叶子节点路径"></a>树的叶子节点路径</h2><ol><li>定义的是string path，每次都是复制赋值，不用使用引用，否则就无法做到回溯的效果</li><li><strong>这里并没有加上引用&amp;</strong> ，即本层递归中，path + 该节点数值，但该层递归结束，上一层path的数值并不会受到任何影响</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++">lass Solution &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//定义的是string path，每次都是复制赋值，不用使用引用，否则就无法做到回溯的效果</span><br><span class="hljs-comment">//这里并没有加上引用&amp; ，即本层递归中，path + 该节点数值，但该层递归结束，上一层path的数值并不会受到任何影响</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPath</span><span class="hljs-params">(TreeNode* cur,string path,vector&lt;string&gt;&amp; result)</span></span>&#123;<br>        path += <span class="hljs-built_in">to_string</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">NULL</span>)&#123;<br>                path += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>                <span class="hljs-built_in">findPath</span>(cur-&gt;left,path,result);<br>                path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//回溯&#x27;&gt;&#x27;</span><br>                path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//回溯&#x27;-&#x27;</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">NULL</span>)&#123;<br>                path += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>                <span class="hljs-built_in">findPath</span>(cur-&gt;right,path,result);<br>                path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//回溯&#x27;&gt;&#x27;</span><br>                path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//回溯&#x27;-&#x27;</span><br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        string path;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">findPath</span>(root,path,result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h2><p>tips:</p><ol><li>对前序和中序进行分割<ul><li>前序是直接分割</li><li>中序中间会空一个根节点进行分割</li></ul></li><li>对分割之后的左前序和左中序 以及 右前序和右中序 进行递归操作 分别得到当前根节点的左子节点和右子节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> inorderIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;val == inorder[i]) inorderIndex = i;<br>        &#125;<br>        <span class="hljs-comment">//切割中序数组，两端切割出来的数组中间会空一个根节点</span><br>        <span class="hljs-comment">// 左闭右开区间：[0, delimiterIndex)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftinorder</span><span class="hljs-params">(inorder.begin(),inorder.begin()+inorderIndex)</span></span>;<br>        <span class="hljs-comment">// [delimiterIndex + 1, end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightinorder</span><span class="hljs-params">(inorder.begin()+inorderIndex+<span class="hljs-number">1</span>,inorder.end())</span></span>;<br><br>        preorder.<span class="hljs-built_in">erase</span>(preorder.<span class="hljs-built_in">begin</span>(),preorder.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span><br>        <span class="hljs-comment">// [0, leftInorder.size)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftpreorder</span><span class="hljs-params">(preorder.begin(),preorder.begin()+leftinorder.size())</span></span>;<br>        <span class="hljs-comment">// [leftInorder.size(), end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightpreorder</span><span class="hljs-params">(preorder.begin()+leftinorder.size(),preorder.end())</span></span>; <br><br>        root-&gt;left = <span class="hljs-built_in">createTree</span>(leftpreorder,leftinorder);<br>        root-&gt;right = <span class="hljs-built_in">createTree</span>(rightpreorder,rightinorder);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        TreeNode* root = <span class="hljs-built_in">createTree</span>(preorder,inorder);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数复习</title>
    <link href="/2024/06/06/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/06/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数复习"><a href="#线性代数复习" class="headerlink" title="线性代数复习"></a>线性代数复习</h1><h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><ol><li>内积（点乘）</li></ol><p>如果内积为0，代表两个向量正交，<br>内积大于0，两向量夹角小于90<br>内积小于0，两向量夹角大于90小于180</p><ol start="2"><li>外积（叉乘）</li></ol><h2 id="线性-无关-有关"><a href="#线性-无关-有关" class="headerlink" title="线性 无关&#x2F;有关"></a>线性 无关&#x2F;有关</h2><p><strong>线性无关</strong></p><p>一组向量是线性无关的，如果它们不能通过线性组合（即加权和）来表示为零向量<br>（一组向量里面，没有一个可以被其他人联合表示）</p><p><strong>线性相关</strong></p><p>如果一组向量可以通过非零权重的线性组合得到零向量，那么这组向量就是线性相关的。</p><p>线性 无关&#x2F; 相关 两者都不包含 所有权重都为0 的情况</p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>线性代数中的线性变换是一种将向量从一个向量空间映射到另一个向量空间的函数。</p><p>它满足两个基本属性：加法的保持性和标量的乘法保持性。</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><strong>每个线性变换都可以用一个矩阵来表示</strong><br>如果矩阵里面的列是线性相关的（共线的话），这个矩阵就是一个高维到低维的线性变换。</p><p><strong>矩阵向量乘法</strong><br><img src="/../../img/%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F%E4%B9%98%E6%B3%95.png"></p><p><strong>逆矩阵</strong><br>AB &#x3D; E (B为A的逆矩阵，E为单位矩阵，即对角线全为1，其他位置全为0)</p><p><strong>转置矩阵</strong><br>把矩阵的行和列交换产生的矩阵是A的转置矩阵，记作$A^T$<br>矩阵A的转置AT的秩与A的秩是一样的</p><p><strong>对角矩阵</strong></p><p>对角矩阵只在对角线上含有非0元素，其它位置都为0</p><p><strong>单位矩阵</strong></p><p>对角线（称为主对角线）上的元素均为1。除此以外全都为0。<br>任何矩阵与单位矩阵相乘都等于本身</p><p><strong>正交矩阵</strong><br>$A^-1 &#x3D; A^T$ : A即为正交矩阵</p><p><strong>相似矩阵</strong></p><p>矩阵A和B相似：$P^{-1}AP &#x3D; B$</p><p>若矩阵A和B相似，则R(A) &#x3D; R(B),且特征值也相同</p><p>相似矩阵的本质就是在不同的基向量下表达同一个线性变换</p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p><strong>几何意义</strong><br>在二维中，行列式的值就是由基所围成的平行四边形的面积<br>det(A) &#x3D; S(A)</p><p>行列式为0（代表这个矩阵所对应的线性变换将空间压缩到更小的维度上）的矩阵为奇异矩阵</p><p>非0的为非奇异矩阵</p><p>矩阵可逆和矩阵满秩的充分必要条件都是 det不为0</p><p><strong>线性变换定义</strong>：<br>线性变换是指一个函数 ( T: V \rightarrow W )，它将一个向量空间 ( V ) 中的向量 ( v ) 映射到另一个向量空间 ( W ) 中的向量 ( w )，且满足以下两个条件：</p><ul><li>加法保持性：对于任意向量 ( u, v \in V )，有 ( T(u + v) &#x3D; T(u) + T(v) )。</li><li>标量乘法保持性：对于任意向量 ( v \in V ) 和任意标量 ( a )，有 ( T(av) &#x3D; aT(v) )。</li></ul><p><strong>几何意义</strong>：<br><strong>线性变换可以看作是一种在空间中的“拉伸”或“压缩”，甚至可以是“旋转”或“反射”。</strong> 在二维空间中，线性变换可以想象为一个网格被均匀地拉伸或压缩，而不会发生撕裂或折叠。</p><h2 id="线性组合"><a href="#线性组合" class="headerlink" title="线性组合"></a>线性组合</h2><p>多个数乘向量的和</p><p>n个线性无关的向量可以通过线性组合张成一个n维空间，这样的向量我们就可以称为基向量（线性相关的一组向量则不行）</p><p>向量组可以张成的空间的维度也叫做秩</p><p><img src="/../../img/%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88.png"></p><h2 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h2><p>m个相互正交的向量，做加法和数乘，可以组成线性空间</p><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>矩阵乘法 是对空间的线性变换</p><h2 id="基向量"><a href="#基向量" class="headerlink" title="基向量"></a>基向量</h2><ol><li>基向量（或简称基）是构成向量空间的一组<strong>线性无关</strong>向量</li><li>向量空间中的任意向量都可以表示为基向量的线性组合</li><li>每个基向量集合的向量数量必须与向量空间的维数相同</li></ol><p>线性变换的含义</p><h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><ol><li>矩阵中线性无关向量的个数。</li><li>矩阵的秩 为 变换后空间的维度</li><li>取子矩阵（方阵）的行列式，最大子矩阵维度 使得行列式 ≠ 0（没有对空间进行压缩）</li></ol><h3 id="矩阵的秩的含义"><a href="#矩阵的秩的含义" class="headerlink" title="矩阵的秩的含义"></a>矩阵的秩的含义</h3><p>它描述了<strong>矩阵中线性独立行或列的最大数目</strong></p><p>一个向量组A: a1,a2,…,am </p><p>线性相关的充分必要条件就是 R(A) &lt; m;</p><p>线性无关的充分必要条件就是 R(A) &#x3D; m;</p><ol><li><p><strong>线性独立性</strong>：矩阵的秩是矩阵中线性独立行或列的最大数目。如果一个矩阵的秩为 ( r )，那么矩阵中至少有 ( r ) 行（或列）是线性独立的。</p></li><li><p><strong>行最简形</strong>：通过行简化（如行交换、行倍加等操作），可以将矩阵转换为行最简形。在行最简形中，非零行的数目等于矩阵的秩。</p></li><li><p><strong>列最简形</strong>：同样地，通过列简化，可以将矩阵转换为列最简形。在列最简形中，非零列的数目也等于矩阵的秩。</p></li><li><p><strong>零空间</strong>：矩阵的零空间（或核）是所有映射到零向量的向量集合。矩阵的秩与零空间的维数有直接关系。具体来说，如果一个矩阵 ( A ) 的秩为 ( r )，那么 ( A ) 的零空间的维数为 ( n - r )，其中 ( n ) 是矩阵的列数。</p></li><li><p><strong>线性方程组解的个数</strong>：矩阵的秩与线性方程组解的个数有关。如果系数矩阵的秩等于增广矩阵的秩，并且等于未知数的个数，那么方程组有唯一解；如果系数矩阵的秩小于未知数的个数，那么方程组有无穷多解；如果系数矩阵的秩大于增广矩阵的秩，那么方程组无解。</p></li><li><p><strong>矩阵的可逆性</strong>：如果一个方阵的秩等于其阶数（即行数和列数），那么这个矩阵是可逆的。换句话说，只有满秩的方阵才是可逆的。</p></li><li><p><strong>子空间的维数</strong>：矩阵的秩还可以描述其行空间或列空间的维数。行空间和列空间是矩阵行向量或列向量生成的向量空间，其维数等于矩阵的秩。</p></li></ol><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>矩阵的秩可以通过多种方法计算，常见的有：</p><ul><li><p><strong>高斯消元法</strong>：通过行操作(<strong>初等行变换</strong>)将矩阵转换为行最简形，然后计算非零行的数目。</p></li><li><p><strong>奇异值分解（SVD）</strong>：通过分解矩阵为三个矩阵的乘积，其中包含一个对角矩阵，其非零元素的数目即为矩阵的秩。</p></li></ul><p><a href="https://www.bilibili.com/video/BV1Gm421G7aC/?spm_id_from=333.999.0.0">奇异值分解视频</a></p><p>满秩矩阵也为可逆矩阵，满秩矩阵detA≠0（detA 就是矩阵A的行列式的值）</p><p><strong>不满秩矩阵就是奇异矩阵</strong>，奇异矩阵<strong>detA&#x3D;0</strong></p><p>由行列式性质知道，矩阵A的转置AT的秩与A的秩是一样的</p><h2 id="线性方程组有解（一个-多个）和无解的条件"><a href="#线性方程组有解（一个-多个）和无解的条件" class="headerlink" title="线性方程组有解（一个&#x2F;多个）和无解的条件"></a>线性方程组有解（一个&#x2F;多个）和无解的条件</h2><h3 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h3><p><img src="/../../img/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84.png"></p><p><a href="https://blog.csdn.net/lynn0085/article/details/79375614">线性方程组什么时候无解？多个解？唯一解？</a></p><p><img src="/../../img/%E8%A7%A3%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%AA%E6%95%B0.png"></p><h2 id="特征值和特征向量的含义"><a href="#特征值和特征向量的含义" class="headerlink" title="特征值和特征向量的含义"></a>特征值和特征向量的含义</h2><p>矩阵向量乘积 &#x3D; 向量数乘（A为矩阵，$\mathbf{v}$为向量，$\lambda$为标量）<br>  [<br>  A\mathbf{v} &#x3D; \lambda \mathbf{v}<br>  ]</p><p>从直观理解上看，由于矩阵的乘法实际上是对向量进行坐标旋转变换,它使得左乘 𝐴 后的向量依然与 𝑥 共线</p><p><strong>几何意义</strong>：<br><strong>特征向量：是线性变换下保持方向不变的向量，</strong><br><strong>特征值：则表示这个方向上的伸缩比例。</strong> 在二维空间中，可以想象一个线性变换将一个向量“拉伸”或“压缩”成另一个向量，而特征向量就是在这个过程中方向不变的向量。</p><p><strong>计算方法：</strong><br>式Av&#x3D;λv也可写成( A-λE)v&#x3D;0，并且|λE-A|叫做A 的特征多项式。当特征多项式等于0的时候，称为A的特征方程，特征方程是一个齐次线性方程组，求解特征值的过程其实就是求解特征方程的解。</p><h3 id="特征值（Eigenvalue）"><a href="#特征值（Eigenvalue）" class="headerlink" title="特征值（Eigenvalue）"></a>特征值（Eigenvalue）</h3><p>特征值是与线性变换相关联的标量，满足以下性质：</p><ul><li>对于给定的线性变换 ( T ) 和非零向量 ( \mathbf{v} )，如果存在标量 ( \lambda ) 使得：<br>[<br>T(\mathbf{v}) &#x3D; \lambda \mathbf{v}<br>]<br>那么 ( \lambda ) 就是 ( T ) 的一个特征值。</li></ul><p><strong>求解特征值：</strong><br>求特征方程 det(A−λI)&#x3D;0 的解，即为特征值</p><h3 id="特征向量（Eigenvector）"><a href="#特征向量（Eigenvector）" class="headerlink" title="特征向量（Eigenvector）"></a>特征向量（Eigenvector）</h3><p>特征向量是与特征值相关联的非零向量，满足以下性质：</p><ul><li>如果 ( \lambda ) 是线性变换 ( T ) 的特征值，那么满足 ( T(\mathbf{v}) &#x3D; \lambda \mathbf{v} ) 的非零向量 ( \mathbf{v} ) 就是 ( \lambda ) 的特征向量。</li></ul><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>特征值和特征向量的计算通常通过求解特征方程 ( T(v) &#x3D; \lambda v ) 来完成，即：</p><p>[ (T - \lambda I)v &#x3D; 0 ]</p><p>其中，( T ) 是线性变换的矩阵表示，( I ) 是单位矩阵，( \lambda ) 是特征值，( v ) 是特征向量。</p><h3 id="性质和应用"><a href="#性质和应用" class="headerlink" title="性质和应用"></a>性质和应用</h3><ol><li><p><strong>不变性</strong>：特征向量在 ( T ) 的作用下被拉伸或压缩，但方向不变。这是“特征”（eigen，德语中意为“自身”）一词的由来。</p></li><li><p><strong>计算</strong>：特征值和特征向量可以通过解特征方程来找到。对于矩阵 ( A )，特征方程为：<br>[<br>\det(A - \lambda I) &#x3D; 0<br>]<br>其中 ( \det ) 表示行列式，( I ) 是单位矩阵。解这个方程可以得到 ( A ) 的特征值 ( \lambda )，然后通过解线性方程组 ( (A - \lambda I) \mathbf{v} &#x3D; 0 ) 找到对应的特征向量。</p></li><li><p><strong>主成分分析（PCA）</strong>：在统计学和机器学习中（如PCA主成分分析法），特征值和特征向量用于降维和数据压缩，通过识别数据中的主要变化方向</p></li></ol><p>在线性代数中，矩阵根据其特性可以被分为多种类型，每种类型都有其特定的性质和应用。以下是对称矩阵、置换矩阵、正交矩阵和正定矩阵的解释：</p><h2 id="矩阵类型"><a href="#矩阵类型" class="headerlink" title="矩阵类型"></a>矩阵类型</h2><h3 id="对称矩阵（Symmetric-Matrix）"><a href="#对称矩阵（Symmetric-Matrix）" class="headerlink" title="对称矩阵（Symmetric Matrix）"></a>对称矩阵（Symmetric Matrix）</h3><ol><li><strong>定义</strong>：如果矩阵( A )的转置( A^T )等于其本身，即( A^T &#x3D; A )，则称矩阵( A )为对称矩阵。</li><li><strong>性质</strong>：对称矩阵的对角线以外的元素都是对称的，即( a_{ij} &#x3D; a_{ji} )。</li><li><strong>应用</strong>：在物理学中，对称矩阵常用于表示守恒定律；在优化问题中，对称矩阵用于表示二次型。</li></ol><h3 id="置换矩阵（Permutation-Matrix）"><a href="#置换矩阵（Permutation-Matrix）" class="headerlink" title="置换矩阵（Permutation Matrix）"></a>置换矩阵（Permutation Matrix）</h3><ol><li><strong>定义</strong>：置换矩阵是一种特殊类型的方阵，它的每一行和每一列都恰好有一个非零元素（通常是1），其余元素都是0。置换矩阵代表了一种排列或置换。</li><li><strong>性质</strong>：置换矩阵的乘积可以表示更复杂的排列；它们在数学上用于重新排列集合中的元素顺序。</li><li><strong>应用</strong>：在组合数学中，置换矩阵用于表示元素的重新排序；在计算机科学中，用于实现数据结构中的排序算法。</li></ol><h3 id="正交矩阵（Orthogonal-Matrix）"><a href="#正交矩阵（Orthogonal-Matrix）" class="headerlink" title="正交矩阵（Orthogonal Matrix）"></a>正交矩阵（Orthogonal Matrix）</h3><ol><li><strong>定义</strong>：如果矩阵( A )的转置乘以( A )等于单位矩阵，即( A^TA &#x3D; AA^T &#x3D; I )，则称矩阵( A )为正交矩阵。</li><li><strong>性质</strong>：正交矩阵的列向量和行向量都是单位向量，并且两两正交（即内积为0）。</li><li><strong>应用</strong>：在几何变换中，正交矩阵用于表示保持长度和角度不变的变换，如旋转和反射。</li></ol><h3 id="正定矩阵（Positive-Definite-Matrix）"><a href="#正定矩阵（Positive-Definite-Matrix）" class="headerlink" title="正定矩阵（Positive Definite Matrix）"></a>正定矩阵（Positive Definite Matrix）</h3><ol><li><strong>定义</strong>：对于任意非零向量( \mathbf{x} )，如果( \mathbf{x}^T A \mathbf{x} &gt; 0 )，则称矩阵( A )为正定矩阵。</li><li><strong>性质</strong>：正定矩阵是对称矩阵的一种特殊类型，它的所有特征值都是正数；对角线上的元素也都是正数。</li><li><strong>应用</strong>：正定矩阵在优化问题中非常重要，因为它们保证了函数的局部最小值也是全局最小值；在统计学中，正定矩阵用于表示协方差矩阵。</li></ol><h3 id="其他相关矩阵"><a href="#其他相关矩阵" class="headerlink" title="其他相关矩阵"></a>其他相关矩阵</h3><ul><li><strong>半正定矩阵（Positive Semidefinite Matrix）</strong>：如果( \mathbf{x}^T A \mathbf{x} \geq 0 )对所有非零向量( \mathbf{x} )都成立，则矩阵( A )是半正定的。</li><li><strong>负定矩阵（Negative Definite Matrix）</strong>：如果( \mathbf{x}^T A \mathbf{x} &lt; 0 )对所有非零向量( \mathbf{x} )都成立，则矩阵( A )是负定的。</li><li><strong>不定矩阵（Indefinite Matrix）</strong>：如果矩阵既不是正定的也不是负定的，则称该矩阵为不定矩阵。</li></ul><p>理解这些矩阵类型的特性对于解决线性代数问题和应用矩阵理论在各个领域中非常重要。</p><h2 id="线性代数的应用"><a href="#线性代数的应用" class="headerlink" title="线性代数的应用"></a>线性代数的应用</h2><ul><li><strong>机器学习</strong>：在机器学习中，特征值和特征向量被用于主成分分析（PCA）等降维技术，以及谱聚类等聚类算法。</li><li><strong>深度学习</strong>：在深度学习的卷积神经网络中，卷积核可以看作是一种线性变换，其参数（权重）可以通过特征值分解来优化。</li><li><strong>物理学</strong>：在经典力学中，特征值问题与系统的固有频率相关，特征向量则与系统的振动模式相关。</li></ul><p>理解线性变换、特征值和特征向量对于深入学习数学、物理以及相关工程领域非常重要，它们提供了一种强大的工具来分析和理解复杂系统的行为。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库复习</title>
    <link href="/2024/06/06/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/06/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ec65f6b673ee6b7247cbda4ea00d875472bcaf098cc10a102a5c50a6ba9f9fb3">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df404dd65c1910ce52e3f7eb1cc408a5dd9711b9d97fbd9265103293df9acb39c85d22f8b72311e5790783577b3d172ef3e8d8ee046f1602c827abc17ef313c8d7b88b173e1eba48f60e355ce3773912320da1f5f46356deedd5d07f31c118a7d041cab60a9b84b82bc011c12c4402c677e6cd376d3d890cf396028fb4e0481dce4b65f29fcfb197cd97b1de1d3f64afcc21e04fccdc65e4784cfb4633e993f536790adf39720f0e5eac140fc6ccf1b6ef5765e20dfdd7fcd2bad334b353c0550d09bffb33222eb151a29c6f5774bb7cab4c771885f581e3b3bbc22d55aaca7ae454b89465e87da55f306c31efbaac6dd87a14cc04bab014cf793fd9518dbc622957757a6950f39a783abdf9860b7eef5608c6af9d78021443fb167ef1117e0acd327e26cb550dda67fd8cb2ef039a5dccbf82e24cc562a6d546b53a40f24e4dc11900cefc6394775d7caf867619a4eea7e6c722e2684630194c4a0634b185e0612e1d30470b7fe57c2e998abf19a383c81f977aae6c4d97f377b7151cb608507afdb7d9ecc434e96998273606c5c299ca2f4260b52b8f4d67356e93f6b23045779cff979ea97c0ab5669bfbd83902bd29ab0ec7d3bbce6eba6758f3ae338a272b73d66e5b1aa41d6e1debee2616a04db5bec44c9a792420efe3a6b18a607be24c28914d84e04602f2d7c8223def1bd88a420ff17499f3e6de9c045117bf0f2cb5c00d8e0cecc67f0e45ed1ecb827a298945f1d4fc224ece8755eeb174b68a4d2b486e6f65b9bee41d7917d4fe8c7a951417793f9f43d7459f6dd5d242b62797b5066c28096f6ad8b0b6234a324b66d8524e64100a2d92bc9a8956fde5f99b4406b0c3dafbc934b9e5f388793cc83170e85fa5644bf03ffff73952869c607715a3ba8561c16764f418ad5b163e90724a210107f81c6e3641b3f98db3a7dd069d76287cbbf14a49614adc8b07c2791737f03c396dbaf4f6593ef4128c11482969412ea124e04be79b91258a3c6512c297c0854fbdeb7c2d80ea51af793b4c29e58b9eb2885d0699c694a07b625597a17500c64a87045cde5cb61aa9a7f2cfce238683eafd24a6f3e0bc03b38ad766a2ec595559565fe9f77821df641220cef69bf3c4240213d776823d9de5e63d628861f7ed4a17466a921974df61511a905d8f574a29f86a56ee7ee9e360de24c806eb7d7a914755a138f597229e85e63e1d31f0946e109bc64490d5a4f3a6638db76909eb305b8abc3f3c5f19ac534958dc91fb4eba21888725f727ac89d2d141515e3f15a744b74a1d1ea15c3d0a4770bcd305184f9ef31644e41a6a9cdc5a08abca6dbca735605a91761b5ef06f5894323eefc27ecbd3333ce0aa761cf1384a0cf347a4180b3a265b660c6a3066b1fc86efa4d1127a6c93cd3a9c04f0fbff779b362d8f5c91268384e538531a4b5f759290359e6b616955c334eb7277f86e8ea386513a90bbdb7877d080fd207b0bc6bdeeb715a4fe4dd472b25ae20872c3dffdf88c6ebb3a7a73bad9cdb9073cba4ac3501b9d878fe4728749556db3e0869404be0b7ec17c55056531da438806e60cecf2069a44cba6bbfa257ed174195960ebbed9000d45fe12abce5837374802b394ac123997ca86c3f848dc318cd71dc35a9321040e6da7e76dd4bf4dc86d0d23e2241635b51e6359ad1e6a110f6f880fcbdae7f1dc589d46b04c53617a038662a6554f2b1af765c3292f12460d396c2c5d010fb2da0e3a9d9fd0ec979a0ee17247a1bb855e517bb9d1a74cbaed561e611045bedd1dfd46bc57850d2f0c84a087f9a2af854b52e44c9bc715ff345df06cfead61930d69105d4887b8613bc4502745c2f9c15bdd041f36a9c5013b4368c3af8428c85ceb3ff0e896357fa73c5a09855f379e8c095c1c8ed7cb7e3bac6a1ab016e6c1110addeb9a28c95f943fca5c3ad1a2a3943889a4b85a0c0e6f9177364fd6e6709621a8db0d420a1ef5b20ab4d75d04e05803ae6fc4e054e05c574a6ccd2d90c3dbfe4df7c2cb73aba6335218fe03cf119a0dc03167afc3c183721a948838daf74081f2b0e3f61e06629fbd4911cc6167a3ab2b5f7e62adae7391a66805d2d873e256368fca97a87055cccfd9a756dae817933a9e98ada8ea0d9589f50cbf920c6174f05582a0aa8bb620aef3935f954f64493261e5c598bac54d604673e7094d4f9daabbe5f07695a6e3e5411f2f110268c33c379ddd06e93bd624188aa134aceea6fd2513f3dcfb1facc019b715e007707380fffd7c5319f3478cfd3f4a597f4ddcaab355b09fb299b64c8ff2c4bbfa3435fa7bb91ba8f1eb6b3c77d453d1f0cf1df920daabaae723f60c17881ecd4fb46d3d8c41d7a306011f2be09c154be9c3ebb5cea90454c9ca64196b2b972aae41154cc92bbb79f41772726e78c746c483ce5ef95a6193e55dbab53728f406bdeff67995af35076bb7ebf7896173e49730eeca387f706b8da20d4b6fd020f290506e146dd115569cc74bfd4336596ee1bc74343582cd763b7701afba4f612ffa4cd44c251cb37e463d5ad6903b99037716b3e65139111a37a792d41c814b4bcc075d08845578300a2310961cf0ba599668f69df733f56dcd649188c9d87627f01b759abf863901ab2f633da3958544eae8aa99482f23f0a767e58fe6f17e67b1321b7bacc19fa2aea8902a3c90c5b6058e7759a1c2aeb2506f47b0c14cb97255e80847067943fb1e9831a21f8cc9d4c316919760c3c1d35db0bda30f29b2a64dbb6650915c3cc8d59691f0c15c8001154340c4428ad38f481a7fb9ff5aa1beadb6570a8da0ccd8ad35e904cbca36375380267865d5ee774fb074b39dbd24448d712ad9ff5cfac2b5333142ddb2e5366779f868f0df35ea29c8a483dab0ecfa7b381a4c60abc8fdc8b2e535348c97bd1e8c01f7943c88db1c9cbba709b781c2c9aec1584a9ff592b7b3aac67bc0f8e529dfe0c3f1107d860ced2281ecd96ceef3eae44949f6c8caaf5766085dca14608deb77790e35810610284720a3d0dcd61a79bff4b09f8fdd976c6b95be2f62712b1b037cfccbf0782f9fbd41d0d24d03b0d0b9bfc9ec4d8455fe728cadb432cb68f3b5fb222d00a12f1cd0ef7344245a32796b632169f96b9ce58099c2849af2dbc03ceb589b0aeea470622c58afa610c0fa58ef04720329b00b9d43c0fcca1b7ae78ed2f53a26b7893298fa1543ba5cd039550c599897d068ea83019cc3905b3e740d2f4b6e5c1fb630227a6e320374a2d7251c25a8c0ace83586e12858458c6944fdc4ac82122997cd475a7c14cbb9afa485f9f31cc5b5b16b40c83c13f7622399dee9e734567622c0ada9f24eb71473a53108cce94f83e269f8753a1374b8ee99527fad5706da3f2eb0fa51e28bcb5e42db9a91511bcd2593e3dace1e940eac7c8cfdc0b22879afdb2dc023c6ffa6be62cb071db4a2e70341aa308c5107d0d37833ac97c6e27b3c62b1d6eeb985c5769ef8c0a003f9e6d9faec272c2fa12d72e31022e80d8db58f8efbdc4f52e287156b1f5d441ca15bf27da4a14d8f4d3ab74602c980897da6f0472f5fa2332f8a8a7d14739787b0bc09bfbf9957caef03ed5fcc5f4c7ec1dfef53543a8f0e526ae1b15ff9845d25ce41dad34279f6a575b3bb702a52a07c8fb1c1bbd538143dadecda7b29da786777fba626a4f3975c07868151882112992f082138c46dcba63b7509f3439bd99ac8dc51443f8a0b75e2946803c8926bf9e8d17ea6027a5001d0d15523db3bbb33a904ee77899eec932470aa90f26a81977873f3f2ac297490552a8f965e7b76d2bcca2bfb42dccd8058231e9bc026eb72e01da238ce38737680579258ade83818a6b13996a6061076a3203f7058e688a43e87223a1193fba29d616ad98cab752c07c40e7009f0d7424d268195e4bb262059c0ffc882838634fe755c49254bcc141a4466691491126add6eef142ac85cc04882704facc87738e7785a6f188f625af9f272aae53e95a3338b67180796dd6a52beb853a8ff378b6389c128e00aa9478d5a97fe65e6f825f3c560cc4db2563fbc8e56aab08534fd440c8fc65e9ff1779364f9a988da499f8cf11da56e91e3933da5e5212097cbf59bdb6678dd1abbad529b09d0cb3f8b587d5b2a2ba9c4b5c954992725173b7f0ef9ab5bb2cbb6a40b8716363fc41a4df168fc9ae9a4875d9d9d3573b14beff1841503b8c6be7a8632ae5b09e141e6ee2f3b66024d4af36987366a8393903cbe54af37840e067b254c68e6b8da7a5c6c37327bc49051ec9ff4338b2e91af089576bc23a9def128e865dd597c6a69823e5bc88ef6fc7372df334a5df06a286fdf58e4a92ae7a7c37fc93006629db8ab0cf523bc262ad6cbe1dba54da088551a5ce46db26ea273603bafb4cc42f99b9fc7805424e0f012cfc680c9f05ddb7aa796766d459d58ed0afa0b01323270d1b5a74454ad949f069170a5d6028fb911ba1188cba939200c4799dd513a9a358fc80cd036d5c94c4abcfb53118234473779c22f86189737f10048aec859a738f4220044e6192b79f312c93279ea2a7c12795da26b15cb6055bee4f728bdffbe83bcdaed3d00c64d4de2c4e216aea3a656ac5ada2c14d3f64428692d9dc5c6d4f9862d757dffd35fa8c55f5e002eeea0003c2fa0f69214a81dd5895a755185c6639c46efb557467a2f9de2e9d7010f06cb8ee9158746ff40e443dfcf03c4fa6bfe4a6e556d1594d5e44374b608f8e576234ef41e77fe3c0c3ae05518340d6a6174b716ebed092b0dbe47394f9e0e2cf17e3ebfecc8fdd3d013b0ad71a6349f5bab7653bd3b9ba86c164ac2a4ef152cfb2da95de7e4471c3f1b28d0793539850d6703e834d69c413fb8d6c7d24dc54ac852bbfec2804d0cd9e033ff16d698d74167ad8b8edaf188175568352cbf73c9532fd77b0fb2fa79eac3370e893c690b3e496c6e0c40b26d04339f16d84d3a915e4f3d8af31349deebb77ec88731e13f51c959dd42c14db338c99cb9dac39fae9f1a40eb18f617aa8821f2b6d9856bcaad3315f94927ec792518710cec06e5cf344cf378f51df592a4d3aea1b3b8a52504de9b0d4978713396e351e6ccb3ac309ee0d3666b2887a3b1edae556cbd95fb90cca4c7f96a5c9b3b1232f5bf9623160df359aa27f57c91520b48fa9a746169da3fdc1191c80281f8d6b4791390a08466356d4f9daec14534eada3c7bb250503ffebea001d7ff359d74dd4fb0fda6d7f69dd11e85196952b2ca902cfb28e84ad2def18b2786cd2827d53445683c7a340b6bdd4e2dd988d69e350e59831fb23bbc9713b1eac3e9d027e674e59c213c71781297fdea12d8e521dfdf57a86d23c9396e44019dcf96a5a3c3b18211d914906808e078103191d1630dcf3f46207a3fcaec399da3c135675595f3058b17b16633a2b78dee3a4d958ad9c74d785435767bfca00bf8364110f662151f062eaca8d3d66ceeb39d3fb6259660361915d85e98febac7e675fadcec590d55d01d1d2f5e5bb1e2adef8dfa150d03abddb642e4a496b2a3592c95e76625e531d61f0f4b088b7fa1dc2a6749e6a69e335346bc8c5a1f07af1c010b4b26e9d5c762fd5fe2390513c45a9dee308d4aec40c55cf17125b263ec994a2a889f719f7245cc2d88d111f57850440685592c4879e28efaa44e9778eb43027419459e7b97585598215bc1915aa56d2f06a46afec07e92a929475ee8d452ebd022ce619f6a9f7c71fcb94c2cbcab1a66bfdd1a25c7693cc7d94d98beffea59e0aead67a12202c749e3ec22d3289ec2476b73b76db1c35f8e1966ebcbbdec35fee2aeb5c32c8d6b76607dd35777b6c010138bf2e0f4d95758474f2d4ec9fa532bcaffe3f2cda45018b0569aa4027f46329d5a180af81771a2b60c4ab7a77561d11b9842cac98d7c2a4096804a7af1517115132a5964df01ac0d2f7d57914e937980d834a01136fdaf458558baa0ddc036ec5f07c0969ab94d5357fa6764be717e00f5bc4a863d335b8c836da8f2b0ccd2f7c162765956e79b23557b4c004233185127c258e4f4d4f0f7c5369038b8e9ffd3ea625514004f644ea46fc58187088ddfeba496bffc6bea6c8ec02730dae1bca5f154daf351ed7380cfe826a5c57b7710febf447aebbb2d8d6beeb28a87aa53c0c84865c7e967453b2c0072078e883e86841ca47e14d28d4b09bc0686b6ec1139cfc3e74ba6d7f46d0c5166377bfb9b77c5cfc31499d52e6dd1919fef8db31a40c4c97af8fc9acf9913aacaf9311b85620b5e50f66cefa1b5512301548f65a9f2b3a17b7936cb2b3ce4a262cf4ee5a40a10d88c64b04606789f70f527c12a4a766345e4c5c8599e0806d7ac536408826112036d6ec53b7453f551cdd1c2f0485a9afd68591a48d57b1799a9cd5d6b0208259dc841bf2cabfd371f0ca5b38880d7436bd3678bcdd091183190947e642f9ca0eeb7f1bca5fb9ffd9b337a54e480a091a161c5d937b742c85d3b73495befbfd7d7bb735f17812530f13541abd7945c7879e5a70f6c4eab23440b00822deea87f8b08052146c034d0b797177482c5be50ff9c4c2a1b440b83fa1ec71b371b4f1573a354e913d593d53eef905a2ec05aa49ce6f0f4eefb3002e3412d01b68d7feffb4565d8650b0c8dfbd1c6626a42660c9cfa87224a86c6dab306c8eb1f461be2c79e36e3b1853189dcacf58fb913aa255c2017d4e64142885f317f538e75893b0e25263a0ef6437ffd0d53337c101e196ba98d854b6e062cf6a63da29b60fa134fa27317c813d40539f45cbf065edc77f4c7e51d0657afa455e320df8326288fe2d99fe7fdad4d3ee4dc8ae74440bc64dc7a3aba377afaff9845e5ab77ca211914b569dd1dda25f4c4f33fbd2ab4b9bfe580640ae0a9bcaea1d280e22bbfe135c7ac81990f5c8ddc7da9f0cc315db6514f56d8b002d7874bc0c79b323bed3beadefd4c7e970a61469e9959882482591c6b31dbd8db8b7e6a51d7f654dcc1e07713e4857b93c04c22325680c03f13af5b270af85a133aab149ec4b1181a52bb60f316b7196626f89ae7210a0d973a8b3988823c21bef0cc67a42c4c53067feb7b48b653c5aef56476709653ab8bd99a1694d38a9378d5302c4a9927b47f64e72b3ba94a78c66a8e7ac67675d9d53bae0a0ab938d232ff2aab987e540dd6a215522a6fdd2ae5d3dc7af4caea3c5486fd8de8a240f96caea041b57609b6c5430b9370816827bd039c6c7a33a6b7cb06ac56c56ca4fa6b9b5985628d5a5128ead17e03d89ff04f45875ab2a3c8e896fddaf92cef6b040b0ef90c4545b7be3b5599da356ccd7ddba58a82e401c687dce65c5e7ed631e1fbfe651cec1912f25b52fa37af213db3fb0a797662dd78f7b5456c22167dbd8eb93e982edd2af28a1b37401a2a17849933e450aa29a6f3972f6bd83aa200fc3fe9d7b4ef33ccff3c66b063f500328a7836f109b93c77712ba6913727f06932b326761a5d79ea91b7e46fdf371ebdf5f2346a707734994a73ea88b62c0d59c75e8a728cbcda2fc524cb623913a1ba3835464fe74bc4af18587ed465847005174e2d30bd9fee195b9b675939ff1c7c19ec3741bd60f3424cec5caa75a965a40ea803ea333708abfc950b80980b1784632a3ed884dca2602724617989c63d77c25322dc48cf6cecb3a7555b24ae46139edb3ff49601b4a1d5353c2b7ed733bb54c2ef26405c40e90f296b58962ce6c06d6df4bcc376a55bc593d8ea8684d508207070208bbe5a4ee7dc455b1a12f1c8482a3f1fd2aa8458a79d54fe246b23a16ba4db71cc166d115472b7a44402005e2d7b383dbbda184b22cd14f0e89921749ffa837d3dc2628274f85a604ef00ca3d43e546f2988f96e05e2d5ada4c19de18a9c84f23b6bd5de61235505410c82903a51e0473be0c60431ba50dac8770cdcbce7eb4d6829d4b5e3a0a79598a0c39cab7ed66fe77e061c259569018da45197656cf43eb446728fd216a59957bb611cb0a69d7ba5ab45cd6e34aa32bf6d2afb3efb5c0f39d44a6153434c5101ed448b4cbcc5c573917e2bd5a0c6697bed40a68df8fc4c32ba31aa2cfd267060396e246d7db555d44b5d5492755158780eaa931dd981d148387d724ef085275ae7ddf3c9a654c1f0609aec4af6a62a8b2991081c8a414d63ecc1dac554f3de83a399d4a8c93c0397728e7fb360af2153fd494b3cc1608746d04a038b8e2a7aea06df3c6bc418b9d7ddb766512d9516cbf51a0627f6861e4376896b45ff0048f981ba3e6ea610ffb5f562bee631c3ce2ebb870660eecdb03ea106d194e601d11ce9fcd1e9f1ae917e6bc0e6ec22407ca41aff3c3e9c55c22d0de2ca46ea0582605b3e6e6a3dbe945390b9c8a4980e5a25237136c1385767bb1a5c9a06b8c059809ce85b3b8b37bc9efe51e7ee588c302492af68f52501788a65ffa46b03dde22eca0b124eca3ec10e82a5b8377c7f07378f64ae1d255664cbd2e18d31e813c8217b52dc74da9464f41c25980e3f2639ec6e08c75451ef9757bb851b395cc03d2b3dbbde92137ee197282bc6354522fde4166c58123bf9bdf4948bb4be65f58ada0e1b2d7adac6e674e8b02819d89044e4d4de31aab6082d71e64db8a813056d718a4b7bce234742e180b41f08b0c1f659d62732040bf25bc3ab851913f0247da452a568152dda1358656fde02795ea781df033e55ee0210a28054da8b2d9f42face04b56b8c099cecf6422f948198c5816bb094120bdb4f2aadc5981682d9304e0551fdd31bab1969f302eb449f23d9d5256fd44e2ffb9a14cc5f7fccfd7dabf406a32a6ff51a49ff14bc4074b966b37d00b6f71416a64d9c00c5b7e452d37749f26ba560dbcd9014539f4a87ea1af50d86ffa1b57c01be020f6146df62a95f40a5e8ea035883e1c811a93d16e7a390bd7dc41894e5ce7c502c08a9792a76f59b1e7f297f0ad100f3d849448eb72126d8a3a15f408f6527df7724462718d750bb94af543efc1dfa286a4674eb852898260061dd5ac9a695e17251f98bbe697e5badfbb6d8f8b57e84200f9930ad50a01c2ff5b0885e54d5132d711df2470533d9f32bccd562ee65c3026dec03587a80b6486f6a5956b1a1c37483628a6c3d80a943b1ae15435a30d39716d294a4656803f52774faa214a2757db70556b9287cfd193b593b0f49b28739b88d7c4087643c7a84edbe3e99fa22bfbe22012021d8069c476d3b051b17c27b3d037256e3ac8efa3bfe4aff75efd62a460581d90387525de1bef438073fc1f3a6a54bddb0d178d7e8fd5bce0165e6957c855cdbf29241b62bcc25343f44573b29a33205f84d0092ca3c69a37192a4441b212ca71f1b387faa5484e64fda18f4ed431b1f2d0749e1d6ebb5d2fa365cfe92a5e27da9a5325cc6cbe6686ee345e594be7708458398a7e9c6dc4c1711a349fcbae2342e81781cef18a01f78a48812ccea767f348c3fbdbee94486bbdc05341d786f37e5e208dce7f4f6f55624c0e432e3e5d27111c2c78f2872751422215c607f64a413f9cda9d87a82b269c8cbba35892b32fc3f4f291d0cf290c92d15a3f30fc2ac5b13a4f9cfa020282b6efb095d39039eda0ee23a32be33bb73e675d4a7241bdd1e3bcafb5601bddba2de7afbff085aec4654a331739bf42304aee7feaec0e73b34046edbff10e8a74cfaa3c7b410985e0b44c4b93e5a132abcd01374f502f211f75bf98785128e5993311a39557e6bb395e750eb8823bdee1388ec9a34e9992575ad7a5bd61466551b3c959fdecf1576a907a2c88cc23f5c3595e790436f831177969271e43d6b09c41e90f0f076d99471ffb2d11b6885508250b7563193563883ad05a9c3ea1d4832be49dcda0eb0787172f2cab373648383b179d246cea87f1eb435865bf778f6d816319332643ffd63d7e6ee53001d1b673ba0d615fc2a691bcb46b0a0e87e458b607a582759edb564f6f2443230ba0f994d45d186b6336a47a1be22db36165e4141eb269305d839aeabc42c15a80a0c0c1e1709192838abbd7c82ab04120884b6d1591c9f7cb8cc3f29f13544213ddb5d372be4b6fbfbe5e39a8b6d400c271585ce661569eded4dd13e3b8693074a8e414b1b0a2ffdbe9359622f20bdb8dbd48e90acbb668e910f16c479b627071108c9302352d124de72d806e984d8a9116b10dd326fd3d3cd0de1d19ae58ec9624aec8d4256d4f381f7a1ba48dc921cc3e34d154059ced49b3e6c71a1f0acc832855e50423c8317b34faa6180c58910b3f9a9513fe55b58e575e80d3ea35d91e65b64fe77bf34fa4890769ef3bdc73292250107e2e790c7636d77d3eca1657f08c35c8176f14f3b39bfb674983fb037db184f9bd3fbd4811bf6e3723c7d617fa2108200f3645ec276b6116ec3aec1cde14c3ca4dffe5ea01f59c2fbc8cfbf72d2c5efe060fec08ba58bc44afe2e5fbb6f106e74363397e7beb26472efbeec3755b4efc2f20447e94b6f81455838a15c0698f358a105a576ecb6611deb6623343103c35053f393fbc36f7969bcb1edc45ac75934d07122c476f51cc1c7992452bd720ac7e8dd5a857d1be1b939a2c0ddacc03b3d71ef4f7b40431145dbc0581cd7c5a1aca0d4a8a2fa5174e1b5946ceaabbde479dcbc5fe90e2b760d5f3d5c690b27910cc593b16ee52ae9b11ce0b91eb58edb70ffc7e564d9e0698423ac2b4a28897210dd2e1a4751369483ce2334447897a31deef56ff5e4ed2315ea7dc233123b3d2d80e43b63cbe2c528f0be86b30d6390ffb98a5f9059fee54453050172c701b77daff1142f2270083f6f8e323682201deb9a5eb99929de6660049741404bccf849da05691d23001218bf1213437e4fd5fece27141e1d0818e3f3d73eda84780f5762cc0948bcfd684e27b28cdca51929db25c510bb7056d4664690dc230b1291bd90b07df61f4a5e003d18f738d66d40d4c88f34e694f0a7dc753d1b439466a1c08492dadefec55f24d52f1dddbe69529d25b4a5ffd17d773b11e7d7e57a96f5e1657c9a930bc997e98d54d4c7231bf20748d866714dee2abff1c61086a8c3e7df0d1d6926a4682110947827cefc1cae91e5ae2fce5c39179f2c97f27867ec2002f89d0eaa4be75a76bd09adce450cec7b3610fede67e9d6d458ba3af4e9343aa53bddc0c0d876d334e81ed64a9618b87e8cd022f58449dcb3d1a8cecfff1d11cece57979fe3f61fd99299a72ef343b716b85320b4aed7d3147610118884c7b0b5d14295997d3589fee3ff4e40c95675199894338f00caf7aeea5d2f26392f3c0b91d386c8d3cdb4d1d5e0aa71a98b6308b2689367ece5b873607a591bd20ca934c91632af23d830362ddb399b3008a8c10ae8f85ceb03dcd54f69550327c8095c9bcf5f1ada3e39d7861d14b47d514d554d2321aaec297bfced6e805b24e6a0be89651abb0f5476226e7631fc56e47291fb77668445c6c3ee6acff625524d65079b4aeda65ff7401f8efb74256f8ce1a64ff6e7e1c2fa390ab97996f3e29d7ea618756ace1e0f518bf7853e00c4e3862741662920ceac61fa715b606d4ac671a3ec1b5b64251ba11eca3653ee5ee7d8b0a37f2ca088fb0141c30bd392943311fa8e394808c173debf737c5b6543838913f2db982bb3e842bb19156e3dcc70163a157390544adf209054054397618309a524eae757b97b9a72a8c7b36dc936d31d09ef3f394df3436828057130cc2b28a8b7e2fc308880a7485a6772093455be1ea74ce9640977fd09f31dfa30a7d58902eb10a9d4f6241c4dd2c4c6a34c8477840ebd74d1c4f7d5826a738633177e87dd7b3ad84c0d1727bfb7f5b112f78147fc8be0885f4e0bf7f1ac3a95f88c26d2423c595b061c8ed7db9403890035ed66524e0c92148c7d990ccb0ca0fff2d99200ea9decf83a84e0cc4295bd85c1192a5db228c95a7514242a0d84a344c8edecd3348ec976d5d40e33ba220415f11319796729880f7620333c0121e390a08fa4c7fcde090e8e843ae8b464f412fdc13071a66988d6a8a64536eb4645d3fe61b8d47690261663a1b453798cad21670b2b7ce46b8e8ec1186e107e62c11c3924a91affd818dfbf97aff686e6a49d79de2df68065bd8443618e05c7c7c23ef0c705db8e242895c2b8d1dcd1dfd991d4483338f285cfd5310ef5027fe4e5ba8cd2651fbd73e65ed3d130f68c3992a8cdf5807f17744bf9fb85e1521b430ea6bc08c72cb8538bc76de8fd1790bd9b49b92832456dc7f81f8428499039daab14dffaaa33447c48c0eaef03386638cd8bb27fbad91e88a7eb25c0364a93e481d0fba59370fe55bb4ad182c3ff896c48eca73ce59686b5af3b7d57c0412cd3d065a3f8b97e9957b684ceae425d2fb69c4203b6f0945104c5514875ab52d80b5507ee89e3d7c0cd37752e41e173fa6d061cd1b71068b125dd8d3b6ae477aef2e52769ae278bc54b91291646b18b261eb343af07ff2eeba7960eaf930c598aeb99b6202f8803308154430bd64a975bab73a1d0eeb2d8aee5949c2e4aa666831f9d399aabf8ad2aa3773722fe596c75f3aeb57029928752a4f4720b7505a157494d40090c61e9fb303749a34493fa17bdd503c1ac3ff31bc9c48e1deec99c391bd950941eb7164dabffd13874a5bf802a3d8363d9dcd0468898e31afd44831dd3d5fe93ee31e542e29fbcad33624b02e52d25e7cedbd814bd3842e89abf5db25f2fd44ef612c5062c48eb9c81643fca8e731a1c52830d459eaf76e9e784c63d31b808ffee25719ae8ae68955ddf36d7f2609bbceabe5f169f57186e29a664ef637bab1a72e42139a760b73b712dd8ee5a0b68c1b479f752744039808f1b9b8bfe0c04ddbe50aec9968ae378104891fd429a0716589d0727f01b35333c237cae9ce6a2939779407e1926140e69a8cd9464a1efd48cc8a1f0e19994b9cd9edbd49fdd8ee4b896e1b77211688c355f0305d773b91bdf36a0254e3396ed7b6ed419cc146df860a71700e496f1a355b50c0ed1bfb29939f726d4d8f77564c98bb35c4ce961eec30fe867f7c39bdea515f70ea7a32985f3067e349a652321f2b87453466d9864191dccaf7e617b4128e0572186e6b0e1b20bf4bc316d6f742bf7c6af5bc130c8b3cacd4a05cbd923f7ac5e27b7a06c58dd2564744b1ad204c079214985abfab9558c12ef084a440143a8363f2b5095003249da20bd3d3384b3ec9a7f5b373d73269cff3dc35500a46597d65c3476cbdb53cafe0f7f43bc6daf67f12945895ff2788b2bba762d398c01877afe656d823750baf735807450ef70970e6001d2bbee941780f8d0912baf97fb5060494128a6a6e494c5f885f752fab6a3eb47cee0dc8fb184ad9f61f9c10429961d2c9a031897219e73428d49c82142329a01cdac600c51c74f2563c74db4f5795729f097222d8bd4d67f542e20ae4c7fc5718dbaa1cf7cf4481abd526c09f03afd0c97eb2aca511e3730bbefbd44db3b778d7bd78920c7bc332c8ba149c6f63a8d6c67d832b3e4691ae4e26d159d355799ba209dee68fb4594f8622a3168a4af32cb7393998e6db282fc8738d051d78e7953144478f1117cfaebae7bac5d4f5dce9cffb581cc1f664627e83027c0692aa8e453d4c8685d25224c40c743cb412c139cae8469c92b1037abf3c1c24bd019353109e1cc9366f177892c826b43b2a4af3bf378dab1481a2b65fbc2d30683a93c8f10f5fe81a93d595d8cbd39bbf5078e1be6d62c66216331321f500e1d01965929d4b9556a247007b4e7b1c70f58181440dd8cc29987a9357ac251653f76891c8c0629e51ebc9ff5c62d973a4ea8370de3a1b3c5f61fa3196b594628f9c7b2264457c6a819bf9b592b00bc6bf8c34c45766cd0efe41ba801da8c6dd5c935ebe5293c624d7f3faddb10d6010a3312eaaa91d6e0d2e4cdda2e458677175424ef17ceb10ef61fa3869974426bb823cc463eb101a78afd267736f8d58561f4daccbd37958aa279cf47d1df884cae425dce43d5404dae329bd2b1b93c6ae8d357601ae289b0889d48ddeaf085939bd3d7bd90a534e254f62c7115087a58a1c94cc0d6f11b49b1d780cd30b3bab0d180a332fc23518ffeab3c121051513bdf3971984602d18a56ce3d97148d4778ae191cbf81beb1ed9530770f646bbc1a304ff8e6bf96b6900c2d472c7dcc4c4099f34adfa5a75182c15815864d56a0e6a924165ba6fd55922d7909da13b6e2531fb33a96fc8f9c41136842a8c5ab10c5d603770d0932918ccabfd0a02b5f346de4b9b59eb1e9d1f7b83cb90e470d291375466145bc73a30962dc185f07ecb034a1f2b0fc6e22d36564ab865c460e18c8912f76565893b06cbcad99ec00c2c42441f6572fb3a82cc5a8651f1823d9fba792be03ff6319818b89444c3ddc12d22152f8b8243ec48765cb140b4e539f8eb8911703b0e4adc5562e9f5c0e3923c0e19220c208940ea225ddb0ca06d375880339b6fd6e181f30bf5f1239a5366d7b8d5acdf75fc64763b7d5191f12c6077ea5325e72a6bbf0d42327456caba5bf2cf4721c1f609261e3e91686d62e1ef54b76f0a8504bc9f3dfe82489c546ff9ad2de63178d49abb7a6d2a5045c99e988c23b7f3fab13b59d93a8657a1bb256a0f82a918d59182069453325adea811ce64a63f40c0e09e6b71bd4f6fcfe9ec6ed93b5ad2e80c5a603de800e07f0e061565526cc6c742f1d3bb499cf3a1a8c789eec24e8d5735e97034b573019af9ff08f405372f6b4aceb82556297fcdef1f49cfdf0bae92dd7c37d27d3a606dcb17f5e8bde37f4ea5ba57464bea5d6361367bcf2c0b1c6d314030977c7c28e86349fe8d2038279b6f4992e2142cfb65a93cd41d71dea2c882e23a4a6be6107050c8b688d2317e61e0f369faef7714fdf8db32ecd967c1022700b92a1558624656bfc0852836c9f99e15318d67fe5bc025cf80e89e4ba88a6b6a2e784b37c4b2848524d439af37c45a5a7cb7333c9699ead916e89fbc9ab7bba8050ed707074b5d3a199e180af159a12c4b23adceb1243199d5b6cc857d3483a8869b4049264ed4325c82a75c6f691667486dc7e498cff459f18005d9adbd98ff5becb23b236ac59e12b1821164693d8507760d4d70dd7b911d7b4c3928816a97e92d1baced4941c9ef7330f5e51461c78c943ec4445f542f4c91a162de1d726ba25337eb036646422418f40ca8f33ee28a85d60744274e300f1983ffe2ef65f2aa2cbb44b00ed1da9280c515afdf78b1bfcd53b8f10032ecb2b6f2fee29a3ce8e59ede13e50791cbc0c1d9e2196b3d8ef950cc90373e774bf0129d664d136d2be523b141185314b89600476f62eb244315fbfabd75b5beaa79f54678cbe9ecdc5102a9ab34a3a43991d205503ff494e8786b77c3ed72beefccf57ba1d810dbc77a24b89c48665bd914c42851bcacd5d271653cbdd26cb83f49a526bfb7a8c4fb9a22a5bc70181338280a6ba34940aa33ea161c71728d112b5b4890f6e22ca88735972b97da3f3b65897fec1fc0bc1e217a236c4e7f9e78421847db56c342e3f9bf9ce605953ac2d2e95cd69dfb283c8c904d4907b9fb5ec919d30b3b43b6791611cbb23e841decc5bce0bfc00b5cfc8fb4f14be0567fcf23aab4149a3112ce6c14df2b7e03fcaad9e10d250ebb4f45d503eb6bd82fdf5e887472e559044ef1b9d278f13797ba5683926e1f4d21aa014746d3c5502338855ef60567248547ebf26713a5d8b6f916287271104b38bcf7d9391e07b7d07ce581fc6e9a795f2749db317b3ec9e4642806edde4750162da10dfbac66c1cdb4756a7bada2859ca3622d13c919eef1982113e1bcaaf2d5aef7428d35ee7b3e316e66f996dd121db15648b020525f4fb2503fdb22ac1627152fff765afeac037f8d1f42c05c8afd4652ed29493cc190f505084a41dacd68151aa3db60863281fd0762fdebc33861be9d25aa281f7f6b4fded28be258d7fb7f5d96bfd99d531f64fb8ddb29f2c39a375e57f3de027646bfed02b05d3948f7662e509e4e52d86b5a8c9ad56599763817eeb5e66e16128e2d1368fd9cf1e823eba29173b28355ae6f676159d20e7843f58efb7b481309d5fcc8745419afa30519c43e7a7cbc3dbbd75ae8b8ce3121ab78a33f3644e5d36449f4945cc9f0c8f656833f968607c3a193ff16cf03850e704cac7485c266ecfc78a56067b04686611368a31f9578ec476c507dee69182bb710838c75a2ca5e66922311d123df8449c518abdbb7989493220411ce327d6936ed834d93fea306711ebb660c518aaf2c31058b5e6ef0e3bcb1f10738de59683e9deecd1da0d0f5c1468a85cf9ce481dff42e37b9407f5a5f859f1045db860899a08d4ae9e0a5a56ab69d1eeb9b8869e02f4c97051da2811e941a24189d834b8928b5947c4dcec51dc3396bc9e8c4d9a4de45da07081fa4c0aa3d2ee529386a56b9096103851a392e8dccacf469878c94838db22180c7b5f923196dcbaaed253faad577af1e7063b42023d7fa6a0bb5b3f49881a4c329947cbe99f72f805ff7ea78f930f59719585cbf99ec869000a2b7419cb1bc0307f39b24b8a7792997a409f38ab80de4503e58f172febdad15c405823473d6cbfe5d83fce2a0f405c839ffdca68aa4a968d4cb8f79851484801fbf119c24afc9133324b96e6cd09f598b59243ab9fb89bd71b0dc5a66d7e46a89e6022b3eeae8fbc2ad90260df5617586b4a47d14d4539a73aaebbf1a4dabae9765baec431c3a43fb7f725a7b353d7d29b3b6fbbbbbeb301fa41db464a5db359a26b7fa6421353956e76190af5f1f3284796aa39b0534db002207a029d1a5e5fabe99a942413f776b88788fb789d98678dd449155fa0838c24a2fa3afd450428847ecb229b03a9fefe98cd2790972b2777e1325c870c0be6dc2edf018bb519d0a822ce682a9b2a2f7a47f935b9ee00db5b54b748bb235b6c1815c6c1cacbbbcade05a8781f42da5eca76622540da41bf60a82a0efde4b04cbb6b849ff3b2461da1e64086392d0e706d5749c0ca39cb793158f7d1e55f561c6d0d7a1a9dc786d8d4771396887d1b4c1134e17592df386c6183230dfae460a34444b8f8a722e93d60d83e1703a7b018bb1cadc9c4e883b40f50ffc850fece0a7610741f47b841bcdd6e923455e8db237f0b797acedde49fba8586222dceffb73785669d4c622ecf35115a31e83296a8759a23aca6d0c59d8691b9f6b498dabff48da92057f96c96f789282526ec45cd403857c75356db0b402812fbed4b5aaa15aa364a8db61fe0aca55cf53e839a97ba6f21a64cb2a88af4d06435e8e448e0e7d315264aeead5f13dc541da9246dde4af6dd73b464a0fea051789d524d18e43c62a2f79493ef846e8007aed4bea4ea734dab12e2e840c270a0a99e17e6bc43acc1a48553bdcd0dabddff3899eab6d60e9daabdd50cebd122f52afdf5f0f6d927d103d0a5010948b6c8c0ae288525559b5c063f17b766c9dc45dda8bc94087725d04e5b4c923919f199f5168beffbbd2977937ec846651397ff4cd50f0f9559e0997dcee9d890424f9d1dfe025eaf091cb1922d56d3172763556264135ce8fdbb86e2101162be19fcdcd446ee55ccb573147a849c7f3b573ebb7e0fd882d6c334079d75ea24db5737f7779fd078c33ef4607a4ba7063471cb49961a0314e8080536c026ccdeda5eed0e516edc03f69a123d2f3cb56bd5126ddda1423f734bfe408972a23dd3defc5293087fb8bf307f96d0e63ae89a6ee9d5ba2e031a27e527cdd05f15d3a43afdb49d435d2b0d16a421a20612863e0e4b98a354ad9ca6ed9cb0659928eaed116233c06a9e57a34be29c180b74bf6e351685cdfdbf9b8d02feb8c91bc2b1d77ad6f993757e07a093dfaef9d2d975ec45290d071350e5751925c611601c210eea1db1c64dfa6a881615db9e9efb1db465d5e97112774c3ab35beabe40862957b4545ff96018b5fc92cd1c802c9826931d649ddfe91c39e93bf687241a7ffbda905cb08edb2ab9cd626260f1024f67f713ce1924f213b70d772a892173eae03a773217a18432e5107e5120acf332064121b0bfdbebdbf71cad6b2eade293b744e1159955ccf1d69a9336cbc87d3c75861cca5268b783854035e46e050fb2b8d9b596b69c5e450840acd75941a3d97fa1c1300b9b42d73873a63fc62290703c18cf689c62519ffaff8e1e3aaffc82af6af6a4983211b2a3bc01dc082ccc09ff34c2d7225abb39d0f5909a6aa8cd4d11f5081f297d0cbd4a708520ecd07e479ba728064c1de2e4303ad7f87da039c3a2d2211f93afdf3e2bc800df01e1001b613964bf1802d2b754c6a023ac0b92aead820a43969e7fe89eb2472b15ee87662aab988c32eef5a7f3233f84478a79adea7260564093cb7401169c89223d40ff5a5be3cdeb65663d7f47f87419bcfb51b947c9d6bd51cb65ecb1ca65c790c437884995d544cfdcff3349584320d1c555756b1b317ee02edd5811c9bbe418228db2b446981d089ec278a11f00d0765a1652be548de2db02f67e8c67252aabf4235060c31ecbe08c59e3680226ec2135317ea57c4ad0093c1e595e835eb18dcd80514bf67101c1c3933d831c71ef6f1c62e001533267c8badc8e2e64ad2dbc2c60c8c122f5deac2b48a5737ad998021c0a93573583ccd73d9f55f9cdd5e04fd23ed96556b81a20aba9a2e2203ed6e7caf421231eb0959b45d6c309bfd6763cd621d4e946c56028e365c0e389baf2ecb332e5a8cf0dda9403a7a67f91ab71f25534cee2d106f8de8822e809ef4ce241e83eeded58fd0334d2bea0a8a2d357a2e5c63539fab5619514a2789a776ab2f01ec85441dc7eece1ac339271803241cc95b8698807ae58896f1e071e6b8b80e11fd760fbce5a1c143413efb88a46fa2cf0bb1f74774eb042977d45b33f3a0334e6d8b435ffa3af2af4b6cf3541172cf39270c5839d517b260de9661c3f581a965a77c05d9736587a2f5688ca2566c6607e5d88c753a38bf2c0b613bf74d655118b86627047ee893c34f14ef36d33cbdd85228c4735975c23ad9e9e22af9bacf81d5e3f99b2c1c36256558dd78f190aa86c779578fe5f68b4e83c9042c6cf9506a42f488a41c5c6d49b13d022ea50d2e4166e8fffc659cff87710e3a5a2da871c59d5c1db638a47d9f69c8b6533e2b9c324c9463bf98239cbd46b36b18b4e52035ab5894061bce885dd604f7fb04fd27e7ce2325f90236efa2e4950944e2638878dd2a656a15132e0b1355f3a10e7ebf429135d7b8663a51cc414449a33c24a4bc8c6efd7b097d01b7c7de88fc17abbfcb5fc80f2cfa1b600aee3174d7baf1d17d72056ff668954482bd4480979951029a40d18a64e082dec0bb7ee4faaf83d3d68254608e613b894704438d29a470e2570c9deeb648a1137f8a9963e58d6ab7d1b08baea5b89145f6e3e016cd464eec5e4035edb29627f9274bdcb4825157e4439c227a0a464625cde9fe83beb7a46f4ebf95ab8386eab2f6ca4a127765d980083e3307be7b17ad0894ce335c8ad9bb67e7ba80feadfd90ad0cc7129864164b5907f9b1ba19ed60ec04608d3a7bbe2fc515f731db285fce3d0f0a17c97b7df8f12774c1383a17138a0543bada680b1b38fc298db789747e522cd98af1709a916e733fc648d0238ce72e3d7dead624101eb9bc88ef6d9b8160c68239373d0810138921382b4b6a817b9b3115de4527f21da6110a8c13e0cbceccbddf71270fc3cc956b828fcbd74453aec82bd714fa18aa4fe965c2e0468a36a90ad4e64f59e6892ad03f5a05866ec7cd3c694300b29f6b37bbffe4f229885c8602f04177f40c277ad30e1cd693042e68f222baaccd2f687063d38d31fec941de75c5b9147bc6c9bac40df604c0012a7b007962811608533db64aa3e0f09b95db7e6aad553183dfba136648a716bbab07de1e2043ec2a7a62fc3e2e936c662aabd759434def81c10066be75ead6db3d81b14fabf43e0450c146481fa757036263ab34f77298a91ef930688232645839ab90e9a0224764ac66fe16a472cf14db71cee0163911428bf51fd6433051aa2d9f106100aedff8ba56747aecf6fdfdf0896292cce20bdca4a964f20420a49916c95bd54a606d7de1dd4d72296aa5cbc26790e680db00f1b975d103976b2cd7167c61e27b12d5187f403c573d39b4b711bdb5e6efaebec780934d41d95180de568bcf81b3e03831e10ad597d7a5087913ea6469ed1bec07690703515ed567d0a347fb1f0ebfecca90d0978053368f5a0c0f3fafee217146555e54ad55a3019d262aa369c79e6c127d2597fa29e8988c3883256334a4ce4a119e141a103c3fe771a5f72e2f5f60439e4136066b2bd1738a8cccd0951d7c78e2568cda574feadca512128e3a80466291ae7e40811c7f2f263b7e93e9d16bed82883fb6b12b881ee8834a3efd3c0d4a1e0eae943ec9300630b9956ffd22c03cf31b64600bcd6c23aa52b687ea90b7924318dd99bfeb57407794b50b9f0f0b11ed1d413a750f878940bcb1bdc8977290bd26f11c270a5fefdfaae050937cca4cbbc6ef4d93e6dd5cc7b77a1129e56a3fe1aee47aa1427d4159e5701bdb035bb5a86263a07b320d1eac0c9af1caf3bed4ee6f9d458e7bb16491c7bee2a06a53c802c32f32d26505f75b012be615a74eb02247f2a67b5bdce861a42eecc62eed5cddea6ad41e0d1648d9b91867b151cd39246ceec7ae02b6656f8b27bfb4c328fc7a559215e3f139ac703043f1ce70d1fdd6401e8a0a1a3b452dffc4e10dd62fbf17f5006bc2e64ef24796f2186e27b04b836eb9bcb3a8f2a9eac45c475c9d10c864f6862f579b426e15de476cb7f2965a4cbf55cf2a2eab4150d49688fd4ef06c39c44380fd182d2bf77ff6360e9869d99762dbae4e020a934fb8bcba2ff5c43f909f04db70a90f8baef9beed74ccfab2bb8d5753d9d05c70cfcd04c1a283b78634c8f959fad829169e9983224212e3e2c57ded07318690d4c7cc5a7609de3fe2303f526b3690507e0ffc4edd6ff28782ff7657c86d3888812830defee45a2ad37a0bce0f2035d5f4a48363a30a4ef96fa930a7354b1fba7c6006b0c4a65bea3e6be06c62fe200c046394b23f5f2af283aed9434b1768cc9b2670c77afbe1dc735f4c22b5fd290f91beb531266b7d088f6784c404109eb213e3fc20839458ece23e695391ae8975e7652f2bfdb8b1b444950bddafd9a7e39859067c236e2ce88eab44a4063ac0ea835a3ce6a59b0ae1b149ba2ac8d6e095a376058149afa01427e05dc59f8480e2375f96df7aeee7b2254f32145ac7eff9dc84956f410966bd4506c1d4cf998177cf54e80b253082dc5cd9dd55e94fa75ca4faffa811e6abd59ac2aaacf9534c4dba5f264c4a8d7030ab7938618c35f160d980b33d03d79ea9489463de17bd4fe8e30cc07417e231ec6fe19060217daa1459f009bc43e7f4e34980269273b902e42f6065125f58bb43f19460b8bf50f5deb75e4fe294f4b6aae19cecc6306c850ad137715578076d38fd8647d6c80526c68a7a37dd167c01a39d701546d05c071f418f65aad612e5f94bf9542912d0686ef09a81a4e54ff368d15f65efe002142e63c51dbe523cf599c4518ba239fa1dd97ed7ad977ccc3050ff08c215ac51f51340a53624b615b5c6dc0e514056c7f85cb18b56d48fd63d9052953b468bfa78ff4eaaf875ae6a499c54b0fb5a8e155a0b74a60fff77a5f31030ba0f020a56ffb5b35f1032834648f9fecab8502d6cca96939990cdacdde702e39873203cfd84fc850fa757a3d1eb41d18b0280eecc0748873d99e43ca4e151b0aaedd12561c75738c62a983d76e9a5bae0bc4d96cb51fc8265c0633db1fe017f5d483a5504a4f4fa631a46d0fde76e2a11299023e62afeecc6a590091cea546617344cc454aabe6452a2bf659253a4fee8d2a3808a291260057d3d3784df8e94711f9522f4cc953dd73ec486af3f29ee9540f1e3c2b713033332b8bd40f62d29237452f896cacd44d2cdc6c6976f318316cab21b8ea977691f99bf15f17ed691623140a93a09d75383b13e993eb7605808c3574cc9967e4b2617d1fde1749b1d2a740f6fe7aecd99a884237df68e5afadd72a0f4846dff81c9449741d1af5aaef0bff260461ac05bfbc35277058732b97e73a0b04aecd460c99ebf4487b8a0573d78c6de169fa2e3a04695ed5cb911ab60e27eb04773d478cb5126195c2e741a2f155f735a5c171a207332665a57b1e5c64ace31323ad2f2a211b9d40c44f51754c140b754b6f69171d26f537b6b164939023b7f99482edd9959aa78ee4c57687b7fba585dc7d3116062c79f0c6f025dacf842563f3a941f92300deaec5eb0fa82e891c2f15f9521c091c37423a18e07032054f31b1123eea8dc986867618378f2f53da9f444a70ed78775ba04c52b3769490e75b328e9c14bf6215a752196c7ca6744141c67e867789ef249f5c9dc0555168ffdae6f9f3a5e733d89346345351a02c1f23d43b3ea95f9f669604cc52bea45f93619c18cef5b1a92c7fb4976e05d91dab98fc9b3adf1067c05b35a7ddb93c474b3c7df15edbe3b1cef4bec7f7d1edbc6a11c4d15cb35f55d13b40d4f76822bea9403891ab07e1069c24ae1e9cf566aaae55b76fd922a607122e79d48ed9876519b24ce4b708096110cd1ebdca832e9751bf1eff7092d50e6af861cd5dcc774a49a59587794c5e35b7800bed11bc7edaaba8a7cb70ee43eef66f648d02bc547e4e77737a08d79e2511e02fc5f3151354b6ce3cd6be1e68717f83dc915252a8d1037a203e8fa1fe05e346718a8b22f74c7fa55cdf8f2be3f98dcc3cbe1cfc8f789e23e8877f94b874690260d483584a229dfcf0757871a0be6de615532ec2d44359227a86fff847903531fa86ac272ec6f3be2ae6b2025e654ec7181ee51764bf23843c86061d94fa71e51bfbd5e00ebbf211e9cdb2ab998dc7d62257ada0fc7678cefa815de9016e5844f199eb5532c5a4f7110239463af02a9a919c6f49d228af0438b9e12dbaab845ef30d2eb66645b31bd6b513d757a44327b39a12d0e96b6e87a8a32c844d3a00148ee6b51fa570a817fc06690ae1071beca62e98d57316eb2dc7d94cfcac9dcbb9c42c422bccf7c360a2edb9d5eb129300eeb75fefdce606faa5abd2f0da9225c20c376af41f615966ff7123937705908b187d71ac6077f27cace0764dde6302564dd81c8c218ff192048817041d8e4e4f7eb64718053874779f28ce0c532b7aab76d55932854fa4040f987ca43a26841de7901e73e8e88e3b6a872d8c0f515e02e9c823f272cfd092e89d5b3f39a84299ccd0d7b6bc0b3d443f2e622e80da8591ce54cd45980d780037f1da4059976dc1acb85fde3ce84516f191302e36ebf3a299669e88d708c499e169d9ce8e80a0f950ceca24ae73b6157aa1947359ba3aa25b4caaef7f23708bd0300b876deca8014fef66712c75caa65b629fb03d4d5301f4daa9e6e8c069b44e998858671d75d9977be66e039e10815321997ddafb9623c8609569497d762a6b3edb32fb8416c88ee3d729f232651eff53c06c136aa1bdf66277fb02664006373356ca19dba41288a95176a3d5b18bec68d8cd0fb798400d3106208771487ee8540232f408dd905dc396c0ceb2618842a8a8307bbe76b4d77d75e6fe4605103a207d998513a65e6b648c4fe6ad8a9e75d0d5f742598c4a48f04281ce5dc34c6e04c7918cb897a375a5ed802a647105c1f79026d6b83e6dc2b90b17425e0718017e75d080f3403d434b885b86eb9a2f7933b2102d26cc7689f305603d0d88200b9dfa20d46877c4fd9b3e7a4573a9a03a79fb854fbbdb9d41881af4690147fbea47f6c6913b9f3173491ddec57f4a3986de817acf22f6eb62a5220349cdefec2c383b343bbaf8bca6b18577360a30eb64f0e34d0ce86c2726abb17a80887672b08775e49385c347749f001bfe44d61e3976e4fd9e427b092cb199d3a7ebb5190fe72b51048c6ab1242d387def6e884241c6eafb96b1a570f428899b76623cbe1d2ac1d604f21346c022a048721be3c3db43535f03b1ffa5d44245d42c6ae6d09c7d0d5721231ffb6ad0ae536453de3000853e82f2c2339ff0f02a1cf64b3c06b2c0dc8cf44b0b4a4730bce9755c48c01ac723e523fd70bcf100ae6a8eddb7be647de392cd4c85aaadb0437b7859c9b1a40bbd5bb54c60cdd49c4dd4e0df7242f5ebf09ac1d63971b0817e55bf624e20e098868dc09ec528ab4bfcf12b268b1b5483793ffd28183dac794edf9131302d19c9ce3f9adb731caf5aa63266ba1550aef31426aa56f777095ffe9db02f074770ec7c1fb2e4d1bb4814a1dd2d1197965a215f1f9cf15868ef1c5b80ed080f45dc4743f7d4672ca2bdbdf33328a9672a956c5418a9a412108f59f3e1f3af60c239f5a0378609a774312a93be9fef573a4070d0cf6aa4bf1bfa318a407b06ebfec7df159c17b8d128d1cc773118148b71e595ddf62b7bf9ccf3c1c7dadfa7904b646154be410e4d79fd4f4fa9e947e9e1fa2f471827c3af861b843fa4e444de49c73d4e893e6483d5e7db3cf8176292da201a93e4227095e06f4951e15c3ae17aa7dc09421c11ed0aab685d683d0a5fe0b83c2944e0e68dfcb99023494e16c625049e27602d3b3b7817f8b84990685525bce417672fa6f18f68093036f03f02b343b5d4103776f518731ca81614cf426761688ca28251151f44aeb01fe8c0e0b9d7fa008fb65c3e6a5dbd6b0bfa08cd40c49a806159449718f75ff9dc91f735e875d81757a7bfb5f9398944081790e247db62448d7833f810452ad12535c97fbe9420a5723d570dc990c6bd9565dffecf60afab515d85385931d1929378aaef4b7b58a1a691c56dbaaa4d6d39aeee0433fb16b6c038b1712973a5f2d5d32b6a49344bac909df255e7000bf2a5c6c5257415eb73236faca626a12a82d2ec6c4236b2cfd4b0edab7f506438273d401501b7c9c8892370a8eb06a10532c65bd7461179981a6f8e67472522f6ff4471ddc7ff0aa780ac18f37e90e5eb75a5b6e127212f008b923e4ee55299e5c8f9a73b93d9f2c4a1a6ce957b4683f37e0ded0b2e93236e738662045bd9aad072126bea2ba913f80afa7fd5171ca60d481c589e9925b7f4f65ca4e1afc79917ab94081378ca414af50231459943e7996a036014edcb1fd79fa70739b267bfa6bb2597067d9dcbd3ff5f68123dd5b044be241fb0f92ddb1709429e14a0131ebba39855e3c99f73d708629241f4eb74336abd4f243e38aee12133e9b0e543742358a4916f3f0ba6537527d82f2b143f81a22cc40d457a4b6975b386baa4d2c737d5a61d38f7f0a0a1142c1e3de15a0cf26909aa0771d9789c1d2734d5231e1cbec7dc1ee63ec7f2c17fd8e7cc159924ae43b9202f20098beddabfb92fce0d20db32f52e7b39111271a004667f3c2741d2bfade19baacba69a9e691a4eb7e54991842475ae47b81007ba15438e56e31f44bf5e24d1b4539eb9f7f1aaa6f43de4d3394122fe93b31b3c13c6c3b63ca7116c6924af6ddef6b033c5dddea401fb35a32d0075eb05b7f4399a222d2a6377d2ba747cc6aef751e5fe9cd6542a50ede2d3a682460e11fd47a339508272bf99583c6098ca667ce1791707b721cc5c66d38013d1db61e967b9c238b5d85113f7ee4f5df98298ab2429a8fbb71e14e7e7a393dae765b48b7d51b636039391770cba7e8e8bff27c117dc3e7da132c82b222cbf38d06a217c42e49b49f40cc223874e4757226a748b271d196b2b8884d9be8eb7cc6e35d507bebfc45c56fa61f0d2d611a8ff759081e224a114d6e7d87b7d383adf69db318153254d3fe1c002b855d5e7765429767a0830704940014d2e3f8f402146458341bf5337caa0a392e80f162ccc324a5fed42d5edf6c188ff6725d7c6cb87c9c6d84a02a128f6dca9fb4ac14cd12260272173713b7e71bc2409edc71473f13e6c7cb19546d5007fcb35138dee9ec5aa56675e405c7b5c3751901223972d6c9168ad7c1bac214eb6d525b3f26e314cdf38aef422779b57aefdee121c1077ff606d60b84d654171d99b1858c5e9a1560064978bc4df55c75d7fa237b99b480d14d0486aa09ee64d4d87e49171eac53ad62ddcd39d66003fe87d3288870801ebdcf40224d617716e63272365e6cff74f1bf710830e126130d2cb4f65f05d3d4c93a28452f8eaffc1152ab10327b59616ff502dcc1e05f2cf46d1c25d0a38cad9f878a8bbe03b6f748f3c3315b188d2f32992922dbac41b75f4c67015fb0574843988297aabac403924cd62df11bbaeeec1629fd2caebe5a92f60bcbd81e80f77452fdabbd0e4058c49dd8fb5a55de52361337ac63b1ce7d89890168613a3413b1ba9d013d3182d4408bb5e8b15093e0a8facab88ecc32c110ed04a8b8ca10132bc8ab884c1f6fb0134d9b682ca786a38b299573df4d7bfde7490b05c492f2df06ba1586d45a39eefd770062a9c13ff3b8284034c693bb50125cfa129a05fc41dc1e9fc5e6986da5badfafd92c61d541d77e62c1a8dfec20ac9681ac2844563a0632020dda334aef1a4a3e730004840b19d0058a8aef8592f8195f6061bab7b47c847f0aaae4bd1eca0155609b315d7c628b1019cdd9173fc29bc98db9acdaee6c545da89c010cb0b957e1ca1fd41df6704d211e5a8e9117224165305b266b1e8ec3b4c69f41a9428b163089b9284768a4db730ab1530f3eac1774915fb12522d40c4e21150e7e5ac6070272bd46708cc2fc696986ed853b66495400903a0271bbb3797b8a47302165ad5e5e06cb42ed901def914cf292bc75654e7aaa278b231671747c2c1c53854c29c117719dbce0654ff021709f8e873c43e439ed891b93c501bf49ffa3f9309d65571f31f5e259cbd429cedf00868e1be868d6549b0ec01c049341cb2aa117113c6cca78cd32a49aef66701905f0cbfe7673ed13f94f14d26d8ffe61b22b845a68d133c856ec21d4e3c1ebf0fe1f41d7a142b783d68764ec363709bcd908d85a23485ef7255330df38db965b53e5c3cf8a8208d5cd5a613a710cdbce3a8ed8c8c99a7e1459f23c1d6b198cd10ad50624cd12562c3833b5954cbe14725ea85ebad3a6645eb3f6811198e1b2b7a809dc068271a3f8d7ede22ba3146f76f7d0e6f0ff8b63889db6ccf9a586083bab6e0263c167611fd03fa3d28f64cf522e8d5ff3a5750ade1b7d9a91f9b94473eafb599caee45aa82789efeef6913c40b09883a7fb2fa2a2ae43492c1a95498f81975247a8e4279160d2002f5deb0d5d87eb9a6e4851f388183281598d65fa9d603df8907604d938fbb69623d97d65ed89d0dc78940b371af6c7fcc845d1559e71cfa2511e65a5a03ac3ae01cc4afedde6c4a8c31ec92eb8f663322c35c5e538926766886c1fd37f24225a328345d18619b7ac10cdee111674d6d20aac78d47a142136f647ac25c3e04b9d1f8add6f984877f046191d9661e37e52677acd67ea282ff15a403735cbd858c81b84e93f963d2fcb00d01e6d256bbb889733707d5a3deb0ba3673f69dc2d120a8d5457ce623602cc8acb39a0b0d36e7d1f0065b82232469fb31</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>概率论与数理统计面试题</title>
    <link href="/2024/06/05/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/06/05/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h2><h3 id="概率论和数理统计的区别与联系"><a href="#概率论和数理统计的区别与联系" class="headerlink" title="概率论和数理统计的区别与联系"></a>概率论和数理统计的区别与联系</h3><p><strong>通过中心极限定理和大数定律结合在一起的</strong></p><ul><li>概率论：更数学，从已知形式或某些参数的 分布 &#x2F; 随机变量入手，推断出另一者的性质，比如 已知分布形式 求期望方差，已知随机变量参数 估计分布期望方差（大数定律 中心极限定理 这是数理统计的基础），已知事件间关系建模 求概率（全概率公式 贝叶斯公式）。</li><li>数理统计：更偏应用，基础是概率论，是概率论的应用，从实际出发，从采样出发，主要内容有参数估计、假设检验等。</li><li>知和用的关系。一个是发现规律，构造模型，证明定理。一个是选择模型，调整模型，应用模型。</li></ul><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><p><strong>连续型随机变量，落在一段区间的概率 &#x2F; 区间长度 取极限。</strong></p><p>概率密度函数是连续随机变量分布的描述方式。连续随机变量的取值范围是无限的，因此不能简单地计算每个具体值的概率，而是需要一个函数来描述在任意一点上随机变量取值的概率密度。</p><p><strong>概率密度函数的性质</strong></p><ol><li><strong>非负性</strong>：概率密度函数的值在定义域内必须非负。</li><li><strong>归一性</strong>：概率密度函数在整个定义域上的积分等于1，表示随机变量在整个值域内取值的概率之和为100%。</li><li><strong>概率计算</strong>：随机变量在某个区间取值的概率可以通过概率密度函数在该区间上的积分来计算。</li><li><strong>期望值（均值）</strong>：连续随机变量的期望值可以通过概率密度函数计算得到：<br>[ E(X) &#x3D; \int_{-\infty}^{\infty} x \cdot f(x) , dx ]</li><li><strong>方差</strong>：连续随机变量的方差也可以通过概率密度函数来计算：<br>[ \text{Var}(X) &#x3D; E[(X - E(X))^2] &#x3D; \int_{-\infty}^{\infty} (x - E(X))^2 \cdot f(x) , dx ]</li><li><strong>累积分布函数（CDF）</strong>：连续随机变量的累积分布函数是概率密度函数的积分：<br>[ F(x) &#x3D; P(X \leq x) &#x3D; \int_{-\infty}^{x} f(t) , dt ]</li></ol><h3 id="条件概率分布、联合概率分布、边缘概率分布"><a href="#条件概率分布、联合概率分布、边缘概率分布" class="headerlink" title="条件概率分布、联合概率分布、边缘概率分布"></a>条件概率分布、联合概率分布、边缘概率分布</h3><p>条件概率：B 发生的情况下 A 发生的概率。<br>联合概率：几个事件同时发生的概率<br>边缘概率：某个事件单独发生的概率，仅与单个随机变量有关的概率，剩下维度按分布求期望。<br>能否直接由边缘分布函数求得联合分布函数：两随机变量不相互独立 则不行</p><p><strong>条件概率分布</strong><br>条件概率分布是指在某个事件已经发生的条件下，另一个事件发生的概率分布。条件概率分布通常用条件概率密度函数（连续变量）或条件概率质量函数（离散变量）来描述。</p><p>对于连续随机变量 ( X ) 和 ( Y )，条件概率密度函数 ( f_{X|Y}(x|y) ) 定义为：<br>[ f_{X|Y}(x|y) &#x3D; \frac{f_{X,Y}(x,y)}{f_Y(y)} ]<br>其中：</p><ul><li>( f_{X,Y}(x,y) ) 是 ( X ) 和 ( Y ) 的联合概率密度函数。</li><li>( f_Y(y) ) 是 ( Y ) 的边缘概率密度函数。</li></ul><p>对于离散随机变量，条件概率质量函数 ( P(X &#x3D; x | Y &#x3D; y) ) 同样定义为：<br>[ P(X &#x3D; x | Y &#x3D; y) &#x3D; \frac{P(X &#x3D; x, Y &#x3D; y)}{P(Y &#x3D; y)} ]</p><p><strong>联合概率分布</strong><br>联合概率分布描述了两个或多个随机变量共同取特定值的概率。对于连续随机变量，联合概率密度函数 ( f_{X,Y}(x,y) ) 描述了 ( X ) 和 ( Y ) 同时取值 ( x ) 和 ( y ) 的概率密度。对于离散随机变量，联合概率质量函数 ( P(X &#x3D; x, Y &#x3D; y) ) 描述了 ( X ) 和 ( Y ) 同时取值 ( x ) 和 ( y ) 的概率。</p><p><strong>边缘概率分布</strong><br>边缘概率分布是指在多个随机变量的联合分布中，通过求和或积分，得到的单个随机变量的概率分布。它表示了忽略其他变量的情况下，一个随机变量的概率分布。</p><p>对于连续随机变量 ( X ) 和 ( Y )，( X ) 的边缘概率密度函数 ( f_X(x) ) 可以通过对 ( Y ) 的所有可能取值积分 ( X ) 和 ( Y ) 的联合概率密度函数来得到：<br>[ f_X(x) &#x3D; \int_{-\infty}^{\infty} f_{X,Y}(x,y) , dy ]</p><p>对于离散随机变量，( X ) 的边缘概率质量函数 ( P(X &#x3D; x) ) 可以通过对 ( Y ) 的所有可能取值求和 ( X ) 和 ( Y ) 的联合概率质量函数来得到：<br>[ P(X &#x3D; x) &#x3D; \sum_{y} P(X &#x3D; x, Y &#x3D; y) ]</p><h3 id="什么是先验概率和后验概率"><a href="#什么是先验概率和后验概率" class="headerlink" title="什么是先验概率和后验概率"></a>什么是先验概率和后验概率</h3><p><strong>先验概率：</strong></p><p>事情未发生，只根据以往数据统计，分析事情发生的可能性，即先验概率。</p><p><strong>后验概率（贝叶斯公式）：</strong></p><p>事情已发生，已有结果，求引起这事发生的因素的可能性，由果求因，即后验概率。</p><p><strong>后验概率和先验概率的关系：</strong></p><p>后验概率的计算，是以先验概率为前提条件的。如果只知道事情结果，而不知道先验概率，是无法计算后验概率的。</p><h3 id="贝叶斯公式是什么，有什么应用"><a href="#贝叶斯公式是什么，有什么应用" class="headerlink" title="贝叶斯公式是什么，有什么应用"></a>贝叶斯公式是什么，有什么应用</h3><p>贝叶斯公式描述了两个<strong>条件概率之间的关系</strong><br>即在已知某个事件B发生的条件下，事件A发生的概率 与 在已知事件A发生的条件下，事件B发生的概率之间的关系。<br>应用：通过发生的事情，反推环境是 xx 因素的概率（原因推结果）</p><ol><li>机器学习：在机器学习中，贝叶斯方法被用于分类、聚类和预测。<br>贝叶斯分类器利用 <strong>先验概率</strong>和<strong>似然度</strong> 来 计算新实例的<strong>后验概率</strong>。</li></ol><p>贝叶斯分类器是一种统计分类方法，它使用贝叶斯定理来结合先验知识（先验概率）和新观测到的数据（似然度），从而计算出新实例的后验概率，并据此做出分类决策。以下是贝叶斯分类器如何工作的详细解释：</p><p><strong>先验概率（Prior Probability）</strong><br>先验概率是指在没有考虑新证据之前，我们对某个事件发生的概率评估。在分类问题中，先验概率通常是指各类别在数据集中出现的频率。例如，如果我们正在处理垃圾邮件分类问题，先验概率可能是垃圾邮件和非垃圾邮件在训练数据集中的比例。</p><p><strong>似然度（Likelihood）</strong><br>似然度是指在某个假设下，观测数据出现的概率。在贝叶斯分类器中，似然度是指给定类别条件下，实例特征出现的概率。例如，对于一封邮件，似然度可以是邮件中包含特定单词的概率，假设这些单词只在垃圾邮件中出现。</p><p><strong>后验概率（Posterior Probability）</strong><br>后验概率是在考虑了新证据之后，对事件发生概率的重新评估。在贝叶斯分类器中，后验概率是给定实例特征条件下，该实例属于某个类别的概率。贝叶斯定理提供了一种计算后验概率的方法：</p><p>[ P(C_k|X) &#x3D; \frac{P(X|C_k) \cdot P(C_k)}{P(X)} ]</p><p>其中：</p><ul><li>( P(C_k|X) ) 是后验概率，即给定特征集 ( X ) 的条件下，实例属于类别 ( C_k ) 的概率。</li><li>( P(X|C_k) ) 是似然度，即在类别 ( C_k ) 发生的条件下，观测到特征集 ( X ) 的概率。</li><li>( P(C_k) ) 是先验概率，即类别 ( C_k ) 的初始概率。</li><li>( P(X) ) 是边缘概率，即不考虑类别标签，观测到特征集 ( X ) 的概率，它可以通过对所有类别的似然度和先验概率乘积求和得到。</li></ul><p><strong>分类决策</strong><br>贝叶斯分类器根据后验概率来做出分类决策。具体来说，对于一个新的实例，分类器会计算该实例属于每个可能类别的后验概率，然后选择具有最高后验概率的类别作为预测结果。</p><p>贝叶斯分类器的优势在于其简单性和解释性，它可以很容易地结合领域知识（通过先验概率）和数据（通过似然度）。此外，贝叶斯分类器在处理大量特征时特别有效，尤其是在特征之间存在不确定性时。</p><ol><li>决策理论：贝叶斯决策理论通过考虑不确定性和风险来帮助做出最优决策。</li></ol><h3 id="大数定律（切比雪夫，伯努利，辛钦）"><a href="#大数定律（切比雪夫，伯努利，辛钦）" class="headerlink" title="大数定律（切比雪夫，伯努利，辛钦）"></a>大数定律（切比雪夫，伯努利，辛钦）</h3><p>大数定律是概率论中描述随机变量序列部分和行为的一组定理。它们指出，<strong>当样本数量足够大时，样本均值会趋近于总体均值</strong></p><p>当样本数据无限大时，（形式 lim n→∞ P &#x3D; 1）</p><p><strong>1. 切比雪夫大数定律</strong></p><ul><li>样本均值 → 总体均值</li><li>条件为独立；方差有限大</li><li>它提供了一个关于样本均值偏离总体均值的概率的界限</li><li>样本均值的分布会趋近于一个以总体均值为期望值的正态分布</li><li><strong>切比雪夫不等式</strong>给出了随机变量与其期望值之间的<strong>偏离程度的一个上界</strong></li></ul><p><strong>2. 伯努利大数定律</strong></p><ul><li>事件 A 发生的频率 → 概率</li><li>伯努利实验</li></ul><p><strong>3. 辛钦大数定律</strong></p><ul><li>样本均值→ 数学期望</li><li>条件为期望存在，独立同分布</li><li>样本均值几乎必然收敛到某个常数</li></ul><p><strong>大数定律应用</strong>：多次采样平均减小误差。</p><ol><li><p>参数估计的稳定性：<br>大数定律保证了随着样本数量的增加，样本均值会越来越接近总体均值。在机器学习中，这意味着当我们有<strong>足够多的训练数据时，模型参数的估计（例如，权重和偏置）会趋于稳定，减少估计误差。</strong></p></li><li><p>模型泛化能力的提高：<br>在深度学习中，大量的训练数据可以帮助模型学习到数据的普遍特征，而不是仅仅记住训练样本。大数定律表明，<strong>随着训练样本数量的增加，模型的预测误差会趋于一个常数，这有助于提高模型的泛化能力。</strong></p></li><li><p>随机梯度下降（SGD）的收敛性：<br>深度学习中常用的优化算法之一是随机梯度下降。大数定律为SGD提供了理论基础，<strong>表明随着迭代次数的增加，梯度的估计会越来越准确，从而有助于算法收敛到全局或局部最优解。</strong></p></li></ol><h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><ul><li><p>当样本量 n 逐渐趋于无穷大时，n 个抽样样本的均值的频数，逐渐趋于正态分布 N(μ, σ²&#x2F;n)。原总体的分布不做任何要求。</p></li><li><p>应用：1. 样本平均值 → 总体均值 &#x2F; 期望，2. 样本方差 → 估计总体方差。</p></li><li><p>即使原始随机变量不服从正态分布，只要它们是独立同分布的，并且具有有限的期望值和方差，它们的标准化和也会趋近于正态分布。</p></li></ul><h3 id="大数定律和中心极限定理的区别"><a href="#大数定律和中心极限定理的区别" class="headerlink" title="大数定律和中心极限定理的区别"></a>大数定律和中心极限定理的区别</h3><p>中心极限定理（Central Limit Theorem, CLT）和大数定理（Law of Large Numbers, LLN）是统计学中的两个基本概念，它们都描述了随机变量的某些性质，但它们关注的点和应用场景有所不同。</p><p><strong>大数定理</strong><br>大数定理主要关注的是随机变量的样本均值的长期稳定性。它描述了当样本量足够大时，样本均值的分布会趋近于一个固定的值，即总体均值。</p><p><strong>中心极限定理</strong><br>中心极限定理关注的是样本均值的分布形状，而不是其稳定性。无论原始总体分布如何，只要样本量足够大，样本均值的分布将趋近于正态分布。</p><p><strong>区别</strong></p><ol><li><p><strong>关注点不同</strong>：大数定理关注样本均值的稳定性，即其趋近于总体均值；中心极限定理关注样本均值分布的形状，即其趋近于正态分布。</p></li><li><p><strong>应用场景不同</strong>：大数定理常用于估计总体参数，而中心极限定理常用于统计推断，如置信区间的计算和假设检验。</p></li><li><p>大数定理指的是当样本数据量足够大的时候，样本均值会趋近于总体均值</p></li><li><p>中心极限定理指的是当原始样本数据是独立同分布的，当数据量足够多时，样本均值的分布是呈现一个正态分布</p></li></ol><h3 id="最大似然估计："><a href="#最大似然估计：" class="headerlink" title="最大似然估计："></a>最大似然估计：</h3><p>最大似然估计（MLE）是一种在已知观测数据下估计概率模型参数的方法。</p><p>它基于这样的思想：<strong>最有可能产生观测数据的参数值应该是使这些数据出现概率最大的参数值。</strong></p><p>假设我们有一个概率模型，该模型由一组参数 ( \theta ) 定义，并且我们观测到了一个数据集 ( D &#x3D; {x_1, x_2, …, x_n} )。最大似然估计试图找到参数 ( \theta ) 的值，使得数据集 ( D ) 的概率最大。</p><ul><li>概率：结果没有产生之前，根据环境参数，预测某件事情发生的可能性；</li><li>似然：在确定的结果下，去推测产生这个结果的可能环境参数。</li><li>L(θ|x) &#x3D; P(x|θ)。既然已经观测到了这个现象，就取 让它出现概率最大 的环境参数值吧。</li></ul><p>最大似然估计被用于参数估计、模型选择、假设检验等许多问题</p><h3 id="全概率公式："><a href="#全概率公式：" class="headerlink" title="全概率公式："></a>全概率公式：</h3><ul><li>样本空间 ( S )，其可以被划分成事件 A1，A2，…构成一个完备事件组（互斥且 Σ概率&#x3D;1），如果B 是 ( S )中的任意一个事件，那么 P(B) &#x3D; Σ P(B|Ai) P(Ai)。</li></ul><p>全概率公式提供了一种计算随机事件概率的方法</p><h3 id="贝叶斯公式，应用："><a href="#贝叶斯公式，应用：" class="headerlink" title="贝叶斯公式，应用："></a>贝叶斯公式，应用：</h3><ul><li>已知 B 求 A 的概率，等于 （AB 都发生概率） &#x2F; （B 发生的概率）。</li><li>应用：通过发生的事情，反推环境是 xx 因素的概率。</li></ul><h3 id="期望、方差、协方差、相关系数"><a href="#期望、方差、协方差、相关系数" class="headerlink" title="期望、方差、协方差、相关系数"></a>期望、方差、协方差、相关系数</h3><p><strong>1. 期望</strong><br>期望（E(X)）是随机变量的平均值</p><p><strong>2. 方差</strong><br>方差（D(X)）是随机变量与其期望值偏差的平方的平均值。它衡量随机变量的离散程度</p><p><strong>3. 协方差</strong><br>协方差是两个随机变量联合变化趋势的度量，表示为 ( \text{Cov}(X, Y) )。如果两个变量的增减趋势一致，协方差为正；如果一个变量增加时另一个变量减少，协方差为负。</p><p>协方差&#x2F;相关系数 为0 ，代表两个变量不相关<br>独立一定不相关，不相关不一定独立</p><p>做特征转换后，新的特征需要满足彼此不相关，体现为新特征的协方差矩阵要为一个对角矩阵</p><p><strong>4. 相关系数</strong><br>相关系数是协方差的标准化形式，用于度量两个变量之间的线性关系强度和方向。最常用的相关系数是皮尔逊相关系数，表示为 ( \rho_{X,Y} ) 或 ( r )，定义为：<br>[ \rho_{X,Y} &#x3D; \frac{\text{Cov}(X, Y)}{\sigma_X \sigma_Y} ]</p><p>在概率论和统计学中，期望、方差、协方差和相关系数是描述随机变量及其分布特征的基本概念。</p><h3 id="参数估计：无偏性、有效性、相合性"><a href="#参数估计：无偏性、有效性、相合性" class="headerlink" title="参数估计：无偏性、有效性、相合性"></a>参数估计：无偏性、有效性、相合性</h3><h3 id="离散随机变量分布"><a href="#离散随机变量分布" class="headerlink" title="离散随机变量分布"></a>离散随机变量分布</h3><p>伯努利分布、二项分布、泊松分布、超几何分布</p><p><img src="/../../img/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83.png"></p><h3 id="正态分布有什么性质"><a href="#正态分布有什么性质" class="headerlink" title="正态分布有什么性质"></a>正态分布有什么性质</h3><ol><li><p>对称性：正态分布是概率密度函数关于其均值μ的对称分布，即在平均值两侧呈镜像对称。</p></li><li><p>唯一峰值：正态分布的概率密度函数呈现单峰形状，只有一个最高峰值。</p></li><li><p>分布范围无界：正态分布的取值范围是负无穷到正无穷，没有明确的上下界限。</p></li><li><p>标准差决定形状：正态分布的形状由其标准差σ决定。较小的标准差会使曲线更加陡峭，较大的标准差会使曲线更加平坦。</p></li><li><p>68-95-99.7 规则：在正态分布中，约有68%的观测值落在均值的一个标准差范围内（( \mu ) - ( \sigma )），约有95%的观测值落在两个标准差范围内，约有99.7%的观测值落在三个标准差范围内。</p></li></ol><p>其中：</p><ul><li>( x ) 是随机变量。</li><li>( \mu ) 是分布的均值（或数学期望）。</li><li>( \sigma^2 ) 是分布的方差。</li><li>( \sigma ) 是标准差。</li></ul><p>正态分布的概率密度函数图像呈对称的钟形曲线，均值( \mu )决定了曲线的中心位置，标准差( \sigma )决定了曲线的宽度。</p><p><strong>标准正态分布</strong>：当( \mu &#x3D; 0 )且( \sigma &#x3D; 1 )时，正态分布称为标准正态分布。其概率密度函数为：</p><p>[<br>f(x) &#x3D; \frac{1}{\sqrt{2\pi}} e^{-\frac{x^2}{2}}<br>]</p><ol start="6"><li>中心极限定理：多个随机变量的总和（或平均值）趋向于正态分布，即使原始随机变量不满足正态分布，这是中心极限定理的重要推论。</li></ol><h2 id="P问题、NP问题以及NP完全问题"><a href="#P问题、NP问题以及NP完全问题" class="headerlink" title="P问题、NP问题以及NP完全问题"></a>P问题、NP问题以及NP完全问题</h2><p>P问题是可以在多项式时间内解决的问题</p><p>NP问题是可以在多项式时间内<strong>验证</strong>解的正确性的问题</p><p>NP完全问题是一类特殊的NP问题，没有已知的高效解决算法，并且可以在多项式时间内归约到任何其他的NP问题</p><h2 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h2><p>矩阵分解是将一个矩阵表示为一些特定形式的矩阵乘积的过程。</p><p>矩阵分解的种类以及物理意义：</p><ul><li><p>LU分解：将矩阵分解为一个下三角矩阵和一个上三角矩阵的乘积。物理意义包括解线性方程组、计算矩阵的行列式和逆矩阵等。</p></li><li><p>QR分解：将矩阵分解为一个正交矩阵和一个上三角矩阵的乘积。物理意义包括最小二乘问题、矩阵的特征值计算等。</p></li><li><p>特征值分解：将矩阵分解为一个特征向量矩阵和一个对角矩阵的乘积。物理意义包括矩阵的幂、指数和对称矩阵的对角化等。</p></li><li><p>奇异值分解（SVD）：将矩阵分解为一个正交矩阵、一个对角矩阵和一个正交矩阵的乘积。物理意义包括降维、矩阵逼近和图像压缩等。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>保研专业课面试题库</title>
    <link href="/2024/06/05/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E4%BF%9D%E7%A0%94%E4%B8%93%E4%B8%9A%E8%AF%BE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    <url>/2024/06/05/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E4%BF%9D%E7%A0%94%E4%B8%93%E4%B8%9A%E8%AF%BE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b9d745ce5430034401e54bd8d7ceb8d8b19949c7f34bccb0ea71edfef8ded300">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df1c35a3996ffa16c4fcd08799576700447be7fd463907e30c80b967e673ae80b43882bcb95cb3f6f354ca65cd1495e031b4a3abe7bbbbc4f02fabb8dd1937e8172251c681c585fcdfedb8d13d522a5de294e1f41b6a1b446136bb10e4199ec397317f7e1485e687171822ffde876fdbcb6c0991d8eca89709608aa682e4cfd69ae41902bc935cff52f02a33f06c3fa4405e6e62834d4e93565b0acc21d1f70c51153e95b4185a9b5dcb9c56502f9ce255d04aed5afe10f8267e7169373060311998e6fe23bc6e7f9d9642613e5f63afc1c0263d9d5545641409b2d554a5e513dd931bc6e71832b68e8486ba82b3d0c26cc092b7d89393b2805e7ced2e756fce66b28aad6a0692a3d69019e3740eae5cd8d6263d20c9c421b70171f4ed4593bdb05f7f4d739703c3bbe13430b7c02a357b11011c8a93902d926b34d90dc19f16384765538dfb34a457d348cdc10b51cb24ce04eeac9efaf9a0f1b752db0322a0203f43fff36cf766cffbe0836640a1d09f4777ca6747fd858d58424e93b63e8b19b4364b634637bdb0bfea0929d27006e0daacba15298f6187c9e8154930ae4c714f84af1bb86661477522bd24840154c2508c6687829dfa06e1d8334d309e309a9ef1d5ebcf0b08a970c59356d3f772c6235e1ff68f687d3b917b5cd389c9c5ed</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>概率论与数理统计</title>
    <link href="/2024/06/04/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    <url>/2024/06/04/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><h3 id="概率计算公式"><a href="#概率计算公式" class="headerlink" title="概率计算公式"></a>概率计算公式</h3><p><strong>1. 加法公式</strong></p><p>加法公式用于计算两个事件<strong>至少有一个发生的概率</strong> ，即事件A或事件B发生的概率。</p><p>如果事件A和事件B不是互斥的，那么需要减去它们同时发生的概率，以避免重复计算：<br>[ P(A \cup B) &#x3D; P(A) + P(B) - P(A \cap B) ]</p><p>如果事件A和事件B是<strong>互斥的（即它们不能同时发生）</strong>，那么加法公式可以表示为：<br>[ P(A \cup B) &#x3D; P(A) + P(B) ]</p><p>其中：</p><ul><li>( P(A \cup B) ) 是事件A或事件B发生的概率。</li><li>( P(A) ) 是事件A发生的概率。</li><li>( P(B) ) 是事件B发生的概率。</li><li>( P(A \cap B) ) 是事件A和事件B同时发生的概率。</li></ul><p><strong>2. 乘法公式</strong></p><p>乘法公式用于计算两个事件<strong>同时发生的概率</strong>，即事件A和事件B的联合概率。</p><p>如果事件A和事件B不是独立的，那么需要使用条件概率来计算它们的联合概率：<br>[ P(A \cap B) &#x3D; P(A) \times P(B | A) ]<br>或者<br>[ P(A \cap B) &#x3D; P(B) \times P(A | B) ]</p><p>如果事件<strong>A和B是独立的</strong>，那么它们的联合概率可以通过它们各自的概率相乘得到：<br>[ P(A \cap B) &#x3D; P(A) \times P(B) ]</p><p>其中：</p><ul><li>( P(A \cap B) ) 是事件A和事件B同时发生的概率。</li><li>( P(B | A) ) 是在事件A发生的条件下事件B发生的概率，即条件概率。</li><li>( P(A | B) ) 是在事件B发生的条件下事件A发生的概率。</li></ul><p><strong>3. 全概率公式（原因推结果）</strong></p><p>全概率公式用于计算一个事件的结果，当这个事件是由多个互斥原因引起的。如果事件A是由多个互斥的子事件B1, B2, …, Bn引起的，那么事件A发生的概率可以通过以下公式计算：<br>[ P(A) &#x3D; P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + \ldots + P(A|B_n)P(B_n) ]<br>其中：</p><ul><li>( P(A) ) 是事件A发生的概率。</li><li>( P(B_i) ) 是第i个原因发生的概率。</li><li>( P(A|B_i) ) 是在第i个原因发生的条件下，事件A发生的概率。</li></ul><p>全概率公式允许我们通过已知的各个原因的概率和它们导致结果的条件概率，来计算结果发生的概率</p><p><strong>4. 贝叶斯公式（结果推原因）</strong></p><p>贝叶斯公式是一种逆概率计算方法，它允许我们根据已知的结果来推断原因的概率。贝叶斯公式可以表示为：<br>[ P(B_i|A) &#x3D; \frac{P(A|B_i)P(B_i)}{P(A)} ]<br>其中：</p><ul><li>( P(B_i|A) ) 是在事件A发生的条件下，原因Bi发生的概率。</li><li>( P(A|B_i) ) 是在原因Bi发生的条件下，事件A发生的概率。</li><li>( P(B_i) ) 是原因Bi发生的概率。</li><li>( P(A) ) 是事件A发生的概率。</li></ul><p>贝叶斯公式的核心思想是，通过已知的事件A发生的条件概率和原因的概率，以及事件A发生的概率，来计算在事件A发生的情况下，各个原因发生的概率。</p><p>这两个公式在处理不确定性和进行决策时非常有用，特别是在我们只有部分信息的情况下。例如，在医学诊断、风险评估、机器学习中的分类问题等领域，全概率公式和贝叶斯公式都发挥着重要作用。</p><h3 id="事件独立性"><a href="#事件独立性" class="headerlink" title="事件独立性"></a>事件独立性</h3><h2 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h2><h3 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h3><p><img src="/../../img/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83.png"></p><p><strong>1. 伯努利分布（0-1分布）</strong></p><p>描述了只有两种可能结果（成功和失败，通常用1和0表示）的单次随机试验。</p><p><strong>2. 二项分布（n重 伯努利分布）</strong></p><p>描述了固定次数 𝑛的独立重复的伯努利试验中成功的次数。</p><p><strong>3. 几何分布</strong></p><p>描述了在一系列独立的伯努利试验中，得到第一次成功所需的试验次数。<br>意义：n 次伯努利试验中前 k-1 次皆失败，第 k 次成功的概率。</p><p><strong>4. 泊松分布（0-1分布）</strong></p><p>二项分布的极限。期望和方差均为λ。<br>当二项分布 n 很大 p 很小时，泊松分布可作为二项分布的近似，其中 λ 为 np。</p><p>参数 λ 是单位时间(或单位面积)内随机事件的平均发生次数，满足线性相加（2 倍单位时间内…服从 2λ分布）。</p><p>泊松分布适合于描述单位时间内随机事件发生的次数</p><h3 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h3><p>概率论与数理统计中的均匀分布、指数分布和正态分布是三种非常重要的连续概率分布，它们在不同的领域和情境下有着广泛的应用。</p><p><strong>均匀分布（Uniform Distribution）</strong><br>均匀分布是一种最简单的连续概率分布，其中随机变量在某个区间内取任何值的概率是相同的。如果随机变量 ( X ) 在区间 ( [a, b] ) 上服从均匀分布，其概率密度函数（PDF）为：<br>[ f(x) &#x3D; \begin{cases}<br>\frac{1}{b - a} &amp; \text{for } a \leq x \leq b, \<br>0 &amp; \text{otherwise.}<br>\end{cases} ]</p><p>均匀分布的特点：</p><ul><li>概率密度在区间 ( [a, b] ) 上是恒定的。</li><li>区间外的概率密度为0。</li><li>随机变量的期望值 ( E(X) ) 为 ( \frac{a + b}{2} )。</li><li>方差 ( \text{Var}(X) ) 为 ( \frac{(b - a)^2}{12} )。</li></ul><p><strong>指数分布（Exponential Distribution）</strong><br>指数分布是一种单参数的连续概率分布，常用于描述独立随机事件发生的时间间隔。如果随机变量 ( X ) 服从参数为 ( \lambda ) 的指数分布，其概率密度函数为：<br>[ f(x) &#x3D; \lambda e^{-\lambda x} \quad \text{for } x \geq 0 ]<br>其中 ( \lambda &gt; 0 )。</p><p>指数分布的特点：</p><ul><li>它没有记忆性，即指数分布的随机变量的持续时间不依赖于已经经过的时间。</li><li>期望值 ( E(X) ) 为 ( \frac{1}{\lambda} )。</li><li>方差 ( \text{Var}(X) ) 为 ( \frac{1}{\lambda^2} )。</li></ul><p><strong>正态分布（Normal Distribution）</strong><br>正态分布，也称为高斯分布，是连续概率分布中最重要的一种。它在自然科学和社会科学的许多领域中都有应用。如果随机变量 ( X ) 服从均值为 ( \mu )，方差为 ( \sigma^2 ) 的正态分布，其概率密度函数为：<br>[ f(x) &#x3D; \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{(x - \mu)^2}{2\sigma^2}} ]</p><p>正态分布的特点：</p><ul><li>它是对称的，并且以均值 ( \mu ) 为中心。</li><li>大部分数据集中在均值附近，数据的分布呈现钟形曲线。</li><li>期望值 ( E(X) )、中位数和众数都等于 ( \mu )。</li><li>方差 ( \text{Var}(X) ) 为 ( \sigma^2 )。</li><li>68-95-99.7 规则（经验法则）表明，在正态分布中，约68%的数据落在 ( \mu \pm \sigma ) 区间内，约95%落在 ( \mu \pm 2\sigma ) 区间内，约99.7%落在 ( \mu \pm 3\sigma ) 区间内。</li></ul><p>这三种分布各自有其独特的性质和应用场景。均匀分布常用于描述在一定范围内等可能发生的事件；指数分布适用于描述泊松过程中事件之间的时间间隔；正态分布则因其优美的数学性质和中心极限定理，在统计推断和数据分析中扮演着核心角色。</p><h2 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h2><p>大数定律是概率论和数理统计中的一个基本概念，它描述了在一定条件下，<strong>随着样本量的增加，样本均值会越来越接近总体均值的性质。</strong> 大数定律保证了在大量重复实验中，随机变量的相对频率趋近于其概率。</p><h3 id="大数定律的两种形式"><a href="#大数定律的两种形式" class="headerlink" title="大数定律的两种形式"></a>大数定律的两种形式</h3><ol><li><strong>切比雪夫大数定律（Chebyshev’s Law of Large Numbers）</strong><br>切比雪夫大数定律是大数定律的一个较弱的形式，它适用于具有相同期望值和有限方差的随机变量序列。它指出，对于一列独立同分布（i.i.d.）的随机变量 ( X_1, X_2, \ldots )，如果它们的期望值 ( \mu ) 和方差 ( \sigma^2 ) 都存在，则样本均值 ( \overline{X}<em>n &#x3D; \frac{1}{n} \sum</em>{i&#x3D;1}^n X_i ) 会随着 ( n ) 的增加而趋近于 ( \mu )。具体来说，对于任意正数 ( \varepsilon &gt; 0 )，有：<br>[ P\left(|\overline{X}_n - \mu| \geq \varepsilon\right) \leq \frac{\sigma^2}{n \varepsilon^2} ]</li></ol><p><strong>1. 切比雪夫大数定律</strong><br>适用于<strong>独立同分布</strong>的随机变量序列</p><p>设 ( X_1, X_2, \ldots ) 是一列具有相同期望值 ( \mu ) 和有限方差 ( \sigma^2 ) 的独立随机变量。则对于任意 ( \varepsilon &gt; 0 )，当 ( n ) 趋于无穷大时，有：<br>[ P\left(|\bar{X}_n - \mu| \geq \varepsilon\right) \to 0 ]<br>其中，( \bar{X}_n ) 是样本均值，( n ) 是样本数量。</p><p><strong>2. 伯努利大数定律</strong><br>伯努利大数定律是切比雪夫大数定律的一个特例，<strong>适用于伯努利试验（即只有两种可能结果的独立试验）</strong> 定理表述如下：</p><p>设 ( X_1, X_2, \ldots ) 是一列独立同分布的伯努利随机变量，其成功概率为 ( p )。则当 ( n ) 趋于无穷大时，样本均值 ( \bar{X}<em>n ) 几乎几乎必然收敛于 ( p )，即：<br>[ P\left(\lim</em>{n \to \infty} \bar{X}_n &#x3D; p\right) &#x3D; 1 ]</p><p><strong>3. 辛钦大数定律</strong><br>设 ( X_1, X_2, \ldots ) 是一列独立随机变量，它们具有有限的期望值 ( \mu_i )（但 ( \mu_i ) 可以不同）。如果存在常数 ( C ) 使得对于所有的 ( i )，都有 ( |\mu_i| \leq C )，则样本均值 ( \bar{X}<em>n ) 几乎必然收敛于某个常数 ( \mu )，即：<br>[ P\left(\lim</em>{n \to \infty} \bar{X}_n &#x3D; \mu\right) &#x3D; 1 ]</p><ol start="2"><li><strong>中心极限定理（Central Limit Theorem, CLT）</strong><br>中心极限定理是大数定律的一个更强的形式，它说明了在适当的条件下，大量独立同分布的随机变量之和经过标准化后趋近于正态分布。无论原始随机变量本身服从何种分布，只要它们具有相同的期望值 ( \mu ) 和方差 ( \sigma^2 )，它们的样本均值的分布会随着样本量的增加而趋近于正态分布 ( N(\mu, \frac{\sigma^2}{n}) )。具体来说，对于任意 ( z ) 值，当 ( n ) 足够大时，有：<br>[ P\left(\frac{\overline{X}_n - \mu}{\sigma&#x2F;\sqrt{n}} \leq z\right) \approx \Phi(z) ]<br>其中，( \Phi(z) ) 是标准正态分布的累积分布函数。</li></ol><h3 id="大数定律在深度学习中的应用"><a href="#大数定律在深度学习中的应用" class="headerlink" title="大数定律在深度学习中的应用"></a>大数定律在深度学习中的应用</h3><ol><li><p>参数估计的稳定性：<br>大数定律保证了随着样本数量的增加，样本均值会越来越接近总体均值。在机器学习中，这意味着当我们有<strong>足够多的训练数据时，模型参数的估计（例如，权重和偏置）会趋于稳定，减少估计误差。</strong></p></li><li><p>模型泛化能力的提高：<br>在深度学习中，大量的训练数据可以帮助模型学习到数据的普遍特征，而不是仅仅记住训练样本。大数定律表明，<strong>随着训练样本数量的增加，模型的预测误差会趋于一个常数，这有助于提高模型的泛化能力。</strong></p></li><li><p>随机梯度下降（SGD）的收敛性：<br>深度学习中常用的优化算法之一是随机梯度下降。大数定律为SGD提供了理论基础，<strong>表明随着迭代次数的增加，梯度的估计会越来越准确，从而有助于算法收敛到全局或局部最优解。</strong></p></li><li><p>正则化技术的合理性：<br>为了防止模型过拟合，机器学习中经常使用L1或L2正则化。大数定律支持了这些正则化方法的有效性，因为它表明在大样本条件下，正则化项可以帮助我们更好地估计模型参数。</p></li><li><p>集成学习中的投票机制：<br>在集成学习方法中，多个模型的预测结果会通过投票或平均等方式结合起来。大数定律在这里确保了，随着集成中模型数量的增加，最终的预测结果会越来越可靠。</p></li></ol><h2 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h2><h3 id="概率论和数理统计的区别与联系"><a href="#概率论和数理统计的区别与联系" class="headerlink" title="概率论和数理统计的区别与联系"></a>概率论和数理统计的区别与联系</h3><ul><li>概率论：更数学，从已知形式或某些参数的 分布 &#x2F; 随机变量入手，推断出另一者的性质，比如 已知分布形式 求期望方差，已知随机变量参数 估计分布期望方差（大数定律 中心极限定理 这是数理统计的基础），已知事件间关系建模 求概率（全概率公式 贝叶斯公式）。</li><li>数理统计：更偏应用，基础是概率论，是概率论的应用，从实际出发，从采样出发，主要内容有参数估计、假设检验等。</li><li>知和用的关系。一个是发现规律，构造模型，证明定理。一个是选择模型，调整模型，应用模型。</li></ul><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><p>概率密度函数是连续随机变量分布的描述方式。连续随机变量的取值范围是无限的，因此不能简单地计算每个具体值的概率，而是需要一个函数来描述在任意一点上随机变量取值的概率密度。</p><p>概率密度函数（Probability Density Function，简称PDF）是连续随机变量分布的描述方式。与离散随机变量使用概率质量函数（Probability Mass Function，简称PMF）不同，连续随机变量的取值范围是无限的，因此不能简单地计算每个具体值的概率，而是需要一个函数来描述在任意一点上随机变量取值的概率密度。</p><p><strong>概率密度函数的定义</strong><br>对于连续随机变量 ( X )，其概率密度函数 ( f(x) ) 定义如下：</p><ul><li>对于任意的 ( x )，( f(x) \geq 0 )（非负性）。</li><li>随机变量 ( X ) 在区间 ( [a, b] ) 内取值的概率可以表示为该区间下概率密度函数的积分：( P(a \leq X \leq b) &#x3D; \int_{a}^{b} f(x) , dx )。</li><li>随机变量 ( X ) 取某个具体值 ( x_0 ) 的概率为零，即 ( P(X &#x3D; x_0) &#x3D; 0 )。</li><li>随机变量 ( X ) 在整个值域内取值的概率为1，即 ( P(-\infty &lt; X &lt; \infty) &#x3D; \int_{-\infty}^{\infty} f(x) , dx &#x3D; 1 )（归一性）。</li></ul><p><strong>概率密度函数的性质</strong></p><ol><li><strong>非负性</strong>：概率密度函数的值在定义域内必须非负。</li><li><strong>归一性</strong>：概率密度函数在整个定义域上的积分等于1，表示随机变量在整个值域内取值的概率之和为100%。</li><li><strong>概率计算</strong>：随机变量在某个区间取值的概率可以通过概率密度函数在该区间上的积分来计算。</li><li><strong>期望值（均值）</strong>：连续随机变量的期望值可以通过概率密度函数计算得到：<br>[ E(X) &#x3D; \int_{-\infty}^{\infty} x \cdot f(x) , dx ]</li><li><strong>方差</strong>：连续随机变量的方差也可以通过概率密度函数来计算：<br>[ \text{Var}(X) &#x3D; E[(X - E(X))^2] &#x3D; \int_{-\infty}^{\infty} (x - E(X))^2 \cdot f(x) , dx ]</li><li><strong>累积分布函数（CDF）</strong>：连续随机变量的累积分布函数是概率密度函数的积分：<br>[ F(x) &#x3D; P(X \leq x) &#x3D; \int_{-\infty}^{x} f(t) , dt ]</li></ol><p>概率密度函数是连续概率分布的核心，它在统计学、概率论和相关领域中有着广泛的应用。通过概率密度函数，我们可以对连续随机变量的行为进行详细的分析和预测。</p><h3 id="条件概率分布、联合概率分布、边缘概率分布"><a href="#条件概率分布、联合概率分布、边缘概率分布" class="headerlink" title="条件概率分布、联合概率分布、边缘概率分布"></a>条件概率分布、联合概率分布、边缘概率分布</h3><p>条件概率：B 发生的情况下 A 发生的概率。<br>联合概率：几个事件同时发生的概率<br>边缘概率：某个事件单独发生的概率，仅与单个随机变量有关的概率，剩下维度按分布求期望。<br>能否直接由边缘分布函数求得联合分布函数：两随机变量不相互独立 则不行</p><p><strong>条件概率分布</strong><br>条件概率分布是指在某个事件已经发生的条件下，另一个事件发生的概率分布。条件概率分布通常用条件概率密度函数（连续变量）或条件概率质量函数（离散变量）来描述。</p><p>对于连续随机变量 ( X ) 和 ( Y )，条件概率密度函数 ( f_{X|Y}(x|y) ) 定义为：<br>[ f_{X|Y}(x|y) &#x3D; \frac{f_{X,Y}(x,y)}{f_Y(y)} ]<br>其中：</p><ul><li>( f_{X,Y}(x,y) ) 是 ( X ) 和 ( Y ) 的联合概率密度函数。</li><li>( f_Y(y) ) 是 ( Y ) 的边缘概率密度函数。</li></ul><p>对于离散随机变量，条件概率质量函数 ( P(X &#x3D; x | Y &#x3D; y) ) 同样定义为：<br>[ P(X &#x3D; x | Y &#x3D; y) &#x3D; \frac{P(X &#x3D; x, Y &#x3D; y)}{P(Y &#x3D; y)} ]</p><p><strong>联合概率分布</strong><br>联合概率分布描述了两个或多个随机变量共同取特定值的概率。对于连续随机变量，联合概率密度函数 ( f_{X,Y}(x,y) ) 描述了 ( X ) 和 ( Y ) 同时取值 ( x ) 和 ( y ) 的概率密度。对于离散随机变量，联合概率质量函数 ( P(X &#x3D; x, Y &#x3D; y) ) 描述了 ( X ) 和 ( Y ) 同时取值 ( x ) 和 ( y ) 的概率。</p><p><strong>边缘概率分布</strong><br>边缘概率分布是指在多个随机变量的联合分布中，通过求和或积分，得到的单个随机变量的概率分布。它表示了忽略其他变量的情况下，一个随机变量的概率分布。</p><p>对于连续随机变量 ( X ) 和 ( Y )，( X ) 的边缘概率密度函数 ( f_X(x) ) 可以通过对 ( Y ) 的所有可能取值积分 ( X ) 和 ( Y ) 的联合概率密度函数来得到：<br>[ f_X(x) &#x3D; \int_{-\infty}^{\infty} f_{X,Y}(x,y) , dy ]</p><p>对于离散随机变量，( X ) 的边缘概率质量函数 ( P(X &#x3D; x) ) 可以通过对 ( Y ) 的所有可能取值求和 ( X ) 和 ( Y ) 的联合概率质量函数来得到：<br>[ P(X &#x3D; x) &#x3D; \sum_{y} P(X &#x3D; x, Y &#x3D; y) ]</p><h3 id="贝叶斯公式是什么，有什么应用"><a href="#贝叶斯公式是什么，有什么应用" class="headerlink" title="贝叶斯公式是什么，有什么应用"></a>贝叶斯公式是什么，有什么应用</h3><p>贝叶斯公式描述了两个<strong>条件概率之间的关系</strong><br>即在已知某个事件B发生的条件下，事件A发生的概率 与 在已知事件A发生的条件下，事件B发生的概率之间的关系。<br>应用：通过发生的事情，反推环境是 xx 因素的概率（原因推结果）</p><ol><li>机器学习：在机器学习中，贝叶斯方法被用于分类、聚类和预测。贝叶斯分类器利用<strong>先验概率</strong>和<strong>似然度</strong>来计算新实例的后验概率。</li></ol><p>贝叶斯分类器是一种统计分类方法，它使用贝叶斯定理来结合先验知识（先验概率）和新观测到的数据（似然度），从而计算出新实例的后验概率，并据此做出分类决策。以下是贝叶斯分类器如何工作的详细解释：</p><p><strong>先验概率（Prior Probability）</strong><br>先验概率是指在没有考虑新证据之前，我们对某个事件发生的概率评估。在分类问题中，先验概率通常是指各类别在数据集中出现的频率。例如，如果我们正在处理垃圾邮件分类问题，先验概率可能是垃圾邮件和非垃圾邮件在训练数据集中的比例。</p><p><strong>似然度（Likelihood）</strong><br>似然度是指在某个假设下，观测数据出现的概率。在贝叶斯分类器中，似然度是指给定类别条件下，实例特征出现的概率。例如，对于一封邮件，似然度可以是邮件中包含特定单词的概率，假设这些单词只在垃圾邮件中出现。</p><p><strong>后验概率（Posterior Probability）</strong><br>后验概率是在考虑了新证据之后，对事件发生概率的重新评估。在贝叶斯分类器中，后验概率是给定实例特征条件下，该实例属于某个类别的概率。贝叶斯定理提供了一种计算后验概率的方法：</p><p>[ P(C_k|X) &#x3D; \frac{P(X|C_k) \cdot P(C_k)}{P(X)} ]</p><p>其中：</p><ul><li>( P(C_k|X) ) 是后验概率，即给定特征集 ( X ) 的条件下，实例属于类别 ( C_k ) 的概率。</li><li>( P(X|C_k) ) 是似然度，即在类别 ( C_k ) 发生的条件下，观测到特征集 ( X ) 的概率。</li><li>( P(C_k) ) 是先验概率，即类别 ( C_k ) 的初始概率。</li><li>( P(X) ) 是边缘概率，即不考虑类别标签，观测到特征集 ( X ) 的概率，它可以通过对所有类别的似然度和先验概率乘积求和得到。</li></ul><p><strong>分类决策</strong><br>贝叶斯分类器根据后验概率来做出分类决策。具体来说，对于一个新的实例，分类器会计算该实例属于每个可能类别的后验概率，然后选择具有最高后验概率的类别作为预测结果。</p><p>贝叶斯分类器的优势在于其简单性和解释性，它可以很容易地结合领域知识（通过先验概率）和数据（通过似然度）。此外，贝叶斯分类器在处理大量特征时特别有效，尤其是在特征之间存在不确定性时。</p><ol start="2"><li>决策理论：贝叶斯决策理论通过考虑不确定性和风险来帮助做出最优决策。</li></ol><h3 id="大数定律（切比雪夫，伯努利，辛钦）"><a href="#大数定律（切比雪夫，伯努利，辛钦）" class="headerlink" title="大数定律（切比雪夫，伯努利，辛钦）"></a>大数定律（切比雪夫，伯努利，辛钦）</h3><p>大数定律是概率论中描述随机变量序列部分和行为的一组定理。它们指出，<strong>当样本数量足够大时，样本均值会趋近于总体均值</strong></p><p>当样本数据无限大时，（形式 lim n→∞ P &#x3D; 1）</p><p><strong>1. 切比雪夫大数定律</strong></p><ul><li>样本均值 → 总体均值</li><li>条件为独立同分布；方差有限大</li><li>它提供了一个关于样本均值偏离总体均值的概率的界限</li><li>样本均值的分布会趋近于一个以总体均值为期望值的正态分布</li></ul><p><strong>2. 伯努利大数定律</strong></p><ul><li>事件 A 发生的频率 → 概率</li><li>伯努利实验</li></ul><p><strong>3. 辛钦大数定律</strong></p><ul><li>样本均值→ 数学期望</li><li>条件为期望存在</li><li>样本均值几乎必然收敛到某个常数</li></ul><p><strong>大数定律应用</strong>：多次采样平均减小误差。</p><ol><li><p>参数估计的稳定性：<br>大数定律保证了随着样本数量的增加，样本均值会越来越接近总体均值。在机器学习中，这意味着当我们有<strong>足够多的训练数据时，模型参数的估计（例如，权重和偏置）会趋于稳定，减少估计误差。</strong></p></li><li><p>模型泛化能力的提高：<br>在深度学习中，大量的训练数据可以帮助模型学习到数据的普遍特征，而不是仅仅记住训练样本。大数定律表明，<strong>随着训练样本数量的增加，模型的预测误差会趋于一个常数，这有助于提高模型的泛化能力。</strong></p></li><li><p>随机梯度下降（SGD）的收敛性：<br>深度学习中常用的优化算法之一是随机梯度下降。大数定律为SGD提供了理论基础，<strong>表明随着迭代次数的增加，梯度的估计会越来越准确，从而有助于算法收敛到全局或局部最优解。</strong></p></li></ol><h3 id="期望、方差、协方差、相关系数"><a href="#期望、方差、协方差、相关系数" class="headerlink" title="期望、方差、协方差、相关系数"></a>期望、方差、协方差、相关系数</h3><p>在概率论和统计学中，期望、方差、协方差和相关系数是描述随机变量及其分布特征的基本概念。</p><h4 id="期望（Expected-Value）"><a href="#期望（Expected-Value）" class="headerlink" title="期望（Expected Value）"></a>期望（Expected Value）</h4><p>期望是随机变量的平均值，表示为 ( E(X) ) 或 ( \mu )。对于离散随机变量，期望定义为：<br>[ E(X) &#x3D; \sum_{i&#x3D;1}^{\infty} x_i P(X &#x3D; x_i) ]<br>对于连续随机变量，期望定义为：<br>[ E(X) &#x3D; \int_{-\infty}^{\infty} x f_X(x) , dx ]<br>其中，( x_i ) 是随机变量 ( X ) 可能取到的值，( P(X &#x3D; x_i) ) 是 ( X ) 取到 ( x_i ) 的概率，( f_X(x) ) 是 ( X ) 的概率密度函数。</p><h4 id="方差（Variance）"><a href="#方差（Variance）" class="headerlink" title="方差（Variance）"></a>方差（Variance）</h4><p>方差是随机变量与其期望值偏差的平方的平均值，表示为 ( \text{Var}(X) ) 或 ( \sigma^2 )。它衡量随机变量的离散程度。方差的定义为：<br>[ \text{Var}(X) &#x3D; E[(X - E(X))^2] &#x3D; \sum_{i&#x3D;1}^{\infty} (x_i - \mu)^2 P(X &#x3D; x_i) ]<br>对于连续随机变量：<br>[ \text{Var}(X) &#x3D; \int_{-\infty}^{\infty} (x - \mu)^2 f_X(x) , dx ]</p><h4 id="协方差（Covariance）"><a href="#协方差（Covariance）" class="headerlink" title="协方差（Covariance）"></a>协方差（Covariance）</h4><p>协方差是两个随机变量联合变化趋势的度量，表示为 ( \text{Cov}(X, Y) )。如果两个变量的增减趋势一致，协方差为正；如果一个变量增加时另一个变量减少，协方差为负。协方差的定义为：<br>[ \text{Cov}(X, Y) &#x3D; E[(X - E(X))(Y - E(Y))] ]<br>[ \text{Cov}(X, Y) &#x3D; \sum_{i&#x3D;1}^{\infty} \sum_{j&#x3D;1}^{\infty} (x_i - \mu_X)(y_j - \mu_Y) P(X &#x3D; x_i, Y &#x3D; y_j) ]<br>对于连续随机变量：<br>[ \text{Cov}(X, Y) &#x3D; \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} (x - \mu_X)(y - \mu_Y) f_{X,Y}(x, y) , dx , dy ]</p><h4 id="相关系数（Correlation-Coefficient）"><a href="#相关系数（Correlation-Coefficient）" class="headerlink" title="相关系数（Correlation Coefficient）"></a>相关系数（Correlation Coefficient）</h4><p>相关系数是协方差的标准化形式，用于度量两个变量之间的线性关系强度和方向。最常用的相关系数是皮尔逊相关系数，表示为 ( \rho_{X,Y} ) 或 ( r )，定义为：<br>[ \rho_{X,Y} &#x3D; \frac{\text{Cov}(X, Y)}{\sigma_X \sigma_Y} ]<br>其中，( \sigma_X ) 和 ( \sigma_Y ) 分别是 ( X ) 和 ( Y ) 的标准差。相关系数的取值范围在 -1 和 1 之间，其中 1 表示完全正相关，-1 表示完全负相关，0 表示没有线性相关。</p><p>这些统计量是理解和分析数据集的基础，它们在统计推断、风险评估、投资组合管理、机器学习等多种领域中都有重要应用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2024/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2024/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">//哈希表统计数据</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; a; <span class="hljs-comment">//vector的sort来排序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            st[nums[i]] ++;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> it = st.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it != st.<span class="hljs-built_in">end</span>()) &#123;<br>            a.<span class="hljs-built_in">push_back</span>(&#123;it-&gt;second,it-&gt;first&#125;);<br>            it ++;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            res.<span class="hljs-built_in">push_back</span>(a[i].second);<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mamba Out</title>
    <link href="/2024/06/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Mamba-Out/"/>
    <url>/2024/06/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Mamba-Out/</url>
    
    <content type="html"><![CDATA[<h1 id="Mamba"><a href="#Mamba" class="headerlink" title="Mamba"></a>Mamba</h1><p><a href="https://blog.csdn.net/v_JULY_v/article/details/134923301">一文通透想颠覆Transformer的Mamba：从SSM、HiPPO、S4到Mamba</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正则化</title>
    <link href="/2024/06/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <url>/2024/06/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><h2 id="L1和L2正则化"><a href="#L1和L2正则化" class="headerlink" title="L1和L2正则化"></a>L1和L2正则化</h2><p>L1和L2正则化是机器学习和深度学习中常用的两种技术，它们用于控制模型的复杂度，防止过拟合，并提高模型的泛化能力。这两种正则化方法通过在损失函数中添加一个额外的惩罚项来实现，该惩罚项与模型参数的大小相关。下面是L1和L2正则化的详细解释：</p><h3 id="L2正则化（岭回归，Tikhonov正则化）"><a href="#L2正则化（岭回归，Tikhonov正则化）" class="headerlink" title="L2正则化（岭回归，Tikhonov正则化）"></a>L2正则化（岭回归，Tikhonov正则化）</h3><p>L2正则化，也称为欧几里得范数正则化，通过惩罚参数的平方和来工作。它的目标是使参数值尽可能小，从而限制模型的复杂度。</p><p><strong>数学表达式</strong>：<br>[ L_{2} &#x3D; \lambda \sum_{i&#x3D;1}^{n} w_i^2 ]</p><p>其中，( w_i ) 是模型参数，( \lambda ) 是正则化系数（一个超参数），控制着正则化项的强度，( n ) 是参数的总数。</p><p><strong>特点</strong>：</p><ul><li>L2正则化倾向于让参数值接近于0，但不会变成0。</li><li>它倾向于产生平滑的权重分布。</li><li>L2正则化可以被看作是高斯先验的贝叶斯推断。</li></ul><h3 id="L1正则化（Lasso回归）"><a href="#L1正则化（Lasso回归）" class="headerlink" title="L1正则化（Lasso回归）"></a>L1正则化（Lasso回归）</h3><p>L1正则化，也称为拉普拉斯范数正则化，通过惩罚参数的绝对值之和来工作。与L2正则化不同，L1正则化可以产生稀疏权重矩阵，即模型参数中的一部分会变为0。</p><p><strong>数学表达式</strong>：<br>[ L_{1} &#x3D; \lambda \sum_{i&#x3D;1}^{n} |w_i| ]</p><p>其中，( w_i ) 是模型参数，( \lambda ) 是正则化系数，( n ) 是参数的总数。</p><p><strong>特点</strong>：</p><ul><li>L1正则化倾向于产生稀疏解，即模型参数中的一些元素可以被驱动为0。</li><li>这使得L1正则化具有特征选择的能力，因为它可以自动地将不重要的特征的权重设置为0。</li><li>L1正则化可以被看作是拉普拉斯先验的贝叶斯推断。</li></ul><h3 id="正则化的选择"><a href="#正则化的选择" class="headerlink" title="正则化的选择"></a>正则化的选择</h3><ul><li><strong>L2正则化</strong>通常用于大多数深度学习模型，因为它有助于稳定训练过程，并且可以防止参数值变得过大。</li><li><strong>L1正则化</strong>适用于需要特征选择的情况，或者当模型需要稀疏性时。</li><li>在某些情况下，结合L1和L2正则化（即弹性网正则化）可以提供两者的优点。</li></ul><p>正则化是深度学习中控制模型复杂度的重要工具，通过合理选择正则化类型和调整正则化系数，可以显著提高模型的泛化能力和性能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hugging Face Transformer</title>
    <link href="/2024/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Hugging-Face-Transformer/"/>
    <url>/2024/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Hugging-Face-Transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Hugging-Face-Transformer"><a href="#Hugging-Face-Transformer" class="headerlink" title="Hugging Face Transformer"></a>Hugging Face Transformer</h1><p><a href="https://blog.csdn.net/FrenzyTechAI/article/details/131958687">Hugging Face Transformer：从原理到实战的全面指南</a></p><p><a href="https://blog.csdn.net/m0_68382801/article/details/127624858">使用网上服务器（AutoDL）训练模型</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 周赛</title>
    <link href="/2024/05/26/leetcode-%E5%91%A8%E8%B5%9B/"/>
    <url>/2024/05/26/leetcode-%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-周赛"><a href="#leetcode-周赛" class="headerlink" title="leetcode 周赛"></a>leetcode 周赛</h1><h2 id="100313-所有球里面不同颜色的数目"><a href="#100313-所有球里面不同颜色的数目" class="headerlink" title="100313. 所有球里面不同颜色的数目"></a>100313. 所有球里面不同颜色的数目</h2><p><a href="https://leetcode.cn/problems/find-the-number-of-distinct-colors-among-the-balls/description/">所有球里面不同颜色的数目</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; balls; <span class="hljs-comment">//球的序号，颜色值</span><br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; colors; <span class="hljs-comment">//颜色值，该颜色值个数</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">queryResults</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; q = queries;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//该气球已经有颜色了</span><br>            <span class="hljs-keyword">if</span>(balls[ q[i][<span class="hljs-number">0</span>] ])&#123;<br>                <span class="hljs-comment">//先将原先存在的气球和颜色从两个数组中去除</span><br>                colors[ balls[q[i][<span class="hljs-number">0</span>]] ] --;<br>                <span class="hljs-keyword">if</span>( colors[ balls[q[i][<span class="hljs-number">0</span>]] ] == <span class="hljs-number">0</span>) res --;<br>            &#125;<br>            <br>            <span class="hljs-comment">//加入新的颜色</span><br>            balls[ q[i][<span class="hljs-number">0</span>] ] = q[i][<span class="hljs-number">1</span>];<br>            colors[ q[i][<span class="hljs-number">1</span>] ] ++;<br>            <span class="hljs-keyword">if</span>(colors[ q[i][<span class="hljs-number">1</span>] ] == <span class="hljs-number">1</span>) res ++;<br><br>            ans.<span class="hljs-built_in">push_back</span>(res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="100321-优质数对的总数-II"><a href="#100321-优质数对的总数-II" class="headerlink" title="100321.优质数对的总数 II"></a>100321.优质数对的总数 II</h2><p><a href="https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description/">优质数对的总数 II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp; <span class="hljs-comment">//nums1数组中某个数的约数 ； 该约数的总个数</span><br><br>    <span class="hljs-comment">//求nums1[i]的约数和对应个数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=v/i;i++)&#123;<br>            <span class="hljs-keyword">if</span>(v % i == <span class="hljs-number">0</span>)&#123;<br>                mp[i] ++;<br>                <span class="hljs-comment">//重复的约数只记作一个（如4的约数为一个2）</span><br>                <span class="hljs-comment">//这个if一定要在上一个if里面</span><br>                <span class="hljs-keyword">if</span>(i != (v/i))&#123;<br>                    mp[v/i] ++;<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">numberOfPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>(); <span class="hljs-type">int</span> m = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-built_in">cnt</span>(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            nums2[i] *= k;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            res += mp[ nums2[i] ];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="100306-不包含相邻元素的子序列的最大和"><a href="#100306-不包含相邻元素的子序列的最大和" class="headerlink" title="100306. 不包含相邻元素的子序列的最大和"></a>100306. 不包含相邻元素的子序列的最大和</h2><p><a href="https://leetcode.cn/problems/maximum-sum-of-subsequence-with-non-adjacent-elements/description/">不包含相邻元素的子序列的最大和</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Hot 100</title>
    <link href="/2024/05/25/Leetcode-Hot-100/"/>
    <url>/2024/05/25/Leetcode-Hot-100/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Hot-100"><a href="#Leetcode-Hot-100" class="headerlink" title="Leetcode Hot 100"></a>Leetcode Hot 100</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天是2024年5月25日 凌晨 1:24 分 在寝室洗衣房写下这段话。距离9.28还有4个月。也不知道那个时候的我有没有offer了（shushu不会还是0 offer吧，做梦都想去tp，有点难，那就梦梦浙大吧，耳机里突然响起来《落空》这首歌——“我们都曾试过想以后，以后却不会来了”。。。。。。希望我的梦想不会落空。加油！！！开刷leetcode hot 100 为了我梦想，为了不留遗憾，再冲一次吧。）</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p><img src="/../img/1.png"></p><ol><li><p>算法一（哈希表）<br>核心思想：for循环，使用map依次存储数组下标和对应的数；使用map.count(target - num[i]) 查询目前map中是否已经存储了所需要的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(target - nums[i]) &gt; <span class="hljs-number">0</span>)&#123;<br>                res[<span class="hljs-number">0</span>] = i;<br>                res[<span class="hljs-number">1</span>] = mp[target - nums[i]];<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            mp[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>算法二（快慢指针）<br>核心思想：$两个指针 i,j 不断向前移动找到答案（ j &lt; i ）$</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=nums.<span class="hljs-built_in">begin</span>();i&lt;nums.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j=nums.<span class="hljs-built_in">begin</span>();j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>((*i + *j) == target)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(j-nums.<span class="hljs-built_in">begin</span>());<br>                    res.<span class="hljs-built_in">push_back</span>(i-nums.<span class="hljs-built_in">begin</span>());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p><img src="/../img/2.png"></p><p>核心思想：高精度加法</p><p>tips:</p><ol><li>注意最后一个进位也要考虑进来</li><li>构造链表<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1.</span>初始化<br>ListNode* prehead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *cur = prehead;<br><br><span class="hljs-number">2.</span>赋值<br>cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(v);<br>cur = cur-&gt;next;<br><br><span class="hljs-number">3.</span>返回构造的链表<br><span class="hljs-keyword">return</span> prehead-&gt;next;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* prehead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *cur = prehead;<br>        ListNode *p = l1;<br>        vector&lt;<span class="hljs-type">int</span>&gt; a,b;<br>        <span class="hljs-keyword">while</span>(p)&#123;<br>            a.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>            p = p-&gt;next;<br>        &#125;<br>        p = l2;<br>        <span class="hljs-keyword">while</span>(p)&#123;<br>            b.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">size</span>(),b.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        vector &lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())&#123;<br>                v += a[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())&#123;<br>                v += b[i];<br>            &#125;<br>            v += t;<br>            <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">10</span>)&#123;<br>                v -= <span class="hljs-number">10</span>; t = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                t = <span class="hljs-number">0</span>;<br>            &#125;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(v);<br>            cur = cur-&gt;next;<br><br>        &#125;<br>        <span class="hljs-comment">//注意最后一个进位也要考虑进来</span><br>        <span class="hljs-keyword">if</span>(t &gt;= <span class="hljs-number">1</span>)&#123;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t);<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prehead-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p><img src="/../img/3.png"><br>核心思想：滑动窗口 + un ordered set<br>tips:</p><ol><li>count（检查当前窗口内是否有重复元素）</li><li>erase（去掉左指针所指向元素，i++ ——&gt; 即窗口右移）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; str; <span class="hljs-comment">//无重复字符且无序</span><br>        <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义右指针</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历左指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br><br>            <span class="hljs-comment">//不断移动右指针</span><br>            <span class="hljs-keyword">while</span>(!str.<span class="hljs-built_in">count</span>(s[r]) &amp;&amp; r&lt;len)&#123;<br>                str.<span class="hljs-built_in">insert</span>(s[r]);<br>                r++;<br>            &#125;<br>            <span class="hljs-comment">//跳出了while循环代表有重复元素出现了，此时移动左指针(从set中删除当前左指针所指向元素)</span><br>            res = <span class="hljs-built_in">max</span>(res,r-i);<br>            str.<span class="hljs-built_in">erase</span>(s[i]);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><p><img src="/../img/4.png"><br>核心思想：先合并成一个单调递增的数组；然后计算新数组的中位数，算法复杂度为O(n+m); 还可以用二分优化到log(n+m);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = nums1.<span class="hljs-built_in">size</span>(); <span class="hljs-type">int</span> len2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>,m=<span class="hljs-number">0</span>; <span class="hljs-comment">//分别指示num1,num2两个数组的指针</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br>        <span class="hljs-comment">//构建一个单调递增的ans数组</span><br>        <span class="hljs-keyword">while</span>(n &lt; len1 &amp;&amp; m &lt; len2)&#123;<br>            <span class="hljs-keyword">if</span>(nums1[n] &lt; nums2[m])&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums1[n]);<br>                n++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums2[m]);<br>                m++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(n &lt; len1)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums1[n]);<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(m &lt; len2)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums2[m]);<br>            m++;<br>        &#125;<br>        <span class="hljs-type">int</span> len = ans.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">double</span> res;<br>        <span class="hljs-keyword">if</span>(len % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            res = (ans[len/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + ans[len/<span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res = ans[len/<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>核心思想：动态规划 f[i][j] , <strong>区间dp</strong> ，以[i,j]这段长度上的回文子串<br>（1） 求最长回文子串长度<br>（2） 求具体的最长回文子串 ：不断判断某个区间是否是回文子串，如果是，则更新最大长度的左右下标值，之后通过该下标序号来截取具体的子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        <span class="hljs-comment">// 初始化二维动态规划表</span><br>        <span class="hljs-type">bool</span> f[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 填充对角线为true，因为单个字符总是回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            f[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最长回文串的起始位置和长度</span><br><br>        <span class="hljs-comment">// 填充动态规划表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; ++len) &#123; <span class="hljs-comment">// 长度从2开始</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + len - <span class="hljs-number">1</span> &lt; n; ++i) &#123; <span class="hljs-comment">// i是子串的起始位置,j是右端点小于n</span><br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>; <span class="hljs-comment">// j是子串的结束位置</span><br>                <span class="hljs-comment">// 如果首尾字符相同，并且中间部分也是回文，则整个序列是回文</span><br>                <span class="hljs-keyword">if</span> (s[i] == s[j] &amp;&amp; (len &lt; <span class="hljs-number">3</span> || f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>                    f[i][j] = <span class="hljs-literal">true</span>;<br>                    maxLen = len;<br>                    start = i;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最长的回文子串</span><br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start, maxLen);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h2><p>核心思想：动态规划</p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>核心思想：双指针（最短木板原理，因此两个指针所指向的板中较短的那个指针要向中心移动）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> r = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> maxv = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            maxv = <span class="hljs-built_in">max</span>(maxv,(r-l)*<span class="hljs-built_in">min</span>(height[l],height[r]));<br>            <span class="hljs-keyword">if</span>(height[l] &lt; height[r])&#123;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxv;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>核心思想：双指针＋set去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ret;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br> <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">int</span> x = -nums[i];<br>            <span class="hljs-type">int</span> l = i+<span class="hljs-number">1</span>; <span class="hljs-type">int</span> r = len<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-keyword">if</span>(nums[l] + nums[r] + nums[i] &lt; <span class="hljs-number">0</span>)&#123;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[l] + nums[r] + nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                    r--;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    ret.<span class="hljs-built_in">insert</span>(&#123;nums[i],nums[l],nums[r]&#125;); <br>                    l++; r--;<span class="hljs-comment">//在当前已经满足条件的情况下，只移动一个指针肯定不能够继续满足条件</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(ret.<span class="hljs-built_in">begin</span>(),ret.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>核心思想：<strong>栈的先进后出</strong>（注意栈是否为空时的一些边界情况）<br><img src="/../img/20.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map &lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; mp;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        mp.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;)&#x27;</span>&#125;);<br>        mp.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-string">&#x27;&#125;&#x27;</span>&#125;);<br>        mp.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;]&#x27;</span>&#125;);<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//剪枝提前返回</span><br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//如果读入了一个右括号而此时没有左括号在栈中，则一定不满足条件</span><br>                <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || mp[st.<span class="hljs-built_in">top</span>()] != s[i])&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//如果遍历完了整个字符串之后，还符合条件的话，栈肯定为空</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p>核心思想：二分查找<br>tips:注意空数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//找开始位置</span><br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid = (l+r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target)&#123;<br>                r = mid;<br>            &#125; <br>            <span class="hljs-keyword">else</span>&#123;<br>                l = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[l] != target) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(l);<br>        &#125;<br><br>        <span class="hljs-comment">//找结束位置</span><br>        l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid = (l+r+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt;= target)&#123;<br>                l = mid;<br>            &#125; <br>            <span class="hljs-keyword">else</span>&#123;<br>                r = mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[l] != target) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(l);<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p>核心思想：<br>（1）递归+剪枝<br>（2）动态规划（d[n] &#x3D; d[n-1] + d[n-2]）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*递归＋剪枝</span><br><span class="hljs-comment">    int st[50];</span><br><span class="hljs-comment">    int dfs(int i)&#123;</span><br><span class="hljs-comment">        if(i&lt;=1)&#123;</span><br><span class="hljs-comment">            return 1;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        if(st[i]) return st[i]; //剪枝操作，如果该数已经计算过了，就直接查找不需要再递归计算</span><br><span class="hljs-comment">        else&#123;</span><br><span class="hljs-comment">            st[i] = dfs(i-1) + dfs(i-2);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return st[i];</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//dfs(n);</span><br>        <span class="hljs-type">int</span> f[<span class="hljs-number">50</span>];<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>            f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><p>核心思想：</p><ol><li>移除数组元素：<strong>数组的元素在内存地址中是连续的，</strong> 不能单独删除数组中的某个元素，只能覆盖。</li><li>通过快慢指针来实现数组元素覆盖</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(r=<span class="hljs-number">0</span>;r&lt;n;r++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[r] != <span class="hljs-number">0</span>)&#123;<br>                nums[l] = nums[r];<br>                l++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//r最后所在位置为最后一个位置的下一位（因为r要遍历到此才会跳出for循环）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r<span class="hljs-number">-1</span>;i++)&#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二分图</title>
    <link href="/2024/05/22/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2024/05/22/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！</p><p>说人话的定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。</p><p><img src="/../../img/%E4%BA%8C%E5%88%86%E5%9B%BE.png"></p><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><blockquote><p>判断给定图 是否是二分图<br>算法步骤：</p></blockquote><ol><li>循环对每个点进行染色（dfs或者bfs）</li><li>判断其相邻的点中，若未染色则将其染上和当前顶点不同的颜色。</li><li>若已经染色 且颜色跟当前点颜色一样的则说明不是二分图，如果没有则进行下一个节点的判断</li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><blockquote><p>计算二分图的最大匹配数</p><p>二分图的匹配：给定一个二分图 G ，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。</p><p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p></blockquote><p>算法思想：<br>find(x) : 左半边点x的某条边的右半边的另一个点<br>match[j] 右半边的点j所匹配的点</p><ol><li>对左半边图的节点进行循环<ul><li>循环该节点所有的边(find(x))，如果能够在右半边找到一个没有匹配过的点（match[j] &#x3D;&#x3D; 0），则进行匹配</li><li>如果找到的点已经匹配上了别的点了(match[j] !&#x3D; 0)，则看其匹配的点是否有别的备胎（find(match[j])）</li><li>有备胎则将匹配取消，让其去找备胎。</li><li>如果能够成功匹配则返回true （总匹配边数 res++）</li><li>如果无备胎，则返回false</li></ul></li></ol><p>tips:</p><ol><li>循环中找每个点对应右半边点前都要<strong>先重置st数组为false</strong></li><li>要用st数组来标记节点是否被访问过了</li></ol><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n1,n2,m;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx;<br><span class="hljs-comment">//st 标记节点是否递归找过， match[x]：和 x 编号的男生的编号</span><br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> match[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b; ne[idx] = h[a]; h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">//i指代的是下标为idx的边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-comment">//递归的剪枝操作，如果没有的话会报MLE</span><br>        <span class="hljs-keyword">if</span>(!st[j])&#123;<br>            st[j] = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记该节点已经找过了</span><br>            <span class="hljs-keyword">if</span>(!match[j] || <span class="hljs-built_in">find</span>(match[j]))&#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i))&#123;<br>            res++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树算法</title>
    <link href="/2024/05/21/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/21/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><p>从具有n个节点的连通图中选择 n-1 条边，使得所组成的树的权值最小，即为最小生成树</p><p>即<strong>以最小的成本（边的权值）将图中所有节点链接到一起</strong></p><p><img src="/../../img/mintree.png"></p><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p>prim算法 是从节点的角度 采用贪心的策略 每次寻找距离 最小生成树最近的节点 并加入到最小生成树中</p><p><strong>选节点 -&gt; 加入 -&gt; 更新其他点距离</strong></p><ol><li>循环n次，找到集合（最小生成树中的节点所组成）外距离最近集合最近的点t</li><li>点t加入集合</li><li>用 t 更新集合外其他点到<strong>集合的距离</strong>（到集合中任意一点的最小距离）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx,w[M];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> value)</span></span>&#123;<br>    e[idx] = v; w[idx] = value; ne[idx] = h[u]; h[u] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; w[i] &lt; d[j])&#123;<br>            d[j] = w[i];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> u,v,w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-built_in">add</span>(u,v,w); <span class="hljs-built_in">add</span>(v,u,w);<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;    <span class="hljs-comment">//初始节点设置为1</span><br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <br>        <span class="hljs-type">int</span> minv = <span class="hljs-number">1e9</span>; <span class="hljs-comment">//每次选新节点前都要重新赋值</span><br>        <br>        <span class="hljs-comment">//1. 选节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; d[j] &lt; minv)&#123;<br>                minv = d[j];<br>                cur = j;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//2.加入最小生成树</span><br>        st[cur] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//3. 更新距离</span><br>        <span class="hljs-built_in">dfs</span>(cur);<br>    &#125;<br>    <span class="hljs-comment">//d[1] 不用计算进来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(d[i] &gt; <span class="hljs-number">10000</span>)&#123; <span class="hljs-comment">//图中涉及边的边权的绝对值均不超过 10000</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        res += d[i];<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆优化版Prim"><a href="#堆优化版Prim" class="headerlink" title="堆优化版Prim"></a>堆优化版Prim</h2><ol><li>使用小根堆来判断 d数组 里的最小值</li><li>记录被确认的点的数量，当队列为空后，判断点数量是否与总节点数相同来判断是否有最小生成树</li><li>无向图的初始化：边数的两倍（<code>const int M = 2e5+10</code>）; <code>add(a,b,w); add(b,a,w);</code></li></ol><p>tips:</p><ol><li><strong>M 数组来开小了，会超时</strong></li><li><code>if(st[cur]) continue;</code>  <strong>必不可少的剪枝，防止超时</strong> (不加会一直循环下去，如果非堆优化版本可以不加，因为它是通过n-1次的for循环来控制的)</li><li><code>const int M = 3e5+10;</code> &#x2F;&#x2F;边数不够的话，也会报TLE , <strong>无向图要开两倍（越大越好）</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx,w[M];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res;<br><br>priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> value)</span></span>&#123;<br>    e[idx] = v; w[idx] = value; ne[idx] = h[u]; h[u] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; w[i] &lt; d[j])&#123;<br>            d[j] = w[i];<br>            q.<span class="hljs-built_in">push</span>(&#123;d[j],j&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> u,v,w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-built_in">add</span>(u,v,w); <span class="hljs-built_in">add</span>(v,u,w);<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;    <span class="hljs-comment">//初始节点设置为1</span><br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-comment">// 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <br>        <span class="hljs-type">int</span> minv = <span class="hljs-number">1e9</span>; <span class="hljs-comment">//每次选新节点前都要重新赋值</span><br>        <br>        <span class="hljs-comment">//1. 选节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; d[j] &lt; minv)&#123;<br>                minv = d[j];<br>                cur = j;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//1.选节点</span><br>        PII t = q.<span class="hljs-built_in">top</span>();<br>        cur = t.second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">if</span>(st[cur]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//必不可少的剪枝，防止超时</span><br>        <span class="hljs-comment">//2.加入最小生成树</span><br>        st[cur] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//3. 更新距离</span><br>        <span class="hljs-built_in">dfs</span>(cur);<br>    &#125;<br>    <span class="hljs-comment">//d[1] 不用计算进来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(d[i] &gt; <span class="hljs-number">10000</span>)&#123; <span class="hljs-comment">//图中涉及边的边权的绝对值均不超过 10000</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        res += d[i];<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>; <span class="hljs-comment">//无向图，边数的两倍</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx,w[M];<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    e[idx] = b; w[idx] = v;<br>    ne[idx] = h[a];<br>    h[a] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">//定义在函数里的值一定要初始化，否则不会给它设置为 0 </span><br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;); <span class="hljs-comment">//距离，节点编号</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//不属于集合 &amp;&amp; 距离集合最小的点</span><br>        <span class="hljs-comment">/*朴素版</span><br><span class="hljs-comment">        int t = -1;</span><br><span class="hljs-comment">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="hljs-comment">            if(!st[i] &amp;&amp; (t == -1 || d[i] &lt; d[t]))&#123;</span><br><span class="hljs-comment">                t = i;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//堆优化版本</span><br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-type">int</span> ver = t.second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//把点t加到集合当中去，更新权值</span><br>        st[ver] = <span class="hljs-literal">true</span>;<br>        cnt++; <span class="hljs-comment">//不存在生成树即cnt != n</span><br>        <br>        <span class="hljs-comment">// res += q.top().first; //前面已经pop 了因此不能这样写</span><br>        res += t.first;<br>        <br>        <span class="hljs-comment">//更新其他点到 集合 的距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[ver];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(st[j]) <span class="hljs-keyword">continue</span>; <br>            <span class="hljs-keyword">if</span>(w[i] &lt; d[j])&#123;<br>                d[j] = w[i];<br>                q.<span class="hljs-built_in">push</span>(&#123;d[j],j&#125;); <span class="hljs-comment">//只有在确定最小值会被更新时，再push入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt != n) <span class="hljs-keyword">return</span> INF; <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,w;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        <span class="hljs-built_in">add</span>(a,b,w); <span class="hljs-built_in">add</span>(b,a,w); <span class="hljs-comment">//无向图</span><br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">prim</span>();<br>    <span class="hljs-keyword">if</span>(ans == INF) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; ans;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><p><strong>kruscal的思路：</strong></p><p><strong>排序边 + 并查集</strong></p><ul><li><p>边的权值排序，因为要优先选最小的边加入到生成树里</p></li><li><p>遍历排序后的边</p><ul><li>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环</li><li>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> l, r, val;<br>&#125;;<br><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">10001</span>;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <br>    v = <span class="hljs-built_in">find</span>(v); <br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <br>    father[v] = u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> v1, v2, val;<br>    vector&lt;Edge&gt; edges;<br>    <span class="hljs-type">int</span> result_val = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    <span class="hljs-keyword">while</span> (e--) &#123;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;<br>        edges.<span class="hljs-built_in">push_back</span>(&#123;v1, v2, val&#125;);<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> a.val &lt; b.val;<br>    &#125;);<br><br>    vector&lt;Edge&gt; result; <span class="hljs-comment">// 存储最小生成树的边</span><br><br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-keyword">for</span> (Edge edge : edges) &#123;<br><br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(edge.l);<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(edge.r);<br><br><br>        <span class="hljs-keyword">if</span> (x != y) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(edge); <span class="hljs-comment">// 保存最小生成树的边</span><br>            result_val += edge.val; <br>            <span class="hljs-built_in">join</span>(x, y);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印最小生成树的边</span><br>    <span class="hljs-keyword">for</span> (Edge edge : result) &#123;<br>        cout &lt;&lt; edge.l &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; edge.r &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; edge.val &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>离散化</title>
    <link href="/2024/05/18/algorithm_know/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2024/05/18/algorithm_know/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>离散化就是把大而分散的一段段使用到的稀疏区间，整合映射到连续的一段较小的稠密区间里，然后就可以通过普通前缀和公式来计算连续一段的区间和，本质上就是化大为小，把稀疏离散化简为稠密连续的一段。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>双指针算法</title>
    <link href="/2024/05/18/algorithm_know/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/18/algorithm_know/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>tips:</p><ol><li>涉及到 <strong>重复</strong> 二字考虑用一个计数数组进行存储</li></ol><h2 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h2><p>思路：设立两个指针 i 和 j ; 分别指向数组两端，在不同条件下，向内部移动某个指针，直到两个指针交互。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>    <span class="hljs-keyword">if</span>()&#123;<br>        v = ...;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        v = ...;<br>        j--;<br>    &#125;<br>    res = <span class="hljs-built_in">max</span>(res,v);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>例题一: <a href="https://leetcode.cn/problems/container-with-most-water/description/">盛最多水的容器</a></p><p>例题二：<a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/">和为s的两个数字</a></p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>思想：<br>两个指针朝着同一方向前进，一个指针走得慢，一个指针走得快。</p><p>例题一：<a href="https://leetcode.cn/problems/middle-of-the-linked-list/submissions/532905013/">链表的中间结点</a></p><p>例题二：<a href="https://www.acwing.com/problem/content/description/801/">最长连续不重复子序列</a></p><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></p><p>核心思想：快慢指针，</p><ol><li><p>当窗口内的和还小于目标值时，移动右指针增大窗口内子数组的和使其大于等于目标值</p></li><li><p>当窗口内的和已经大于目标值时，移动左指针缩小窗口大小找长度最小的子数组</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1e9</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            s[i] = s[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[n] &lt; target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;r&lt;n;)&#123;<br>            <span class="hljs-keyword">if</span>( (s[r+<span class="hljs-number">1</span>] - s[l]) &gt;= target)&#123;<br>                res = <span class="hljs-built_in">min</span>(res,r+<span class="hljs-number">1</span>-l);<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                r++;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h3><p>核心思想：</p><ol><li>滑动窗口的双指针</li><li>unordered_map 哈希表存储字符和其对应个数，以此来比较是否覆盖了另一个子数组</li><li>下方解法会TLE</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; st,sw;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string t,<span class="hljs-type">int</span> m)</span></span>&#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-comment">//这里不是等于而是小于（如题意中的我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。）</span><br>            <span class="hljs-keyword">if</span>(sw[t[i]] &lt; st[t[i]])&#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(); <span class="hljs-type">int</span> m = t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            st[t[i]] ++;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">10010</span>; <span class="hljs-type">int</span> minl,minr;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;r&lt;=n;)&#123; <span class="hljs-comment">//这里r到n，是为了满足如果r最后移动到数组末尾时刚好check成功了，但无法更新的minr和minl；因此让它多循环一次</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(t,m))&#123;<br>                <span class="hljs-keyword">if</span>(r-l &lt; res)&#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                    res = r-l;<br>                    minr = r;<br>                    minl = l;<br>                &#125;<br>                sw[s[l]] --;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(r == n) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//防止数组越界</span><br>                sw[s[r]] ++;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//check函数一次都没有true过 ，则代表无结果的情况，返回空串</span><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;<br>            string s = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        string ans; <span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=minl;i&lt;minr;i++)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(s[i]);<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习中的梯度</title>
    <link href="/2024/05/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%A2%AF%E5%BA%A6/"/>
    <url>/2024/05/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%A2%AF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习中的梯度"><a href="#深度学习中的梯度" class="headerlink" title="深度学习中的梯度"></a>深度学习中的梯度</h1><p><a href="https://blog.csdn.net/a910247/article/details/137354786">深度学习之详解常见梯度算法(概念、公式、原理、算法实现过程)</a></p><h2 id="什么是梯度"><a href="#什么是梯度" class="headerlink" title="什么是梯度"></a>什么是梯度</h2><p>梯度的提出只为回答一个问题：<br>函数在变量空间的某一点处，沿着哪一个方向有最大的变化率？</p><p>函数在某一点的梯度是这样一个向量，它的方向与取得最大方向导数的方向一致，而它的模为方向导数的最大值。</p><p><strong>梯度向量的方向是函数增长最快的方向，其大小是该方向上的变化率</strong></p><p>1）梯度是一个向量，即有方向有大小；<br>2）梯度的方向是最大方向导数的方向；<br>3）梯度的值是最大方向导数的值。</p><p><strong>在反向传播中，梯度是损失函数关于网络参数的导数，它指示了损失函数在参数空间中增加最快的方向。</strong></p><h2 id="为什么要做梯度下解"><a href="#为什么要做梯度下解" class="headerlink" title="为什么要做梯度下解"></a>为什么要做梯度下解</h2><p>既然在变量空间的某一点处，函数沿梯度方向具有最大的变化率，那么在优化目标函数的时候，自然是沿着负梯度方向去减小函数值，以此达到我们的优化目标。</p><h2 id="梯度反向传播"><a href="#梯度反向传播" class="headerlink" title="梯度反向传播"></a>梯度反向传播</h2><p><strong>反向传播传播的是损失函数关于每个权重和偏置的梯度</strong><br>梯度指示了如何调整参数以减少损失。</p><p>梯度反向传播（Backpropagation）是神经网络中用于训练模型的关键算法。在反向传播过程中，梯度会从输出层反向传递到输入层，用于更新网络中的权重。梯度反向传播涉及对网络中每一层的权重和激活函数进行微分，计算损失函数相对于每个权重的梯度。</p><p>梯度反向传播会经过多层反复相乘的原因与链式法则（Chain Rule）有关，这是微积分中用于求解复合函数导数的基本法则。在神经网络中，每个神经元的输出可以看作是输入、权重和激活函数的复合结果。因此，要计算损失相对于网络中某个权重的梯度，就需要应用链式法则，将损失对激活函数的导数与激活函数对权重的导数相乘。</p><p>以下是梯度反向传播中链式法则应用的一个简化示例：</p><p>假设一个神经网络包含多个层，每层有多个神经元，每个神经元的输出 ( y ) 可以表示为：</p><p>[ y &#x3D; f(z) ]</p><p>其中 ( z ) 是输入加权和 ( w \cdot x + b )（( w ) 是权重向量，( x ) 是输入向量，( b ) 是偏置），( f ) 是激活函数。</p><p>损失函数 ( L ) 相对于权重 ( w ) 的梯度可以表示为：</p><p>[ \frac{\partial L}{\partial w} &#x3D; \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial z} \cdot \frac{\partial z}{\partial w} ]</p><p>这里：</p><ul><li>( \frac{\partial L}{\partial y} ) 是损失相对于输出 ( y ) 的梯度。</li><li>( \frac{\partial y}{\partial z} ) 是激活函数 ( f ) 相对于 ( z ) 的导数。</li><li>( \frac{\partial z}{\partial w} ) 是 ( z ) 相对于权重 ( w ) 的导数。</li></ul><p>在反向传播过程中，首先计算输出层的梯度 ( \frac{\partial L}{\partial y} )，然后使用链式法则递归地计算前面各层的梯度。每一步都涉及到对激活函数的导数和权重的导数进行乘法运算。</p><p>当神经网络很深时，即存在很多层，这些梯度乘积会沿着网络层级反复进行。如果激活函数的导数值（如sigmoid或tanh函数在接近饱和区的导数）很小，或者权重本身较小，那么经过多次乘法后，梯度可能会变得非常小，导致梯度消失问题。相反，如果梯度值在每一步都较大，那么它们在多次乘法后可能会变得非常大，导致梯度爆炸问题。</p><p>为了解决这些问题，研究人员已经提出了多种技术，如使用ReLU激活函数（其在正区间内导数为常数，可以缓解梯度消失问题），权重初始化策略，梯度裁剪，以及改进的优化算法等。</p><h2 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h2><p>梯度消失和梯度爆炸本质就是激活函数（的导数）和权重相互作用产生的联合效果</p><p>梯度消失和梯度爆炸的根源主要是因为<strong>深度神经网络结构</strong>以及**激活函数选择不当(函数的导数数值过小会导致梯度消失)**，目前优化神经网络的方法都是基于反向传播的思想，即根据损失函数计算的误差通过反向传播的方式，指导深度网络权值的更新。</p><p>在反向传播时对激活函数进行求导。如果在此部分大于1，那么随着层数的增加，求出的梯度的更新将以指数形式增加，发生梯度爆炸。如果此部分小于1，那么随着层数的增加求出的梯度更新的信息会以指数形式衰减，发生梯度消失。</p><p><strong>梯度消失：</strong> 即在反向传播过程中，由于梯度值逐层传递时逐渐变小，权重的更新将非常微小，导致较靠近输入层的层难以有效地学习到输入数据的特征和模式。</p><p><strong>梯度爆炸</strong> 在深度神经网络训练过程中，梯度值逐层传递时逐渐增大，并且可能超出网络的数值范围的问题。当梯度值变得非常大时，参数更新的幅度也会变得非常大，导致模型变得不稳定，甚至无法收敛。</p><p>梯度消失通常与以下几个因素有关：</p><ol><li><p><strong>激活函数的选择</strong>：某些激活函数，如Sigmoid或Tanh，在其饱和区（即输入值非常大或非常小的区域）的梯度非常小，这可能导致在反向传播过程中梯度值快速减小。</p></li><li><p><strong>网络的深度</strong>：在很深的网络中，由于梯度需要通过多个层进行传播，每个层的梯度乘积将导致最终的梯度值变得非常小。</p></li><li><p><strong>权重初始化</strong>：不适当的权重初始化可能导致梯度消失或梯度爆炸。</p></li><li><p><strong>学习率设置</strong>：过大的学习率可能导致梯度爆炸，而过小的学习率可能导致梯度更新过慢，相当于梯度消失。</p></li></ol><p><strong>具体例子：</strong></p><ol><li><p><strong>Sigmoid激活函数</strong>：<br>假设一个神经网络使用Sigmoid激活函数，其梯度为 ( \sigma’(x) &#x3D; \sigma(x)(1 - \sigma(x)) )。当 ( \sigma(x) ) 接近1或0时，梯度 ( \sigma’(x) ) 将接近0。例如，如果 ( \sigma(x) &#x3D; 0.9 )，则梯度 ( \sigma’(x) &#x3D; 0.9 \times (1 - 0.9) &#x3D; 0.09 )。在深层网络中，连续多个这样的梯度乘积将导致最终梯度非常小。</p></li><li><p><strong>深度网络</strong>：<br>考虑一个具有10层的神经网络，每层使用Sigmoid激活函数。如果每层的梯度乘积为0.1（这是一个合理的假设，因为Sigmoid激活函数的梯度通常小于1），那么经过10层后，初始梯度为1的梯度将减少到 ( 1 \times 0.1^{10} &#x3D; 1 \times 10^{-10} )，这几乎为零。</p></li><li><p><strong>长短期记忆网络（LSTM）</strong>：<br>LSTM设计之初就是为了解决传统RNN中的梯度消失问题。在标准的RNN中，梯度需要通过时间步进行传播，这同样会导致梯度消失。LSTM通过引入门控机制来缓解这个问题，允许梯度在时间序列中更有效地流动。</p></li></ol><h3 id="解决梯度消失的方法："><a href="#解决梯度消失的方法：" class="headerlink" title="解决梯度消失的方法："></a>解决梯度消失的方法：</h3><ul><li><p><strong>使用ReLU或其变种</strong>：ReLU及其变种（如Leaky ReLU）在正区间内具有恒定的梯度，这有助于缓解梯度消失问题。</p></li><li><p><strong>权重初始化</strong>：使用如He初始化或Xavier初始化等策略，可以更好地控制训练初期的梯度大小。</p></li><li><p><strong>梯度裁剪</strong>：在优化过程中限制梯度的更新幅度，以避免梯度爆炸，同时也可以减轻梯度消失的影响。</p></li><li><p><strong>使用残差连接</strong>：在网络中使用残差连接（如在ResNet中）可以帮助梯度直接流向前面的层。</p></li><li><p><strong>适当的学习率调度</strong>：通过学习率衰减或自适应学习率优化算法（如Adam）来调整学习率。</p></li></ul><p><strong>method</strong><br>1.正则化：通过 L1 或 L2 正则化来控制参数的大小，防止梯度值过大。<br>2.梯度剪裁（Gradient Clipping）：限制梯度值的范围，将超出阈值的梯度进行裁剪。<br>3.预训练：可以先使用无监督学习或其他方式进行预训练，提供一个比较好的初始参数，从而减小梯度消失和爆炸的可能性。<br>4.层标准化（Layer Normalization）或批标准化（Batch Normalization）：对层输出进行标准化，使其均值为0、方差为1，有助于缓解梯度消失情况。<br>5.参数初始化：合理选择参数的初始化方法，如使用 Xavier 或 He 等初始化方法，可以减小梯度消失和爆炸的概率。<br>6.更稳定的激活函数：使用 ReLU、Leaky ReLU 或其变体等激活函数，可以避免梯度消失，并且有助于缓解梯度爆炸。<br>7.Residual Connections（残差连接）：在网络中增加跨层连接，可以传递较浅层的梯度信息，缓解梯度消失和爆炸。</p><p><strong>Residual Connections</strong></p><blockquote><p>残差连接引入了一种跨层传递的机制，即在网络的某些层中，将前一层的输出直接加到后一层的输入中去。这种机制可以有效地传递一定的梯度信息，避免了网络深度增加时出现的梯度消失问题，同时也能够克服一些非凸优化问题，使得网络更容易优化。<br>具体而言，假设某一层的输入为 x，输出为 y，则残差连接的实现形式可以表示为：<br><code>y=F(x)+x</code><br>其中 F(x) 表示该层的非线性变换操作，即前向传播过程。在反向传播梯度计算时，则会将损失函数 L 反向传播到该层，生成梯度 ∂L&#x2F;∂y，并将该梯度传递到 x，从而计算 ∂L&#x2F;∂x，即该层输入 x 对损失函数的梯度。</p></blockquote><h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><p>梯度下降（Gradient Descent）是一种优化算法，用于寻找最小化损失函数（或成本函数）的参数值</p><p>损失函数衡量了模型预测值与真实值之间的差异，而梯度下降则是用于更新模型的参数（例如权重和偏置），以最小化这个差异。</p><p><strong>对于非凸损失函数，梯度下降可能只能找到局部最小值而不是全局最小值</strong></p><p>以下是梯度下降算法的基本步骤：</p><ol><li><p><strong>初始化参数</strong>：随机初始化模型参数或使用预设的值。</p></li><li><p><strong>计算梯度</strong>：计算损失函数对每个参数的偏导数，这些偏导数构成了梯度向量。梯度指向损失函数增长最快的方向。</p></li><li><p><strong>更新参数</strong>：根据梯度和一个学习率（步长）来更新每个参数。参数更新的公式通常是：<br>[ \theta_i :&#x3D; \theta_i - \eta \cdot \frac{\partial J}{\partial \theta_i} ]<br>其中，(\theta_i) 是第(i)个参数，(\eta) 是学习率，(\frac{\partial J}{\partial \theta_i}) 是损失函数(J)对参数(\theta_i)的偏导数。</p></li><li><p><strong>重复迭代</strong>：重复步骤2和3，直到满足停止条件，如梯度足够小、达到预定的迭代次数或损失函数值不再显著减小。</p></li></ol><p>梯度下降算法有几种变体，用于提高性能和稳定性：</p><ul><li><p><strong>批量梯度下降（Batch Gradient Descent）</strong>：每次迭代使用整个数据集来计算梯度和更新参数。这种方法计算准确，但可能计算成本高，且在大数据集上效率低。</p></li><li><p><strong>随机梯度下降（Stochastic Gradient Descent, SGD）</strong>：每次迭代只使用一个训练样本来计算梯度和更新参数。SGD通常更快，但可能会有较大的噪声，导致训练过程不稳定。</p></li><li><p><strong>小批量梯度下降（Mini-batch Gradient Descent）</strong>：每次迭代使用一小部分数据（称为小批量）来计算梯度和更新参数。这是批量梯度下降和随机梯度下降的折中方案，通常在实践中效果较好。</p></li><li><p><strong>动量（Momentum）</strong>：在SGD的基础上增加了动量项，可以帮助梯度下降更快地收敛，同时减少震荡。</p></li><li><p><strong>AdaGrad</strong>：Adagrad（Adaptive Gradient Algorithm）是一种自适应学习率的优化算法，它通过将学习率分别应用于每个参数的梯度的平方来调整学习率，从而使得稀疏梯度的参数得到更大的更新，稠密梯度的参数得到较小的更新。Adagrad算法通常用于处理稀疏数据集和非凸优化问题。</p></li><li><p><strong>RMSProp</strong>：RMSProp（Root Mean Square Propagation）是一种自适应学习率的优化算法，它在Adam算法之前提出，通过计算梯度的平方的移动平均来调整学习率，从而加速收敛过程。RMSProp算法通常用于优化神经网络的训练。解决了AdaGrad学习率过快减小的问题。</p></li><li><p><strong>Adam</strong>：自适应矩估计算法，结合了随机梯度下降（SGD）和动量（Momentum）方法的优点，是目前非常流行的优化算法之一。</p></li></ul><h2 id="Adam算法的关键特性："><a href="#Adam算法的关键特性：" class="headerlink" title="Adam算法的关键特性："></a>Adam算法的关键特性：</h2><p>Adam（Adaptive Moment Estimation）是一种用于训练神经网络的梯度下解优化算法 以及 自适应学习率算法（lr会改变）</p><p>Adam 算法和传统的随机梯度下降不同。<br>随机梯度下降保持单一的学习率（即 alpha）更新所有的权重，学习率在训练过程中并不会改变。<br>而 <strong>Adam 通过计算梯度的一阶矩估计和二阶矩估计而为不同的参数设计独立的自适应性学习率。</strong></p><p><strong>自适应学习率：</strong> Adam算法能够为每个参数自动调整学习率，这是通过估计梯度的一阶矩（均值）和二阶矩（方差）来实现的。</p><p><strong>动量方法：</strong> Adam算法利用过去梯度的指数加权平均值来更新参数，这类似于动量方法，有助于加速收敛并减少震荡。</p><p><strong>计算效率：</strong> Adam算法在每次迭代中只需要计算一次前向和反向传播，这使得它在计算资源有限的情况下非常有效。</p><p><strong>内存效率：</strong> 与其他一些需要存储过去所有梯度的优化算法相比，Adam只需要存储一阶矩和二阶矩的估计值，因此内存使用更少。</p><p>梯度下降算法及其变体在深度学习中被广泛使用，它们通过有效地调整模型参数来最小化损失函数，从而训练出性能良好的深度学习模型。</p><p>应用：<br>Adam算法在许多深度学习任务中都非常流行，特别是在需要处理大量参数和复杂模型的场景中。它的优点包括：</p><p><strong>易于使用：</strong> 只需要调整少量超参数。<br><strong>快速收敛：</strong> 在许多情况下，Adam算法能够比传统的SGD更快地收敛。<br><strong>鲁棒性：</strong> 对学习率的选择不太敏感，因此在实际应用中更容易使用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>夏令营机试</title>
    <link href="/2024/05/16/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%9C%BA%E8%AF%95/"/>
    <url>/2024/05/16/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%9C%BA%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="6cede7f7238e5ec4a387e1b9db895d324ff5e45bf8e82f6dc4dcd9b354caa6b1">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df4806fb5f3841121c734f986b18049e9e2d1aa61dc304df8982e42efc2cbb7a227105ac102e97be12525cc9875aab4d19404c47cef381125dfa829e58562f6e83ca5688bfd57525878b959d3cb5cd4eb7c59159c8b6b539ae213385cedc162052c9b6b62a7f82a643e8a905ae602761150469f24b15d9a9f19f0f2a25883cd9e367234d458d7693528167cc70caa38dad385c21ff8ee11966290efa09186ded218d8791f45a4764c70c3a5c30c4defc99e858ab64375eae69e3b8f8c5d3dfb7b068f720820431acf20a9200309a3d8d3aec7fc9f7aff25a3f172787d8364804f7ab0ee5cf7536dbff32e076e65890ea25650dd9a9c89e4563ae0bfbb938363c28d61cc027423402003ba64d9d6a04ea09b19cc025f4dbfe2b3c6eacfe07ceeb1a603602318062ee3023f03099bbb7e35d3b42706c90bc2ef1ed0ab346a9964167fc14bcd8fe14a33cdf4e304941c21cc8fbc5a147a28c3b0d95f7978f88b3fa8a54a9902bb88b361770317f968c72bdb62dc0b0437c99cbfaaefef277670a7967209f5c60374cc8251277ace4bb0401917b7ae1b8b748f8d824ea1b19494b2dd415d31674ee06888e999d82221f20cb4f718b9851a9a301dc9d626cdb50180f2aae0ffa9285617e0f3c22ec5930b348936abe56fc2ee2be0f1283b0e6c19e50cfe33a74ce534c1507493dae6b0f4a9457b33a5ef522032113c4153d54997d8530eb4f0775c4449e1d901ddcd1525d99039d72deb5692c8949f6630ea7de651f828566b72e89e703ef03ad18fce8c7b8097136a1530842021b61f75cede38134493e2457222badecbd21232ac9c0e870f155459b0c34bb10007a1fcff1f89ade8cd3d8f62f247b5d4f51cbbbc952d83c8354bd525aba37f8a21e0454a386806eb8afb02d021d8fa767ad8e1632fb83c940ce10a67bc446e08ee3cd4856c7414f30f180a34045ed805253d412b22061eb409dee47d34459a22c0b532e78487cb52cd85ad757db597bdd99c13d7c9c7f7494633f4bd0d071a474f31556320eaec4c9e266b23adfe52a21192e9f696760a600403c11c429fa582dd70ffccabc7371f46a07d187b548592c93175308bc90bdecef30452f3c0e9099edf24f8f8d61c918422a756c6c100c9fc245bd3ae98a5151824c4959f5dbd650c932ee32fb76f69ae4359724b7b9aef993d7010d33d338d1c167cf36ec9f65ca36ab67f24ebb38009d645417271270f854001dedd302c8747e7b918a1c709f6ebe42edd90403f6b85d6867dc66e2e5f793d05b8b42c87cffde5d30f8528bb02169609aa1304710abe87a03825b437528d0c23cf3218041fb6183cb874d97021319cf0fb2c809d19a0edfd65333c8f1feab94d86fc938e68844f105647e11b58f662c377075998256261a0b35808a396fd1628b7770c2497f8f5ed320b92b8c149dcf264065e9511278617eb29dd42e9332342ee6bf01c939cb6e8447cfdfa7bf016e2d2e68860a56dd717571824ccc506fc6a03960e1fa416d50b539f82e5ae83ea4ccd54b7734199c2ce04976caebc5971168cacc17fa69a5aa8286d92eb99785c6200c55f46770ad034635dd8a8ef90a4ae50dbdae0464a26a0cc3d54287c1b5ab4e163a1fc8a8dcc2e881b28ea2a54b3ad1b97256a2467e0278adf297d24447350f633ad74defa6e25f3d8955102fad679ee6f5ec27bc10325231eb64da0552f42977c9bcaa6fc891d279d3dabcf356463ae3a23af55345d7aded95d1277ef308de688181b92f8b3f79e8c49176d29ded3f3b725a2374e1441fb57aa2d7ffc68d3e1fc00ef8621820141ee5c4be429e88c18b1f17e615f609c33a0a0656f446ce4df1ffbc7bb993aaef559f50dd0fde3b20ee9fad6066485d42306da17b8c36394b233db254afc8a66a57131e479f7a8f5454e77632c1a2b3e86144111e43d2abb47229e5d66623ff95d2120f955772974e066c9299785cded18ff7f42721422c15a8f0c322f930300e58fbc6e2ce00e188bdfdcca4053104a5930623808f8239910033cebb09497dd7fd00ce812b8ab3f9a5326eeffb2b592c19af2518523f8ad93ced4398c18920487c5837a3aae41d2c0cffa3d7ff1551a9cae792b53df801d2fb1aafd0373145f92f743ec010a0d967fac39bad36fb8db97b51a26f160447156c1d61dfd2c46a0eebda5423ffa35eac00a6cb9c27194ddc1cb188f854d03e6c0aef5ec4fff9d3139bec930d09fe32507ea590753c599b87388ac0071e7282169d7022cec4a81cdd03dd406b9fb1f8d0b245912e2ff9c43145e356d80541a51d26871aa74553c75241ef95a8aba0443ce922ebf7f82a7379c5ff6517c6be96a13490479889d59def7c37ff84cc5e3c40b391b3b559011b6839ba6225e35a81b753240d73072e10d5433ce99a4a2487b07ef4f308a4a3ffffddf82c00cabbda53867a34520c9f72e06a094c06b2b95b2eea25b9cf03a9f4048e61cffa4facd2616de73d5bb52279573c69e2a3ea13b7d91659196b0b025a3aea6cf97b65928a8ca1ab29caf81552a92e7e23ba8b3598a41245990533ea9e5f0923082f1b804c4759e5b1a295f0cee7a7fd57d309390cfc005b48213489b9c8dea9488df639428c90c7e9646360ebed9c6337b4d7f3c82027b3b4b1da0b5744a2058c7c52ca1ff16a48e5db07982ff6fbd48a754b45a318a2b591035b9b19caf07703216b9cf2d6efe3f1f81ed00e9f1e8987c68689062597f8b8d106337aec73db9416d26c12bb27b38eb88cf8d796952900abb886e6d7e82aa32df86075ac5d6838c68b50da0641cd4e2490b2ec93e0c610c661c4b8a1b8d2098266113662a4157daca758e12e216fa4bb64debd6d64a44d9c184c32c99a2e72cb24b983909d84391e6911d79185d3a937399c9c2c8d58025a79bfd01cc57ef3b86940646980e242832a0d750d47f85b28664bc3eca6fb63c025a1bbf11b012747dd7fc56d33d4c9775a3e02ffd7fdd981fd69214b317045838e90716ad299f9ff233bb0a475cfdd0bd61912fde9e8dbcf23f90849fb00d9c85ab87a6c0ec4f39676a2186ef656a27dd6c9b39d768a5e13e5aeb1279e67ab5af8d45b7e778494aaa671baead8adeaafb527284bb73f47337f27be26bdf3ea40809be8a1988eb6fc650cc78c575717ea79ccfdaea58d6666a45eac388d7ee95b29e6dca4d37dd57b9245a9285b77c490c9afaaa348c7cf00646e74f9285cec84466c1b4bcc169917a4bfa8c254e7dc6c6cf41242141a5b950eac3e4c84148192fa51e5c5d333d0cdb1c12a194a335358ea2612744c82d3662cca5348375c78dc57c45574406d93be499b2e171a66c14da1b7de83849e37caabc92b95be717f83864f4db4ed5b6779b36ddd4a6abf96b45591c8b04b4ea7c8b6fd1cf053a1dd8ebad6d94a55c04fd845ffc06b13718070a50da6f1f9240c4462a6a4a9c1c976710a998f39cb4a86aa190e26d6be15f14bd2f79c81a8a06fa0d464e3a1099fcdf69474502416aa2d464df1ebc48fe3f94f9e6cfb07a8e6bffb8c0d52ef8eaa9fa84d741d55ba3ad3e037c5d313971440e992e2c9e6f6aaa61d7fde1d22db642960886a9f86ead61ced47dadd6cec81f514e39f92cb87578a03bfb13ef5505d38331d8d51ba4d3f545fabe173e15c56fc365c1e7f9641e381763f37173beb63faadbde8f0bb6a39dd13dae1a54989c67d3cdc5dad18da5eda0c2cb5a5ff601bb57de8f559a1f4b788f8d4802b770a366136efe940b13b9c016d50f6a7da05c5dc7c009dc62d5740b51e23461036dee9e9b92f437e72204305358e71eb8b9a74d2852c31373962c653e4040a415a919b7694b95848512342e1a3f861f3b14e8f3ca6b34c85083154b479cbeec41837b83cac3a139df8556351bf0793a36ab70078b5c2b9e36f135f363b12f59d5275dcc43266198b5a8393460ac3263ca878541df94a843d435184aec226a60c7384d949202f6aa43eb491f129e32671b63fd462fb5ec87b2c24ff69bf1abf90a5452b9d81b914bc95f0002dcf97e68f75782026f50c5ca23317012d8360c5767ad1f6be9c12e761330e89b85f60a4855377cdf46908166ad3ed18d5698010bad3f5f57743e701fa19143f6c2d36cd6392509c10b8394815196830384592815e96ee9e97b066314137a9d47e0fe3fd5bb51e798e8fad1f072b866a43037dc5fd96d5aea632b2601560d45f1cb8bfbb9cd8806e66e91f14e6cc922d102d287791ae5d9aed5c60a36152d1f5a40656e68fcb293ba60d4c2659b3cda6a7252940025f25fc73a195be09edb1d0086d20bb89f08419319de4666959b58534a1585d94314c8a498c09127fb9ed331a1fb4410a862f23f16c85be6be52c0e4f1b7c6a170031b9bc8feffa46a84d004531915baeb4eb32b6efb3fcec12dfca1a5c072b0e1c1f2233ce6ae818b532c93714d9361de052916cf651777a712c99f878ab201d3207fb9561d95ac0a54447ff9a27a99ce753511ed4c639841c429023fb421c48ebdc07f00c4c7674d954c23b116b6c7df6d778bcbab9c5ab82a85d3ccdf5a760ac7e7b0da8b74596d99b45bac2b1dccfdb17f6fd4421c73ee7ba7eaeaef3b3fa2c8830e5f09a5dd112b418fb2da1efb5d689a62e473222a04335336284c1ad4612a40a8440b9ba8dc2d2462ee9e32dc048fc8a9a3166e647cdfa93422834dbe3e6e20aa8bbea5e4b871f7f6070ba2e818112c00b0158c1edfb13f892a6ca14884107f630e6315172e79357ef795898b81fedb5731b106c49053f634146f1e8575d82a967724405d7424e09c04f6e412cbd7065a885fbe661e26e719e4023d333a3addea0accfb356af3688d4d9c5bdc458f9483c04bdb9bafe6fb4faf5600c62dc2c29be6b520fad53a7730f7f744dbc3770ef9447db57a7d9dc3a8f6ea00f9c8b402db7ce547ccc4eed6a0878ca1015dc881cfe990212cfe1046e974580402fed8bb6018a9ea77c4fa3e8f343e0d213f29d12684fe69a56b782fe52d40ebf1b18b65baac984edc578c4394fd20b690f7ef77a75f4e9c9f11defcd0de4de9073075ec48ba2cb1b57b93be3ba22b864d9dbdcdd365d89f36f273ece2bfa1bf850fb3350feb0e553a5944311a3d83ebd5b2df1f4b180bdca3514ee327e5e68ead8692bc3864ccfde976d07e36d3906486c5e60e473b7b5a3edef65643895c121c2b4fcba826b7a6762a769ef937496e8f8d7a9dcbdc7a58a66471b42dbd458c1807224f521a45aadf4a71eeee4cb44f54bcc6fbbd0c5a28f9ba155cd6125fa09d7924eaf2d844dd87416e188649da1df0396ba1dc63a8e535f9605dfea907d72cbebe06e9211612e4271193caa59869e67fec5d8ff137560c2aa6025092ccb99d86b2a551d5cd261b2035617208e781c702ae4f81cda128759bbca3ba779af4450a31c1cf937a4a8accba005abc17f01e7c426b801530cc172eebed6856968890e94720d7e1cc71b630eea768c2ce7adc96c534ee279a4f28e5b857631e581a9bc936d019e8f9c270ef3da15ce011f9a1148df7f944c15998a2e44af1ac3cf126bd844cf2cb1c843b31f767c78966f44483471a8836614989a042f52dbc73eb01763c3d899fa554e21603ca9690a3879d0569b2379ca150f3f08368beac945e081a0fb25e7069bdac4fc1ca83d0c165e09f0b6aa7779febe5074c11a0c546309eeb566c8efcd168629064f45903ac99af9b0e40cad2a7d932e4323226002c75ddc9f9b96baf4ae9bc2e47ed29043744e7444c774900406d2b94cf4c6edd363821f5f6bbbda5ac0d07f8a958491c90cbf422bce2e720a35167d3146a335d60ea3a51fc9060c4a9697637d8386adc915cb476f1e53713670a699f25f0321ea317fff6978e9c1f83a1f435c4c2f027c99dcb8a652f043abecc829c18c98daaed33b336f0b3c580b3c94eda796f8ad3846f171eb61549d3daf592547ab10d578f3080528b95d57f8359ffd792536ee53e02b009e9395b1532ef1d2b3aa0bbafb216a8931d4b63c87a7886a9aa5b2fb04e470dc576936f8b09ee52068188ad4f6ed65a6245b9ef4ac98c504805fa79e6bc537c9ba58f2dab245d9238e6fac55c238dfd6fd86e0898911508b2d250c1e71f9c5ee9de6e5794ed26ef73765ad4ddc1cc59562ef09a2795a2f36033aa411dba239ec4a380d9e7e1748584bba5ad9c04012b38fabcac3744536e9365f2c8c91bf4e140905f6b92867a2082c9b4e4cd791f00794e76a875535f8ac1eefb0d9275a107e7f1301942a50a6a473108c68f044b3675ecb756814c195ca4aa59b8196f356cd126f097cc45556fa53b9a92f9c0e454000c1ccd110a5026bac56b9d706989fe35f6e06c5b1e0051bee1868e240b028cbe97decb73626ff4998ee0507f26efa345c5f35f4cedc9812bfede1088a9cdf0309b4af0fe5218cde7dff6b9cece80e6166b7387060e9a3e59be7a81af29fe103addf77bcc15dbf1168816647ad7893df4bc0aad1b902fcd33589f26867cf7d0b60f7c1744d903c31cab1de9f9b1e66fa51dafe870df55bb417aa8adad611b35d645ce112375f5771b7f89011cbc54516245775b722867ab128c5142efdee8d8a35cfd4bb46379c46d5a361447d75582a782f77058b6496bab297017b63e643853591677d9c9c846993c72aeb094f289feec80c1a9dc938b0e9097f76ffc237fa6c41a36a7be057409d404431e3ccf199bfea36d54055b88c9ebe325940662234e3d4f2b5744cd610b057e73abd625c05adca90ac672782846cdf1583755b45687461d327e3732dd853ed6bc56a3a1209944f055a3e886013871400dcf646dcbcbbf26080c629f4d51750ae727a2c4e603bb06070195b705542fb79ab888d5f11211ad679776ae43d8c0e27ffc3a767c9e86911be8a208bf4cb435c3e5e459d058c52b2394ff41fd848b2e115585f3b8858f31dca00482bc7128e42e6e826098340efc380fdbbc7f21817bb869994eb05c0be257b8bc678e18c2ce1d0c8eaace8db66d6469d61473b364d9944748534f791e3dfcb29761564887df23cad494dfff0531081a67e0734f219c5579911682b9c863bd72eb5df02244e89f079fc12d1ff94244c29d48280f0c98fc9a5a51b67b1ad0e1de52f763634db5c2f22b56c75fded263decf97685c25cfcf97ee7845833e609bc6fe29366ade48c7101addf59175b6d2afc2f0bced6dc8be99951db3f67d7b183499e1fe1144e565e0174810aa6a2f4c0d356c8effd3006203457d23d849f9236bb5d89ba7b08c210f261ecbd1e8fc336a9411377f81913efcb3ababceedbc80911453026722d215cec3280c61732ef85edcbb3fd540d243c6b2a060d731361f64b51ac802098eea9cc7c064cd977d7da78491e5759f719524b28f176399b39efe9b726d8bd0a52261454f0d3c21b16e0249bd6ef5942511bee8c689a6be143d32005fb8d843ea90636bd28c3a199e779f869bdd626dd29995cf46aac1524419b88e622a14ce3a1669bbf0d36534688618225aa43fc66889c3b4fa053bd3782f8480a7be18c338c54f9afdb5e8f1e43676b43ae0d88933dc4b8878f9d8992166dc02ea07af4c4717955759e17b191fe86670f705c7c4ff7d5bf9997a6a409649a77f748b945849d4ffd4ac9146492de52537edf80eceb1e3f2f055346254d07318e59ea8832a1a1fe82114d04174c4091cea5ed8c4088f6f2a5d5098b80316615761f4bc8dc129363f00b624d50f33b03c388107425ac1e243f8018f72f66acd637c4819e39a36331a59252ffa607540ae4d0444b4d7095eed59af6a629880d9a7de24a47cab23ca090f80168978b9b5e63a3e8f6eba53eb82e6b740c2702974c09997a595d57bedef822cb6a1c63dda82dca3a06bba71659bb9627780cd35aff9d9aca0d5f9bfbf48540c30db5e1911ad71367e4d52cf9fc921efe6c5d47ac7be879286f31a284d4752becf3fc30e9d2e5f0543147d8b538fc077ca38ec3be3942d680ef0c8089e573b8f6cb2946eab0681a7a7060f952ce40565815d4a950118a9d0e8c19cc51d9bc46f2316f5806d1ddcad6365e92cb617e31576159500ab58aaaf1270edae199ad2e04a95ec12abb8b5b6d1e92f1dfb6458d5a957a7adad768d789b951b4a3635120197846a83420e32aea75479e265618bfe74291b6639ece5bbb8ad436e2d5b32a72f256d4d15a02a98f07ddb05879b087ef15996a8906d936cf1c47e7b47ebbccbab801a01f1e921394a970a30ad28edc20ea67ea77bfc006051bf5cd0010f9de0c5b3d060b1ae6ff40353d9015a645666f78d9df3aef50e8bfabbd0727409ee086e8f6e61193b2949b3fcedf4f93b810a41ec83323851dd4356ee24463b96c02b7106d5cafa93c42cef25144727824d5b1103f30c0f6b4166ba7b1d45d425824e207e15e6d515775c0c2bdb8814d43f52bd60ce0e9833ec067c79e8116fb808c05581c3503776f9de4e438d2993714b2d598647ba11887f54ed48bba048011ea62978a24e748342e3f342c11a710b77c0da57e559734e6defdbc671d2d6574f1bc058e87160723046e3f9260283df9253ce215bd025c2433023fa29f46b22805a9bd76b7da2407f40119e9b7ab7a815473f3af9ad51f757c5eea54024ef5f049a72714c26a8f8fceeb57abc464ffe23a1af6f2efd3b7656d395554f062ef22f07fed6a66fb6d151e5b4bc86fe96cf5515a4cda371cb319f0cc88f9ae7cf4612582637177070ac2af4e352c5d9a79bf8e837fa7fdbad376c4bd97052d95cb894542d32c1872c779c6715aded96612a2fef148e637ff8be87db5bb2c7728b1cefe2dcbcfd5f9f99ed036fd994840bf3f8719c0ea61e7f655c361b4276d3c24c02363840d704372e271046e4f20834ef734200f9be753d52cac467cb2838976101d95db75e9759e0e75f216105f105866f389d1061eb3e8fba527b24c78dc0d45b60e36526324c2eb66c85dfa652e137950a7fc1bd331849d961367639cfb1d44eddbcae5b2c86f278b3e24113b89e4381475411f175feaee289037a50be3c474a39b42e3564b721fa4d25b484ab99de8f8d9727bf0473e931749f6ca29af1e7cd06405de20c2f2aea7a70a4dc9894b3b8025e9cdcab37a2a7a634e69e7f5aeb46c9ecad6bcf21a1ed283a6755862d055f99a35be6a6c38607827a6fe98107c976c8a4248884ba696682fd101dacc2709a3cc5e9989966c7716c769783cffe85d99940838b565e4e4ad51a7a31ae733f8adf221e81d59b610cb8c76378efdfa427e405faaff4965ed896fa42567ff9bc60b791f9d5dade9ba354c99db2c483e84473550f30dacbf86734e51cb163d209cfba6431f2223f7af8642eda070f3db43f0c74062ddc0967b3e310946fec5bfc326044fd5fbcae468492f2a39172ef88364a930e50bb25f03899f6e8b71aa5cdae41775a173e710aa9361f0707083f20eddf256c6f9749e0c8d50ebe3f03b8294af55d2c0d25f6291981b338ed72788d07f09d7beed38d43d2d6ba2fc02d1af6cc2882bbdaf66ba863ad60d3af1f1d73fa61e62248acf09e4b2faf6e4f2dba78f7b8878fe88b7cecad5383054a3840a5c2c029b526969371c01fab942eeba744225a12e46fceab0fca1d80302e1fcb3045b4f9012c16cac49fce7400b67121141925e76468d827e40c445f51b3c6c681ba4d1bd1f5528cb652aa27b9e0d114a088f8867288a9f88132f53bf0091bcd72588dff7f161eb783aa940104d4f910e1189ae631629e7ff691557ca30e15f995ebeaf461c5a2531e77334ceabfb2de106caf715ff6135de542d7e6a8765070c9adfca787ead4bbb551361636ad8a56f579dd4fab814d5a3044fb781a7e2b26fcf0666442f6c8fe3d974250d4dd6a053394ae6f28fca59fb0173cbf8836b48bedf00328947baa64dd070953426a9f0c36b0eba3317010a2c087978c913a2901a09dce1fa9f3642a6a05168db38aee6a3967ab0416ad6eb19ddc71af31c5b858fbbf94f36c9ae3f3b9b2f6bc1ed874d09fac3277007be0ec0a0b5c337b5585d3a25559f90df26b69807c2e082666341855a86ea26487aa7fbaf1da2b027a5572161ac7341775680430ca997a55f2696bf2dfa7fae8b9454ecf9ca7edc9b20ee602d409b3237b36606db0447180519fc5727ad09d81af70bfb83a259ad9bc33748bf70dad613bf2d26274ef022c363e1bf578d7d755b55378f90cdb991b73a8ae37ccb0a9157391536e7557f8c007b5677f1ba7fe2b08d7bd580354723b562ea0b97fabe8e08403c1f493c5c2ee28e73354d6f0a53d414429ea21ef2e173655ed5b3ca2a89916518a305813207f406e925f1050e080e8fbd40181b1aa6bdca029135f46d6d5a043e3586496a9d428be9760bc59acb6593b44188c16f94de62894764b5cef451847c96ddbba3518674ea9d35af3a497f2c33d44ed1b4837c3588c8a0ad4a51e268bc1ccf534dbd8bf3edf5623b0b9c8d6eb18cf36474c0f2352ae39ccf7e52cb9d7227aff94224d6cc07c06408b36505ef9abfdf1272c647c88cd123a0369537ba2038f5b8d348af31367a784ab3a8c1d946b5d0844d351784896912ac2dd8bcd0b368a64d596e969e60feecbf55cd6be0e5f39849b3344a7723a7a6ae796b38bbd251c38d6f7dcf5416b08404c50991f60cf84eebe2f1edb3b0f1c524f9d197420aee7e13c581ebfe2f19e6bc9c089f81561536e634c56004241252ba79a40a2bc803386b8fc63e44addcf87a0887e013760da76c9b79df649005001aa724484f4db7c0241de731caec259c7a80996e18cec32444ccab15d9fc0aa1ba5238b1fa93fc97d5b7efc93c570b231b4278ac3aea492ff0bdced193e45a20dce045f8195907ccf0c4a885ae1010555a2a8ad4e09d2831db6e5595fec0140afc7c46e732d731debce25011c283046fadb97975af77fd1358f4b52d3c15e8be7f2421474670f4d3e3509fe98e0fed6fc1b15148093783776e89282110e7dd9de370ee3704bfe2933ade2fb8036e2b1e3046179c00894258852cf49ee56b9a0574f087b330a8c43ad4dfb6d8cfdefee473133154966523a08094e506e4ebd019462980503dabe3acf1026fd37519979448521844633c296f5f7543fa3c4a9a9b4b75ff31b774a100065eaf4a428cd90272165729da2c5e32850cfa51df40eaba6b2ef79eb74fb03c07f0cd417ae7b2b48c4b4aac44820a860dddbd00ea1a448b3aff1c7055d507efc5e1b0fe5273d90bb5bb0afaee0fd943a3ca759c87cfa4bf97d327d10b26a150c5457ebbd15a5d33c3bc632b6608e95571472f76d9ed4b42e978e74381a24a657c09fe6a5fbb2e14a73a348d2c77efed8e95114c44d4c7c0036a618ceb4bd11f4db95d1e452e9b47d4c2331bfc99f3095102eaa127107cc0ef49dcc1307e889bd47ccaddaf7b5ffd4a42505f21f7a16a639de501f46f1d6738eff936f1b61a1f9ce1ad769a2960c2eb20be6bc5c528219d3f6506f0840fc30f314c823fbea127efa700acf8774fa026db35c98dfb949ddc3d78933fc6e8f1c45a2bb6039cce8a7372d1bfeff16c4010f9bdf89df090d99ab78a09a80fa3bbc578bd67f261d450e73022e7785421c4ef8a22c2f071b2d5844aee49ac5e18566f038f5a1c0b567070927c288a352bb2a7ede74be507677940eedb545ea3904f156a580df8bfe9a5a8adaa3f85aa5a562c41e0433bcd383a8be9d4ffdcb256c8ea91f2bc8684e8a329e3e21ad0e96113972171054d4e5be346c0419f46f8ded1491b35fed0e37e449afe4623cf88bca26dafacce3862bfdcc8436313b3524be7fa98f7c0a330aa6b35b7f3bf942bb6044daba0853bb47d7b8d6810b95c3f1ccc09628f096dc0e999379c7ac35b4f9f292336eb1a48dfa54cd872cc90122c3185233a152a8503ec14fa6310c0364abf53117cd5af60a7a7592c046cd9b193fd2e8b00b5fb45b4d79dce6524bd7290c5626c80c2f3ffc484ddb4a62f8ef16cca7fa937e07d935b9f6f134afd64186694f276f8388da596f2616ab5d0466b871f55cfff25d11a0fa018465c26c0d07c65daf6e316624e17dd91473bbfc97c37c6cf3103f276b0778849b7a872d6032486cce26f0b9a01ffceb6a1ce0b6a60daef02e7ac6c75d5217b01551afe864d136be7998080dbf451ff1050ed43a4dcfcf2d18660b4cc238a64076771c89ed09940a2c3ccaaa40fe020d9c117ced71f207e3e4429126e03d936dbf47c88971a1d2dfe4dddf882337a80a063cca7c0626880651ae0c5aa233386e67aa1c079e1b1cffcf5486a7e32d658fafd38e6d02d2cbc03a595c9fbf3aa54cafb46bc6af2be94dd1c046a5097abef50cf09e857e474c08a6ea58ca9eec7a2f480b98e1ac4e83660faeec20083e2b5393d91cb8cafc8924158c9b79d2f070daac7367a5bc5a45f2c6ee3a137e4517f3a9708777c597b35d3e6420534bccbb009027b66b3225b4f38ef33e5870ed2f9c607a3a025e29f1c86b9cc7c2cf6212137b5b35b97cdf65cbd88b8a4c7d1bb642f367a7117a2c23574627556012f5fbd17f24fc18d9dc78bfc8402bdcd3721f711855a2e945a5b9caf253f2fd9c86c332bc9058f439e2953e3456c80fc5bce783c16c64df8d34a1263c546c093b96825b0736a03fe2646aebeb294fc41a18a0a1540fb090a5c17a800e1b22684c2c062620409c625e847efb9e763cc824c39a07d18ea615205430619f33091ec682ab0926e35da78eb38e01ba088ed7f2fc315150d637cfb5c4b9ab7b8fbdc0a86e7cbc6d2e056480c1c7a7a2ef9408a90740509ed01d062cf4faeb2c137856ba24f5ad39a27349767168e380e62b57db8016a48b43d3ea1383932458e919fa7757546160bf460ecb30c32947386392917c99e00492abd923e16983f57cfd14c2bc88b884dcb44e5b0b02c9f040e0df45baafe3bcb3b586f980502d33bab1b15526382c929a2912b14d86ef661dd40e3cff4b6af60774f673a55e6bd1a61e686fdd1fad07c12b2c8748da828109cecbe9a35fe8dd527bdf1b1f981cfde8c3591643792b9a7e5fd4e941f5d8b104efd88377a31d920f381c4c580622c36d673d6b4af362fbb3bebeeda27a0201372d75d9ea9eeb2371cc173287af81e92bb0acf2cb3ee5aa5ce5fc16c1e98773df22668c2fcad488280dd0ac5989b5f94cb07e7f8c31a228fa845cbcfafdea1f83a7bde245308a744653db43fc7c4fe103c498defea91a6a42981623c9b1279145fe5aad60b7900c1f7d99f184d1a2154941a920ccf1faf13d41174b6b32311c42abf682dec19b7f915bc1bafa5ff58be137d2c9f421a7142b40b50f563aa9d7b4b4a9771af9ae114b482e863fa7819b08c5c17e23e12a69f65c6fefdb264bb5bc1879cc33a7e106b4d15836709f7434629afedd0ea83f8934812f8660e990a62da02f100c8c01a3167112b283951595f7f7cd4217ae58d6fc12f312a33846aa1ced8e5e9f09d6ce48e7aaad5da0b9873cd8064e18beccdc11378ed9943be66b68636aa595bf7f43806aebb00f36a35fe2702bd56da30a16dac9a6b878c7682d6f87b59a900c2b50dddb7593d99a3023040a130c8ccc58ae72aac9b0d8b74e7692762a423ee4956f3c75dcc31ef730ff9bcd43d7ced9d63bf435aa33673e9d2d294cf2020258b7c5652681b0e8ea8edff3e6bdf74a02ffed494d67581596d1c3db93df19e8dc1dfa13f10029c280ed687114c82719b64bfad9257a06c3942f45194541d75d3a99b7848045cbc883a057f6137a662a9039c27a59220e0f155f9359f3da1a93117b6fb82379eee155f5a16bc0a617b02f4899aae1a2fb0946b7a22913b4c5fc51955f095a7008b0261f85296aca6d4741feba63cdc1fcd4af1f41c4a20a8713860d1fcb4dd32020a7936f02b5554f220a00be859ebbde0d66121fb620fafdbba64baff24803855e104d4faadc0339959e1284199497f76b11e4e6ad6d6989630bae6ba33ef327ea4df6c176a7cc7563ac0f75c5f043239cb8c1df4c8bf3e0f02e27cbd529362c158400a239eef3c95d997d4c8f7921237b71c4e1d382a387deb562e0fb0adc3808b1c72e07387efe09a22b5977f979a38a39027e5e53c52d125f31ecb91c92a1add6dabf6dd6805871d1b146e9c2cafd1fbf69de1c3de434087a35ef9370ad25654991df62e44e572f5b6d7274f749ce063caea18477823390a2ce55152d3c4900cba30a767b74b29aa2f37e4b6e4f1138ed2c2e964aa8f8c7d00889870b442145e10bd0db82ef345df4bcada737d045a2db5f8cae5fd0566174b752273b0255b453dcd042fb611807a59e52a73b737574481246168fe5408ce83db1eed133239d7372ec81380515a7f48ddf538c26746ddf6f1677693166208f74a4f4f8c7444d14b164e227fb9e7bba12b3d55fa6324d11b40380f3594c95980b51fe37b6105d245567f8affa8335c0210a0224565541d1282885e5d23f8fbb420c9673e762f267eda4b738c1f4161b3e27c1ac21808b3c33f96bd7329d98650adfa007f498a0c1d306159aae59246d2b405f600690d62ce1d2765f5eeb8cddcbc35c756690953b56ffa1aa230a0eb2f294ca3ca9305e581082addfdd997b93378481e08c9a7cdabdb4c7590c36efb0c854d328e79009e68fde92773333c6a6d1f38ba16098e7d10eaee41674cb56714548f59557ed3cf3ce9bb21146dc879389a32fb67d3f8e742c622eb58167282a79dafeed31d12ba3ec377b32f882dcd81a94c4023c71fa5083c6f25578ff760f44b5f4d0d346c3936f257645b31ccb7873ff95b63eea22a391beb0e60d3b7333c0bef4a3ee7831252eed1a51b8aa7866a3707f6476ad202c3540550e3b7d4333336e3718b63acc876ee1fb5e880af4b1ad80274dbbe6dfdf25f3527d71eb5147dfb1bb3d653e51b830c3b8d5870f31367b85ada8ab8e59d2749e8fd463eab06d1545cf9d4c7cdbafa6d8d0a64cf6cfed73bbe0eb7c4f17ad0f81d2445fff25c0c4c854ffab665ec2cb0583dfaa8e7289fa5a09e0818424ef9bdbc6f53ecb902f885a1083877c812319feb6d7c66f9c7b54bae1b7fe72365f3675b96f919d89803b6ef7b00c0d19abde6ec4025512b481904abefd9294147fd4f3fdcd1ca8874ddb45a09ef23daefe511c8c2dcfd9b57bc18fa527fc83735aadfcbbf4dc9ff6f2e67984276211f25bdf0022966ed1db9d0ddefb128d790fa8c5e2fcf5585d3890ed0423a21bda377992bc9c0055db1088898cca5fef8ac5319c40b811014ce95f70103828062718e64683683c375fb58ca070b2770c35b5c12b32302519033ae57c5beaaa40ee26565971fc18da4e37354e1bce6203f8cbfd57be8ba126a41467483ba73b4d925a1537acee41f4d22e2bd72ef8dcf7ef6bdfb67e478fc6e3b1489e761936e7a7165600ce13afdc2403170ee46541c5b677dc67d2f5853e89ea2664090c01dd54d9ae944fa3cddcb30f040a8f9f042058eebb32d5f9c291148d6019d10baa5588d6435eaa2b78f2a7b396f9ccff00bd921b718a0df536bee9ff11bda286d06e7b0529f102c01f5aadbc83cf1041939f5289187e4c4e521ad886f89b3ff50d7452151cac17477c0e1de6dfb45212d02a1ed49e03df1ec0aa3a9017dafaf14dd368278543de9f539d4cfb9d7d5f66ffbda4fcd9d23d446f7d472e12b02cd956b63fad280bdf91cfffc94e39cc8a91af100394f13ec7bd37684faeedaec9e55e0fdef3a7e09b2b11d9b2172198f41131186aa6b2a07f38095f26d1ecb7e7828e82e5d7fe8e71fdfc46eed1b5bfc72a37041e76009e318864f98e0f173383b6082bed678b3bc47d571e5faa1232687778bfc474e057ab5627c09296037e5a251bb3e655ac520378f2cda19f7b1734639d7ea0b2a3ff62d4f92d06e682305dd5263fdc704a7a652fc9ab1f4f960409c8ee7d7a5895f3eb1aa9e118e3c0b611b32f6678b5b69f25b5e953b85a60e34176cb01f7d6883cd02958400eb4dd71465d030cbba234974fe07145cdce7a73b6499844e5eb46dd50fcba8e5bc825456e1f5d95110d02f72b02a25495de431945d11dc61d541928aa605be67d40c608b0aaf5612423a781978db3417b10ccf79c91c43bd65eaa4ebdbcd2159d2a5df82cfcb5c01c22f0fa10d8d6a8ca251d1c2a689f71e9a433ba3fd5b2feba3d1159f71a5b7e749ef190f9029fbd2ea2f827ee2b0ef671d95567009e88ddde42f7659bb589ca34c02bfe5129b7f71e6d86e064f52714e1f8666bc9dac8d16586d36fdd41c53852f59b038f8ecedf3b4765b0b5d9d3a9d0a933e9690066d9d216398f17944e3a89f38f571aeacebce8f6d961572f8d2ee6354b6f63ab467f0c6af242b624d3c2303658dd8128f512608ebd31a79fd54879ef4c2b43e722da1781d02979cbae579dae7ddf0bad0f1136317dd9b920552e481e9a5899ac1411344111c32ed0a60a9ba5d7a4a310fac8f60fd2a1814e5f67b96e1f5fbc517f0cd939ba3b7e72077e666873f337c603c7833332151d0ed2ff54edeeefbce8c9c681f89165c3b0b969f9bda0138153ec8ed35d7692b4b8bc0ae70ffb86d4b33133d228e0e3c5ae50304ab74dd30aade4030fd2b1fc2209bcb996aa7ff663d931d246d19c421cfa7c403382bac3696d15c5d377820d0ceb0f27ffbd08603d2127dfd3632e5edced0d1ac91578bf5620025146d642552f7dd947f354f1bee278f7864bc52aacf5c271831247fae34e9efc4ca14465e3bf41fc7764e3cd6b4a126b5e47358f0d4bfb45d8584fc6b86096538978b18e0bb92eb0791c89405c2ce3ce51932ececac89dcdb44a617c96ec504b017b70df37fc89cb98482d9fd762ce0ff4280c0833c8014b6bab7828351c47e75dee67a71deaf77ab221d9f99516cd60a54d36ff898fa0baf0f5282201326c2ec6300a26d8cbdbd7cd5cd6132ed56c1db214aa5f5c48f21ff83cde59830b4c8c16ea2991196094635847c759e78b8412b1d5d997629ee5a66b52d0c510e3ec2f2d49f7d4e9b06521841435eb0e766b9cb6bccc1aeac9f50080110f5d0d255f9da091e4fc74318eace56f1b9a4555fffc56c4899fc66679fe13868e8d65d1a886f7a9e8d7f04d473e47ac81319b53b25b06ad026e4a4cd3ad171a2e1c5d1148f15093d1ed2660179d1d17a98d7c73fbb731e65e925bb58998ed83513bbb7252c15655083b260d5009797f063492d2f18aee5114cde8fa85687a3def583861769dc16016798463c0a4c7fa13dde7d292faa9bdc16be246e0190201fed0913bd9ba0748d9ea3af7e5223dc9ffcc63c147fe68f6ad3c41cb4b5be44a09393ecbcce217331c7c13976b97e879a57c52388849e8a7d935ffe5517ad8632487b69c000951c1e2398f76c449aab1b28c191b81eea32b3c13ad5712a53b56e891dd04cc315d35fa4bb507a0ae505ae05440d376b081a3a0a02008c0bd51a682056da457654e24946f587e0f870d43fe8c67ee741982c0fba7b7e6320f7092ef04fc8ed38d73a4072ec69fb57af51a2b6b552e2bf056f865860097abfd92c58f38926e951ada26155287d776a1a2f06718d965638b8ee13b6d4b0a617e329c1fa8bfad7d239d2ea96c7ce5c6ac1e40086c4117a599d3dcd9a26ddcf5cffb7293ad7233958a5f78debf278557fabc7a5b0de73e0ac7b62ddb2d852905ab1c3b0613e597c4a7c6741628658654d6b90fe940d814db9b5a08ef58fac1556b45d05ba700ea323e8cedf270908c194c9c55c6337d62a54f7fcf136eff48dcbcbc7a0f88e7ae24cc91de87f29463e059ac791060e6966ca1e5dc4c4f5b452746fc5d64ec3ea914b7e6d41630f7bb119c0b5e714adc9cf6717395be499e6bd26e1facb68bd0c0a2587b2dc325c4a14a9b670fd9d5274dcccbdfe58b798775d33b481ef9fd30cce302df224bba403c42b4f0917774212407b7fbc0ea05bd5a80c21a418140f7cc2e0dc83ac55d5544b4b65081d40827d3895800703b4232385c348e561a4703f0ffa6d940a9cf793e35a79098c41a0b38248470b17ba4170b5562b57670556b59852c0a95f3759f1b7dba43f8f7d1caea503df1d8c6b0bd40c9fcf06021eb88e805323bc2e92434c5505aea2daec944a635a2c98f8b2e5c82c5bf52b9fdd57b17aee2f101d98516dfc26141a1b1904217f530eb559e147cdf0fdcea098a08ca800a670470a5e023e5b7f3067e944950ca10ef3166300149cb5ec3c258376bb023d036d34010d01dbec34a313d42741c2e835636460522442975a155247efe4860bed43299e45bbe51d5bbe32aa4e4fbf7c982a7f97a03a3d4eddc4756a2557a8f5f5f65f13be1992f900ffcccb97749fa216eb087ee48e2a28ccf163551e80a352d4c3cd91709cab6247dda5bdb7e8a9649aa4015ac73ca082c2ed63d96d67a9be14405dae210731010362559826d424c842f0f8f57f4de0d076c4e19cd7393c09b5be76378aeb134c085b868eb64f8d0e5858acd1cd829b578425bc844189095f0477bcbdba15cee51464bd7af31d8add20ddf851e6aa9215922f851026c31ad808419009069fe1129bb3514391bd46732805aa6c5ea373c7c534ca292f796ff9f1bc3e86ee8c5de28205ef5e4ab75f7b5777501c7855951cf98af81f7973211c1554887e52e03520dcd08e4368544329e5f702128a3e8d9b3e6ceae9bf8394785c5894712553696619a8c136253b4a16ba61c4e8cc0d30cf74592a98eaf990ab36fcc319c92749eba77fc756004dbc28b82e2577fa8f6dd411d889348018b215be51ec2091ec09f8db12996acd098a7c8a6d3347e98121811bf554dcdd7a77dcd0d22cf9d50004eec0a8e44003937faa6773590c8232d2a005f954485d7fc948b924adb99d5ceef4f483e444e591d9ed036faab2f4fbabc0d2ad879a05083651fd6bc80699a648cf00785f94e55573a684edbb0100fdb72bbb4e1991335be653683a6d9bc12213146808d851b7130661656f9eea5baa70361a33c1360d5611b617b64dd99064d8bfe8746c308df1a4f195e12fc052b970b5a2ed832bbc67f5baaf987b522168d9337fd94a4f9d1bcf1c8a5d2bdb48c1a707945987d8d6ea2dc34850ce32db68046806abb36fa97b9baa0b296dca41d97ed1ad8da714bc069787fb6e4fda077b022d2865a2195f7a43b3123c2172469af71ffa68d908fb0b5e65ab9392374f91736383ad09f89a2420631f86d69ade3dc173445681a521b6e5fe89fa0b8e97df9d3fe9cd39be5bb90346b282eaa5e375a6f0337ff122ac151209739106f72d65d11a124b8e7de0e9a207c0423f73d376e83ebdecfae11c025a4162fe1ee6d03964001c3fb8df29f09c08519fea9a9e01f80ffae18c9db1d6aa6e255e44439031681acc65421d30719f6a0d569cbd1653fb4841c57ea93bb97f050ed9e823f548cc60165038683a06138f26467848b65522192208db2ea13c2b66705bced152c5a75ed51e450fb55084b2b86ca44a96d32a4798cdf5d99c62540c0e3e6eed86810c8894ad3d20e36e3c752e5fd5f85cbe877134441f61248115a0ad14051524fc48fdb2f58152f5bb115d06ff8d1228eac673292c4323509d4ead3fb7ce5e1564b0efacab033d1a81aaee0f7618e78408032fb371af22b38543e2bba31e10e26c94862901aa4a605c6df710c8e1470665c8b71e9ff2c9e795e9889040ca93b04af0a33082c3340e3cf9831a48fc6f29bd7a6c4796813b4a152682e8af8d1033c5ff7ada68356df529d85162bec4ef71c411f284d23a23140ec3eb48d4e33c465298306c8b17cb7227730e891d3dcdc4237b1e80d169b2fc35576162d5a2ae58d63795470c5a9e778467f2fa67929c70d786733b4b5e21459421b4e2a8b03beb6d0bf4d48f7358eb03ceab9c19a7900113223bff22847f331e0c2893b39d07963ab54f3a49f0b8b8a7e3bd65522096909edfe933f29c9bc36c1afb85e929aaca620a165e0b1518b2cf57a721da3f3a20a0efb9b26514b1ca30b9c4bd1c7c129f837cbadc982767f353403a2868b4c46d3546d64397666c4dfac89ff0ceacb82eb791dbdc9b7eebad41e695540012eda44e4359b40d3ae9ef188b6a702356c7445062246b1ea748c77eb53563868342073753c3916a939bb5930d0ed19a65ca3c57c806cd1d39495702d562616b579ad33004dc61d319d8caca3214e28e6cda1d8ea5a6e63fe228ab2507056ddaf98effc6d9c740439cee427dc0111cc48de0e415cdba6eeff4f56b8bf1c0280fd76aa533270dcdd761744556f957b901adb3e66dc5c70a14d2b3a3630a3556e31bb241e6dbc691849e07cdc725eac5f76c9f321e0c679057cd32e1b43c01ba6846dff823cc5200fa6874af7da12d4a604407ff663546b5af12086ef984086221b64cb96f479290895d37bb85e857ce225e00c909168d4aa963af1750443a4a8ffdb9eada46fc5b31fbebd5b8b21668b686c31859b5608876d8ad8a5d86350cf081342c4388a5c7a66da9a46169b0fc1c43cd0b06f2d50f0a6877dc2cebd32a41b2a907cec341411ac461e152ea8cfdfa1e245360026ada97995706155df2cf5552d428f6c873faf701fc2e5b5b5fda64a3a549f06b3455f1c43852f413f3fd14e7736e03bcfd09c239fa23039e19897b72271476f28d16fac75dd2f56e8d630a84cecd59af2cd90e78f6d561401ee4b13db97088d9dc3bf4bf00a2a1ca8efdcfcb9f59be21a0a824038efb1b1572fc873025704904a024d8d150d31e5463f06f9a55535c2d8a9cc7e93877c2a7e19962bfbc1c4ebb26ea9133dc71eeab09bfd07d9792abbc2c5fcf339c0c246aa8f968dfd81acc5d6df8870df15ef984acd1e1978be9ee9094c948b75c8979f9163dcc5433782b3466f0f952b7d11625dc62dd63525ce335f53a15eac0632029a1f968f2ea481dae3a57bc407e561a9471ec58139eb0929a5f2fa9d529a18ee35ea10e021cf6c381ffa3d4ee223c844edd14f4a8968b840a4d42279a98c27d235796ac7e9a1087c1a08c31a88007a0cc2d91dad817e391640ffe19c219a3332a9be7260d54de6f8a901245dbb54c64e1ae7a53fb336bf789c87c3ae0f866ba2b56f74baf7ac36100876302adabd3af856133e59aa9e7dce8434e2f26ff37d86973adf4e34cef16d8497a853f01d00c7ef9b66719cb190abca6ffc321c9d2fd5574c3ccab172fcdbdba1aeab67e3006fc4eadaff3784a5adb2526d425288121374ad8f0a603142ad3bb3f167ce06fb80bc88210c0cb7f2d502c5cddad20490451a582dd7d16f6c9037016acbac06add16c783856e84be0c3d9ac383625f67bd7677654371bab4f1c90540810ad206a5ee608a633da93518e9bf03eef8b7c858ce388168e2aef75d50c4c44ac7f92e25da92bd6e25ae6658ba166b21fcd3eddc3878b34bed5f78ee6aff3dffd51b1b27ac22a8f0555b0c6ae2791fc47fe2034328cf4b1fe21717743416a8f8481221c53d3ef68b57b78cbfebf4bb3e570b7d93e95da6efe39cc14f4ca593502f002f70c70c07f29f6b202c3b00603c09157645c5421ce0269abf6cf474888dfb31267bfa491283ff402de4c3cc554616bfbd3036b55fc341e16bb1df19d5155bba24570a52b7c1f9dc72beeab36b8be154779fd0afdc89c7018b3c14da1904efaff9c33c29fe310fb1da94acbb5620fde1fd94ddf4a6aecacd6f7199720d1b18cae8c1f89445b2b94ae1d0dd379a232221ab5620f4aee9a3dcb0cf8b0aeb53c106c4c91e0592e740a49871e68c54653f46016e543484f2145c237ae9686d933c948f95ecb0e8d47d2cdf4936aa542e70a915f819a7080a7bb302d2d32058a2836251dc195791ae4c0de81605ded927f6a98539950757f2e33d69ce5b7879be41178c21074a17a77b294fe0bd8aab793e3babb5244b56189f3dbce6210fb19365ee13255abd09bff720926fd9e7486bc50f381eafeb9039d329542e788cf3e29c4cb88c4654994b60d08a43d1755e4ba1fa06d94bbd08bec3d5fec05d07ea152099a2722cec252b681e5df2db8b5652cfa3828f780db5fa555aeeb9beedbdb40914d380e3f3e24bc27e896d025e21cd76933ef846653319b1cf94947749ecee24489c5468c5cab1cff0eaab55ce60675ccf3a9f0bba4ea416f7f31ad845ff8e2b23f3fade8a52af7909fde23cec26820d41746ede3d402729f5e87ccec4c1700ce8883aeb481aab64fdbf9b8bfe7423d9a4dd86dc70cb07494b3ab2c59248bc27d0a14b74f8e9d690ae5d6a5afd858d92851b11715cee1b6a3d29c6b8239af232835b4cbe034502e9a2f5ce4622a32a4244e3aaff258543e0fe8c180493b2f7ceb357fdf0ff393af5af8770f5e0d69d2b39097aa5ff6930bc32905e93c22fddf5967f2c31523b03d055b2bad16962a8e6d3e911ee2da2fc410f144cfe1639d538833c1aa385be35f2146528fda4ee6858aafcf21320b91cc92a15c2e8e78643c4c401787b9cb8c13bebe49106588df2c930805c4f12101a213680cf3a56d372897d7d72545134af28aef96cb48138ce96e7c8e6fa2d3c898b0a9045148a4ab8e14de5ffd52f38716edc0c3fe4b50e805e1dd65a261d0789d2d9b637b74fd87c7162fe21fa5e27f98b900a619cf3158644579a3b036e67ecb0860ec0544b54a01ec29d0b052eab0807b80c92fb42881806b9c9c18de90215e29a5764a2ad74942e1d6df36e02c430e19cdca9662fe3c73eb5b2235980d68667beabd2401265368e3baf46ae695ce670061edf8dcbbd51520f931ac0792ae8bdebfeafbee32bbc9faed6b2786d4263f377bfc1ee982bf43b6e425b2145a9d5f6217ae9447589185d6c2c3f6de2fc6eee90562380c5b062ba2a1d9c1b990c88d6a6ad68ecb0a8390eb7aaea1049a4740b63254ee63bd6aea887cb1a3b9dfccc0f39aed46211ba1474c55edef74595a773f760ad1395327c988d722e5b9d24ea316d4401f67229e2acbf4a2a1d5f11778c9306852f819dcc2b910328bc4cfe0873bc0a166eee4859c3d8c50183ce61ee9a5162514f08b1cbe207662c55ab211045c176ca46bb6cad8b667f4d29284c25ecb80664e1587539466715588196d73537f89a6f2451b846fc8c271e0e5de4f2c2de66568f533caa41237467a3614fe2cd25ebb7c468dd1e8ca94ffc273c3cdc7ee8cd1adb13eb2120ca5a9a83187c67ec18f6e37f041f47cff5717b31e2b190b673a8064df582b43163a64796a713053e0168bf11ad0738ede74489765d7298a272d093f00363fed2e7a12bce3592e873662fea5c477bd333fdcdef2de166596c9c573e9ffab68a9c91c6b0978549aead7ca6b9638c0b50dae5c2cda5ee10e0a45741321089a7e353ae9d33edc77a1f8675fd40e2da36eabd36e16558ae02cc8577ebfd57ae1843758e727a55f987719133384ccf245a957d7868406b31a8cdb938ef5665aba35bdd7801c351acf133016fec41435fd2ea941aa080eef75ef077c81f7fd175121fde718aaa653dd926ec8f8726f7d014e702b2bdcae778cef66fdef80d51d3300f3be6408a0239c4bad629d22d7649c1aa9b58e9b76e7fad7bbba603518bd5d7151bd984f5976485dc5c89a803ddb1de3b99896f3303a5c54f7b71e854dcfa114ca0616f1a155d04542771014e1d8edc6870bfbaa8bf30a415e1b8298cad7f3c1a8271cf96ebc99c67c535b7121136cc36d66bdfa67e1cf26a10d63cd4b0ef647fb0d3735b42dc7aa35a3a55680b8ccf79a1fb93b17554ca97f304772129ce853b7677e77003d7a62f6edd3244effd3ebef75ed9222a3db5c98385cf7aaa93518d6fc0a2538b98c43d27098132c3e2a97a0edec7d51d383058201d3efaf4e0637c8b13f4650b30f425e516fef67a888878fe321c951a8c7ed4bb26795962c2a1ecfa8de20382d8653530ae3eda2ce5495b9a134a0d6d0b2e28ce214d31227ee0c340dff5c3af71ee99be2c60c3920cbb4a5632a61feff113e9301287e11b00395fe993af438eec7870fd61885c35a6323a3dfcb7d7327711351e5f192e22893da2e113b19825437dfea8a37f025a8d723223285a7dfca7821fabb5862a2508612e8deaf8c43e0380c18442d1d48174928b42fd1d6181732564ec6cccb50e5b7f7e302ecce6de8cf1ac564fb668e5edff3b6e6bd8239648dc346a2843b56dc7474289b1c68ae9edbe9db6a261b7f43f68553f3936cffdaaf215bd0298395a2b00157774528739c92a81c991108f4804b0c8e73883f42d539e6f54be9d8ac169db8d52d19603212efafc196125c701f9bad5dcc9319e3f07b071d04d395a4e666894373b103d43980d5d2f70f7c5c423ee0f058cd61f46c489f66dadd199c085002e49d28bd03099f879b002a4831f11399a25e80e87ecd2a836b2088d7a2ecb2eee5fbc2ac9ce1cbd8ac1a44e93a2a522a3f8b4704c5300c82c9acdd79bf5a0e6c8e5644512942bada45d62694bb1a9f4247845ba9425457928c1ef0c26141b4df825bc788adff5e22d9cfe114647a71adaad4702eb83fbd908ac55b15f9ea404ea52c02db5f084b9eb254fc6c36f75821d01f5b8e18daeb7f604bc78773df0031741c5b3ccd8db524f45ce7ce1ec9d2031c7c39c61515766ca106c392949d41fb766b8dcb766d7db4c81b5ecea94e738aa695da6d2779d055240f1c5480940ae491ca3c09b58c3394ef44560a75de2107e5306c1d8331e80592c81a45a67b042bc8bda63e81eeee8e9eb9183777745cfdc18c44f58c1274d887e98fe2fb72dc743117c245687c26d5e13deae06ed0fa168002b603dda6ebfbb739391eb255fca4dcdcfef9a97d4d073acb526d06c774fdad96e200dd3f36d4ea704ee38acd2e935f554bef78b9f8f6a110d9db857d4dbfbc0246ab9969b4c027526d9d5d3260fe326428b4248de9f446ee9f9c77f787cbe7e4b885e3ccaebd235a369fb0cc731c9eeaaf1df7a7cde89c6b2274d04c51870f15714aab81fdb1e4bffdf57425c1e3ca416d2cc4278b00fcf229b43cba88fcb06cf53ade93ed411bb93f22794f4a97b26644b75d20f3b6fe6ddc927656b0d74a41327238c1aaf93cada394c119b944a34e1c02cc9d309eae5a322f36d824f68e6f0e26176eb5a59e7ca181d9cad79b00adf46532b6e8ea5fa675dda955a24cc66750396b0c94afc927276e4fd0d1bb1de05a8052b40f85bd0ebb87753332b09e1d0a256ac5b79025c1e99c248cda92ee60e4441bf30de9bda303f6460049abfcfb07d374ac7bcdbf00d43ae8aa80a52207a02098b16d6c6dee51742a61f1cf1ecf12e7032b7ebfa9eb2a76168f3ee3fee6e2735343314b8ca77d408c0abe44e42364addd43634ea3ac0be4a4edb7c8eb94bbfa1e59f5cc751a763d5c3037ad0ffed82cab7c589a624d1837cc4755e3a28d85d177825a5c4778033e7de5743f64fd67a05d2b9a175687a3142720a104e96001d9fdc843b641c8dc6a345a7fa28ac48e8fc2e22581006530bc0cf68cd2f3c9fc5d787ce82b01f95731d17f708da08da814d6d95ef9910084994851fe9c1cbdc08615c2a5fc03d87231b9264f098d1e3ec154604f3536252b5c6ce7d4e24b9e80a38cc08140cae0929149ba76cce2f7fbf88a35d4b35481e7ca2d90f83185de12f74a5ac2bc535a387d511561fa4fa802317cae299d56551ee3c896b786d2f3efae89b703e441f2c47aa738ce76d8f2f5d1e14667781e370b33470063dc55e95bc1e844524096a82474bd3bc54c373d6544b7bc05e2d34f2c65b7191fb179abb1c1ed02fbcd698617d1542bf50066ca8291dac94a71d295c0d1b4cbb2e806a09e7db049b05b36a56b678139ce88998055e0e2610ec7ab1a90df817efb023ad04232f83d650225639275b2806bded3ea466819c26432d92a7e83bfdd4db17172686d0389a4f5c76f46df3a834422c9c1cc4fb25d7a35e159248fde15524f32359be4570c88c3a7207ea8089204e356b643619eb3b3bb83be84454ef210ef022cd7d1043b7859d0378d6aa2b05fe26767ce3d0b8ef3bfcb3c4c467394ea0f10c1725da7d413cf9353ae631b6014c3531ba1eeaca25d5e6866d2ae1fc2872fce9bc0b3c8130a3f28bc642b2c3d95cda03347c4634864cc576f9e4a19345c3bf33252ac432bdc2deb03a0367dc675f6cd502edf652768f15f9c8e2b6ea649517ada4d16d24279ea185c2596e04bb71b83153d9971290c93f6e4d860021e03705b3a184e3ae569fc3be53a26651993272b54eae564b8172cee56c90b65206117f933ac5cc02c51b100078d94b950f0814c4a8f79aa27597c2b9e2408b225117a9d48b13b84e8740fe0a29a6ce5d2a92c770800fbea4c58ef41c893fcffe5c24aec187581668aab1444677530e86889b668ac5b7642d0c171232f837842fbe2d0163e6d207e8eb61440a489573f2f9cb8f42829eb6628def81de4bbd1a9a9d1d5c1bf911d356a5b11357ae461e31a6d27c9f9a06a2a5c66952ebd8a355478eefbe9d42e3d931587088c03ec5306c8a3c5c38c47f8630822b4f7267bc8abc1f4c28e313c9b0a97be46f23e2967ef67c224ed80aef0c1f23cd112dc28f85da062c0395fea75e145cd73b6d94a3f4a9e7ab250f25c52aea4419d7a8bf48297397151eea803851e9d28ad1ff33b5afbbe4b069fb8c2f1e69ac8ad0f6a053e53b9a9833607fb7746f7889276e4498d7cae87fbae269150b9c427ad8878932e8ce4df6039e6bfa0103a8d92270c3cb895959f3d1b5e3248ca174ad26285f7afdbbbe19e1c4b0f56b9abc7f45b96b8464d731af50c932d1bae2eca98775fbeb60f8ad05e18c49363c8c8481ebae6443def4567f3b21bce83801a3ec5fd2c8973d562e566d423de23753b1954ef40da96e727baf3553cca5b18b6fee5f2442a19bf52803896f72f6b926731c51b5d3f5649caff7ec3901e92f4373c380d30b6ef56270bd31143eddec4522bab2a2589ba10e7f02604a2f0db2e2ef5d47fea344f0a055a8c1614e60c5d6bbb6a99c452b7ea40d67819c8f10e512c70df22f7c8871a4824fca16f4cc3127c8e330c4093fb0d7df380bfb1dea3b9036e785894253e7794743dbbd7f2fba6694439b21395e59f6b505e3667998876ecde7cfc2fd6014855c2541800f330810235ddd5dd1ddc23abc74c25e0be70e77e0d1332aa350f9bd0d0f1ddcf84c20d317e109b9346683b3ad61bdab59367c20025ac7612bf07221e018286073d9d2089e4d2823d395a441cf72b7b5e9ebe4d11f90f316d48fb7d5fca3a4ef66200a890dc762b5faff233613965d3863273690b37563d52fe59c21b69946fdb432a4d7a6f1cdcbd1fe72bd73d3f6346fad4255e2949213ecf22ce1648b53f0d55733381e9ca80bcbddef4c429c6e9bcda01d1fa0db5822b657b91bde6e7cddccf9db1c4ed4b525f9f7fc070885589d1d13161194d0a305ebe2c42b1dce229afc0406d70fc1220c185e7d20ae601a37e6d20f75bbc9b3e467721704d16cf1474c13ea393e220bd1a99c7018f932434ccb2e00155c515752f2dd3236d1933d8e96493fcd97ad996a568e096d34062da302a6cfcd751fda705872119f2bb7c98a239f728503f2392f59797b2f6017e9735fdf4736681f4126d6b8bad7efeb40d025f86023f954ffc648ad3a77e21f72dfaf36bbbe42dd75184e7c99b81a64b90f95b09936bdf6dfce7dc1f87b5cce48a473ad0e695f4ad4f098644d18b97e8500eb9d413bec674fef28f9fc8bf01cf5000a1818ed735a187e74050287587e3e972be3d6f9d9b0e151f84efe26d5564a1157df3908b95c268570b871307c5cf1875f4e7fd48a232d48194003109207273f7104b4916148226500900a2682c05db3c6d4893869d51eb246f60c67af4e9ea5993e98ea8c41044d9ac46b5406f85a336c7ac3f1913873f621bad0689be16fb5840bf69725c32aca8e71824a42736f3cd12de96e97fbb6fdb2ac632371cb54c4ceb9df125eb44eacd8cc6bbfdebb1a71aea0455fcccc1d297f99cbdd75e225235e0826ba4bc6b7bf23d1f22cd0929c530b3dadc9e9599e9f0326bdc51a93248ff441f52ad47717f5d7a73bef18facd1132e70bf50ad0e8fdf03007d4cf117fa7715c46948ee8ec099a6d4b447e7f08d204dd947ff64f14daf8477cba54220101ff30b5ec1925b65da75122d1d1f0697d3b10b58c124db6d7a87cade8fe799424097e4fdb9ad473885cd747415c98a54c5b66b12e1c7fabcc3a971faeba9a2c25af202e7189dd054b330b3a5084d6fac91dfb8cbf1a0abe39a8c7222c0e9783a0d9a3493802d7cb24c323f6b7054e2ff6dab5b9590ff2bf4090025066c37ff9af6ea277e75d3fa79f75ddec1a669aeb55fe717220886ab8d6c12ded2c09f5d2fc1bbdba4959641b6fec23a0c43e780c7aeb1c39d55e5cfa693daed7c0e06aa8532bcb8bbf27b2881bcf791450d8a81f729c06e9fb6fcbf18d7a0fd8501d483745c8d1e4318db2e53f3f9053a9fb175f966646717b421e8a96a214f7dad640f21bc21044b275db82962e131762f6251c3b789f5533f96d7cab05a6b21a98982988262547e76707b3e1aea43c8e3fffd13b1059bbd23e38b1fc679a704ee2265791a88767de3b493b915f68a17efcde490c2d4df7f21879244630d759153bec54bbee6d272ac9a47fc5cdf3910f41b212785c9f5fd75d81bf3f35db310bd260b5eaa95c0f6d75307ed45490cbf524e1a8e7a0250dfb0d3032327d17a68612a5361f2a84056eb733337825e9eac8749331f425e9fb7d2b4b8fd2df33d8c5c2b187ca862f5fbe6bd70e5a1c3e6e17d578ccc35c7f34f908c6ce0d84e47b3d2159a69b65600b77a1d5560bcefc4a626e661d92488170e2bd55e7da7532bd88a46fca7a9de2dc3e48a6a41ce6d86704b61c74730b920e28a90e7f808305c2f43e85efc29643307a9f6b55ed5c03690dae4fbb39e2e8e84ee2ddc0d21bdfb1e3673752a545f08ea84b965db0b3089a0d66a67ccd3e80a2bfa4b960b963feb4ef17ad85796cb1a5b958e422ef38d58b861089982f941a4f585be98742bb570a530f52c767cb56d7446270b4ca5e141aa174a5f428e7d5b295331ae1506993e7d9456c7baf8fcbb32c289130740892a44de63f10a25b19dd474e582db107fc939fd0cd675c9562c7f1d8d69f82fc193b90c23a8c5a2b73019e21f4c18079b5d9d496db2dcc999886b37c20b56e7ed4c6d7eea175965e983f57d477ae19566f3ad50bd201194d75f983d56416007d4ac5d91a575dacbd0aecd1374284ff7421a2bdd1d4fba4c76d7fe337bdd9b55a521554228d6e0060bc2da24830a8f30a62b9674019be0e0ceec9ee60fd7d0b3b8bc2ec8b8da19cd13a8661e6a318244add3a19738dffbb0caab102be0ea110a6be9528abb7f28a2012e9e3a9209a9547a21c30ed016ae8320d99244853116865fcbe537c44344059e23e19ee819225678e33f8ef81a1d170ea52945fbee5e847bb78f94eef9a8f46d78feaa4d3d3aa98a6444a8b056a4931e15f1fdb287baeb2f6adbe54cec7df2edadedabe8f7941b95e8c162407ca1501353090cc5cfb962d4f6495376d504a89588d029ab57deddc4b1e22ccee2c44cedac0c0451f9574168fb658a57baaaf46ea8cf5d6c195b0544cd2fdbf229a31a27643db4791d0bf94ffe09ec6df6f2346f2ebad1ee3871b8c9a33db71612799e26d25af662180ab1077f8832dba46d22ab5c074bbcb7966db62a6125f1aff2425cec0a5674addc411f2c233c650635dc879906a06cd8ffaa268fd6f12f2c2764d06797d9be8592c86451ffaa9ab699d80c792e05fb99793e452f20d8846e74f4a1c79f83f65103a78d79dd15d7772cc72b7d7e0140b3633664150f9c7192eb6d8c8a0c23bb94c9b183b4386977533b79958412a673ad632560571f6a39facae2e875669a4816bd5204ece980a3401f63fccbc9cdadb456f5ffaea174b346a8e0e4396d09b9adf8bef11048d224dffa2bce7c50e37acc32085f12aef6763ff253b4e3d34cd6d144c1b8a6b76171002a2ece582087d13c8c8029f24279884595e8ced693193a7554a7503aaed751a0a863056525e2d466d46731fdd9cb2e9bb3343ccba22a94a1b40872733f58934635b8c08e8dcda50bb2184fef4a4edd57935ae5b887f961b780255a0b751942a4ea537e6384c46f64caa2e002a19d58ffc8ed2ee765a928110d3ccdcd9053b2549ebc751cf52519cce0ebbd4da4a139c2f5e7cdcc908f25c38b1b07c7b6081b1a1d22f30d7b67d1e5a9a386558ea45b7300d00ad83365bdbbf45f93f51abc6001e5b6dd70c07cf2f8f58cd212ff41e5d5ccbcbddc0067b60ba80fa2c8373f3ea198593bc3e7ed08b839e4592b9c8901cb22c29508a33329716d6bef419a00023a43a28c3897ad4960a1b41ac68dd9cbaef54a258a6211402ac4a5032b39ce528d1ecb5454017ee9dc5a42838f260911926e6e219e64baa92e3b06b630cbbceee2b7506da32022ccd0a6bd36f50a6898a173d50252b24182de4a00d2e2f850eea6adf8e4b4df24b459b9175693680f7372c632985c369f38986f0cb708639d398adfdbf27481782383a805788982111e11b303e7b4eff5e3993e2b2cb662b74bf62f165c83d2de8367261dd5539c5631ed6457288769207bd7df2d343cdc885b91ba67d03391a8588806a59188079eeb78c64d801c1784325f654375bb3dab6fe8e779b0b0ea335c801358d18ef2c6dd857c8b905ca7acdb3dd641a71792385d50e1433dcd450fc955b8d32c1d92f6ae3ad4fe86a0d73b33a4306d32c88ba677e2cc282ec5c3bdc62c1acc3634b69fdae0322e5bfea40a6df25ef403dd22419b8c73d7658f134418b2a44ce7e3562f1234c056da98a85e1a88f40f3d29bb7ac6e63c9d6f290da1d0dca84afd888d852b340e007e9deb39eaad5107d56b17f9377aa178f7a6cb4ee31e39052b7ced976eb124f9c2e8c94076297a3b257ba5018e65ae420bb7511f75887038392c8d9ed74eb41103117c70b5fa2111bab27e9d66632c64a4f70559d72e96e01cae95ab7c7bb601e28263bbb4c6818424af5a3a1f086eb2760fe2b1e9c9968fb6c688823fe6a1690f80abaf0ae226e7832300e18fa89cecacfe975750f7006dd7d54a980462b3e80668e88f1d63cbc8eca3bd5f5ff1b7a26cc7ed781ed83cacf0268ae86fa725cadd62f5ada22f3f6611a9695642e24387f0f4be1e1494d1d29879a2f914dc6ac3b7560f5bdc8422a8d152990931295dc957eaa2554a0f52d4e409f3ab66768b574004ed2b0544734e983b30fbf43ee1e685d21a5cb6fb7d09021d49da13211f44aa20ec2fd6523e0605b0e0ea4a6ee1e1a9e7d0008290302fdb5724898c7d6edb73810c5040d8058560a43ae804cacf7ce34acf80c3243c5e8f47ce342e9765538670cf2a3b3411336b1b008f76c0a1e7311fb3dd0559c214e653c75822c27f684236c621a52e286494e75d22db80a20a3d9dc986514622ad24d47324a6cf4ff78e45ecd6ac820610176da61af7dd6f58577ea42161615977bd75a208a68bf8fd97345ba09cf6c6ce69f34ffda0a65131940d73c08c8aeee35f1eba9d83a14d7e206942c63e577441111079b3b831f7a21d30fcc6827f335ec33f893f403e6c080994c2c1f51410d78653d6ad5bd8615648abdd133a0661f3d83bb51aab12690125475ea8e08fa261de961ae939ae0711bcd5699d9b9aada3b154cfcecfd4ae83ed1cadd686e8c325b1d1aae455eda815d4fb68225d659a9de568c6d5acbbb0552c3f29c50e77a20517bbb8b43d7296f32a925b91bf5446a6870d88fdcee080c15d570abbae8aba884cffdbe6e8b5a0d2108efe8d77066e1c60d0a6855064263a04cbb82fcb54349a72d49e5f8374d66f6af019f78bf507ad6d78dac42d81f0fd6ecdd51e633382638f6ce73f95c712934dc1145b5740bd19a530536e5c39b11ecf3433a61ae3eb5b09d61370cd7fcf4124d4236fb8796d3fc7b470516db1556c31b885fe3bbfe0700fb34df048061a0995e0d7ccea1414e684f5c3b4c9651dbab23b3821e77d0330e0d772605a00ef5a2d7d8d2e6d077632962b66e0f6bfa376e42e2ab1b1c75631f0365e65cccf9c66487ad4d2fe349d769d0076e280593b3838917db109974e8c10e57179a7de528ebac45fcf2ae9a64a0fa77e11eb102023659f02812ea0d756537939ab39b147f38acc72aa8771b1afb5205eb1d20c3adaebc13cca7b9562d82a72678bdc0ef3327323dbc65b0abd510c63a3b63a2e1cb4a8da4c95b921147f2579aa21a0f45b0e1bedd4c767a9217351c9bc0878270a608d54493b5ac0b8630c52c6e41137848330484d245b205b91d6a65b468ce35d33297730b43e408056298d0458d7512d83d115d413ae24fe833198cf649424c6936ef8643295357cacce8a760804bfaec887005717f68ab0d4ea67da6e5c5f01e2b75a0727ba8e0b727764aa1ff03b71fca8f40763f7b0bd1b00e0c10e03af3a478d66805994a178a949eaffa335248385e58783fcf1840afb29494c107b605e54246dee0414f86195bc250775bba431ca70c4d1f7e62685bd7c567c63ae10de6c56afc3c9d4f478688373d555124e1e71f25aa34dd8892b80c6bd16d4d9bfbff902f42e2d4ec7d0cb0f7e030f68154d2de32fb212d6547f9215faa05091f1ea56f0204f4bac1fafd0372e115ad52f386da841842af452855df54e78721b7332d6a86f618e302b03c0af8f09deeed937f229fc1e8eec5374a9006f7dc043e38fed567b09039af7ecdf47392588a455bf69a1c4d118d461f947e6bceb62d008834614763d0cfd67e61110d36efc19ec2f38ff9ebce3bb4359127c5df036768013ce481a5190ee3861849c86728d573dcb6e975da51d638a116958e0db37c693f73dc05174c6c1950d52523c39102516da4b5b8bfad08c562eadc0ca7984704b7accd03cda33833f071372ecdeaef0ecaac95460f8ebd71e533eb895eaa6500e47de6ce6cf3da1dad39e2ba9ebc3cc7912e418a93795da4df3114155269e41fcb6bbc2aebf87b5400b3d46c26185b08303ed3eb5998d451e0c55dc0c8a160e4d27fb1b04e38ddbd6945f48c6eaa6eff417c3bcc72ec68cafa9f61015b023f99932d9c53b8417e1ce50c9e29657093ca2fd007ffe85ca15fcacd7daeff731d7093f0b48654024ca8075e9febc762d700bc3b7d94266f6626263f93cd531c3183bf123c1cd2fac3d71ce4639cbf06ee3fc4f989233d245f9641def7eaf8969f0fef02cdfcb7f7cd79d21499bf269d781528de239cee0752832c58eee25a25d26267038d9c02c8ddeee938f6e7a9a47ddb3dfca1e24624693ec15c3d9ec804f7a264e24fc31b338f5225d5f80e58fb855b33e8f3389babf64ea01e0107fd3e61aea7796288267aae86609031240ac12f484a90faa8c206714a57f64164896bb3ccab627c743b95c970d5e2ecd6a2255be0b690c051b0004d52d54749b3766689b5ccb837ed9d6045e1b1bff39658f847c5d20f10ab283df1c6840546e9689aa25159e44545db889cebfd90c932e8178228f3e3430e95d86f94b899991eda4a55ffd3428c1fd4dda7d030f0c53b229294f94de5c99260579f1b18935eadaf6efa73e0bd12783194a6773e8c7a2dfcb1b47d860db2b58752ca77975a409fa7a48b4ac9cb26ffc55e361a184dd8331688793e0a9e99de52bdaddb6109977dadd983134d50380cd7814d4c8024de36a5a04e386cb052c23356009bf4e654a5776291bd4b9c998f6905e38df1be7aa3156399ea41a8e025625ba0ceff6cff55b887547ffe3c71b8f47d8a2732a708e2fec5c765693dc39122ce5aa1378e1dd075da4a3305110b0ddbc946051fe13b13d7a28f6e9d157ddd99c3a33df41e4bf9b7dcfc223c59ecc9e2a18bb43fd1b90c9f292dad0fc256e658f2404105588212f6338128702c7eface03fd1c89022e1e01b94bb4cec535c3c2fa75a6e99ad0a853ba96a5bccd8073bb1bd940a7187a38b4ec773743a6bd14f2f09b241437faeeee285efc8c396e7152dd61d1b16b8e353b17fb76268c31f9c5eda75f398db85f2de6ccd5ff6191de951dd2b640cff92f01458ed0f5fef130fbce7ebf345db0f59aa5e9331417b74ae54a434ed0dd2f476d90ffd9994779d93a325cb0698e7e6285d88df5c751f7cc28af8a84ee234824e79c44b2356b44cc521cd73b885b3185aa18294184fe0d94aabf3644c03e76a721d1e8c045798ef1fa42784a5ff143a6a0c9b278c5edc284cbe075f5047b737f25134ed5da8ce55c45fd4398cef0207f1be3f9465371c7a0c00a73ca6ac89218a28db13ddc14f28ffdd3a7ee7e4527f25e07209a8706b51a5ce2445b6425fd0e4d26eb0a3eb93badbf966dd1f7e93c87cc4c8fafc9fe0f42eea4aae9ea834e1b0e59b1743685aab33b3666a01b883158b5a3448c005e2441f6c86f1ed1aa230d34738946131fa2e2b7ef0ed21042444b9e9f7079bf8df28c39414e4d8bc5952d21800018b8407c5eab5850baf18ee552f9ca69ba96eb81b577b10cb4a977dbe941b275b7c18331505ec25d70d99a8c9b2877f022c9c9ceebf11cf4695f4a869691ba45096d4ff34b10469482b8d0f46a04ee752db20f3cece65604b04eb87a14483e51fc31207ca1a5dccfc857c1b3c8dabaad7c04b948041aacd7652680949db281bcb3c119468c738923c7984e919a400f76fb520aa1cfcce98bb7b499ff9db5f1f84360487d5a912d1928899267b0b8648e320093890deb6e79c07cfe28c4ed4fad6421ccd9554ed2bc3c927dad7d38e31d8c5edec75e1682c849c2eecf143eb077173be2aef15d618e558fb69da9ab7080356ecbd55573d971b00131c962d1cf1f748a101ed22d45819a0d43f0c6a812560be2ac6cbcf71374c56d03bb82448d06f7f9c5fd8f2a228415b1525da1acbe3fb4f5116302bdc1f8ead7c7bf8ba11fbb6de063cbdc9d3bd86e3063cd3535371c620f6635ca98f14e6237b6512439a237cb0c0ade3a301057e7691567063db1788b5af464a7c88910f288e7937bfa21381dbfe48e51ca8b355ff80eb860b87d096ef719619a8018a02df6ce0533c70b38bfb5a007c41f26ef38693b799b61f48a9ac6adc390601167974d324fe8aca82d870cdb99319d0bbb56e313d4a146d162e1cf4c7dc9dda07d7d2ed929f93f784be1fe5c1bdea787e93ab18a3dae639c135f02e7d24656169c9f60a9199105f53d66856e40b215945e232a9f98f266b9c8420190c700e194342231051151df2f95d50047d055bfab3e27589fdadee63232dc8634d742a4c43a1b4dec0fa5f34a5a368fc08f39d8debee1513bb2c94eda6e51ec9d9ebede1c75818b19118e07363aca7038dcfe2c5d46addaea41aac7b4c3712a09ca96b6314b59d31bd8cdb9f62f608cbc85fc5d55a22e9254806a06732ce4acb35b9a1fa865cdab48d7ae8748540faa1b267f31913a3f97bb9267ec0da6da2c23cc18251fb3361fe1890d46978985b840a933a64fcbf2cdec139a2e49a1ced23d94d5db8b000b40bce9d9cac0d7ef00b7d865a07cc83f04a929658483514a04235b29739dd8846ba06fc770b284b7602c4d269fb2b4c203084196638571dc30e81bc030332e2facbb6acd3b0aa70c1e8620f540105480fc8be44a6a88d60a2a91d2dbc257e44348ddfe4ad0a4d71953d15a29d34cc19fc8161b8a97938e9a52743d89cb2ca23fc58fb911403a0ac1672141262f276ebe6d938ab7f3d51c1e0d9ea07516bce4a217fae7c6ede899350ee5f4190d00936c8f863883301711e7aefdbe9e20c48f059cc5bc115fa8637eff945821293086f3e884e1d246cb1cdede533a1bf3694cecbf26fb72d16ba48a029dfe9d53b2e5cdfa16b9492dafa2c38b515f0148bc50b33153ce62acfc1f929c5a667ba5e879614a34ea798c20b76eab0bdf395c2b96c674ee588ce2877c1baaf2d50040120fbbe6105b3c1da618c5cf78734f9e717c7fc52f2752496088ab4cc9cb7b1d78f7cd8e24ddf863b9936a6abeb7eaf664ef32ebd6a581fa58f36a604e3e2bb18f8873a3a828410e8a1902e243c2b12fb29e33f4f587b3e10348d1c80402f71f8a8b85d747aede6d645d86b2fdad614d51e69fa59df2c69de148ea69cc8ef599dabf2d65c20b0c5318edbf3a5e0e0c6bf44dcda368908231cec85e081b28583a335f05ffd3f2002bc53fa0f8cf3db60ddd028b48a0b876ab3a8f32ec4b5f49c13b90c398dc6780eed7c705d4a92285df09e6f289ea53e5d020dcf06c6fe0b5be7ac7f1a8bc8e24d7cdd0dbb3f51167b0b8d1484250136f46e5b929b0ac76ccd63a051ab36afb2f3d9b8ba966dc302699fb136ae184d6c8bac30b782d5ab5ff9696d690a546d00a88036b6640127f8aa35305e62410c32ee5e707ec2545cb3cd5329194fc19fe035b87c1809dbb395463d878dbc7c84af0419fc52a8815b17882d0b3e06db96092b584428ce7dce9ebfb1004d605967e42d6554e7cabefc8f24f8ef598ae8bc85f3e877897cf2331599d743af9163db7adda5bd92d6c64feeae3c4a4939d0c7ebee3a56ff7f756c01199128a6c433afa998e977553186a75aa77bf37a011987a510f3f4afd911c56e79ad39bf7f5c47002ed5cb081b827eec9d06c24dfdb2ad83645d70eb6f331e93bfdaaa6eb3f1f766d8584e8aafe431ffe7e1351375d56102a7d78d1158f60aa360020cda418de6352dc14b77f8da84156f411a9a16497222994e7f2939a21372598126ca86579f8a3b4c1bf4e44bb7079ccb0688f47e01168cba1acd88f5b4bcecb234fbcc1c3baaa9f25bba3552e5bcd1400b53c62f74d594dcd9f17b3831878492fea46f00fb1dff856bc13e367286f92e269d619f520a0db6d09712b719b5e4b1abfc23af81380f2ec0e8f81ac8ffd062f92b89df48d4d937c1ad1bbbcfb8bda7d12287c434ad84732fda64bf1c9b4092e1eb25358c14a92472eefb10c14c6030c272425f8a8e13d5cfdc1be6eb690b149f7dc643fcd5f43d715ce976154362af89ba0bc992e6843a9b8cbb7675f465f27d51ad7b36e781a2c875460992001b5c12a0d4024f884a03b0f4c2ae75be31537deaf3d77813c2fe62e8e0446cf24906d3a12633637f2983c33fbb6bccf954b386c527e6fc73aa165e19c88e68caa36861d3385b1e78e47c7e6414ce2cab478428b1afd6b09f4be557d2b995310c47d7204b918251dca5355e71a1219977a3e91bb77d3c37be4dea38bd5c260f8de67f7e1220ef495f23ee46f08cb4bee9b00321144e172a443c0d6d46497e455bd245f9b51d93fc966072e0c5cbe089a0a1bde1d0d6166ab2879be9fad66129bd1481dad9ab45da3e70555cdde7203adbe52bd32a1ab40eebf9c2002cc2f4f7b6c2c692faf6426263103ab9cfe0e95bcdde5baa6c11893d130d60998b329560f1c612e85f6088700159655ba878c1a01985b642bcf8538e1a70d0df8132f0db493cb4a225b20d181f1f4aa9dbe0b30578fddd628b812ac9ce54af91677c208e42e8b002795c0aaa9b8e84595677453b55d6a943ca06cd322bf803a7f877ce7da97e3f63708028332dda726961e314e34423a9a2eb5bdbbbece726b0b2e4acd3043b4db6d22df2a307c12ea597b80eb48e7507ebb3d7473439d3e79073bca4955e4de306b0a9f6c69d4c2ae298ed4c738f94683683ccec78de7dca37bc502bb29078bd470a6fd7d729b9ba8563a02e945c64571e44a67da2d1c3f58ab0c2556bbbe7b9dc159619468544e12e63d144717034b547ff15c98161e63b456a53fe0d99fe74d7efae0ed89039d17ff10b578d2e7279bb1bdc44779c568b08d2b59825aa1443fd526507c1e9b82562af2f6f5c64e5ac95890ff3ccae2279c53354f2582013bd3d9b13b49038e3b2f974abcd213fe70c73828ff2f6b5e396e73917dc0ce4b75876d702c993714a358ec5c7a295953e791136cfbc3222c6afd77befc6d1a85db60655a9ff768a38b497d88f22411d1227967076067a05efb9404922931ccd371af576a1fd541bab89b661a307556a1c5b3cd7c910da18974bcda58981dd6c611a439c0c4aaac03716ec570f1097b80fba888070c9da13293a7743ca7379339f4bd79d7b81f1929aa96fa8e8069881d7c9792ec05a5e7e0d00518aabec487e7c966ec9abf9e4a61e5cf5346373e7b239f5bc16b0740469be46ec68b0deb4ca374eda8ca04ceff4b8ed0ba0b53eded11e54133dabc91d219d1123f1e1d976d3c10577a86162f341147beba94f578bae0c372589db4055b39708ff0e3d8aae48c6aa1b20ba91db35586320e916d7ae4e36a0f86174773c94cf68fe1413af96fa99cbf03d1665ff4aa48d84832af15f322797a04ea9cdafbf909b50949bd2a484ececeb3d03480433b69eda439ec40838ffefac906e83aa11726e74f93be00fab7d2abd59b071727dc1c7c48b509ec725b7c32774ad8272650b9ca0c33557ac1a4c6f2843c63aca722f831566558e7f4b5774b007b6d87c301ab78f2407f2e00e225acc9f35d69624837cedfdbc1cd1ebcabb2d3bb9885410386505aa7bf2d91d34a15cab99c96fdbd0c35edd1d22987d9422b95fb7e64f2235241d381e2249dc53759ff328543540d6a16c59f6623e32eae859794ed2c9961c34728876815437b8f8b73037bc4701adb87f3c593a29fe4eeb0d2b12abf34911285f4181b3cded56e41290e340850b9f3f693c345f277500b97a1d189492c0a9785f3c46c0311822c5121f03d8d67c5826594076c0b52469dd7fe1ada2d78dc4d42190c6ed6440807bd06bf21c668acda3bc03470c811ef13050ac7ac7071d403cb80b649ee2946f7c2ce72e946bcaf4747cd8f404610eb98feb2b0e0ed5a6a7fae20b0bde6762cb85be40fdce31a7c0792e039c270ee244b662a9813ce7a7554cf583ee0ddc5d4a009ce03b65dd36cf4966a95ccc84cb88f785990bc7483a1c0dddf4315533c0d645f4253f82e10e4ab0758ea3328827efc643e0b01f716de4a67ab335c6c3542a0ff0ed5affa37c0b0a86b818ef97529b998cfc154cdb16bfa6909ebf42287d273c0e721bfc3564b2608a77f1f0ca89c92b554e6b7d0ac1dc16f285ae6dcf3668f0ce07639db9047483b2a589e2fa102451c97e540d81274b17621425d31163b4ec9a0f1063f9cd6d14c4ce23b5c1ffe6453b56e638ba12e983d4ed8a1447e0060f956e9661e001f8ff05ef7c02ec4c4126275621c23b30689618fb2f2f5d59f2828539e67872c1d836bfe9850032c256e32d3fc3ea3de75cb5741d988500fc8d67ee60c8b3ab100e3fefec6ba2caf5488771b1c05a131fc14183a0b732df15a5c12a774ad5c34b47df41e93810d6b291ac9e94a20abb6ee46c6b5641c03ea2ff4cef9f7082b9424f7a93409603427660c377115c2cf2eb6f2e39ecb314ae7db8f874d5af741c8d2a0863638c31dd08d4687fc73827528f57038751c1840e8f9345a7c48a7698920cb3c6e6b42254fffa08f38058c1777a81266933b08c90eb492e491975f8b7703d31042d08e29f836e208e357e2e03d15277563234d8bc3fb6364ff9cd3d3ac58b94676958e6719b50c0932af3a58c8622dc7336592664778bd5354aae0d2d2c17b92f8a7c1273bbdec4a9d2ed671a39dc06f24b8ded5ead8ed78cfb5746bc94f25987eaad6c30028e31353aa8d0251871622ed6977fac9042d6d598cf23f79fba6853acdb8cc294b8ce29b66f9d5dee1a2c5441070c466f355acd577d78c214eb1e94809a358e40cb731003a9a7073ff5790eba52800bb0619b39224629c8bbd07708946c29fb784e0fe435767aa88463fe9444ad20ca3e8d7a606f688bdbfe52b79210bfbabbdd33aac2af6dc02da18262204db9dc5659f0b476325805559c4b49e21c92677ab1da9539b4af9b75baf9292af191c0aa4ec54f6ab918695608264c76ba8390e15c600d0cd029017fdcca5dfa3f90e25dc8054b3064e0aa25de76af93062d6da2c5cd3f308414f59df562cff908ee245fc967e18fbd04838d222d49669d06400622d29dca58056ef8cf7b29383d007c72760ed24bdab289a8bc93cb1ebf707a02f36aa27fd1802751ffb1d8022d142d6d8eec4b9b17cfe8368bc9558624d81663437f0ecb61d307201256a93592c55c3dcb31ac98770da9fdb419bec4c7f6c21dd707ff52a41c533d28c76fd933fec47a638355eb8e67e607116b99801e3585b82efd705182ddcf18b5f67d0c674194564e97c52924b0a8357eb5639e335d07c3128e58ef126aaa07800aaa3741694c608725355f28f157f2cec40144a140dcd3c925395ff3b337387265d9227f7ea2bb6484d318c424d4a790b4a7891db23e9009acd4f58e514a394bab9ff70c5093ee8659a7f0bdd7608bbb482acfae08d8802f9d19281f2850cbfb57819bb03468c1633aabbd6a9ec5444c7fc75c025f9b77ddb9dde043b50c555a9234f2ac4abc03e22119bd2638d69a4c97492189966d9b61793843a99f04bb27766a8028d7debac34d85b274ba115469ff9d4d69b3f21438ed9df3daa69e1deb543a96896a51a933a03ecb370cf643580d3340ef6c1192a1426ed4bb178f8cc84d2bbb7dd4c818648f0e5ee2e4c72c9c231b107221766ab98a8fa3f0bd4e750b79fb880bf6f28833b4bc35e8982b1b78063a51b36b8317484e17078d8bd703a5108b87a1ebb3abc41e79317e736e908d772aa7d2cf6746703a5da67b1cf922ffdc87d0c0ef7664354b740e9307b630c41dd4d199ea115e09f86d511ece8799f0e4a3b76a3f613823edefdc6a80842315a1086383d18b0b2b4a5c46f723eec4088bbd6dd29bfcc65869eeb0614462e5a71000a96755202d917d622f771df102a14faa4b914da16143c2b10b302683d7baedf86ea8b800907cdfa776095bc7989780e997c1348816dea8b97ed80aec2190ffeae49df53fedb246654b3893f6adf5335dc0e8708661b077c4a7e10b2b1a09e3bfa136aa8c875a93ebc6fde39ef0fa01e5202c93d0f8bf3be78f390b4203884b23163fc4b159e549f3948b49b097892e41ce17542193fc2b78a53fad1b3f3acd67a66b1594b79048ec7c7c36a871e3fd8374fda65a0769d86a50a46c4b90a15007cc242ab66ed1b255f9ee5f9bfe99106cde7c7d63428abdc1edcaed7f1610583640da8011c74241323031b4683a3aa65e4e0c4efd457c60b6edf73d6d5838f14bfc5358dd8b428a5fecc1ddae4df31189a38da859906e4df22834a6f19cbcf11448f313c55ecb5aa706db717287ab0391cbeceb7fbf1dd764bbcca8125539d55d98487f540355401e99eeba3f8a5724eed7e172e3cbc55a38a0cc4125281ddff1f8e39827170dfa0c0bba348500f0d64ff6d9470f488ca6cba756c805947d2bbdacc76f56b2bb2ac438c8274838c1dcbb97c7b6efbf94a61a0ea4b2a3e39eb3592023d55fe4fd4bb939b8659565f56a6844ed6aa99cbb3840b76f83e57b9b9bfbfd77e873cd49050236cddf3a04946472485c62cb6b34f79f0eb8ba209ffde80430c314e5d209a02690430342b678bd30aa357f631a32cf63deff07dfd424cd7b0a79b3a946d785ea706cdac4c47859e9addce0e32ede63213fbfad5a05b875ba24c683be35ada631ea59a2adaf41f2558718c9bfd30fb15aa9aff5d35aceb9ca3866c2c653493c156438983cb45d2e64f209e99483606e91ff13c56a57f40906bcf5c2d1255912e01335604b7312826b666190f01c908587628b883c4b58c2d0a3de20b5890b60e2cc53736687156ac1c9efb99026692afdedd1e46f59488a4ff941c07604a8fe174536dc5339a43fc9ce43b1f824fb844339159dcd9f8a1325a7646a64104dae51efd7d1ba66b4e448e555b6f8556ba4a267a3e6b952691847a9ac6bb47831bc675e35afa6edbe2eaf901561bc2649d105f6f457759436f156789590898ddbc20c1aa460d54e15dfb981daaef3f13a3b3529ef2855a8c343703ae2c8be2200dfd52260493dfd0f3baf225ea9cae7cac3deed7d9fd3f43ae8799cd15239eec3ef097c3752a9e43960943ee3f258384bbc95287c5baa3b68cfde743f497dd0cffef4e91e3d1dee3afd541f4cb6c91510fcb60516ec040c06b943a8e70eb8acf9b5ecccb3f323af9eca9f6062bb4c1f68d9c3f4edda38fada2c2eae1605646b9ddb88be1cf2dcab8b4b38ccbe93b68dd275a8d25e0585476b865f015b2bc7bb193686808486e010d944c6fe006771a0c277b540c83854016ff2112ea6f86eeca7475397259494a4a05374f7e66ad8d571489895829ae699428091edf1785f4591fa8ed5ff9feb7a63795edaeea5d1b6ca325e0047e03c9c20f7177a73b6f999b4fb32e52c93679c826d3d26b80369ace15a6eee18d32453acb395831c0f97bf853ccbb6011dbba70f0f577922e0ad0b3b954f0e8b77bf906068328d3cb2c59b8a083c28602e9190acd5f5a3fa3c94378f4f49c7eada94ee96d0878f4ad5e7b0e1a8672fd5685b214eed7f8cdfd1582a6522d0e96a3e938e3835462ede78a43f35ca92d44fa035ee80782d20e4df0c4255430a85912572ec794e33f18483cd0261f4dcbfaa52369032899228a98a494d46685cf5dfa3d9b5511f1a4b6e0642b5bc813f52563fba9ff99ad6ba0908b7a0518253754ed9176665e6d69ff37b468e71b7310144f4455122b33978b7d233f8080314d8c6f56c5ca47d670ec1c62b6b4e6b137d5eae3d5f025395b34a85a2b45c0da1bff848d3f140b05b66d22b6ce1a11b0bc262990ee95ae84910a195e08923a4985f97389f45b5b15040c74094b2b71906ebf04b96bf1932c9deb77f3766739bb4223f7b708c3babbafde70e38df473ab9a0c80ee6df9b3b6347ef9ec12fb3f1f352f967f5eb870cf81db56add23fd535530d51cc08be4225f32bed6e3265470e7590a49a88cab8533ba924e46d865a60db57c21b0c06db18e3b4de358bb2ad3f9473878d202eec928ce0269fbf6fe36ed362e56f6d39552c3fb7f04ad712073ccced2ae5db014a8c7c1226e208c837662ade590bfcdc41ba71dcc4e60ec1c89e9772ff41664d19629bdcbcc13fb96baf403e63c275ffdaf3f176c62b9539a5bbf83d8c10981eded2f997b414d8a788ece8ccc0764ee99581af151b0d098acc8ef8954d730a9af44b397c060510391059a802b2b2d155333461cfc292206ade1ea4c0b5ce998f7c43b9064944d9f7b44de6fb0e214d8c75c23d167e4e473f93df5535055a9332b673defc9bc36a50f501d7db7bc92e34e02c881041caa4863d4034b9d2cfc2a7b48ee70554f0cee0b2e22adb4d9d1e59220b66da8f1ba6f99a22558ac7cc67c2ec7b5c4797d066fba0175fc2cb8c0bc8776d0af9ce46a05a6efca525d95716d74105414ca8cf3aece9c144c470eac15e88371e0f89265b4ab44b6d4378fe2ccb8567e8e4a03db134dd44c24eb09782b285c0d71555057d6d3ac28fa1bc1b9ab55c938ff58b0878914bfbd6856fb6a42df922827baf86f767e9a14aeffd4c2f0a6f88a873e16dd6280ec9aceb3bb6de8e23eb60d9e1ab4b8a4b4c8cd9ef4122a4e457f967f7b7797d6387ba97aec220ccc0a446c5771785fe9ccd5f0c7dd3c4d2bf9fe6e01549b5b0829e1af17bc787cc136a6a7ccefbbe7e09cfbe4773afcef6d87c6f2cde8b2a41db7022db8b5006c5f4c0b0953d362f9ceaa2c81d6e7d259edc8bdf23a66f458509e7677f6999d1b9c429baab5ae9bd5c3e561f0f2fcd7730ee90b1c30a2ab404765947cc396d979d70504e3a1096c6932ea9d99feba1aaa3f3fc402018f8274f8ec49d6f74d688b38ab8a176e20ef5da8d9522cc22c521d041bfb956e145de59847df0e43c6210812cfce7ba8875662e94856f8ab0029713884730f067e4099544c2127f04834526296986f267e701ada53f3490ff1beb1e26b4481084e030730a9479cc8c43e2114d3bef6ca297366e4ffff9346f11e4b94c1ff51df61e7109f705af89d17fc79cf344c1a44e585ee7c32732b26d8c03a95631dcb3042b6bc3e137e9de0fb501be742e56bf119bd3f7fee898177ef224fadc2b49c4fb78bcee8af73d1ad7652132c0e4f3dd292e7cc42d1d1d257182e5c733a8c02770a87141c7cf32c2ac12fc83a71ef96e05b7ee3171e694957b10e26bd04a3201a874bacbb4d4706c50f5ab1453a17c95d1404cc7ee3fcb5fc73ac838c313b1538ab70395fe4eba0b3390fda926bb4e67b99bb730171e50f87040031f5d3224ceccf0714d31fecafd1e2bb2b34b11aadf0bbee701d2fd96216f09c4106b471f1dd3677fbdb43844eb03fbd3760e0dda7ef40dd8de6f46e80c810cb36706798721e0c0d110ebdec8ed80eafd206b3816bb9057d650c58c1861abce5d615e2b4f5e5fb44d60d1ab117bdcfa4adddb120cfe287882b27b06324a750e2b5816e97e72dd04e260a5be4412c06c02724daa1cf16225770f8aadec497c115f3339c384397b69a8b44ad8d926244f87d8e9af452d6edb598d120badbf150732f77ceb88d2444a976ed05c6696cfe463874270b4176138e9bd95c16efdd00df4a295ff96372ecca4b120772ae40c9c0c5b2b001edd5f33963cffd833d39ebed8b3db1042d760b3fb320a0d664817e3d0cce96606e722e2c3cc2ef8361e79e51c01d668ff947dba4016dca0178f6fe87b685d24252d293368f23d7d213071a9065004b5bd7dc350ef9a54ed99294c83ab3f0da1cc1cf192fa99fa66b0b9eb4a19e81710f5f0cb1ed6b7275aaa02cf22102e9ba48fc4c8d52366909b0e65eefada5f5fa2449b6fee9e26994112b2a4d8271a872c57989695fb6c3fe2d4632573d5373ab18aad59090e9679887048f5da661397f3479b70d7d26f36c614908503d602a0bd3131950fea2a410c6ca21ca828c63f4432f6b494c24d7f1ef4f6f29ca71629d2f16c1dc39d668b8cf6f66a970795f9ee9d1cbccb928e1181729e7ee85d7207cc0e0448126ced4c81bedb737ff92781ddac356acbf561752eefefbe56e4c222b7e8fb2d2698c2c2c9ae60337c535c3a348949758eeff019b1bd88d5e21b5814996e49d96d15f2439e4448ac2133a93fb975f615f3857c236499fa692d133570ec45286c948ec0c26469762b640595f55acd3d7d1a99b493bfed80b158f04e72e6a0a67fd41cba6a6372f13d46aba290baf0311cb89520fd578d02d7c89e1401be9a39c563a42ae5c8c05732bfd6c4c5c04d3858b450be53d326387af7d25a1a67370e66118763c5dacc5bb98a88a29faf61ba7844ed941ce8ffe2e7055a52e8907dfe7cbe56d22fa41bf9e589d5854f95789722c293b1ee9b04d7000530782559a8de60b875db700f83de714c7ec861b8ef7a45ef49fb9da8c3b3c50b44981336f63694232961d4daff6c465e4615be4b645d7da374ace81865c6795b0cb7fa9f7bc0e19de01d90f4c383eb86db34caa922d16b43939b1b10819bc52e3c8bdc9f8552ffbbb6b3348958725d2b149937a51b26331d1043e228628a6a89d9d58dd0ed14297fec58a239b44f7613972a1777ac6b15782495e497d8fb376261ffe2374bdf85a968fb9a48e95dda05ac05b2cc4991eb05ab50165544b8c9a137a0feaf84ea60d51390d892413fc44146fa4781f7b5a2b56e2e08fc1c13107e17e773582835a3824dff99b29439118c1f2f376db9a1ca817fb96729f6a91963bc431c695e379938aaec54042ade59e7dc42256218fbb8174170fda9a82e8af86bdaf0462dd29e48324ce8477900071df649efa450e12535f64c7c905803bc2eb38eca65dc43fcffd710d16c418b7e74137346281ebdd7764d9ab81e7c20de280e364c2715d843394b7f9cfe25e2caf9dbba2c4bbb6a81cb48df3628fea89f6cb72955bc776463c59fb6458d7bdbef4f533eb6e388feb366fae43fa075dd0216e617e4e348959874038bb445af498855a8eb3518c7a590d7d47b698d5b728d7ee6addf9f73ba48102941397fe14950bb60c0529e70dc762b5cc3ca9a7d1dab4feb58cf70669f0ed9c231903e0887379f5124694519bca9e3e610cca8ba1354ac3a5cac7d52582829d9607672c7d16c66bd9aca7c5ff78112efb3d98ab7a65a4c70d5427024754a8222e435240ae277905a36642f3b61f51f02f52f7932ce035e95aede98116714f2508e0d09c7ae555aa05424e05ee3b5929d6c55e16a3a83579d90457eafc5f687a31e6e14948a5246d2c5495d1bb1f0c00d0fedb43b47a31f506cbc66a7516ea42672a4972e6b1f2f7427c8fb05e8c8b2a37e71563ee18dc2b54ef6a7ad8a17207ba814a019f84589bae3b41f260490d462fc2e63c2ccaf6f7ffac289a4d809e80573b6a35db649ac6b0810945130072c4345b35abd2022fcd3269d573bfabdc5caf53f7395bd3f8248f80134fd526e87fcf5fbb74a3546e9c0a505f75e4819fa1e0d2aa11a7d4ceb45d714d93b6ad8bf7f258dae64c164a594089ed42615aa61e1969bb1fb7bd9c561e8bbe935d2b3a9dbaa7451e311bed31da6a3d27c205d46f1d07041c28d6a5c6b9c4b6f3c644b2def1c73b4b770c7152cf080a2fe07d85bbef2d77e115f69357a58de51581bf60be43b1f2485d522e84970813361932e2295517a4f604a7f13ef0f20260da3cb0131e3e815c3bbb4f9ef2cfeae35f47414040a8d78224204c0a93f15b831b0be042f48b01acce3099d565f979e57c4dc134e892374f613721e3f9659cfa2e157851d23fbd342a509ae967e9517a5479e0db04ea0af3e5d74c5885733e2ddca7fea854e66b3aa330c7d87a0641eaa760ae4100c398bfd8f9ac7465859b444ba70189bd5b7fb5d83abeb2912e046390785acda541bab7f1a7f6166dc7d3de49c493020bed49b1ef0fc5ed3a0f029498ae11d5cbda066d94bdb31bb430e33928ce32d7c828e46c7b02b282c8f17924652d1ecd6befdcfb19690f5ac997faff1379b21cfb31890a8568e15a3e94fd170c3b305a15b50cab5e29fb798e3e43e13203e5af7931c03d28cbe52765c854bc3f6fb357220caf105c6362f24c27d6745d1b1de505bc9814a41302797fff9e8d0bd8e713fc2025a8fd2b846c83a6819366e9c5ca5bf0f90bc5a63fdf9378d6c682a6d58f1b50caab2ac275d0f622a47b7538609da6a87fc25fb45aed6861af551e2578188eccc5f27c474d262a05d7b865a12a99d6415380c3a90a5a2632af78748832480030f114f6d7e49aa9304468209cd0d372f4943277a506dd1138c2cb73de809b27eab5552cccaa0ddccb42dbe288155a1d846ff1e252915a94167d63e4dfb047f730b73d4876d0412be846e7a123128e053ecca87abefce04c4b4fbc26d1ece7807e26d3fc9bd345189fd60620094d412499ecd458a4b69603f3c3f4557926078da80288cd7a882c7208b5f953b723266777de2a16533a1f0e14f4ec23f35358323559a4e7701f1687c694bd32cd0812aee6d0f3008ce347acdccc2cb72b1304dde7620ffbda610d212f6eaa05b45d7ba713fc4216936fc6705bf1bdbb09ff8ce0c907878cdfc9764b9335dae34173fb965fa9f35535ce7654ded0a0065482a8826bb56b2b77150db63499723859e2b1c1f0e78565ca2b2e81588746b68475a2d2659905db139e73af63e8e55a09ce79ee957d1ffa467db7d43267cec5953ca1b3d210d0bca45000758b37fe4529f0f5b53ce6b469029c6f14f5adb2bafa4e28d17356f193b349bbd3f9be33d396fbc7f1ce7f5d4087f15d2d7b4ac4ebf65569def25ca55e7bfde7666c1a1ed2931761301bc191e54f9aa597ab3a9db9ead204292068605065e81a55e3bd3569004c8802bd708c328494b2bfddb28b71be7c5e6c497acc52ffbd38dd7873ef62d5fd92d21ddc3e7e0359eb5f97c0cbd3ed35070c2778094bdd06f991f3a51130a998de82661f2877e24bf71d3f937172067126069856bb4d1465cc1bd26a28ef48465fc4dc0532a306b8909da51754c2f5b40a8428d09fd910ec15e59eccb97649fff1b9bd42dd9a745508b47fe29b7d330c0a8d1a2b1c8f76169ca329a83cd2afee38512a5757aa9e73375a98558316e8c3da634cd31a0012829591315be838f407a5c36d5962042803d2141fd3174c3369a738f81ba091a2b6956fca0ffc038b14488167f051f1f48e577e42c66eb3fada460552fb83ab6d6af2365ec659d9ce547ab212c91045b87723d36163cab5644906b7363b35219b619ecbc51c09a291142f6a6986b3759f1a2ea26dfe3c169653a8a35288280dcd77bc1abc9ea70a817ab580a01e9ba8d94924c236a780144eedb3f94f7256dbd6e813998d04dff5b3391dd8f56c1b04eeed116374d94fb91a3f21107875cdedca58c7bdb09be44b0e7eea723878053924aa2eecf17dbf9a582a08b9d1fcf92705b324b39fe1ed4b2014932b35576a31dca9c1976cbdc44b00a3fe8eabf46a93981c494326e2fb1539161bb6cce46d8d809d8c71d02caedc35b0d593cf7920ab9434d0fa503caf26b6a2ab278e2bd6daca4823ab1aa5cd171ecdcf5f822e808f066e33f20f947090bc598003968632755d4994ac6728327bd9f30b6a91ae5bbbcfde2d80b3e67b2c96b521d9a9f71823e1954e42b24b14b1f9732cdefa1ca6405626fa1aa304ee27c2d7686f4ad0ee26ffd0f4635e36d9c821abd0e2f26c585499ee17412d38e3a20c4332db58054ac7b03ee5be941b854966adbd2f9db54763c8fe948e2bc39d7165e9e268ea3ab57610f25683b45a4174c39b000e2bf430076ba5304a7dde52a5aba954363a24325d3259c1376ae95915b3caf2f9a83a3d15de33c98d7beca4887cf5c974a7a8f826d324dc068f2253e258539b39b94be9836206cbf319cd297854acb2f05ad87bc24bfe3a93741f19a881a8050d00d502fc5d5f9ea2d9110ca94300dc15acf1d1839a0cfb77d8608051ff1a9cc0f2aca69bb061bdd26e884b584464c5b7bbf6c516db453b18709507da801588038000671d38016d09744cae0066c8bd2963af10cdbf8c8687a00278a09ec78207f18ee1c72315c40c5b1952bca1ef350875ee762cfd06f794e5db6a40b37614abc7572bce90f2276f483eed3e2545528b23dc18af4d1f082ea4ab2fc69320c3c3a02520d944ad2893c72016e3b2ed4781e3b5596dcf48384e81f91297fcb05db5408971531022e24970c0d540b515b542011f8735e78ff7cb983312ff278bd8c0cc5c48844125d7e03841ec26eadb4589741e25c6deb896a2a8c820552d74a5268e9fa6c07848958ec9d4f7683c5c774137fddbf1100fe933c7673cf9feff9f0c20120cb22f577b628bfec70f06053e6e54546621bb8322b074caa3dd7d1bd764f158035563a42e12164bc7bb61af37d581c6f9f40727efd094ca8f1e2d2f279f1734177787d7efd9af0fc640b0714befb629de3bd11648e7cc289466ef69920e66d08bf6b14c519fddaa47af486b454d18c1e59cb7a0641a26c76418f99b067f438ede2d72cb48574a32391acb2053cc18db636e60c9be7a0dc29fee332a6d8a270a1a9fd51bbbc742f83bc5409b4fa446ed8ba99fd98ba72a1af3de7adf43a015b15b2c2b08d657f70a475f94489721c1215208f84de10efbed527f1748250743836b7fd97824bb9cde7f3f7d2819a96899dabb929728efb93ccf3d873acd99113e7019cf57bc5d40cb3d81918330d86c0faff00eb45b9f22217a097a9753469fb278864ad0464fa8eb47e63cee5bfbf42c783b5df3f0ec647883d1457b59d08ad38de52416996b6f9faaf1ac2c9b6a965db57adefea703179df0e038ca5fb9db7ab4918ae2c54366b40030499a3fb92629d775ebb927903effbfa251aafd66ed5d397d3032c32cb8d49c7a0d2efff0cd6dd1fd3a45f8cf7303308fa7928222e627173b625b4c063f14bf97deea4c59c93d45b8c83af5a797fedd31f5503989b18151400c3b9d7e10cb1436df0a2d9374fa12240cac02c60a92f23c1e0ff33d8b7a37ca155993ef280f4398abda301d269ea31b8f547c0c0474e7942cea34dc1266d723353823268b182c42c3a3c944db7c9239b025627215181eb40dbcd48e866ee6f65b731913da8c015ec23d686df3568200c6061c27d7fee43526c0ea9d5b2c866859f993a13dce82e123893247723b64846c9af9b0af5738a19a38439fa21d1e2934a2581b817eed5ee24910202deae513b283aa84a13da317f9687d80783b760e467c08e7a0e2026021d347786de968c917fd8747c6db485e71936a05cb54e59ee6d739eb56956f1eccacab0b58cfec54d6bcc346263be8755b2a5109a3ed1651898b625bcb182d5fbe56ee5916a1768cd77cbdeaae5bf4265acffe2b5876d3c5521364cff49472311be3f9657d71c03e3f74ecb1db8fe6a9872c4b7410256e32d148b0836235519312f9c36a2397bb3ca93ada78b92e33911a1b10e901d4702f151d6362d77619b09959854e26d79376c4aa150304c06bded07e4ec3070f143ca7ed5bf7481fc3a26bccd825aabb34ad044cbaa4f401126172a6a62d586f97562a166be3c19d1f296ef70aa454d2d13d1ee0fae8624d006797d0ebbd52675abfda74ea6dc4146c59e6722b650d040a0b6e53dceb517679480c58594e5f4e469914d83e8fd445a295221307b2dd376d17ca4103b027f023a6008e83100f65fb32adf04e6e84eb3c362d745a29d000bd05e9612f373b03ea17f59955f066130885830d71e4f84c1caa7dbdfc261db73289c4ade011ea584d629712505b92f087b522dd61aee7ec70b7a77e03088466b6e9fd81b3213739f07b4683a33c9938f97eef0210164cafe0fbcf55f2a35f7f3be42edbf101aecf8c8060f5469cca2a120b2d2258c89dc2d2648da1182c2c6c6f81c9c66b87a0b25d61b99d97b36e602284e6ee9b918b88fdcf638945fd3f6a4c70962fbf86832af0f7bf7a9c1db965fa3872d9f0c57271ef6daa076955360335817808d1e0bbed0320080ebcc25dde7308d9011b210c282840adc072ea526559273be548674658acdacd84a710bbbefbc2f022cbd6276c3fc843b7aae5064b72fcca7d8cb3986314b88846d264347d1368ee536fb0d90e5893fbeb196ce109576fcf7b18b5be1d1e952194fe24bb4e8da4b84094bc1bfcda124fbb2aa76e7622fb0da472bbb42618847cad3cb427347cc9e43d424c426589a38d14924b5c143c69c1628b63bc9d93cd60c878b2084f7b0434ebc057108df144b648255a1b4ff08893085c8bd5037c83d08ee28c6c8e1fe54554940db2a2eb029cadb01db540794e1fe96bf2a8fd0b50ffb9a584a499edce25b13052195177bc9f121b876a592936ba2243af6ddeb617e5d29888fe4ca69c46aaa027e370908f1202388ab2333df4df2fccfa4373c3d3dec2d02cfaef8034eee29d4f9e301bab49499719f3efc54fca35182e5c5ccd9d1d4d148c2f09a9089b77dd2f217b976cee746be22023e4987e074b400a39454878c25dd7290a142e81d8b8c3e9920d9a8ba2148b1538f85a1c0768e12381654d1e93d0a9b8ad946458989465a7b88d09ee1b7d1790f6b15f722fac513a16466a778e2ff053eaf0101703604aa0d434c3625b00577108a76e2963eccd854e00b7bc34663d8f42dd0b48e2c23a5cd5c1ae371e2b1c931783855f19d2b2836a47d5de1a28184ce5b8b147cc504a73a0d99a3dea66362408900e9f81210c62f0e5de1eb1ff9cc97ae35b04e748c000c295b2bb824d56fdde84126cecc472a6e87233159aacf42a5c24603881ebc49604ad4b06c0660199dd9c9185bc7b47e206c77c0de9ebe78c2bd6e0495bf8cafe2bf088827453348f2e864cf891725ce0bb242b1a9342d31c8ceed5600932270c837ea7ebfe4ea7c2ffe29ccb579339fb3fa983553208f588940fa4deff11a67b499488de4a9a5f1fd7c98db7a79fc0cc410d6a266c77212bba03f8af7e65f0badb2f0d7bb36287ce26d78dc5e0e1ab3b7f818cb93711425f7c4a8bb654b995b3bff48299ba6e06b7041261347466b1556315d03d7b0211e5956c637f81e5b7d9c7140cad512c0a9b292165e590dad18bc359a7c87d3126e94d2e903b512c3df6d45af221e538bd913700f2c0203b2018e74419ed8e2540e4299230d026cdc26c89ed386b8261d9cd0a5057cc93892081492bb60473efabc413f265c4c643e093a6010d3d1f2ff32237e8ea8d4cb32a834cdd4b23ab9558bb37d3689519102a25f348f4afdc3b7571792ec7e0f7d1824ba34acf391146078e25828c1b133e5e205fb89629ebef7d0ea61aa288015c139ae4feee0c9f65cc6ec39c8b4ed3447d56ab33fbb5c6817fc7184caf62719922940d3b4daee418c4db99df942c14bdd411e55458e3285e74b84df6465421c56d8ed6a3f6ba9450a2cc9aa3da931d44fcfeadd88164c53106c61f06eecd013f1c365b685d270ae5c183f32a50d6b675ad06b1572a9ed4ed4b010bebea761eb18db17289af65da59ae1a9f89ec1f62f694df87d63ee374f10c55a99b6e8920d664b95af8182042f325ec5acd3221e11bb263d3d5cb3e71bbf912c2c1257d638bc13e49d39b8f293c7c73bedb51676faea62df10bc04479baae61db75c77c6085af2268dc0aa93c1d90cd2ce57bdbcf146844d8cf32317c1ba739ed709247dab07b8e52994dbe25eda2055e507aaea3b6cd10a8de028ef3f2e97ce5f356c76c7c472d28d844c2d69d39fc0570020cffcba1dfeed773ac859d563334b0da4a01b8401d50306bdfb5b4fdc2cf7e433adf64f9fe8d8b65ca29503665a0d4b17bf83e101c1d1cf5c3bd11262ce1c4ec3d621fe20f9206cf4b9d38cc927ef1e7163a591cc5ae2dbd6c86f255ed8bbf7eb1da1cd7a30ea20c4774f67204d045d6e29dd515f69c08be7d3482fb1dc291b6ade8aa0a17c9f0ab90f855f8bd0893f4f5bb24f1fde1d1c352031e920e3d2f243fc45b3b27d110a92f0c108ab372d1685c2350c800907f68309a5a5357e8f33b16e27c64977e9eb0d109336b2a079b29bf2bafe917368694a6064b67e4af2e2d139883561642e11c160bca22d62f07420d5a3058e5bd42d143b5bd8554e6af6548920271f33175af2bb2db55acda3cc6e8be6344acbbe7c4ee5b6d98fd2f28599015b11ed3522256936ad28297757082dd242f96cd07e1e2d931be32e7e82773aa3c03d5b566fef8b9a2a32cb9d65e0b34654b8450d57ce5ca70e318b7c9a9221c9c2437cc51740dbc569f00bcddc51e7f79e1bf0ff1d40a78fb320ff9221eda94bc9ea8c8d6df5775c42385b52fae961fe08cdd9f20eff05c5fa7c778a8ecca5339f96816519691f40de3178ba77fbc777c625ef1537356ca005fc4450cb6c87594034e34365bdc19cf417f13dc2da24f9ca577375ec72077a96fd5e71d262c838be0f677a75840f22bedd9f07d91b44f6592b6f8d5026646277ada084cd589d6ac943dd1365d9c6482b6b5045deb25cce1bb0209ed73a67d10d3019af7aec01dba672e8b6a7e757e58090e35ffb36963eb37645f3cb6e5a09cc13f6ad4afd9e8760b26d07918169bcb59d18f6c70cf855b5e52cf8946325a1cd5ced0d86dd7ab7dc6332f538d19e899cfd30dfda6a1e50ec03644a95c8502ee9f6564c5cd96518760e7067f2e7d619cd264583ac40ac672881240e53a855f401ca2cacfa567d0106c497748410b9800a13f0d4f111888bad241cabf57c67ae3b8f440b62d97e5b4b8b33d44007de8fbcf9e26514a2418c55d9a4c724aec4caddaec057ada478472a6cb09c9a91ba0c8700e08be9a754e95634acdf35b3571330b3ae13ac30d445011740db30e0f9c0166d76aa686774587b7cb7e61b99a985958d1525c5da04bc76339ccb8f2477f9d37b35d6aaf23b7722da063f3565f54f1e20f601e2a83c1402dcb05f13be086fff462bd57bdd4b7a4aaaba6de6757f8caaa7fecd3249b5fe6eff9aeae99c98077c1622a67233975f0379ff67819205b9f093c16aa69c7b1d372b365bca63a75670b968f420e02721b7802abfef10d21625f9ea656c53d3319955200d0fa5cd8dc67fb715e1abda6fcff1c5dc2bcdab33b99e6a03b0b95870b180ebc5b09a42df6ca44bf0c86c34d125bfca8e96a10e80589a432136c32fdda181b06515d421b8318a66cd5275b566cbcec8f4677128c52b7eb9cc440992d605e66dc063dd5abe4d35b66324ca04a13fb8dcebc012a23efef9b241c91c15366842e7f388e75bd7f047c060a8b1db4461bf8512b81164605e0b5ae79c4ec82931df87a6d2eb9a24e040025615120317a711f6269797ce8b31cdc48084a5e59106e12e5446c671ee4854e7b5ad321c50544dee8c7634301ba211b22e8022daacf2c465fd4c8e1bc7b41eb1967bd4b609b99fef4be068f86e03b7cec649baa59153bdf109fb9083356b34c9cc4eaa36eb227366a7b49f3b952b18ffa59836e19fbe995bbc2f97c8acd668b6a17109162ce537a235e5981adfe725412c8ece8221b0e1712cc8ce8614d720372f9d1b2255806febfb32064509d68bdfe46efcfc71d5d29834b946b7d40a63589a551c976cbca07fae975178e0faac7740eb9a43165b157ce685358e37dadeed15f01d444c62cbaa2e3a69d53ca5d2744e1a8f6a83132aa23f90b514e3efe00216808d61a87cea7386646bd3ad6bbb191af7239ac2905d3d334fedcb44fb227c767ffcbbb9944cd5f9e1f40efb3e0a8f3e128e11705de372d8083b829967a5a4ed070b34b19894814b6594bf882a6cffbd83d3703688bc0f62e190f16f4e45196d5e52992ab8b05b18ece9feda3d3b79b315e0b9e27669965dc60a4a1a9d9a56e4f7c63c03974bcf21cd3afef624b366c84756dec4d3218db01a9056e37ccd8836967dfc0624011dd52a512d73a4e49c0ef2cc0f1a0993593f20092038377569e0a3a554b9f72bd82905c89aef7ed186c9e6aaf2fcaaf27d0d9d38cf0e84229a19ddc9d006af6be1510072e299e0a2e106d7b6538101c845c9d7abc6b63e52e384f76dc5ec74abe5e6d52d7660e1e37b1971177535d8def7d9acb72c046d7e28ffbd107d39835872d4c756eaee3af8c091231a33d94cf6b69980c64340372f4e5e4a54fd7882eecd9205bdfec0705e8aa94ca5023d413831e2dc3d5b33cfa810a25aa6d29f144d74b552ffaefc37ed0ad32c2b088ae8b0ef91fc511862fa5a6abaf81d1236bcf004c85ac2a10fe021ed32fae33cf66b518c6203a1d408b8c82c0bb7c5fe6f80d119f8007e2c779116fb528a6199b21718a79180f62d4de41e601bb1573247c67bbd4ad6d7e443e61af2e4f8f8cb08cccf148e306ced69d656c3eae8f0e8d170cd0134b17c488735def6bd0b19f96cdc6b609eb11417698f246d3a0bf9064bbc3ac8e15da1485c4d26f89c37a744592987e232f2b2a7e599250fc4d657c01a3c51a66267511454648621b30ba405535517e365c12ab3e36d8f50d008ed0b7841df398890b56964e6d4770c6213ba9ccc9fd6603e33462595a11dcf3dd659548ba9ed670ff79d95c81c66c49700952cf173a333f407e939225652f306089ffa8ac3ceac1293184534cde34b89e3aefefe03bee68f23f4671664ce3df930f4ebc6bd42851848947cfd1267fbb3bc4e2601d51b4e6630710508a9c04175961270520e7393ee3cb6e74b308c28d70074a6bab9c33ed4ac35615d3b85985233e3ad9f777aaa862e14fd806c8fc8b7d0863175bf86359b5008b2fd1d288ac8c5f91038c2c8e9f804aa50cd0e000a3e129b1105ec99885d89b2cab26ba0d05bdb5d8a0ffb44c13f52113006cf4e1fd04f43e8de7d99fc05d96adf50e7fcd23dc215ba21f47dd106349e4fb2817e24f95c08ae1d2f56c22d115f19c3b14685355d099306653c8e307d4d523a8d2f1f42c2ec2876a58b385dd8d84d58c6f23ae8f540279bcc05d73a539b6555156024cb14a5953dbab4b99728af27ac7abd43ed7bf3cbe517ed52419ae714c4be7c7f619581367c5ba4fdbab735a70f656c7cfc94ce95ffb66e55332cbb4252de0a0b3c069ba7be34077c26304b4432228254632308a52901198d9636b5179f4fc9dd8032a7d503a043ea15696a55fd96dc3d9e4589cc073384cf3da32e9d0dc7660035e98f6d1b1fdeb90df587620de73d4af67456154c2f0417de677f088907471c2fa1cdd3138f0372770e083fef0d7ed23dc6d2d50db5c2fbf09b963888bcc752fd285ccaf1e906d24a4ad5c11fa647e902e653bde3c35340bb4ef24718366d8a69a0888152fc4ee5541e841b644dceab31b4283533d749b6c2677ff4b6ed488ac0996eb7f5d6bd69cbbc0268aa48390f94f9f21295ad8d52c6c5dcbf89d3bfbbf30f3b6ed2fa45aec851fb8ad343fff66a16cd4ac9ede8d097bb4f5eb8f43a2d182889478ccff7be600f533382605ec209e951f4d9372722b02a078885c64f510218e71a9c05f7ed45abdffe92f3e2ca1bf5df09844bf353c3f4f84afa3ff3dc422ea8f6f4b54dbe5c0a35f5d694e65f43cfc741e5de652256d04dbd26c990e8bd0353a8244f677ff0df19ad76a619bb2d9817e7a047c371cb12c51027545e4b1a60a41c5cc2d86d1213b777b418d9a6bab4887165e7e1b6f50758d1c699b2513a8bfb2c645b6c6a7e1d4da0bbe466c2d71c8537cc243c08e10dea692a2f7670c8eda32d952d15e3efd8eba9c8e32329fb95f88175e523f375d40b537efde23103f00939635cc6928f67f996d6256b9f70b8088c32d1a0ec838e289d9752191da55b3505449cc3d90f39f5f06a4a232783e413ed3dc5ebb03ff6564ff06fb017aabcb94a3a4cdb2de9a6a6dac66b21970ec41e883095be60a1ddb3b11403eaa505568a1f7a7b0f87b3a9be1fa635ec207ac74faec156ba471607e2fbde86731c95394f15085058d803e8fc5a0c9acae31506f60e54aee0d4274b530eff2da35c44471ca169fa7c7dd53871acb5d3e14b14e81df68ed872d84f8be7a10875e72e0a53d43cd47a6ff382bb1fe6de55526297fb561dd007ae55d8e63f9eb28cb3edd8084a05d6eb2503df26f9fa8fc19a18db0a81920d351d77dfd9302f5448c41e2b729c2a1317cfd8e8eca1bb6c2b98e4ec392dcad67ec646c0f5442040444f3a43a37cec8fb7fbe12732eb969254a6910dea938c81792382b2e89e7e70652a3c7f4d894fe7bb2e58e05920090cc8bf1071fadcf16fcc48a83438f8c1d672e0c486ce4c290e24103f3f201902f0a011c4b7c1931d3ccb9de31d15d5085b8f1735cb1f82028c9552b544a4bbf76cb0d0c1da7a7bf03d64bea1a7fdf660b3703dcbe993723dbb3c819f3556b51122fd5c6048b4dda0860f077d90011b1f09b52bdbdfb1a0e6195f12877ae7a536fb51d1e554282782d6b0b088812331fe30ccb88cccbc22e70330776c7df5ef78136a69fcfbbb0da197e592fa5e9dd2c283f9ec87d625c831cb3795477b693c5b48693e25c32d4662c367bf5e43e8c16bce7d6ff03f1bedcc4c6519340566eeea996ebac493d93f8026652c94e42f5e5f992a4d8a2dd8dea84a732321cf1f74bdbff15c0067049d9f6f10770fb59d07aba6af492943ebd1417cef01f07052e97443c54f794a52937497b7e6933869be62717d06b5970dd9237fead80dce311a39ae0065591415d76cd7c144c8b953fba7f374a85a2593d8727c1e74be2af853c221f6ebc8ed93c5b13f74d22349c1ba9cacc5005394591d585595fdba7f8fe6abb9aae35ea06b58e6122e528fb1fa53e3ae1b5c97ae4e8f6103808bddbb1b01b5791b512359fef7464c657258734e3cac4282a1c2ff006405195c0f7d17977ebe65c9fcf24b3a8387155edc0b74661c03a88e972b1d2de15373eb37ab864f5dd5cc91754a5f385f0212b5becf8aefd94c6802938adbaf6f08440e8a362de5b3b6e868e054a36536c8c686e2e329d126027e28ea56f92b614efa98349ef3810f4014b8a65251c286852e7e38c12960969f6d8133b6e5f7baaed19d74e823ffd420d80e4d37b7d468636507b963e58ffb4f3000a510e531f1bdbee737ca5ca3ba205486bc4aa853c4bb6dbbdf21b636dda56ed490c28665252822f9c8fa7f1128eac016c388b91a4984439180b76a86687076b9f89abdb0527806acf01c1cf4d45ae1a0532324a7a2c01369d1102ccb633ff9976e5cd42c890ad7865584d631e24db1ceb569d2fecd728f074d8cd7f03c5d26f22a5bf0c84c3dd16b2992f6d81e1e392d1511c0c58cd2aeea934b97cdc82bd9262f8d1dd664412c8add52e757acf5ae24a64ad4c8f60dd8d0b0e3a6f8b687d330c78d511142cf7a71b612a0b908ed9aea374c11c03728aae911a8945bc9ada333fad60c2e86f6b395194cb459e9732a9f451a7069f1f96933e190a7c80b99d2e8ff7a8bd95675afb7cb04c0f9af05a6765a62a5fb83d8a088db22eca966f0ebeb1b972f20bac703091fec2351f88cef766378113b25edd6f91eb8e90511d5671c0986386c652e90eb41c457a91d9df4e4022911aeaa4f7969e1cbd7340331c330594eefbca69e360a49a752c283e1418c13959298b2dc74b949ac33bb371e0235eacf317363c6cd179986ec4c5bf8edaea22bfce8f45941dec81208c8acc5c79f474a1ba9491bb38d26ca9bb7461ddce9691e71836872a3811b965b678607766c56033c591a8618695e8732d0dd26ad9b280fa82c54771cd7243f5103448a47857f0711f1fdbfd6304853204f45a47f633cb17c1d39fe1846e5d3512425bc68e1a780de4979f7da077f85aff7a055952fa19aff9be4e538dcf02a2e172822516eef0808304251126224a4371772ac950d4f44613b25f14606fa947ce4e4a53bc21a9f30a77d64096c96fa914e4641075fd2adc4c31371972994c77e7c7c7d35835a62eccbecbbeda52618af82b82a3935f2881a8e4a92c9c9e6288ed9a6a967fdfbac54edfbb9dc95785f8af898480b70d8357c3f7e21cc47b89625a950a03cfd047270cab8178b3a17d9beefe30bbdc54cc63270f40962529c29483cd786fbdb0f899784f593b4336de39a4d4a5749d24e0edc981b4c528ac4d9833954881d16899813a4bd40b202effb6996e690fb5939a42f61f28486880d356102d21c1be314bf674e86a965862d58894d070d605bbe26bf0a4257f77fed3fab236904f055d89754319c8dd812fe59cf8adcd1c5d55a46c26e700b714f378a515a5b061636e999010ed7a38666a36d96aa2d7bc5232688a88697051d6caff324f6497a57584db8d554bad04149c0cad0baf04185334a2fff654ac7ed65a27146ab88cbe28e6197d2edf78e13ee611cc3b2798736e7f0ca4f084670d614885bd3fa7342614db2fee7c1cf0e3b1d009154b1e0eae28bedd28b4c38b0609870560a8ffbd70c202c334d4ee745839d60eee537a8a04f3dab9aeb887b054410b0c6996af47aa543cdef7cd76eda65aa21243783a5afb4a87525bb3aa4986f89e4714c66a0527bc79631fb4f45814ab43cb44ce83c980adb8c9d8be999f718c6c768b6c6cb3c6fe141f06c398fb44ecbfd3c66a11a745c002a6aac4aab652f0a23db52551b10e9c7d7aac2a11a4aeaf03ebb18781422b5785ead57c536f7c8cbb680bb5f893a7baab94c46073ae3f40926b15262954e0126c9fb9d4df1b51a4d8963a523b27360838c8de09f189c909f3042f8d431638517bf89016b0144a18738c5fc95ec461d47e911c84ddd9ba64d41084a91cd0fd64cbafaea693341e1958b9a09630f77a8ba11dcbf1f2d4aa057b484303c3f8fdb262bebb7541681a327d0d5deec63a83216f5b415e6545b4408134e597c7c2cd1ed15727d937fa7430491919ccad0fe7b9f8ebfa30c40a9f60ea7a9142adb4fc5d9018d9aeb5f77cb548e0202b0ad20e7c4f19ce327f0f473d876f88257803bd0cfbdadf69ab1ce102164098c8a1502420602eb3bebf1f0b2ed290069dc684656f52953182c902c8169dab88a353be0189cf125072d30ee4a2c7068757cd76689021a81118c888e6793c72bafbe45fecf06d758225d26420228b49b05b74e805e3034c51779f1aa325a1d74ec55b3c52e98de73bd1ffe628921f2b91fe0a7920ab2ed7e311671d14a52181de50783a739c08fda17dc90378ab1a5e0787f107ecaf4b749a7aaf3c06b31cbfe1e28780bcbb742d9fec08ce1fb0e1477224bc8812a49b65be86aff924ecc39679e139a3b019dbef6a5f1140671dfeeb0217f6fad921ceb4ecdd7de37b9fb182e80037c57b98fab1be9a668f9ca85b6a01fd597479c571682012f395fd257540a8044c1b961696246380a6c6ff32928dea8f551cd52476c345863d9a621f2abf10b3c2e9c3c276f2b7a40e2b20e2afc6da81c327bea9ea569bf63544ae1e97241ffa1021f3b9b9909ec25f9dbb032b8a067b68ea4d0d2aed3a106687f6d94cdd5e541dc87c7650017db7c02952bb0bf6d5771a9cc86fc5b56654cf38b1b423da07a30151671ec705938958b996a6dcb8fa6a0c0282995c2f7c98f06ed17bb0c47d0830ca5a6999a099fa432ee8c51941153927ba533c1380e540d393201ba4d47233828f9790b8e1e6834e99b2a88fd75b44d402facc0f219fd8e894b1f646418d260a3f5d741bad6fdceb1c80b79417b513036d4928e5c70e5e4f83b5efdfeadfcaaddb62a49d3a40b079ebad29a0e8effce3c4ea89a37496dacf99364787bfa10046f3a2b7fd7cd8277b6d181af1b2e52cbd8da8a0ecab9438eb371eae186dc7482d74b2b9271ce2609b2eb84aa719abbdf4a88cb1f567ee97ed82b090d06ee338dc849f6f8d00481f083987e816412d40e19b337bcd6897c4a4809b605569d5967aeccd3b149d4bd3a81018b0bd1e7980a1db4730014b112bc25ba8f1208b9da33e269cd2cd832d834d0f23ad625f078e6f250d49a6c370815854563529fc5cc4774f3cca2ddc3346029dd13a598ecc41c561479596b1879ec5c33980d1a169d3f69282d3a96de651ee3a97a013b8265b9d26a9707a9132eb7a3fedb23f65308fd25a8d9f36e5c2d938893ee12ab0bb3fdfe7efcafca9b794e04a90309654a3f49281301c65bf4070c4a936c9868d1c8050b7736b03c3ad8e74473c55d1339b2339754a006af927599bff3b62bf101cd6ad5f0e1b54ae1d7f2392a8a5f81c412a76b96417ebe392e1bdade215955b4ddf53108054bcbe0ad55935d71da9ff9cafcc880b9e635fa6e79a08fb4b274d6abe1314baa70846418ce67352aa4ade77d39eb8391bcf99e9edcf31681a4e30a70eab13d61a1dde9a36426c65a6a5dd259e585b9f436318a53e7ab5cde33394c2e343f6e376c1cbb041694caaa84742f78267197078c4ef81ccfe7564107edae2a183232749a27ac3e8a785ad7cbabd31e1734815e9d451bc099976723d5ad7ca0433fb1b7914443f29112a752d1f697666502783a36953e3d3575a62174fb769b132d296056e777c77e6cbafaa028d458eec55f17c450ed228d700bf02a49bac9323abe9dfc8156f2e254aae2919be4831681dae31996cf998fd9c78df6d466e925c2ed2d20874b9ed987954a12d44662c7348a0c2e65f63d1ea3174ab6923d7acdd410f9c36bec22ad0f3f1b34e65a14fdb2cf583964e3ac2e9499de16f1b3c06fdcd95dbcb293f0ff12f8d8f8a54a0245e9d4f035036d6aec199c49ae1505944abe87eab078f1b0fcaec5b3c46425254b2de7b35e652e8228389e8a94bf291e88c5e2723ecf7a3efa46588249a684e42c26791e79dab1cd5df92f694df670322f9847f264dd84be4bec0722d4201b5fb6ada4b71d65c250e8cc538da12de2edb30affe11e86a614559035ff0b1e6ba14c1919bdb4df8fde0dc250f6e697300cd19c93d96652b7164003</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试问题问答</title>
    <link href="/2024/05/16/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%97%AE%E7%AD%94/"/>
    <url>/2024/05/16/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%97%AE%E7%AD%94/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="24e940988c7e13bef6459646d40945901afaedebe359c3386a592024a5d744e9">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82dfe04647729118255fb8b8ceb7ac0a70331562e75c6c2b9eb87ac367f56a775708a99c9f587eff83ee03ea9f41734300fbaba4f597e274ac19b7f8814680033f2cf4ee3849f3ff7b5e2dda0a5d7441ca2290b0c6135275908710fe98a8029ef124e046925adc50359d3f13407fe374c646233bc3d58b5eec87e68e06037e7bcf98a46c05603a887a53589f0d32744bcc0a718cbaf4acdb226defce10aabf010714b8d231de189f3575a5cbc7221c9414ba746b2b9ec72291477afc94d50a3ab8306fef233cadd4a9cf27c2602ee745ec4c1dcddfb89caeffe803e9cbee389d9860e1f261e73327743e85504e1a85a952281b93e0cdbe0ffa0a2ded594bd9bf2fe7dcef41d31546e4438a218dbc1391a79e8af94583e8a396f7f377f507cc6bb6279855d130625844006c56ad1d09ceb922190abea7c8c84543e351d777aa094146019a54f47622abb35d877cf252b8b53d847e3768a6dbf0095a156a32a2ad45d979038bb0b798a1215e493580514d4ce41c8c7fbe4af82d3a6114ed21d1ded66f62a1ddf16ecd7e2e2f417e92e0a4b7572c1d8d18705d1f8a35ae9901d82b66363f5a819715dcc924f636019eb3f65813745d2857f2cc59556026e2c8e27c6410e6b6d79bf2c3846a4a6845d976b1ef32be9927dbaf45196e6a8a1529a94f2a9561bc0650293d52b7d282dbf8f2604d4aa2dc2429be2bcd87c089b9e9d7217ea316d0f9627ffff0e059c9715a9c578cbc6384a16f65a436d06af0e07377b63cc37461a2aad1ed5238f73763bc8b4cc0ac98e0ab62fc8958978abc2c81631cbac21bb82a853d2498b93255ca3aba56f929171e0ee14f66cda26756da4b0c50b31bbf362941b99e880c6977a41de4b193161ea345e04885e21825a471ab66ae3fe9e76e57f9c91deeaa8d7821f5523d0274f2edaed531b117dc2b9b1b89d47cc3bb794eb4db7e3955285692bbc63ae68a1ff9ecd3db0b47ebca124c471a06ebbfbca25c12ab61d6087302c5966bfbedcdd03cf981f6eb1a75adb78a7868a80c648692ad1eb3e44b86567d7ba35e8578cb75be84dc4d4d02d77e77711703c8a2abe30bf266c05ea4c9a930d0a5b1224686b520055fca9d373e2f9e56d0e0c9e7bbd89f8111fa391d793a92376ae870a606a8e5e0f2975b250d1eea6cc0438e91f859f1a70db9eb1ef7af17c9122b73a68c33dc73206d301120597afbd1c1ac8f4765b0fa7b0639a79b1ae0b0e949715987e7974a8d6eaef0e73608e1189909c8cf2aabe22f17b4d7a0ff6d3b691b95edeb83beb6117c293ef0bfce03b76f1a167411cda9a0c8551c3f644f0bee4c3c0763ec663f6995aef210d335020841983dd0c25c88ef33bead8b99e999dc36e737cdbcbbea146a1e477d8924afc0e183b1502ff1875ff0b348c4cc873cfa87121e8cfadb4635a948a75dc6094044b33fb33d5e7e9a0eb0bdcae5141f724c0fdbc578add6115797b9c9886a9ac5a253e87850c0f13344cadc59039ba7d58dfad3782e61e70145f211d11e7461fad941724fee48179cdd7b25b468b45fa7ce84a88e193a51f125202316bbf5c1bc06ff0c596e4f181d69d3c3b450a511dbb492c745c1859ff456be7b7d65541ac8cadb5cf63c3f664466f53a3e387c6a04def4d9b99512bb8f6ca587542450b875aaabbadd97e314551b13932fa4169cca5f42aee2bc9c8a6e80b5f1fb1b691ab16a7e1dd90f0c9f95c75834f51a19d9c9bbab0ed2f2cb5ae68a430f04414c5d6dfe2585923911a52e16cda816010094424b148320ad22c1495819fef7b6c00d174745dba609f431c2029859922c8183fc93eb8c5914a0d23c0b1a2a8771f4db40c747f31c634475f329dd43c27bf387d87b896c754a63b86e9515584df886991f8e0937b74141d59895b30a66a535d9f2173a8b6051bd0adbab38d96ced3a228659544a1f7b6f06cec03e8490dcdda03b13df44a1d5783ef3855b6b24d07ff7c94643a1b1a33ef6f40cf24e65568fb40356f2abe959f01241186f68a303aba461d78fdfe8e873340b59b82d477ca5cca60196327351436bb1663e63a387019ffd8b495155e620a109dbfede1b76709c3f294945254c8650f02d006ace4b5efd9c1a20f2c0e63df2d4ce54f4e03c734f526be8dbbe3ced1c6859ae53b1e76f4de20ff330ceed1384f611b37c6770b5d314807a0bebd19025c5a526be3ea4623ba4cca4eaf2af1545c402fa9f8108ed46905c085d8338fcbcdbdccfe18074090106333a21a3530ea7380dc1eebb9304c608a684213303ecce7c2787243bc3e6944e279caccb61f975dbf0b2b735bfe8f3b77de1995b6959216d383cbfb932f9ee312a7ce3c3e17c1ce18f96002b99ecc2ca732912aa1becb233ea936f43cc007a56b7f96bfdc0e68ea13ed573281d3215eeefc99a4275f2ae06013cfe67e0d924fa8f437a5287d68c8802d524b25a0d750869a59bd05678c202e14bde2e6d165be48fa3900b691b24438978c34870c956cb7aee34a5668b71a03aac3c6bd59e1723a1bf59f2409e3771795392115774e6fefbac5619c785367d543fe9f4372b34c13640216c5aaa2a845cf78c4e425388e442fa7eb5800c9e0331e700a6bd945554c66665e3f49ca28fe29c0b6c7a9339e7bce42c20533a6e34a39e0f140ab5c357947a40f760d219d25ccf7c748462bb4b8f00340d97932e4454b67dd46d96648698cd3c561b112bb48181305424ea7708c8a5e8d2f76e2ce3def103828728145c54dc41466c39467f4b465f6f93a00f1271a73e9051f0a8d06a1cc38f34d8892cdcd3cb327424b537cdfb5fbeae5cf5501bc03f3deb98ce25fb77bcbb07e1f0cf358c9ed75242fa43bb3c0804ad8a644826e6d5147794216f9775edc123c5faa8743e4032b7887549f93296c70424103a98aa930ba2b194b7da49256d4409c02026f37d9aa2aef075e46c698a1cfae2ff1af15beb86fc209637b4e42b3f4fb8855f725610c584beb6b85c91f5ff9f17d4f0144ccc5e8a1880c9f6de362f86bb97f7e9681e599cc563a9c9cab60f53361d7cb3f4040f0b0ecb06400b1616009b4482bf6772205e743a1d12b839aab42c6b9b4acbbbd1d467a08c73150cf395d166ed9720736f140c5bb61c6863c0b146add32e73fc80cd83078a6c266ca113a0c2977033163eb2b364847e2a21908566d313d0062b8e93d285c63edf1d9a43f2f3255e9324aceafb1fc3c1306632065b0cdbe29079a1ab6a7c3b142fad0f5fb851e144d8d5755d79f2245c648d7099baf8b4d07be3b8000689682d80cd26abdfe2b104435d43036d4578a94d3d1f0d429f25f5a81d6d93f8eadf10a4562a72bb45427092229049f8cce5359c838194bf1696ca3dbe49ee36ef9f6e8c873a08bb57452ddefea55282a591ab368d359274f3a788ec7030d3cd6c96d14cd982e12b663145b3a7eebda25d6f4cee97c838d53221532b621135e6cbaf9076fd14587acf4c36a0ca60730579f67d6c4782446d33e73b6a7e9e2f88551254995b9678a6c71fd7a5de12460f596a87bef09d87e9c9bd632de8c2b9f960bb813769810b4de5429ff293062b242ffa7518e04b84a0be3070e88c508394c9d095c36efa55fc500ed85d6773ffa37dd98ef51942b900b928a402b4e5c86070335a820bf1aa9dbe046f382c24e46e7688a412587597ddb79c68db6341ccc2386347ac37484de7d8c8c49e137a4758bd5ee420020cc1799ebede519daa0283807ebd71c96f763b65a10f4cf4530ae84ee7eb73f7e1777fb9fc812f4528a9337cc89c1e1699dd31620e9afc09caed221246dcf72d1e2a818c460ac11ecfbee1752460df6283ee2e6186cc0c303ca6518ca0dc1974817b8c3d3f91e0afa01453ba513d23e304d140400f56b4e78c9501c1406c8a7316e7721cad6b0e6f341705cd9e35f9d4d1fdcb7ed8bd9072f00675117de2a86b07237bb77ae9c91b6b0e4413babb8cc47dc8e29be42dd8fcac350faf36fdc4349231269433a52564fff0615b5e61bf5773607e5edd99129000213086ca7c084a11ae61524b547dd404957ba45cd599c61aa96dc3aa1280d11e7c9d9e21bf8f91858d983c899bc61ca4065194f9494ac68306177287ebbd6316f51748cda0537f3df5aeb62388ad4a48b2073be26571b7ed7de83690f0d91287969ce8298095976075618ba090e993649fac3bf5ac26ca7298fd5b8c082b4e2bb1faaae2fb6717b6ec459f0b55700dfc5d2b9bed91bf586dd088e9694a76fa986ba5b80c6ee205004653c60b0d5d4b287d46948ba81a30deab878ae77b2fc834ee38c7f144fc67fd12354675e533afd27fdd166147fc0b0ba8caffb76145601d287359ae9b4963f8e7081c5e35513d1a6c491912475656dbb8466a35c4719250e91c26731dee52becf6d8cc65cfa8f2e3064dc0aa4bcbf43e7b5b6292cc6d7cc78082a15ab80ecd3ab3adc3b0cee00a267471e4f9a4b35178fae59e2ec1f713cd2e38b806efd6b8332cf4db6547c9da90da21da97351669244966257839557f3095cc6ca1b5f52a0caaad44c29e2dd4844bc0414c6a5e19b7d14a2f1d9bd4074f6f05122cbb7344fd343c7fd01e95ab89be7cd869f88585c6dea1d0dc8a3737379e4ae36f527195294f53f8887f6f2f0c9f2bc54a520c968b50a58fe459efe5d569792c86a4645d4a91a5bf9640cd83e6cc6cd5515af59e5e26b107aa036aa133e9600ba2b5082c6e947772374589b228674c742207e436229104a25c5f2b6535134d8b2fcc64085cab9aa394b8a8df3b03a49fb429e4063b342c042b863144d5c247b06a27430890bc3901a3619b6d74d145024f20ff80896b83e574ac955636e57ce958ad062a632c8521166984c394288602dac49609ba183d03d592d37e46cc503b4dfb0af0606cb105be8860b8a56546588e1a340006da97b6cbf5e683abd62ac3c0cade52c7f43b4b905719fc1d7317299b80a40792239f1c2943e17eabaa16950166ae5c54ca9796bd14fda94e1118c97befd2571ece920c0d58013981afd9a956532ec78b65e9edece6d55213cccc37d11be985d83f7421be40ee70f6a59d016717b87644779901223074dd70bea33403bd7c98c04b31677588605cbef55cde91d82b4458575ea29d8bc1e960c0990ca7b4519b468c4830a29ba5faae3d604c6257527b977fca16e849aeb1d75ea674be1c060197f6d4c8a0b3284893ef77820951bd7550075ae15fbbaa08d6fb2885cd08059a26635b3c23caeceacbb176ce2ae1653dbb8ad9c6e5f0a9aa8fc060bc7d621bfe7f9589e95750936768b5ed47fcf91c873d4cc331942f9efc5189eaddb37901944a9becb37dc7a868356c2a4e2c30e6cfce01b33521263144f022cb378aa8bbc3e38740baec7849500d796a762f1cf20a81021c5d8c6b20cb5a3df0024bca6496b0567c896a8f1d7d27c38cedcce1c8823c766a4b163c241b8706b52eeb98144075615414ef45b2f2a2f48c5f782609cbec176b4c631cd8db524d427f3ed48ff47b4e3f7b1f9cd1f1473ae2233691588ede5abda15c6ea4c41bff05397bae6761a391ebd1ac66bafc75a7148d36752a584b7dd2b61e50413af405b2f56bb7c8cb5f34fc9a41e1b605699a5e2ae4d907060c8c9424551150debd3140ced7eab9897a0404cad0dc4c650a163d7d5b1a2ef041a916ad8344a2d36fd335a2dcfa85877450b427c6d7e678f03b05653e2f0b0a3b895e7998059238213b2be436dd3693120109e72d6db7dab8ba12d2244a9e6be6316c0e79e7380a4716c4d48f6fb849ed22d0b702ce12599ee008b95deb9ff1fe38e5179b4c9c2a36d6d40662eb5460f5ee2291531b1e9d0e66828861e67262f11228515ad588e56b8bc89bba5159aeab43b7b73ae0ea89bb2c9a2044e9c6ee29ebdb3b10be4f0a90c4de9338d58389616309df246cb9cee54d1605a9a0447ecdfd7e31627e5628fa7bfa992f1afb710d584c3eeb8aa0b1e33dcb668043a032598be2e6f9bb27e37de0b9243b5e5850066374c3b4195d13dd4d08caa3aa652af985cebb8b75baf08e076ad206ad39d92658b5897a882aeccf7c705652286cb08816ba38dbac13ba7dd3bd509455ccda1b4f6d8e5659fc0b74d876a6ee247dbd44088c269fe27716d7e1a3cabbc28798ab7df3145143e682d61169762298e96ca7c33a9ce4e763b46222ac515e30fa068cce67e50183bb32dbd7d6acc0b269d3b3c00151262dd30a46074cba9cc64e0a4a3faf7ced1b72f4f707967a666e0f130b32560ae9453904d56328574df69197f08d46a07ca6ba052ddf34cd76da80d867d91b6873ab339ac6de1268766bdbc8c760d22d0814af07d5a49825fb402f526e17ed8d051ac191e42546717833258382389f01b5801eb381439021a3c5dd40d93226cb157e72d4930ef8abedd24ce8ce70ae868da98d05cbd9af9d03ee8520a0813553fe13f872795190a883d0b06703b3d26c085772ce9e828ebc50c94f8401279da80debe6e2245d7427d06e3873b2b587c1a0a6ab1cf5a3dd0d01c9a31662fecfc84da95ee7a30f614b01ce4a129934185bf7293a8316ef382f3ad62612d904b90c61d2bfca12e1255811f414cec6a05416bc3c3e97b64b89530126635f31c4d3215cc9649ec2b24f96857f7d660db4f74991c81037e5cd5183d28288512f84604e797234227f0c10d873643078dc7aca7c2e9038351c37faed0eab8ec2625647c026509add58e7197a026c2afd7059e44c7e2488d847cafdb2718c98ab5fa6336d5e5ab65b9af60a3a433bd0b3173094ca2ea1cd4ebb8a2c9d1a33df89911806afcf28b31fd637dbbd574ec251e900d1acac4e2a6417809d43001d599c3e2f8e6a28ca3e909389a5c5f6c7a11329627cd4460095642285ab97c5a194da533c3e71724b93eb96f696fd8c0d0c3e0fd8098f566ce5044f22e51e530d80cca2ce70b5153625ffb3b55ce8c6b158b93d64677f2985d37dd3bd64347838f7476225bb636967381beeae3eef851ed8a0c4ab55ffcfa8ad9bbefccb44e6e782e0a6f754fd2af50589192ec01d53faff0307bbeb07346d5dcb0ed59c67b6b8fd98bd35ac5e7a653a889a03219889e0fcc4a995bcf8922c8dca033840030621129cc1f0509b660d9ab18b01b1400df1ab8f5ed11bb51aaf49408d77a7e689d343d36dc18117592184b3bb8f0591d7b2fa0b4ab8462e39aa253f158ace89014500b6d64699363208aa42211e8ace840ab44ed698d22a7ed70a423f0054fd1f264636476b32e4bb04182192eff42c9e5b81e44f8111fe1d06eac060f3d355a19ab6eb4114dd87232c9cbd0fca508b4e735cf855ed67150f0efd0e970a500a45ee229a6fd7259f5b080d62d9bc721f3c35959c962bcaa1078d492adfc2f9a904be7199f5cfc98b72d24c459c72152dfbad645696360afd41c727c09ac4b01cbf1b05ac1235e06e994a01e933c6cc7bb8e6d1e30afcb1c84edc68cc4000209483c5955661c853f9721d11988e9cbf84e79fccd9ed635d39756614b48276e3cc5d1f8e85beedcf41b40414011801a75dd7396d5df9c83b19117a6c1e7942b6086b1bd3aee2ac66bf4134d5c0b6a8ccb86cef26d84566c94aa54977d25bd6c92f496bacecf021d0d08dce426bb192305250efd99a3852333d8ae51f4a5c7ff9fb0cd911c04cd1abf3991d0f234a39c5b39e4879914236f3cc42032a72da28cd7bac1dd9f4c00d15ecc2c2bfac89aa990115138fce17807274fdf5270a0db886a36f63003480485a997054908937df39e2e5c654927eae3b6063ffbbbf4d7fd2f742765b8701fed29fc3f209c549d453f6695d422d1f89ed6490bcaec9773ba5bb800ecb72fecd54d1352ea030e139055e8aff8e6742a5ff04b2166cf8e84462992e3d84b68048a040e24e9dda42c9abb00166decda1fd8d55176cc3cd8c95c5c2c90cadf701e95ea5dc517c0447b3b80e0dab6740d138825904a3002c6d34dd72178eaf77ea1e049ba7aecefe2d59e300957182d2789575c8d16dfbaf6127cac73c58ca0bc1b1e2c745d735fb3bdb29e8e69c3e4cd03a9db76a5a20f13b76d0c29f528639ba8ee9a10b4ca73cafee6e1802a0f84e667ea74d0517c8e35afc2408897e7f41728b11d8a08972d94e23b2bc1f166399c7f3f091ef454ef836b37439daaaef21b34815f048b26d105be59ef0753d5e86bb22401ab63012feec780f2a8189b3f20d013144b43eb5e2b47a650508f5ccb9e954906d537ea0ef7483d2542c04b0b96a7d1aacb904bb694385a8d41dc45640a98544d7d52a89fd49561f1ce8c4eb91ed6026d616c277e997eb8307021517d8357cbf4c95edfb757294a3def1987defd39bdec05782d9a8a31f4d527a2f0f2e0c530e28e58afb47728a8cefcd275a558e0f764fd8ca2fe9cd64acb694cac396b0c13cfeabdbe1247e266675b7cff258d26b6bcce804a2c25e02ac36b12e161af0c2b916edcd538f5122a7feb054995b09b356e67fcba598d5742cc3af87494272ea18117d27146d4dc2e229b31734ade0ff3cb8ebb0dda83852d753a9c7057c82a334e232af3674a84afa1b04f304f7c349ad40085bd88e48917640485c20528b4ffd64977b83d943d8c0c460e282e37cd34977c7bbfbd9d684371970334df090b26e63c9a80751e7c30047cd65db42dc73c90c990714fbcfcdcfd4f33501088214324d14798666e2edfe50b6cfb33c204437cf58f2a4e8b8c7a3171b215d06658682fd552025a4cf26716b757a1bcf1712272fea18248fa115894991e8a880c390f64035828a7a9889e09d0976eb00de54a171ec001cb13d50f8955add1f51027b43447fad9a64b89ca1a8f0dd8dd95324aaba4c9ffaf7b8155133d9880982870e492e535c35dd46360ad258ae37d582c12a6619c02328fbe56b98403237fcf0bc6fa9c344547c3d80386fe95cb2f79ab136d21b1c0bd9590624121512db5e56c4b9859f573bc48161d1f13d5a07046317e7ff5182b024f46dcc0ee8141e175eeee11770e670c392f89e6e3758dfc579139443b045d696370b9e59411f2adfb6c4e90c4c8eb0ca95b48e4555e488d5da625b1b5ea7471a0cc35753e7761fb45a288f841273e0cb4a3be088daa63985b2d351e939838dc9a4ac9ac58dba90d66d466da6a5488508cc1dd5357e23f71c1d3c4d55a577645b9a26101a3ffa0d793fdcd9f2ccd3b8b14d29bdb5a28dcc1c572f6a0e17b8e72f880f24725d9ff366d39cb1d12032470edd21b3f6e5c798ba397e7e18058dc18033660edcdfd56b4af595068b7d474dc4df43319ab42e49ef55219a0d6bdf1832b8f983b46d3466734dc893fb167885c64c950223e6830dee8e19f41080d62a16c8ab70f65b9b2959c23a8b334871ebe56691a697c62159dc59a6716acd6903228221502ad3e41a713d3aba5f5c672c2abead3662a4166ef264c1ca87187ff26f57803a9b33c8db79c126ed8b544a8e57f91cb2dea3c41d9bf8ee48dde8686ba9a1ebe7a7eeee76b80a3422359e12520fde8adc89fc3ac2fd018458fabb672bfef3db23ef53e7ac83436b0ff5619fc97ce2a9eefeb3998a73ac0e370eb6eb4844e52b551ea73e36d03e924a63669ee1b8b21d9ac7ef8b2d4b637c73755febe1f5e9b43292052196414cf183bbb27dff6be7b16aea084e2ab29b11bf2022a46a5b52d23a1ceb20e8a53faa0f26c64cb4741d822f4e3f068c8fba9c7f09917abf3982f0399941b99e7fa4a8863f31b4674714b59c0c0bd089e3b7401b8cb671fdfd90e5c3d9a54e2d443015a00ec68ade0c0d80b9ea07c3c9028376260026a6fbd0d26293e8b7e0813cefa94eab241ad5406c19dd30249aa9dc4ae5c4c12d9e5ba9310b98929f725e8371a60f1a48d4ed2c4d2fb9988fa2a00b87aeeb4e7ed1211f978c652d84997bdd5b0e37843a009c31395b776eeb678f7f922998a9ad3f86c8d59305f0acfd3273d5dea6b2c133e4af66dc0f6e6b67965410d19b768cca95f1f4da58b7e0e97683773c46f208d015db4bc84568e7b0c12868c7b92fac01adb857d0556ab78ca58c32883b7dde65f98bac3015d7899d6221c6783b006b19cb546a07aabe11146cf07aea3b8f871f7a46c04980847e18c79d34057e6728b913d0f8d2493f53ec71997b30fc2659d71a807cdcf5166e7c846701ca7dc8d28d978c9b34515eb50b1444f98b4f41634dfce16fd9891059ca9a0fd4fd91e30df7681ac7ddd8a1ed19153a498526e4b9841f50c841ba680c85bb0363e76dbf6f63544e6a08ce7f59ba068daba062ddeffb7f60dd55465a892841a3b6f13940fb88002d40a884e92a069c8ddb2dc1f8a3ca6e74fdc39a1c57e89c97b082c3c0bc3ce741fbe58e9d20a97d1839e7f7221b6149b623d1a606ddfbcf0ee64ce34875dd98a5675e85d1ad702b75f6fada26e95bb4f658d73d17bd7edf22e77044c8741d354f0c1e775c691a773e79bc2c483088dcc945968407e28d06e030e13bb03410df0b5363f2d8b55b1bdada7475fbd370d8f69d8a990eb7277441371b9c3e37d877888abb26483c0437bb0f8cd797011b13d94e608d46b8f3ff273c47d6d7535fc688ed20a2ca6357fe8a8beaf2aea04b9b7dcf65355719f124c5b11ac0e646ec9e91bce6fd271c1829e35c96e5e5c904bb18e20efd367587f78af96023054a5e5475102bea20c8358a0ee93302df2bf0a6e8d968504a8d043ccf57363828edabb76366c06eeab42511f7000a830b77a5225c56e4384047273a58716cd01c1274e2c36fb48c5a81fb12315e8319845319fedd326d5717109912d2f050b146c35de0b09ee0bc7faf1d960e24affd0fa8ff8cd6e730d5b54ed93fa8731148057ca359081361bc2e1e7275b295cf280c402ae873382ff743bf5ed7192f7aa29cb96675956bb14a45b35337e36ee60d4535c9ca2400aef8bbc217fc8dcece21c4bf7163c1b24a00763deb77e24e0016fe24cee2fab57eb9e4493c2e0ed3dfba3a5300c40e400867405a6c6d3ab160af4aac15a4370cfc90a8e9aa1e744c656e2f636bb1e7c4cc978a069da3bea31043cfd53af0ca91e0620cb597ee29eb7aea9899a224b0c15f8be4b9335a98e85980b51527a628c5b5f25f1c1c851f71807c00b955b0078f96b36265355adab59a8558307d5b92805ec7044dcb3803abeb6002c9aba34d83f2ddb207454700b085971fabc9b2f2df80c63adc5c4e0b599134328059829e8f93ad752a5fd28e6a498aecfcfc7a82f22a882b7ab8218b977b76cf9b70d745ff01626d58c31d9cb440627a79cbeeeec54c912731e1b4975e8ec6392808be3760bdeb965e78272aee7fe2afa97e96f61608abd3960468659d6bdc459d7965a52b772768ec38252773576bca82780029994b0463e70b885462cda4e8253077407d360449a0929b5efd76253df5866b1d9757a6eb10b8f43a28ba008ff39eead1445fcdc32933e918060a89faffcdb808ce46886ad3c5ba2f3cec8267e4c15c67bdb229ceda382c3ea5804c6256040981c87d6e6ba1037b946d942812b639b1c995556c188019f2edbbf71fbf4c9749077543399026224060f1274daaf69d808a3f9aebf50b3e6a0373097c9e501236537fade6c99b45e4f50c840ff190b1504e29e3028cf7bd9becd257515013fc4aafc737dc5593995afc5f63cdf5c0b3159d00a95d3a1bde4aca80d046978ba0699ac23d917f471e3c21b5f63e67e16004318b398e2226e66935d4ab51b9b92b8193ccd7490fa41e6b2b38e088cc92fcd24c5333c5a9f5ac11a207e1544f9aefcd4aea104f7a20dc4f9608255b2678fc0d8a27470cfc565b93fc84bb583049bf430ad99a4f48c13873566de2a507a55da3f0079042c49118cf90a6c0439e5312185b238d9d833cd636acb022cb9650ddc21c1b693a9f9ced2ad130c8832f7487a8859b348de79fbc0e74fdfd1a0e15054e1a1d689b07a511e9739e4c44c49fee3e4a8e9cbf9bdcca4e260cbdc5cd247e35029b7580459ca4850b59e79005b2f55917885c1b7c750f4d2bd05af25079ce83c6857c0441107d98fcc2e1235f06911dadc158f09c29225806be2b3ae2baca88968f7a336a6d0d2b8642993c79c4445272d11b645ed6a825850f964ef1749e90731794548ebc77136ab7a20038efbc27d5b3d4b718f47d75ab42c51616ca7cb28073dde71bcf9cf9336f4e669ba0067157eab0ecec9004d62435622b838fe776eec94e95f990b23a61fce6225b40e0075e643b3375e6fe16b7300df169fbbc85becc0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>医学图像处理</title>
    <link href="/2024/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <url>/2024/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="医学图像处理"><a href="#医学图像处理" class="headerlink" title="医学图像处理"></a>医学图像处理</h1><p><a href="https://blog.csdn.net/github_36597203/article/details/90638835">深度学习在医疗健康领域的应用概述</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>论文</title>
    <link href="/2024/05/13/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%AE%BA%E6%96%87-1/"/>
    <url>/2024/05/13/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%AE%BA%E6%96%87-1/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="2994d8bf6233b701e84287a208061f9200eaeb58392646dc52aec550ac0ada6e">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df8faa2025a719dd4840111181a53d8471ae7886a7b4f9c1adf44468c2474fe2798cea52d16f0965364d1c09d148d252a6d9c7dc085dd87ffe0def39b89a12736bd2dc7401bdde496ab36ccff1a61bdbea14779f9e6658f8383a347caf4d5cf582da3f104f2e88500b48f1c5dfcbffea23a154ab01b4281a82e344c514cc2b5c877bba29d5e0357cb6528ecb70789355817a74fce7342aaa0d35b020def15a9ad91f98760f065bf1f48fb855a97d076d69884f88a23e4b4a19c7d0d567133327dd57d48cb45cd02b6a72ef913bf869745c6aaf22db4da7b192a5766ef9fb048154a379a2d27c5d9d7c162005f81efa22de7204332366387d329ba6dd1c562a35d1051b0b9e1daadc77136f8b747d779443f6035e2b5165d6449530aa3a9b7c1456534e8aa512a8f4be5aaa6e3ed91e9bc9c7fc35582eb7baaa3649aead7799ea10f7fa44b45c72775f709650620b7352d62d681c4ae5351ff59c7529b1b5434e486286ca4f29b57cefa03109e13b5549920778e6e25de0d38d29fd5e893fd13c828db8869239b422e3cb5198e9e04f6c026a272b1124f59dbd533eecee57c6db9ec5f638188e658aeb3c2afdd8d12619c3e676cd8128fa3cf28bcd7dc8c0dfa698bdda2a40a42e71f7f23eb3522d0f647c58491dea846a1f9d5426cfa57dc7493813bb8f999a949a53bf0bdaef23c0e6ad0565f4de18a8c65e2dbe901c5dd31654aba16e0aa9f30a6f16b1ce340972678481d2078cf466bbef7c220a7b398f13e3fb25f213b95ce220b24b4f1f2868b6b2c114376e8acdcd6d5436afad49284aaeb4f2658039f8b93765a7222f82b227d524daf13c122e50893aafce2aeb02d02bcf776daf4e3302cec82fcab743e0b2f4a787c9433e382ad2326b374fa4f5a59a6423b4012184c9bb10529ca8c0b54c5dbd39c3e45de5b01cbdf8fa855594249b8f4d4334736f4fd562ae99748175c72e32a6c233b881d7917f0ac26915dc6627bf1f80706b862de909d58ee667703767e7fd5c4d7d610a911d1ad8e0fbb398dcc6b92e8b97cde1a90313f5d977555c3bb9c2d4c9b83bc860d4967e27d808c330cdc5d038e0cca4059d681f473caa900a652f5ba53a74bf8e0e2bf3f0179412431bdaa1d2acdc31013221c0aa9aa7934e287c707e57701be91ff0ced8cff08945732ed546ff0a588f7584ed32f18f6641e3a594583baf4f69046d3204b80d6f8003dc214cab5856255c6b72b5efd6b57a32ddc939a9ebf9b6e427c71512a54aac614ece8c07e8a53482db13b477ca482852b1ee5e074a2e341111983e4e76da5eb57fcb9eba18834ce272e6984b3208134947e8d096b8dd50ba05349c7688bf6bccabc059761e249adb196ce61ceb51e2c024cbed4103eb59239a1ef1032ab4bd8b82df4e61bcfa783ca22d7413b317b7d31c31881ef98c7e8da392536299f91550b763a91d9c3187e2a97981bf25750b23637248dfc4b6888517e70911869b3d10aed14ed1b659af7f467f74bba635cb78afda6f2247a589a6c0ec3d297d9bc34ea7e0150fcb53b4811ffbdcb8066d92d9d922ca3390750ebf784ad8f25ff6bd184a4ec8e17209519ef44139c409cb85dd71cd7d990dc65be5febe1081d08a6cd2012c064f8aea0343885c2bc5611de5c884c034b8733d758921d0a73d4ac1a66efb7d67be492ab3cfe646c18f4d4a0cde54fe3b0010f859fb04405cbdb242bb59a692f59a5529a6f1f627b1e5fd8d89a0a176da062a804f0db2bbfcc807b6ef6e665ae9545cca96fe5d7600b678363a95afd17a3e9359154abe5cb16cfe8fbaa8f4754b61f4903f36c06093e927c34041376734fc94dfdc170345e567ac49f522bc2a2764f992765443629708604a6d815bd9a2fd8108be77edcbd8fee9314263a142285ae3ca37aba0d297b59ad740e9949e03bbde395d095b03075febc433701e4f900275618b61e4280cbe9354f1479944109083be239f68ddec16a8721ed39733165799e47d8d1a11711c535b87874e9c7bb4eb4dd4e8378354c69ae14439fa608805b1404cbe356f92c0a0bdb31a6cca725a529218ba9e900922d20d66b32c6a9de997f084a98d4b4749943602ab59e4f27911c7fd63f67d65004a3004a596014693177b6c880300d0d0614588f65df45a9a7b67256be1178feb21e92478474e14168925c32282949813552c7e7ad1f72644a3d6542eea5b45279c602a667375124fcd551cf3addc07913ef0dae680ccd17d105867638dbc42653c9129755d7b8f03bff9195b8ffbcc8a75e879e776c948f4ce90d5bab294b41956fab77450966d16b2191ce21a3ad1437efe3579351c0ebb4c30b558b1acaa2ede14958ad811fc9fe684645438761967def4ad5afeb6a0a4fea9e7e3861775050144363d42f4b48b16536e2d9e7a06ad548b04f567c332ff9dac5665e66bcc5dc905960745ad2a4be6a754b6b1181b2a62dbf10f49967057beafae257753ce0bc993fcab8bac310a132ed6f6abb90b514325e0bd5671e9002208f504c18a43f02b122cc76aca37fc7f3ce5a428a420f6c7eb63b3a2e177e741086f2652eb07337479ed83482a2ca06edddf9090229550609e1c179580e2d77749787b6df725efec45e205205b5818c1d110af740c3de0a084d8090f465bececaf628f48707b0e33e39197e7446a258f7e8157f75d5ff344a1a2330378606fc20d5b22022c7de7f7484422ceb898ea7a51e0a74878eda56b1eed2f194a4d91f83874569892f1f07c689396a83df9fac82c1f2f83243748c02056f77f5b11f4e1da3b6275e1df518a8be9ba56a2c74d670f48e719b9ad69565198f6e4bcb83c0c5ce9e8cf802c3df8ef4c33dcc4a7871829b0f7404e4252a844f29fd0171a11bb19689a11f6cb0cc83e43de84f1c11138baa1af329bd98a103c08cd57e39f9caca2fc4da547ee4032d611f9fbe99d6db22e4102ff3c820432d4618052f28cff70d511db83102dc7e47f7b934184c3426916604b2428fcd8e9fddfe9c14119aa441395c93695a42dd7e1d791eeda9bf662f813fb77e194cce722e0c688242f4f54b20d77d872e617d59bbc9dac9b7671df77bd56d7f3e24c7ff17b210431f9fff5258c34eaa864fa7726157652f034ce196f84c1087a2ff752a14c4433324d628dbc4e0f9bca05ed82e2c3789ca22c378d10eeb65df4a3b74834481959c083f8d2d4122a0f3f7d5dd7148b90ca7b596abad4fcaf0c347319f3d2f4bb5dbfd9cf1101fa7b59942de5f2ad174b2845988da934d6857dd895f24371c47b07c85ebe908276defab548b2be82ad55eede65b2ecf1f216b7191ee5d06793bbed4a0b7d191a39e704e9585dc241bdd14967ddc2265481ab68dcc14acd1716d3365c9cbc52ecc4cef9a3083ed8f97a717fb2b563f05f798d4a4027df6432764666ac9afbb6b1ece2516d80b1bd40afa8b4a5bc0603592a0b3cb6932436434d0dc539d13f5ffc2c0bac79a69e7092fbe2fc7d060d0b62005b028b72780688a4c597878ea6b713ed8b0f6283d940e5b0926574aebc02f60e8bbc10f42e445c59d410e0e7351b71d9ff379ed50d6ed9e9705fd81cb7130dad5370a47a84b576ca2655b5f6d1faa2bcc37c43ec4403fd2a743b5215f6722cf7382193fc91b4fcd157ad4c9bbbabd7c355f26f3ed19c0fc3dc8d6cc0b892e336ae55826f90b7531c23b8372d10f9429b9b9e6033701df9061b59de16579f0f3369eddaece7ca38bbb8611b5b88b05bdcf040314044d0d7abc032f68ec5b5660e5f219be149174cd969ed1447b8cc97ac9be27dc73eea6c02bba44eedaa0ae7adaf4b9b5d1460beac1a9b0847f1515b6d7fb74ffb5f95ebf5082a169977180fff0c1b10615071d12276fbc71ee56c538051f827f8d0d77ca0e2c1bab937495be99264f3d2aed70708cf96c531373051101d76bf6ac21a6ee9703343405ee0dcdd3536da2e6e2bbc98c9f25eab3a3880d1ccc52902928335e9d06abdbce07b3f766f93b5c21449541ef879bbbb33fe0c241801d4fcfccfa5e08b7483cb0cef55930e967e75b1787aa0031044ecb82337aed2d67779ecf85ebdbf6e6e53e375637cc47339722d52843b24983fe364052ae38cd9df5c29e8c55d2072f377ce43341666f69dc001a5a6023784866b2dcdca686308a1ccba8fda52475abaea8548425d9d02a2fe0de671dff5c285fbd403445eed276c8787fc00be3f6b898c574b706f601c10b2630e4eca776fec4ce97b29f8390c6e463c50bf250ed45f118119c3a0a802f81a6ddb91ea47b0ae13223476e153e946a9219ee4d2d3af08bd256b733bd91ea8d9b7e604ccaf8ed62e9a8353f86ca7e4d8aa9f3c96d60a731aa837ad1f643f2b12fb5de51bac6c4e2e8c7e070a8309950783d9bb5c2acd2248f3a858f35a15ca65ccbbc14e1bf9685b2b11b3614538aee55c102caa40b2e35b3c80719df4ee41b911b94ff8908ce370b919e82b9d1ae0e8687b14896e8ae020e0188476beec1e266eb7176487d9b970e0db9ef26825d61f7530fe7f5cfb6e773e9038a34eb3f64d3b6b20ac05fbee656acbc2a759d2e72d7dc71120618d8c648963d840a317b6dc9bfda187724abfcd4678415e0826727dd8c724ba91f0080d2147f3b1ee1c4d6e107448adc78261b57a8ff8926877d47fbb2c95df7bff19c92510a7e730ba12131ad300311713ea8887a34becf1b76b56e8d39c7195f7250f99482be71689ac8900cdb5bc8dd7e095091a8324f6ecc158a5561f55c2db890a88d95bf9b23331a1627ce853e4a6bc0e9bc04e1a7e48c9ebfd47ef0e0003fcd796c9fd75173ecebd2da0c9d55262bd61771d28b6e3ba65d4ce1888cf7802b0d238ee9610687ad15a9978f07222a370c50a45805ed8a7d825946298cb0cb5ce5a23f6289d70541e0b211cb9240dd734d972b7f480c3d3c8cdd7eb57a4baf198aa9140e12a1bffe2cd1d69713f198dcf4f149f5be13715b40c386707f0ff1621b26fdc9b0f85a08cb67f92425c297ccbf3889e4cce05be96cfcbc156a4112f4c23cd312a26012a083d19cc20b1470aaca818f49b8f882f9c29851ed76df785c09cb5f1c22b2896bcfe897edbbd3c6db212355d715567d1d248b933a240c679650eec8cbad6fecddebdb4548631bd005b62c78f20823e2730cbacdad86fec4b8b55b58234081c03e5300cad9de9af2c0ba54651dff8729763a7161f4bb31ba9807a39483254958c193022071741f052c53e8e939aed714829b027f471de2e1c8f49b0824e2a7c6324fce80cab553d379c2587d8b40b4d8a456000652d111ebffcc85235f589034c275f267ba40a6a619a05b412d90d27f2e160443bf4853bbcf21b10a1254eebb19657590dc9aae8477c8c1504aae4f336f66d65e11119ab2156b2a3c7627c451c584c7198dc8213929fde4f1d187308955a83aac2f04e64ffcb3ffc9b4fdad9b156e5ea941cf972416331db98d91b8202b16891f54c09015bc659e06c687af038bfaa62fffbacd679e0186e1977d0d5592a5c322a9d579b0c93653fb3094efd3fe393952b1c6d606c04c607fe39a261098dbd4a5c8afb82e4dcf7dbab9dfa760f7243d6c98364389b8844827e887bff9569e231c79900d2bf0d49794173aad19abae54cf7d5be22a17d53fb7e5b9bfa71c2625b299417917fc24447c8be2989b0348367180829aeb025fa956d36c56825de0d5972cb03ba614ceb60c34cc329974c0fb84663b3598314ae72446f81486a76201f905f38396542084a1410a350aed31da7f53d005ea0ac799c33c106a14ba72cf3086390de356be949be2b3b0aae65d7ad87fff7edbc9a6096970b1a2328ed85e617ed6201fdeb73b6869f7135798a98d3a6270b901fd9a509fce7c97d94e62dd0d3d473b958c9103e4dadc5f85cc0e0e41a5e6198bc3df4e40abe7e67c621e56bdd86e059ca1d1592976f7052f7551f5fb544bd51c57af9fed4f395f29bd490c9c72113d774dc9310a75f16b3107676191f6ce9670795363ce81b9caf36ec5cdfce3cacbda565481c0708e67fb9deaf1275fefbd15fadf5e1c4954e265f4ab8dd81da85395f73e28d83474941873ecd7dde1d9eadf39d54423f9cc6d32e7499d8a286c3fcdd4c12bd62988d3d4a49297517b510ae10651fbbb764939f5b0823cba78368e6c877e2bd6a318c3c9c990f0921dbf79afa46b22905920f7ad43beee34500d5fa28188aee3e052c2692ab7edbee244a97b2860075f26bd7daa4dcd2b95d1d60b3f685cd5d301f206f7a8cb17292637cda61c20129c06cb89bfa28b3b54f48ffd095122a54757f34ba499457fd305737a374a3dee1d1a7d835bbd6f24506a8fa442300fa867c7349821e4d32ffb8ef596a18be8fbb486e2b56ef172d89b1f2af8f01523440ddf80910adb4ef897fbb3c6912e9d56c0465ab85bab27e2eeb2acc2c96a944093f1bc8ad63438dcbb5054c4d0dc8ecc55c5bb247c1bf8b4e6b5c75f17d659da73ada2ff8bf3ac9ce6c4f941983e23bdb149c73d66f33de44d11d507a7517f7092bba8e173d2828825a72a9a01a25eac25087f5d3a1f6bf94940fc293e74e2da148838ad839573bd8a114e92a58010a370b1af9e518291adb0f3b9bb8e21aeb7f0e80c42f67825696b7b4d38dafcefc55cf93d8a42b19f4e6a65bb85a4d86e7800d5bbd1b32ec9f06f8f4fd9fbf122bc7fd128981fd34edc7bdd20202c154d29436b94b4ed407fcfa929d2a2f56bef5d11a6f72e5f9f77766dcc245cd63fafbb4db4150b732ec0f347270baff104530a37437ab8c96a2841b6f574bf5c3bb0a7ee50069f9dcd025fa56688839faf783fd4a42e9a6b3a64ff9d8f45c18a0a62e91ca4ba8599bbeb96eeebd2ce099328d9d02b7c29a6efb4d125602b9dca6f89c3cc3d0833177de411b1839ca5d1d74165d2cbf3e0fc7e18c1db4a1dfa768d5c848e4f799d86f6c963798b2eccd31dd45d2e2a55ee6be110f18f97ed3e3c62d537a85c71db7f3673c0cec570158a3d99bfd1359855f44cce79c76b4ea2e3738ccaacda1601a4f7eab817d887290cf095fbdba74e92bfb1b4a34fabc4ba0ddfaffc7805b336b56790cd1226262a72a1f3513b6c2440a4e45611d2747ef36d7e9718a3653d6f92e1c7613001e78e6afcba6b04c445602336a7238a508fa1903e49c207967aa6d2267d874611a0fe894916c54c78ff9c6210cfc5b779ae712f0704e3ef13de429410361dd5a75452f0fe33dabbb581c9b78840816b337577df75e7f5b549cadae3d50e542f01fc3b7449d9715aaea9fd6b1c7cccb69c75c6aec0f69ef047b5b0d7d0ddfc4f5c68e1f24db3caef10fe45ad5e181fc234db3a64128700655e8a6bf9d7154fac48e654f89a20ecb85137469da6a1ea95cc37990e3c782afade127739987fa351532be4ed0a49291e8d9386c651363b9dc93ff699da5ec0dfb0ed95a8709af1d953e7daee73f6c4da3c0daf879acdf3d658e74bd1fd80e81b18c343da8c49ba23ca8129da7b0a9119eb1f73e75dbe74304ac31716a93dfb60a9d842636c1186845bedee6764bf62427238078700d499e0b95ec2f38ae1476447e2299f948860834e794fc3fa8d5fad46c3e519ea0bd0564cffa6541f4ba2384bbc4548cef0f105472a8a333eab8ac3dbc4ebcd33070397f1389bbc0f9f4c1fafb0ca5a5e6b6f36d6d2ccb3be7a4e7aa9daf9cddf86de53782bc35c3403ba6cc336fd3a44f94bc0e89c3c10edfe6f409fd9e8e9716ae81b2b64ae0a6c631b7c3157a28f638a95899d2a4cbdcd9843ef8072f347cc2b551bf5a6e8ce75433c71229fbc972f14fa0f61447a8619bdfd829541cc29499c230df1f4d4575fdaae5adc739cb771dee00cf8349d578c974383ccd878b851299520e111442569680579fc3567c123083976773a5cb03625e2fd0498984cc4fe14065a64027c6cf87a178a5012878b12f5477377239efa88929e873f6db55a29de8f2929c1a502c4b7a20866e2cd8b9ab2c6ea2e7a9175b398d7f2091544ced37d964fa171250d53b01204d2f5041600bd51385d542a9dfcbe95d9db6bfd138f9355ac5467204200f76dbd7d379c32dbcf18601990bfa8f029f2d5d6f800800bc0b3787ee860ffd31ac3ff1c81da770d38f8d14ead39201d8bec1c398fb30b11d56490dff657f7f0ac5c4d488089ea06ecbd5d3fb16cf1d25f5e2ff2bbc55c8ccd4533264d3c1c97fcd90b9bfcf99ab1d59f050ab8d95b55fd99c30b726aa8719e174df6c8adaed2d42ca55f4de04a56690bf7ab674bba8e192a7d186f9990049343042fe981bd300905d9033e93b547a18870ffe5e3b79be46541e3c567b2a3275db3f71c810e66029e21fc956333312a86494216424ddc96f7c20e3567af9fbfb9d5b092178c387986f4ef8ef7ebbd08f4ae04df182ca6cac20c6678e3c5a028eb15ca119fac53fdabf763b8bd9325472ea426e57fe7c2340a0c932c940461189eaa200456aaa891c53a6d9de6f1179f9a98f7bfe0b1a7245c1ff575014505d1971ba66b66fa28a2d279280a4ea31e63a5b3a3aa05fa3caf0236981bdc06900560dc07dc36c7bef5d76f4ff7885526ce8e1e8978908d0063976e6d2ace83797643091c7d70e2687f54fb7fabab604c6e277777095ba9a541339ec25ab8ede5a3a2a843167fd129b16fa191faeaee723414b75873281ad645e2ab9db9828e565c6d79e7a6b3b16992cbd3e74844a804d40c1d066b9d5a63b95e5c7d9b20366666cb0ebb0e99509bcccc57253c823f0f8e3b01f04583e32945e1292313a24f19a3cf8e8406b6968b3ffcba9f2fdd3014569b39477a44e633e0b6e61c5e81e7ad02f74ff9457d983f262dd0d294335c9e3b4a35757eea3f449a9beec7af8e2db3efee66d2a674a027cc53b6dc175bf47a4c14d7ecb3d09e8e279287d6f81669d57dba3252dcfe4f487eab47e3012203002806e0019bb0bd41e6b7987afeaaf013032853072fcd6bbe75fd38875dff88b9170a6c1ad714815ef1087f2388403c57d2087ca9dcdcb2d5a173c650458df5a2c637d25445da6a2424869acad35eeb1c04a06c3b548003f6cff88f89729ef480892f0ec7bad6ce1b31cf35a7dcce2c6fb7d3277d128d0b3f1456b06bf878455241613a6d561f4e87884b33d49f52bf5d479a721959689c36be12ac0b303633b792a84ba2ff3a01a0a72fd49fc89176a6bc16c5ed5345c9b438069d49492881d56d43275ed1568c9eb32746afa195a5562e8e1ba400b1e817e42eb502bab405ac126a37a4d07b04c72529ca9d2aae16afe8b9154f645f83d53ccec61e1e5b0eeb7c67a83b5bb4804608221e1464ade6d2603f9dc29bd5928862df952b4201bdd8ea5c39001d979191d3fed70682c5ac65190eaa03b86ccd7e8a62b2e8f204e09a275cebdd795e211260702ce486b74732fc813b95621f011a95beb8d40e2b8cbe109b3ef65f90236558b52f8e2680d5e6bef15e664e2415f2d000dd33d9f182a43c96a33df8dad495fafed04c2d7e629f5328b90f12860232fee9f8e990ed4cb2dfae2e172597e472ce45ef6ac7db52052e50685532cb8769e8b7fb86843d19ee02d14f46e51ec309695bd7e4888ab413e6c96b74db14002c53cc5226e0883c5e4e64b192af70ab2bc9efc5c02225d065c05ef98d5a795b59144b0584ad60a4b9e6716c6eb0221fb3c0117ad3484ba6582671b2866c69c41fe71606a9dd2cab9979442634fbe85229f1e0004f5cc0d240933b1387f8a28cbbfc0d00208927536dff6d09e84a295626bf3854c228baf8cbd8de8991496feae7b852a36e60fb144326855f074a0e5c3ce5a9cf4e5c84b18cd74d65e6027208f2ca420597770568b3ecc20766ee98ed0dc5b6efaa9a7087a675a3ae69370ef39cb38a76fc66b4c5053f17e282d081ed03ef9beefb93eb138b038364b87e2c72f65ad364accdc1de8cf7caa01138a99995c306e48fd34d96996a9f7987879b06275188723436726fe7e41fb4081e7b2dbd60a73d97fdc7c21cbc6d6b893c4ef867dbee30e1b597def178ddcea44eccb501e16a96ebab435a68837a09a9346b19d0ca4c7e7eef87f4f1c519d84de1984114815e17762bcdfa3f6d056c8bdfc83a3e0a426fdccf42460b72a030e3964ef433edbcdbf3520ad3b2e7e39e6a050f276a53a03da2c580081f24e0e23484b6249d04d9a31148374c1cfc9586e49574054b5b64321961b55ff852af468cd25c91a0237ecb186dba31ccd0f61b2f1bcec36ec8daf89b63c084be294b0d8590f447769314330710f7c48637705903dffade1eb73f81b47194e76f6f7f2186cfec8fd37a4b4ce7b07af8a34554656b84fd63ba91fd94da91a1be78f72b3f47e50180efd3acb9adfe8a2cf4d8116efbc7ce20bfb3c167ddc2236d2a91d9ff10a2b636ebbf68277bcde1b07dfb612bb5182db805740276bca2a29faa037e24096e5adc4dc46f9f0ef26902728e06e64b47e77859c4eec0543420a57ae9f422eeeaade856c4f9963d7c6c5a6aedac5ae7966717d4ea4ea4ffa5a04493d338977c58e7681e23e1c8ed8e470ca09e5fa1559c84ba398ab7c956056e9c9c47befc0c44167c1dd3bbab73e144b9e221e92f4929a0dccd9680e55c4d07c049d6c0bbd33e5d5e48ea7c014a243aeee1681163304306b0ea8bf943914979ec4e42adc219b9c95cb5502fbaa7cf2689c0abcfbfadd7249b09b3ead81a986e5cdcba2eb05f3424f7008935df902ddc3a73029994fe1b8a4788fa59ebf4f2d01bb44a7d1ec73910b9c3a9e30568f37a4694276c0f5d4284836a88ef7ad8a5f44add8383b8dae5f510754532fd9db4f7235a8f0573f56538d8bb36f487765b3ddc0fb9b175cf48bd7eb2aca6e22ece6f4736a06a439aed35a2c73618e70a216db107f96bd49bd91300b144ee426e94a2207899a034b0fa959351ee5d59d0e36ef1cc48bfccda44ed64b5ae6d4448d19a1a434377436ebeece3f866944533e4bad307af3c12418b6265ce0d62c7b6cc825526f85964238a341baa4f4c56dcb81d7ee9ef9fef6107d912a83d87d5b1ce714f9c3dc17e6aa23e8324e8a2fb356762d95013f38fddd79ccbd94f1f32928ef47c855987d6d5c2676a0fded83ea9644722d3fd08f6401f6b6224e09c29d38b350d226d76e8a2826b86215f1907fc4bf2873a7f59694d459ca292fc84fc566ad0fe7e31d8a69d073c08aa9476817bfa3fb03e098607d91c3a980fded1dde30fbe2be2884c9b80a4dc3f4f7e5f827cdde95618fa780d4529df973b00e71463760faf6b2cf3d7cd5e6c3d60e03b359621752e4a7d7b54fdfa10bbc47f42977226195a9fe7d9d02c1dca6f4bd8aa7d82c7ef48ae75c99fdfe5dc260d88f5305ff628ea77c05b52eea491921926ef8f4a068c55f09af6cf3bd9920292dd0e92dd6fc3dc9f51ac0c2d8ec54d52d560d47306b370c8590254484159f3cf7d4e9d8532b8f260dfc3dabdff1a583a5a21fb7a586f9836ecbe951d066be3b8ef98896e505b307fbe3760836b05dfef04c6022fe5fd20a941b9cffd8b994ebe959ac4996f59ecbeece91350b4b53487bb652cb7ce15cddda1596ff7174c9481b716399319ce92f3497d5aaa77b7c1bba8dbd2ded41b0a909a9b5d35b00389da3e2cfa4bb50ac1835591b6b5182327c481df45c2e758e09c8470f8cdf4ab1a51846e849a24d933e321694877c3b6306a72fa6d01ebd4856359461e218550c283c05c5dd91909c33fd847197d0f4e800c8460f22be9dbbe48ee319aee3beacfbca78e602a9c47efc31319beb7bf8b8c384ce9d51a86b4600267bc7af4861037ffa029cab74a70d87abc9612a924166321a1276a0e2cb9d018a0d1524a52736768c5b5f921a189ac2d35edccbddca71ea572d74c3cfe9c9a786ae714935ac2dae7258d7583327a922cd8452d74266661ee482e14d2d43be8543a9c257d89e9259c0ce91953391d7600b98913a9e0555d18df49cd456ae7aa1d3c09d17c6beaf1814143bb13cd7e4055aaba229df2671b5fbea574056d256bc379f8489d32f654c3bd824cd1ab22b8edf749c25cb42d09abaebe49101492a849fd372190c09b8d3194ec05e368cceadcce41acb5cb61ff6ef3d4ebe79d271eb8c3bd1281c821149697139ee5608766cafad364beef0cc77f5daef53bc4352e3c9d8bf50d93d9f9758cc04576738fc421a8ec871b212c6ea7e5ce58bec8a2f576f5e58637ce31276c43c0fe296b4ff8582096de0b455bcfcfa9cca6256f933e9d48268f9283859f0ef06de2bc51a8cd265c3c9b3eb04b91148dd557337355ca849557212b42f3bf1410094f4cfef1d4845a91fedfa2080931a1dcc7fe2d232b50222d4cf185783f4483dc0f6fac45941a44ac73e188ced916efe17f923b977d6aa7ac434844258180a7f9de23f95d94cab33d77f6be8db5dbd735d90d408a4a58ac44ba3ad4850f167b8a789b1fb36152746206779178ec390a4df66a5b332024fe2b16dce1a760d82c4c571e0dde98efc2c1df87436452d88224e9d1b2dc1b8bb8a192bbeb07e0e52201931c8828943f72cc8da103c9088b5f6c9309b2183d38b9056c842a5b43489086f22069d9a882471d24c79887389a3bf431c2415d378f3df30a258070e5d1571ef2c26400502d2dd82ea9cf215e77b11b48b208e14caaceb4cf6440518d21f2c2381c9cc0bb4bb46576c32848eedf2f9fb9bc80dac3bb68206b8c7faaf3fd01f202faa7c6c73ce0146d5c20e19ba97590c683501e1a64498103881132cb4e80c0c6d4801883eaf81b9e6eef247cb8a88d07bc54e199d3ccc9b521d0e25edc46639d885e93ae187a54c02e65ac60efea886f3d1e7aa445a41ba3bd8169f500148dd8c16d2dfbde2d258618b9500c72ce5ae59f506e60c3f0a86213f9d1514530b7c2240c0e6d4037063a36705ff631fc2e679f070178d4c29199c57755034ef140981de70190e326b4ea7dc2977cbce0a928bb93bfd512dc6b256d49fe7d0f899ea69a668b7cf7137ce09724bdbd0ceff318b80071fd1e491f2ebe93c4e8ce6fd9773b91f62ce83e03476d9c121033d71d4f06953c09d47d3d05ea66fa7764bccd4f37e547d53a845fcb80a6185e65e543a6af4f6396fa62801af8e4cf3d79f0e0567674dc48fa6e5df04b63c7e5654b3ba049aafc0e2c34907ccfe2c2e762b2caccc618ac634abc9ffb71f4730951f3375e7f2fc710e5e9d0bcaa1628f56b672533241a0827b756e2e4e8e3bad63ccc1c3951bba5aba506e5324652f25385fefd2f6445f1b20d08b25e2fedfb248aabda62cf22c73ebdcc291b2301be4b0f19f606e9e451ccdfa960ae0c52af43cd5ad240ba4a4bcdb046b18b0344ecb9d6d04ee5103fe7379a95bd292aff3a2394d5dcaea39a495caacc2d0f9dd39bc9a4ccb210d72bb44c881f61471fa71914ddfcb90af2dd4b3d33f17c18ba1961fe248a2f172514e1c4d199a33f7bf2b70edde149fd77ff50a57cd6623a55780a41dd9640a108c08e908060f3fc13442ad6f2a825b5c1ffaca7c3d9e8025fac76afb9bce9ae68aee4c3e90777ef4c4876e8734d7c26f3511918140ffd6316084cb0fe666b32280f038385e7d023ea8b8210ab5e7774577121723984dabfa612b9f99014651f188f3ffc9650dac575fd26f3c01764c97e012617ad18399b7a0a7af0af2069d703fd12b61b3705fec078e176187a2c710bf0682c3449b62aba70b4ab8c724893cf37141b26e39c0675e4fcc49c3a5186a7eb83b8976ff75deecac1aca8438cf0dc8ffa252564231356bb8ac816587bef3ff8281e1cf98926c2e60666b1265da7de9e81fe761555dae96a5253be34f46f17964eabf052f39fa14ccd81155daaded81b5b987ec9689e93fded50bedf8362b8e635f28ef7be794638ef7bf8c9882de97159d5725f8f0550276f4f467883b5203b2c66b5b1e0fcd82085a90a072fbdb50f60bca9d2b59600773704f009da6ec535f21da778497e58e521cada420cdca304f93d9817f43a5d46f25c6d47c7890009a7e8dee0d78da15dd55216a4f477b7f2275c239a792b5fb97348cba87d3ecadd2f0ce6991eb059cf6c6b6103e71e2d0b6b7bfa4c38de242be7776e81dd1ee36dec34402e0a1fcc1eddd9018d5754150b1d79e76eff03968047bc7f6feedcabcd491b149f9269c72bb04294cacd75a51886a98be943e7fd761357f95e33f1d8608d28e1812413934bdd3d34ce04e332388e9f63bb5fbac851ec67b5462388efa112e740fe5add27b77a496417dc830087f06edeba4d0c3f8ded4c4fbd5cb723e9640969c6f5d8bc2fd5b3bb0117b45a8aac2c71fdbe693b43747bf20f3ca2cf102cec297b0d6fc8891b0bd94cc2db46c23404080e28920a68dc86a9a0b68e4f03c592f76d1dfafa1812c4a77e8ff5b39f8e21b13f1d3aac072534d27d91698d9bcccaf383146fc3f44538d9458ffbc49fe8d51fe0aa62ca5254b9a70a86a83155aa55bfd5ef615375cd9ebfc40b0b206bd639b5302543353d5af8475655033caac263a016586ce29a39d2af25863a06beb604d4bff9b0984e45b425c333739c7497c821fdf012afe36c5e8ca2fc6974a50e4c1573afcb236b43c10dfa8e7dff0c482cef102143f3afe77674f64da02385ecd9fb61475692ed212fb11cca7b6ea6fcdef0b98dae3a1c723ce811f7f3934c77d49d35c3e5aff3dd1525e46c55030fc1158e3640c20ab9c2a59821232023f2ec8f3fe44c3dd97c1767dbcd441426edd52a12ef8aed12fc6843f73a43b85412eb6e8c95740fd3d3dec2e04f4875ecae85f29c1e374ebfa51baffde39f75e662863ff09342116e3b4b97324e603ec647fb13f9f100973f7e1ac06c1a17f962d71781b143916c4da8db5b35987a5840157ffdd4f24e43b7a4a61f0c10727ee85507944e9f2ef02aa746dee9f3a1a497ffe1c3c23bd5c637128d64f776f3284390b8fd5bd5d1ec8a6271dca9b62b3b30be1d283ca9282cb6784a386d9608af06cc9f35cd97ae2ab51177b0ef915e05d5d8671771b6cb644b09886a9bb9c512a06ba82e25d5c5360d251808d63e9b17b33c443ddad12650395ef999d72d0fe28c395ade3bc063e4b8fa2f55fdccce468106ac3990acfe9e0dce484cf9ff507c6a0f989f1794a219218ab6b350cc1167abb6edc696fd8c9e2d0e51963d2f9bd774509ee99ae388d9e87a682cb5b460b09f159c8bf4825a87d1483b52570ee3fddde3fcfb7a25253be3c4a359a0f10a3c0492608a8b23cd1ce22dee5db0a579bbb23c298a4b258783411b45969e9e0b7d2c776ff9afd9aa2935793313138e4143cb793022baa80a29ce2473d28da6005c552507e177b41a1c009eb9bcaef4a5fd196cb71358a28f274c9ea7c04a89345ec979306bd95ec36bf4c19f5c19b72e449896470ccc7490a833021a902bc5ada014fb95dae4512f972d7870d9a6a970ac328b8f7ee4321729b67dad69b6bd4750687fe478f4063d5290fc0ccf239619d66a65b7dc91072eb854ed7573ddac0312fb1615507c6d96867dc458de952d695547fe5a1d23a4c05a19f1386535a6b037d67aba64ef22859baaef987b71e5e3b849e691235687d85d56cc83e23e02d7dee0fa03151f248c6766a7eb0e5930a9cd2d7265eb4ba864f4a71f7d1a58c76f74ef64659b633183ae2b40090c8a6c445b18b1fca8ee1226780fb78107ba96e69011db47b6d4d020483b3391bcece376cde9d1b26306fac401dd0f1bfe65ebe135ae2845fb5aef782df0b8a8ef45eb7ede918d1fbca88ff6f0d144094cf0a6aae4d8608b719f3a52ec446693807257473eb5052a55d857a10dc4180e2d79a1f53e6de17e98f813be6b9d3663ac706ab92a913f366378b4341eb56e587051afcb2fb155d1aede999bf5c733a4056f77d8580e50eb058ba91cdd77ad63e5d0cbfd0167fa9216f0602a885a85648231bd717f5769d710be4b13eec93ed4690232f7ebc13e5c873ee0828d989258c8d9117fef31db74f16855776c6063a132e2d03ac0ecb9bb65b9a5561af130484c39efc711820f5792d1e95a4bb68e317eb43be3268a73121e8e1ee2213034fd667ad55fb6fc8506a54cc96b9a38e19d82822a52ea31bd4d37343d3cdb9bc03fea039f16c86dc748d1619f40c56cc77a6a85e1783a6c04cfa1406087e7cfa1090d8b4f991ee0ee9bb28140dc611cfbe1bbde3d2e0d7d4fda537031ce005a9c84f9dc8d3a6b7eb1c65d6401315267b766e996c4cb79969721a164a021c57e690744bdb6e66ab84ce4635cdd8310d867da2b327524b9317335803587641dc131cf682a848cb02b8ce9983814ba941552040410c8dff4f849a11df31c4bb2d8719e9eaac8ab6ced83710a5b0b18e44be194ab9a2e3a845c746a65d08f9571daf8e4534127795da816ee5f733c8c397961c7f41fc81820d639d232acf4fdf71f803a39263ef360bd9028e5c9f8fca05b54a71025389c17fd95b8aa3d9661daa9ae3a92fde9976ade50d9bd50055b4b227c755517fb392d9b6b72f360e5175529a353f99d38937c4722edb4d619cf5af142d1aaec40f7edf822c5a7b67b6015a632c662eb483cac77062044e819c7e5051562fc186a71c2433250466b8494b0a675ccc319017383c1e067e5d88723e163c057a6f897a294fa739bc8ed8a950dcc81de418281b0724dee859e29f8b603970702dc9be5cd5012cca24cc4701175bb5f848f02a79da35521b667fe76a998c8598e859da7e1cb61f12da084ac897035563868724a8b5b0f7fa0ab9666092754ac79eafcefb335d292a17260cb5394fd57923755019232e3783eeacb7e8704255e55a52d32b8201b1cf3bda57c9a60c946d52351f3198747580b2b6fb6b7180529fd1d12bfcc69676725542ae8893dbe958b5c3c3b72b6c60dc75138506568e2de250b792107a226460a3dbfbaf02954df6342108eede12e050221985a4959a2a672a326dd5b840b220020aa274ee80d701b87cab4748c0d0ac264bf0c8de58d03a0bfa4ea0fb3a6ccc9bd61173b4b3aa11743d7449acc128bedb5bb22d5dc5a97925bcf47a7f9edbbb779ac89d393e571c9612ec4622a86e123bb5cce54c654ef87c8dc7b707253bd3a69c84e35d9656527e2709a67f1701c456ce0d74a4093d7ff52e177710d72d99b934398f9fb3d6832b8944d120ab56fb9854ea64106797c9a11481ddb1e74c0ee3aedb3730c139658adc5411e0a369f89d98bbceb6612a3ed6b29b34615b18e5319b4deb8f4c36e479bbb477d2c04e29d9ce4fe0cc604414751ac41574d4db468724e42b8ac9580631b0ee8dd326a79dadcb4f3450fbfbeb9a6a7b1b04173bb1d3bdc762239a5b66af93cc140c89b30e0cf0da9ab9ead3eb2fecd424c5a278eae0232daf4bb478e9f7eb0bb73de4b2f8eb9769904a5bc6f4496e71f10ec67246b7949d2102fb301134778696a3559416a35b32da2ae069ae7a012a3d69e538cace5395e5dff8bcc9fd0bc83ac4f15346713864c6284af79f884df8c8e0ee46f030713c316be68ac7f906668401076c9446933791cede72e7d5b31a90d5baff6c68dfa8395be2bf977cf7da5526ea90260eb598364ec9f4ad53c2539556d4fa42d60422ab7b35ab8ddbcc0c3c3e5f177310e7098861e0f6ce418dee669983d60b3ca94283534efe15ab1e63e28c5fe8cdefae10f23fc2a6e1682c4f1a2bb67eb1b49ea3b107a92cd967354c92f972e3da46a24eebeced2245e9f6f02df5c21537e017a6ea4c8d674ccd50747d78e1a580d0dbb4a127d7fdff6d4ad33f366b841ea256e3ccc2d1303f632928deac9af37dbfa8e2b6ce4fc635d3e0767c9783d6e242092e803f766e87af3db4f2178bdaf2700556df8d2a0831b13fb1f42a608180b57117a44581cb00c5b2cb36b1b7a036dc67ccf7728c2a6b301387b8572bd5c5839547035a93567b611af00c4c1bca7ddcb074689e1128a55374f43979a6627ddd25b34da4a9fb10f6ca7df61b51eec959c1c4e2d43e07fd83d8560165c8cde21125e3e605aaa2fe54a30f191c8ab0ee3e4b1bf422bf8cac97ec535bd3d087d55596bdf2ba37b1c3b5d579fff51907dd20e62ad4b66d2131bda7e7a7d7ac2de2faa276492b8ec1ac2c233a41a7589a03553b1e70b92e5e9bfc2c4a26ea25e651578644e929c6a0de066470f0d2a402ad3136713e6bff3c170f2d0aa40eab1e5936c4067d440e1c84d659aa6f6f121936003fe4f0a08bd7e456b6cf599f15a132ef766bffd35a79600b9c43e574bd43a2e6f72683d9c346e86b23db3a9cb02cbe6e2677e4c6d7e43e41aa75e8f71ffd2693921cd9caadc66ea2654a2400ed857b98c2d4f481c0118f66a2cf87ded48ab30aafad6eacc30041362e88ec04c0adb5911b8f337d089b0227d175262feccf6574af08cc0192f6dd6c747ae96ec1a3b7b0cac2af7d25b3d3479a39c09625a4fc8a658ea752aefc32677e75186c45cda4db61c595959c1b4719f8c69e13bd0803d2fd7d3eb99e82e6d89a6ec54bdcc254ccdaec1eb30725d7473f6b11d1d3f8d55f8cc153266df4472aa82d75abc34f3554ddf8b74e0c969d023bc3d9ec1df19efef444fc8ccb5760b39bc6cb55f65b1995aebf58a5c631f7713ac8a57b496309cd76838c49c716dea93862c0b621a2dfd421e7b84eb3b767fe7c4b3c2c4e2c7a66af669522a940ae17ad8f70e62ae09492e14fec602a27ebe2bf7f7759aed60816ec74d8776a39639652886e06d72279f39b84b2b25da585b135375234c8bb40e02138a5854b3928874d86e93134551eccaf3cbcc0cb29e4461a774e2b66d12c0639172611fccc0c466055a4bc1a81a701e38e626da097441cbcfa5ea6a6dc82597a4b6cc965fe05b6c56197744b468b0501feed13c7757c1510da99aa8c3363ced15f3791f004e32c93fdfe71914fe4bb4b3d262a1d9a380c4b2987c896b5ca70f683f76edb7ce45eccb5a1adab02dfd4f20c1be8c3161f54823d3cc7403f7da77bf4a52ee4bf0deeffb0d9dfa45410ed0eea12d90829c06cca8d01bb06548c6cadf2334c80c2a7c774064e15a802e188f2d44a33b1d920ca8994d60b793a377051d0662202fa7d4691929a3975e90e3b5b4c95326f65b06dc09dfd90c7c8fb0509101c71bf05730c44e0e035404366baa8394997d7000243093e9baed76087826ad27a8bd5155139104d60ae90505c2beb0bf1db30b55da2739d2efcd244fab8c2856d016fe948231a9d7fcaae5a805b4af3f270f28c45c354e09e97aa2317735a7f396770684c6ceb63008eae6897eefe2e562825c31cf8ddc443949010a3c30a0e79f194b0a2dbf6a34b0bb061864c5ae25f15af304b7a4c411f44b3f86b66ff8c5c5ef7dbced27c1f740c70631e9057f8df2e92a438f9dd41274d013049312219256008e042fdd3d95c09dbae8f875894dfeb86e04c74ad71b46f0168a1c2baac1bcead08c873c126a5bfba2dc0d4e6a918b07aa68fc81d7928e6438669f73b1d079f114735264e0adff1aa196dbc329c2fa6860ded267065de408f90a754cf0b4a283f03969a036b6ca0bc6de083df5403404d33bc79beed61b7f1aa6f6ffb810943c9b459191d26de356e3e74a53e08e863f506c7237a7c16ebc8aca8086eeefae6cc79e2d0456761b58a339ac896329992de3a0f089f787759f3f54021cbc539fdf79d9bb2d1ea4f9b29e242251542a3d96db57262dfec3bb665eee21d1371d1d75a53c977c1ee6b7e71490248d200f2fea2248eddd88c9cb4b9da53655c924cdcdd1d51d07412d26a2384676c8008d360407a45cc86e60f9da48a067804feacc05f4ffbc62c3810e587a1600daebb798ee45dc0c22645ac73108bf61b5c969e8007911783a04c61a88ec5215cc08c952885669ed17d35bd58f245b42ba2710c09a6261c795d532ce52bd736d4956759d70d84b99e5cb72b576aa22a611f1d2e17d6e7a9ec69357d26b500112a0523a4b20c575aae308235eb4ee36715877ec82e20468347f5523243231f96a53f5445e771029079f16d766d93ed0bb503f90fb4ae4655c7df6b18f508d4479fc3a0e9b2eb5e674b7a723c452976a454e015e929705de2046e5affd86d866725366477d81984b41b214289fd5426d5161952c865c65f6b69ffe2680d147d543a2d1ecc0babbda409091918c9b2cf09def866ad668e09e3f556d2f08042fd4df34bfc816268cc08de25fd0b3eaee0e05531e5042f0de6afb3dc64db81c401209d2c7594ea9b0ae6709f16d6535deb3cb7d245382f10363ed397be83be1d8742f14501d3563424b333a65908825a0761de4ddda03153a0cd102cdc7211107ac5775726ca3abeeab67aae60b8cd7cb6189acd00ad3f03516e0d8123bab35d4174bd13e30147266941cc2090a74f5f45ec745108753ddff1aa3c01689419807768b19ec25f79536039aad4f66a7c75abb88f28eefb7246e5607e2e051fcec292ab0054ee1c87543999fca4fb316d7d0cf836f480f7a7ba2cfe2541fb9117b71cc934d690ae82ba09498ddce437788ecc5c49c360cac942ed1028045649a9cd260efa86bd8586828e8476e04831bff34864c53befdd3448d0771af84cb29bb89ea3e77767b4fbf288eb323831000f0050c6b8b0132c6420b9fa51b16a744ee5de6e76ab1853d98da166c2e5761925395b71827cc1ea654c037239bcdb630b45da95874ce2c2ae6b342bcb9a109294fc95fb52103b8f4377313b6b356c55e0a3d8816c69af8ce90966e105e580ba12b92734c6371711dc23feb537b3ed3c4bc6856f9f6fafd6e0e98917467b096ea39bd55c1c872588b113a0ed5fd56013c8a69cf2066627d61d7309579c339a4e36e8b2c3f36ae136e0d4691abebe935d0d8ad9b88e49ee13cd48f1d15c0bb130d762e524cbd239352bfa5b4eefe14415c136e6c206774a89d37ee09609ae2bfe57b72e76915cd4f9c5faf8713514915bfa569295ab6583389b21c75db72377cc919188366998b040ee7153c98101a805cc5f8bb585b1f6b014309bca8cd83ededf1e8203ca1e12a31db4f367cfbb0b87047c55d3e00037bc15af2f187ac6820fe265f3e9e1a16e20439db7242a084fbe0e1ef8e05da99b2e6b6644c71ff46a937fa8b5a4b0defcd64fa345c37f3835effc3ee912dbd741209b7b70980db95822942b717ca2b374017a611148732e3f1e515cd70a76f9ca8bfa6b445aecd2e73fcabd320d518e44b7539e4bb6f3eae4dfade08e88c8b91704932057c1442322e1e494c0e73d44722c76053c49f5d856c672f1075bdeccdc1b57cabdf9da695666ace6833c5048566d7ba1a5ee0729af16a12d5196e96c2787b6a3edb75468f744a6f702d3ffed19c6f3a41ca1ea75856a00fa29cb68e6fb02d154d0e3e2c917c1173aa729bd9995ac5b3ca79e86cd1a26217b5d0bb450e5ebfea09e41453485ea436b6de8935d88ae7e5dea12a96e0d5d460568797f725b556cb03f9bbb81323fc2b927190532c627df5b622c55e06d410b17701efcfcd22f65ab1a3c444fe437b94b3f082fabd1d7941daf0680474c07d66ec13bc33696736f8281fbcaf22ae1a6312ac4a2b6f766fdb19e7f8124703092c3c35200050bb7169161ae13be0195ce6c6a91508d199420991c6f8aba089cc7e4b79c41da082ba924cc6001feab4f0eb26b5a0026e24db8400a674e59c52d95f71f813387e55e44b559cedab490aa05052f50dd00ae318fe0a123b63c32ef3838841353f0a29f7998ff32a0ac78d6312dfd7d2813f8016a09d84ce1acb2e0ac350af344a156fad426f890b85db0869bde53427309564b8b29aa163ccba4cae8b5650e45e672020194760547161d7be8637e6d5dd579044cfcc85eb4ce59a20e63d964293d590e2906d4c67f6535510e0e0a7586a9f14f56b7a288ccbf777e585f3609f1d03338d99a62179f5da72faea0fb8533efd1b205f5c5dfdddbb2cab90a79be912c00272f42c8ad5a467d2d8ea7d489fd80655bd2d041ffc3343d77d2b38e114b4efd4af072f447926961f41d89ade549b09f5742b267cb4367459876580c63b367fe9a13ed5bb78e17537e339ad4086a62539e6c0c3631a21f7e2776b6a270fd24dc1d9d96b677be4844eb625206dcba84bed010f0abfd695859d11cbdadc2182ebdc520aebad5dc6b52210c73e07cf2a5a3b23f0f2094ba62fde5db27a3b1b27edb65ea4aa897a9cd9cf929c8729c0c2410a3d4ce5d32e21d0564e088fc182c93e58fdd842ba3dea9b406962e13a5ad46e052f2deb03e721208e7790734127dfd1d5a47fcc38e89903f68c18782e8f4fa62abf34b920bfd1a5db99383ebedf624f0cc83782d9cb4789acc5db7b9fe62df8c24d25fc2f2a56e910bbe4b90de6f4c68a6c4e219b0f7e6669824a5664f1ac4d32294caf105805c567bc2fa9186da7ec1aee89641cca0c35238ced90d56040c7a162429042db10ffd3fc6f020835250cc460a9ce32dbed6466c0bba13f0f78b93e2e876977a7dfd8ec5262640d7e04651505fec763ef8cb3b187b612f6127185b9385d8ebe5ae6d5c26a0eb5bed8186f66c2ee429126e53925bfcb3df1bf0ea8332c47c18ac3ecf965d762b52fae3c95ec43cab1211a0d14ba205ba284201cff1536b1d6192e336da1142686c27476e0f8e82a21898b5b5da70d0781f2c91b7389d02fe488057c1c1a95ccc6446a45aa92ea99effe99cf992f6f5da3b156b55624aadd7aa5c77d8e7c8c15703d5d94de312e2aeda8683bef69f3895aa9cf5754c9e275a0bb6152eb7f436b3bf73681a1c488705b0b6c810c19157aaf7f2fb665d667a603bbfb1988396f5d2122ad99dbdf77273a98983199c1403b5911d5f49b2f2e1797085029a7d6a94de5989d0e95ac5787a533ba7bb45e395e850299ff8087b910997c9ca21d224ca96f002751d44696ae2dfb7435cef4de639d9787ee58bf42e11e8f78ee1fdd1255c3b80a89cc5b78c5ae2773924f72a971c89cbf227d890cdbf12f5cf20b0cf7638184019414b31c223a8d00c8b4a6def6936070719093924eeddae8f68102a4d772190ac2570f449d0daae5c48a786bcddd961929a7917e7fd54fa442ba0ef3109123f7eb81db0bf671b48e9ca4e630c12eb93672ad60b22242bc2a0825e688a865a1d7b2eb6fc9399b91d95fd8541be661811841a51723e167427a16a84e6f416054c97c2a3fc503ff1a44674b994cf1883ea624b63f0a91cbc2cb297cb0e186915e485edfbde55bc32082c0e6a3d99d582a3d8a79f90113cf72252609cb57239b3f217552b34965e8e251a269b7d16259e94261f67b897edfc5f69102494569bb69aed56bc9335d212feea6b1713e7435b1e18e87a1b7be078968fb0b6a362537aca02d7524d25663919e7a76ed5187f3dc0bf44d0af396400202bbe38eee7f2bd80596338fe5997abcdf5555c188079865ab22bc0af0c242a13ecac7e6185821859c886de6190299fc6e348f4bd3e8d30c52f18ab23427f0645abfd6e4b67c98875ae68634b3dfdcec136d2d51bd0ecef36625291225b85a04465c963a24af80b4dd5b665d879d5e558b9df6531370563ee7c9404bf652eb2454e0e2149c15d3be51ce1ea920fd2a21d2541aa54dda093db09c64329bf0f9628a3e4653edd7e1e0118e9ee962fad44666b5b756c1b31554605f369d002cf40722824a8abdd6f347426d48a3f88a7a9bf90bb50200173111da1d70f34eb8906255940070db5923f28391b7c30e97b28d0aab23a8176779efbf6c1b49271128e2abefd365c95243f019f2f7dcb33cf4644010bfa99821dbf85ca1c5b17aff0a61fc7cdb4666e2aedf9523e760a72f269c040be223b17350a2b6e754b2930ad815527882c36c0e2081370b409a68556052d5ca6de61e21405aaa16f83eee1491c0d7c2608126a3c95e53ae4a2d3c03da0b9aee6668a3c85b6e762fc4661a608916c7959ec921c8dda89e1531fd48555c0b88c2f3a9a2229a756e9248fbbd9517cae798bc6e1c566f225838426fba737d3310e63d179c07761569accda432f85e204953b1322f88dbdf5e4bb196774f092bea9abad54ca725c7d6a04dbee609d6b90155d89b6817b8b02ccd81679a58b81a331e66a163e30a1b97dc4c25a866afae4bafe8141f5a941a93ee3f3507aa3e6a63e7b39f1aa3d7e5cba618fc3376d42070b3d54e038ab8c832306021fd34ef9595fc44fa91bf69991f99b82b276749402a44ba3d10d8c28035782ae1833418992fd27609aa3b21746794326c2430d63e36a0fc8d652c0f7873ac570baf08b13b2f2816271f008560e1e3b04ea3365e6103c335bbb753fe2c9a3d8371e40d9cd812f1cbdbb994e036a4a4e95548e838f4b913aee5ef729f1dbc1dd283fec2b00cddd7b9a87d78b29da5ed330f33fb1abe844e1a678e8584d3e6bebd2ef33ab80579999b9dd72b256e3ef4c1f4b20afebbaf0a85fcf9f31075f5a0d5eadded33dc2f6de3089ee497f28ee1be9fcad73bfd3c08a45aa46bfc287e2d73d5a58e3d946bf5c79bad24be6d4f88d8b921a21c5ca5f02567b37fb1ac184181b82c84743ce597186df5f1b13c803f2ae7cb118f5e16570a07e6dc29251b25e1836b752da22d9a2e80fc0db42823d9e25898721b32d46363045d96f76bf50f9e75f883d4bfe52e53b0f175b9bc307917172382f6149f22071c2aa10d9a0db1ab8dc61068923ff536ff6634dbc683eefe5411dd381c0c81cec019394cb631f6a26542f9931d37d6c1085f603c447ee69952da9bac586a2ca8014049044b8800de5a391b5c5859f15fef4e5fad04c66368e0e0a35dfc70ea508feb463cbc90baf1474eac88a5c60ad753f2e3d4b89e87c674a996b0ffa109b73545ba81ba2ed1c737a859355f01598bf4c070e2f06892b3d4c935b9739249821ef4e84739b781957d1a616a7a9259758fd48f86c0dda9da911046a92b6db7b97238cb864df73dccb88d47702d0d01d2fc835ffa4d346cf73dbd9a008626ca81174d3f6d8b9bbd198fa3dc7e0d338b7c0c84d3d160b2518133d4dced8c0812492f045a14b24e2fe482d0b4bcffe39edbaddb248f106078c128e56d2c9aecccb499fef30601553ec978bebd398efcf56ea8a9d02f8f2cd0e7e3e79d0415fbae1ddcb039ec7858e8e8e76a19158c519bcd46696e45e873fe2d7878b21e96777f3559568c61a3db053848062f9f5d4dfeb3ccf6cda278dbc6b77ff9fb6ed2aeb6294a3d545c5cf32cb00e0614abd2d707eae1f9c91f29245d3b78ce2164e346fbd40437fdbd71064f2b9c73eb66c32fdbf4b08de04dd45feee8848cc0cf2d2d0b4f8a494d9de2de3865e5ed15b3cb7b8c37aa5d99e820e2b2ad96c20fa4e1ca177a6a54221905456db094985296a26ecb4ffcab2ce0dfd0a8cc3327f4ca735d108db5865e94f68fc6ec730d847cb44d713ec794958b166e465501a72b8e2fde84728657ef73594587d2c3f540bbf2ec03aab1a65ccdfb70dcb8aae7694eb961bb80b7bedd7bf02f180e550d5b828fd00828120bdc9a994971823aead1da339ac33e4c55b22ea2825c18db8138d1c1766912edba54474129619c5235a16c21c014bc5f92019dea90ed5d4bb8a34bd5e019e7aa0bbb52527a0431d2d485ffb5189011dbc7fc3a2e19d7b1065895c39e62077526033faba25156920bc1f44025b3db81fa504972cb5d1617e415b86c50b8d2a0f0bb9cb441a573ac4bb1465ab9e2d8a1a2adb501744364691a7918add93e8ad21ec8add9fc7c42419c044c30d040c2b81326bc20cd5a195d823833bdd466b99367ceeb8ca12f4bcb5190fc2779c759ad1a6c28681fc819a004c2361c901f7e32afe40c0aa37662e83565b471c366699204f401a0f02a7b6d6d3c68de2efdd0c054a920a169f91f0c9f55dbb5e2af36afeea08e3612052216632bbbaa2204301d032076777fbdd65e611483fbf8335fbb82fea74a6a6e86135b1d662a482bc2e375dbc17e8f1b30953ccd45fbf0ab06e84d1205918f566aad40ef2a972d3762264c7bf4a59cf23d0f393eb268d52ab6fb3c30b0db0da596ee636635ff8739841cdd7dd2394f1a06d25c1ad0dead35265338f5868927f691fc886264f8f9eb28e77ad5d65edf55adb501a96b7a6bf82d4664498bfd245e8d4accd13507ee69450897021456f7cff715555a4d2fe4caa0d9b06be4420ef23f530b3b592d60c5d02f441924f0baff2a8c1ea1dfac471dfdadba6728308220a8420792da4d41ea215072fe300cbe6f3307cd9029a0a70f5fe77d83fbf6633828cb7b8069216d575528d913861d1dc5b2870bdddbce35293194e92b032d2479f412d671f59325b0662ee40b735779214bd11c02e01949a2bfad2f99e9e7324ced4050800a72d5369967e285f69f0a8f8dd919627c328f10a96222b368d28de8eb1d9dfdb9af8af722fcf75935967ac412acf670ac68f916a149124077c2136249814fd817d78299318e32ea3cf700b84ab495e8230a0ac4f3c05a5bba9033e4351d0ce27824cf1e8bc0d737d595471a57c862fcd5fe70afc5ef950a3926c44932dcdefdaaa30129ddbd468d0c0aab6080eb6120a24acb1f9f8732e16785f2bba291cf8043e0a93bfefbfb1ff9444db3e7a8a7d7fda0ff41d633d112dbdba7c263f3c8d089a0601fb937106381494a89a6e862abea68af45f1486e7b0a8a595f069d81fcaab45f392bfd6271eea85b821bddbef01f8246ea87688bcdb9fb806f5279ae81a924ed7c1551d8d477583e0d293349cf5cfd7e08825f853b70ec17039c78cae5310eaba80d82fc52db6ecf7c37f48b5b12e8f9004d4fd1714de9694eafa73bb29e477374bdcfec80432542f2337e7e3ff1c0dd89b0fc27fae5aa2cabb1d3bb12f87159cf26d2ef74785d37552b9c552f44152c27aabc632204460385c8d84782884a7ffa76d6451b790a00c537e34b6d38e3feec2e24fea7799ddee102da77bdc45d19b0f0f1537aca6a92c17d36133f704105783822b776b6472d2bc63e7028c9e570fe6ceb603580976b980b895d22aad76d4926bd63db9fc0f2b4aa58a3c1182bafbd0d7137f9e7c4e6645a137e0c9cea2396522cdee4ce12ca2b539744ce84ae729ba437b00f41fa9a00cb7d7358a37c5269ea4a1b85f2f0919d094c2e42e0337346e51aebe377af609d0c2f026d5898a033e378c4604640b51b31f2c57aeea0b591abcc76140aa61cde32c78b2abfcb98f586478b62259eb364ab2bc64ec7912d90cb008a2433b4738e7c546fdcaba3f20fc97975a797accf60fc364cb66e00b101b27c54642130c09505d4135f7b53a27dbbec30efeef37f7264d2923797f701659a6b17f6e071e0fdbfe3b98028982fe3c0019fdb015fb4a7b3949cd4a02d90ab4e5bd7b793467bf6bfc5ec5ae41bae0153be8e970a04fb8260a3742d24078c6468283e67c107eee69fa30ddd6cf9f736fadada86d93da40dcefd55f6b75f9164b7e61a554e2423f9fc0924997523cf88f1e2d4870099eee339750960223986a7ab8a2cd8127dc209828961747f76f0498a6ae2ae4cfd8f43350b05a6bae8833a86a16baf2c9b19c7ba55b9912cf0dc54adfe8fdc823e0372d8d42b5019af9018ab140d3a260b7bc50932a5bb19fe44dd121b444b845e7834e5d0ac00f91741a9d81e30119480f65abded956e4360704a06e46e2a1214495f5e7364b235d9e2613e047913d158c39bb1ded6f169402a3b549e7b23769594044ff9c5abe1a49cfbde2494c8bc43d6060b0eced9fb89a58523e3317dc97f2e34dc5229e44c6eff700353c6ef56cb09ed3e12c376e2059c7b49e9c17551a876a761684adf3b30c2728c098c6a946921739c2ee78c815f0c55f1dfab12c6b1950e3d38fa888184ec5b5db9c3005f034df88ecaaf0a5702c03aabacce16f974acee6d2869c10fe46fa3d332634f89dec7f6799f80503033bf6870c8ce59423bf1e3b246f132d235318a5f2cfa279fcee75f9ee4cc4cf4d0c0297ac5b6cc2cd33830959645f6cd1fe95d8798bbf1d5e7b15cfd95f821702b19071b19130a55762430b7faad594cc4b76aeb49055d0d94d9e5968e160e6806ac171f485ddce17c56c496df0113b087d0ebbbe7a987c3e0acd2c492fdbe6589bf57bfad223ba768f66b6ef5b1ebf8107788139858d47e19bf4f42f6e078fe693c9879381cd7563d91ebb71232ce39299911cf41924c1865107912b6fbf8ad685846f9e717dc9cf99b2fb3fcef8f9d5870912ae00becef0b8d06f2496bf44be109df566cf05d007fab899b84c3c453d6ddb0eba74792dbb54587b0c3b4e2429e020b469f1980496b3300590407504a57b937882132f030efc99037e0eea49c97022b206476ea3fe50249503cbad09bff2542a603815c793b5aba55f02382a4a032739586a0b572ce9137dd21f26e68611bc9c6bd62d3f7ea296c5fa611f977d8bea52cbbdf14f8cfbc852866bdcd6ee95b39d47e3a61009c297abb37c617b94311dad1f59c35aaec9b1e82122d57f6e50b8e3552d2a06af28c08d1177b1d013ab61a41af10e39dabd2bd03dc0a575c4c76aff2039825ac308e8cdae3de15e9b51c50972b46dfc1ba86a5700fc2d422c326905769edabdb0ed34b0be130d9fa71d2d082c4fddcb724935bfd9a1b655cfe89bb2d2414e7877acf70095838552e82ff42e58e9c870fd8abe3a1d13167e47fbe6bcd077a9852f9760f63428c4fa1b2d203aeb2fa634560740506364cf0e70ccae2adba60d5aacbce7add4dfa0307440057e35b60fd7133b0b3a465c3b4020f89c8dc1f5388541373f806756eef14736b8b9bb0d369dc4fa67ba8ad2b54de00c08d615575070ced21c0123df993913677ce8957a361a7ca3943d65eb1811531077f6d726e95222ad48214a9118ef743541bfee1f77d3e1fe68dba976de759a0011a27e8252e52f56bd7d66932381d290a8b553eaa16afe240835d0579032c67d8d5c82e4df431f7dddd3cac30e6871295e55d31eedcfba93cc9070fda1ca479c94e07c577458611bf3c6ee682cb6cd527ff1d61e87f29828141388784005db1fd84988c9ca7c031481622fef62f0a2193215c8b4d34481be33c2fbfe2cc396ec20b1eccb516eb890622eaa77d45f937ab24b53a1eb8ada84f6eded51a8bbb74aff9447265332f55305a523b4a4e033dfff8a297a8a92e748e2f2e1ff2c42a7b4c6de3bd4dcef762c100b8c983ebc3e49c37af0b416db3203c2f9fc02b93dab48065a83de37955ba35402acbc45ed989f187234126c26f45072f20fb74336fe68c9add69529bee1aeeacad4ed9f04cb1f6e572d6e5a63c04062f9920da2af057b3cd53d5f7afb07e86238d810087b13724f35e75240c21d0fae5ee0a2f056184c3d0d710e409d540f98d3dfdcb3cd65a72879081112e509e2c213bb4ecb71b5628587daff1ad79192994be4bb3d10e38e6c7dbffaf5ca705e9778a01f81214a422f540a94c3065cd4f515051f14d3f6ffd7ff6c6d9ebf50e670718a0dceea478e59bb7ad65c92c5b8208753c26a1cb835286f7d2c281a44a2cfeef98d2233218c23f915901d1dd6869443c7ac0ad654b386dea7468e10b797650ffc30de4f2c00cff2bc3e96598222fa9b174cbee0f908d05bfe9728c9efa705f82d4d305b6b93273e64ae4879c39ca5a1f053ae5fb8a6621aaad7476ff802ec11937aede19c8123f6e96aab9c3bcb583e912899ab01ca8532634565c014be506d482c1892e6d452a9ee495dfa7a273df662d52614516deecd9bff7272a835dbff3c6b9e43ba36d147fc50e84e2a060d611d7b7626dd2e53776306f1debd4818acd7563df64b3ec563f919f8ef412d778b405431cf9557cd8ef64c3afd26e7c4b18a15736fd465f84df78fe922ff6c8f2e3e2f08a685b43dfc078a6b02b7679cea111b99f5aae4242459de10b1957cdbb7d0f911dc0a8d00df174abe7b44bf7a0b72d99ef94de28a5e49d663d4bf575b4bb66cefb789061c3917a49c006ec1f4d9a0d5ed11650ae111883e8640e45c09eb70af1fe34471a015b81faa24f3816bd74a8640803d85e27c1af37d52811c65d5bf6ea609c4da4adf9cb74103e80ebc3e429792fd982d18c3cd264b8195a383605ea5c1df7e27307249b7e841bceb135ecde75693c068b1fa8c605e5d84d518337817e6c95aa282190101896f180ed382f33e9eefcf4c9bc43887667d23ccff857f2e0eb6bdebe9040293b4b752dc356b6efccfad2130a90a9d0ab1b9ea6b5349675864375a6b504bd169616688958791acda4b9d92b2eb4e556407806e97ad46bd3ac9e7bc57d2410019ea8d9ceee9a34b181e2a456507635df1293294f4cfd3ce8cd3b8ca56d935a05e2e33f70cfb34167e685cd8e4220c8e92a273e5bbae55635de8848e3ee607b986a57b65919e051616ed705bdb71948ef38de0882d6e9bdb4b84f4607a80528a89f0ae8b7b106e4aec1925a4a2d5e694c0d7907048c8b773cae2e457a09267e507f7f515c2b406057386d572ba58afc9a6eda854fd7e3b3b4bb3a09a97fa42d2c016d9f8309cb511df4479b7f23e239fb213c4a2a736ab24d24945e4a45c6de973b4b53a76d34f515273e0e385241df292b5b6998977b18deb50d8fc6f34016112c974ea8de72551dc9f2af39a1e3f4a7320cdec06b2d4724ab50a7def89d4dd5c06b84a038f6b48c961dab5c8951d7d2d02f4193aa666d539e8999b0551c5919b124501a39506d457f7936b054863e1b602cf85264dec2f3d6cfd3a9099ed675fc9c8ec2ad0524e3fc9e5b9cac0974efc60e9e0347b78632313d5f208912883826fabf3fa733af9c579e749456f7b353ddabedd788e83eaf95bc2c8614e60a7d1bdb137a8d9bbb690678b3a4c8f3d3ead5375ef6823b20c812ef883eaa56b811ee78dac56bc99ee958ae2ff3739d56a7f088516a1c97686bbf00e69a86ffb7ac110afd60b75db82c8c0d6605b31f2c42fdf39556a457d0afa958006e07c1c01feade790ba4f2d8938b8dc818ec263efcc9c67d70c0ee4b22de3b8e20f5155f44d86611044f23dcff8c05b713acdf32eca45578ca538f60e69e095ee90337da178f98a9b463e020ccf0e4720812e85a2548cb10739f00f54e749b38ef9ff6bff21371e66dc585e477fe70faabd59fecabcfa75649b79459ea2de5c3c8b5a8e25c8bd2c072e1a184eb7d2b5d4fe9df13cb5579247afe4a8ce6513143b01799e1d03440e4ca390ed91d8749347d2ec241e7b85694062e294dadddb35579e412c8434533803358ac63c2d9b9b1bb0fd47d50cd56c2986147b3f6e6bb1f265d5148c77f1c6452095bf06dcc4d164ae91f54d8b1527d2c72039e6e8b1bfab6b156e41a3c4d56523a2e12a6518de7060f8b38d1648b4dcaf7b985c31c76627579d550992541759c995622d15d8241ba80e5599fed6d70564d37ecc46344780b730c8159c1d2afa4031a926d983cb8ad764621ce799a229f454cc5dcea03391e9657ae33b9003789217d680779cecdaf18851843374b0a0b9f94e74998b31e884c32eff5987a5d0d087dcd4b5793757d606fa8fc9f0e990ab316b1b7e379c5f0f8467bdd031e9dce50d7873c80f5b65822727f46728422a7023bd44ba7051cd9218543108cfef465a76ff02f5a0c971b7229d71f96e1c8ff39f861345163c7508e0f4223f675d1264c32d3759c33aa38dc393dde1f93ad619521991122606f8606c3e827e59f04cefec3599e2bd8c34af3c87e7935b75213f6d312eabfd880ba4d646032e380e4cbf7525e91781134d5ac5b088a5e7e0855d39dab01660acdb6321d24cf5c881f54aa6bf67cfc0ace79b9c702d808b56c908faa285d952e9473cdcb28a4b33577d490b1d7c8a67e1d1a1439b25ad3ec22ab6993157f9feb1db49e915b5e420320036c01302ce2b0d9b41cfc3f3f29b0665c557a8aeab1fc246952494443e13fffa05fa340bd27401f9264b1fc45a583ccdfa826825915053c3f143a657c2f4867c69f64f61cd037eff1a84bc5ff69ca4b2ff727c69c64aabcd4e5043610a9309603122af7ca416659c79aacad92c396e7b67f92a73470527ccf5eea68b52c09bc926486f80704f7e8b9ffd93a22064dd6de7250adf01454bcf36a920cbc1023a4af3842b5cd4053fb9b2e77c5ca2890dfbc1e4332058e6b1fdcc52a929763ddeffb8d1620fb46aa08c5e5b6ba4f31737d8bcd1039a87403e54755263a8fdf17628740b1a58efab67bd9b6b795e5916de149879d9303582245dd460383315096f5a7a597eb15eb657b5f702c41db70873ce4ba9cce7f07d2e9e611679f03a27510215bc6c3bdabaf7af669b6c6f67627b9e70588145a573bdff209c65cf08e00a4cde8ad069322ea509cf5f145ef82d88d5b2b1ab9f1c72f03fa0a6a35c4cd0733dbbff7e03dc09d8cd6d7d7783b94ef37a321a47e88888dc17756a51ff3a84ae77ac825a43e3e8af737c22fa0d33216ea2f372412d792266f9ba64231e818427f6e5b562d744884803629f8c83a13c55feb44e40edafda8ed108a05b03c7ba32b40f12195e3a13ebb97942c4dbe202e208bfbc5f1fe088e6f0fdac7f2b43c21810595d98f720fa2f726d7a0e0646c61fc5ff788207966af616e0468ca198e0d01dfe4703bc4847d03a798f4d0a36aaaa500fb90bb7f2a2699eccfe29a0a255e0a378d5498fd03286e06a8455dd12e4b43013fa74409266fee1b9c90f3c8aa3ae79c83c17dec47d70ebbbe91b1fc80bb848a25df548a0e0da0ce216873bbf9248d53f809278bcaa7f6e7a1647025a250461bafb3fcbd9f7d00065bb309223a605ee02c774beaf67f7df27419157a8f6e498c1d6620f904af42a1a52e430874b4b2e30173817bb62c7df9d2b5b0ae658b9aa65b328f798bd64925c59a0c4ee60e8ca4c7999de2b82007fe039da4ba829d5eaff341f6e8db42710bd61c3ed89587b66a3310d80dd3080dab2013b071cf37dc25194ddb73cd12b295a93c84514d440fae7b2f3b3e29b91037bd60d0149b64d343e6950f6b411fe3adc51850a8200eadcebe981e26f959eca0757c4421093828b7401becc1e9b5f59774c4caaef6d59f8df9fad0faa8794706dd80eb8ffe640dfececd62486f0e559e4dd3a40c8175041ce1fbd6b0778be6fce5b56e96b931d3b393f1c0bbf2bd58bf72a57616a977c56839a2eb9aacffcb23c88f6998a98929c5a3c068da68ed860b2449084e6a5f164e908f039477f99e8e7a630194b73a626e080e39bafefd0dc64a1ee1b064d0f76cb555e4d5eb80d3104b5720336ff337e81aeebe3ebe175afad8dbc0d551761a4a8f561c690e31803dd937a9263611df8675fc4f946fb15092324a1bc3724c57c55cf8ec7115c2b277a0b86fb20bce340ba8627549c9ac2976b22364ee5fec0bfcb8fa0a84655e5094cd281460ded20e297054bac6eb13228486a7067ebf15a80e88846b9daa3078253318aa590b460158d48d69fe9fdae8d6f77f479fadb2c95600fc47a3387089bdb3acac32ae1ff7bd7b4111f2b64394d07388fc941cc16542a6a867fd8056afcd1c4f82d094687008c9737d67cafeca74441eb67b6857e4f515b1f8c01d3fe0ae5dad745751768e81d19e7ea47a8877401e4754b16bcd61a4a56f8d3e2fe996bc29714fe7d82304d98b0177c487fdb5c82be0b1a57c5f086c1a3e22488d3547f4afcb3189a7fb7c14b8ee2f9d0d38c4fcc6a2739c66c844518bd956c39597febaf9034222c134c7c3382a73f7ebea9f050a076758c587a75128b9f132bb0dd72b8e85bcb1188194d0895437b4112cb2627bea438f049d58b4e9c766af652fd0e4e9f157530abaac77249d80541c8e188466b0f5ac276078f14a9177b5e196e16f6d5098f72e43c57717a18e5c29c489e999e0cf12f3bc4ecabe383313d34a478d79e2dbf9a285024402131f5282262e9359e15bc1ac47a0c00d235dceceac997eaebef86ac23d1e1987e8e424d6db88ee13f6a68cb18daf38c1fbd1cf4d52bfbb320eea187b45e7e25787f37776c0d299de2ac52afb3a01c1040bfe4a6f0199c93555370a1ec7570b8df3de525b4274ec489926631f955fa21fd485f605151abcd5aae412289f2a3d609166f206bfc67e6edb81dc55221049bfa7d50db85bf64088349da4d2134df246813b333923d66e9b6d691e767d4c76ed722b7559d3a8fdc4764b5f49bdfbb6747790856244bc04499214acccf73130dc7aa1b4d2601aaf89711cce1a30d5c9e40823a800d1d0746a6de17bcd346e510fb7ffb7bc787a3034d6cf7567676c8d37bfb0e5ac7814e35eeff6b19afd2c5e9a98ea0db3e5dee5f75a1e2b3c83f23a63b374dae8452163479eae3f5fbaf15455a054a154b121d829c34d8477ab58d91046d443c4224a0dded3d74bdc17f9e65e2b5a9944ba20028414d3a5193d843f5371fc74827f2448b725972542625fdcd6999e426c2233a79f8b044d4b9829af2ded082126912b5e8389b76a9c63d806b09ec5125c619980cb070e83957323a79c4b1ee9a5026ccf6b800c27c071f86f58b8fa4c839138f4cd5db2757dc1bfbaf64f24833b1679561cc89958f784df61e33d1e8da3649ca736b8e77804bea37080841dfd9dd7e24c83a69f0b1c8f9def6ff3ec7a5f299a0c3cf6229de8f46395b85e34c4b964c2341f6dcf7a242b198dceb2287e43b9b64c53ea1c1031954e59a057d914fdcfba2e908e642a0e1c08b5e5d78d3adf8f6983739b80d67f7db6a7849a9998b17433a4aaf79d7522812be937c331271e329cba075101f47e2b916b0f5db66b01a1671a58eef42cbfde303f744e7752de814d55a07189e0b2fc250a437983b72941d14f61efd53d3ee705091c1adaab0640930130fdbfef6665c6692175485bd76a8ed76391e077ea2ede6f6f5b1c43f60923ebc4738c1e8afec7c9e9a95ce049b2ff3afb811ab86efe3e2ecaea53d31e67d56eb37d525281276282c3a24102f74c388418abd237eb4b701f57e1cce53b652b35ec505d61cd53f05c800ef5d603f4ee98a5ff56d8a99ad4f72ce40f2355282895052d43ccd05b3ea5449cef1632995659a116ac5b3232d0744a4011ccc7b9bd28f73b4300af40c06847777172d788ed2528bba1ae8ff9ecf3491467abb4cdc6ac2fe7198ba09b31c7c0617a21a5ced01e628076ee57ab2c9d1fea47364d1242f800fc3985603c8731048a77b24e2455d1c916f91a9eaa99774b77ba335096301912ea1aa868e47e9af36c908d2e8875aab0f2816f9cb3f7777cd94f98dbf8dfad1d62d31378739160b5ddb4499ac5507e53344146130f956d19aa951c8c58040a9780de11556fa2af5f01128385cda46eb74c14e449b1bb2d3d632df523be97611548b7b6104bbc508004f8c96cf59e3fc65fee126be69258d9512af545520c16f7c027bb794d0697ce001b79caed247dc80cb944f3262ffa3e1dfebe005adf61de5f8f19bbab5967f881b12f888911b00819fed6c7a4fe150f9c91a97bc78093eaf18da4a0277bffeb6d29f5ecd154bc2b5c0d6fc6f6620bf9e60192d73ce0edb651caa757548e43777ea5630a99f3720c96ed08b4107aef6f296088bf10952121a5480ac9fcabafed647283b3baec2f665b10087661a570919ff8666b6941c11fae1c0cac7c4a33a83ec3df5dad5b5fd37ba8a860cdae200db586dc7b091931d34ef0a931322799977375674a61aacdf824a52a5087369de255c5f0567bdbb2fc2062bd52695ff734d06363e9443e4376a99b0eaa0f5b479fe0777dcf51dcf93fdf19e16ca083a556eea0ad6d0582e89b6ec6334df15856683ebd43a40d4588853cc432c9a1648ce58c2cc9559e46d50bbbd34f32b7f23b4108636e38c29d5ec71fe5994381e4024adecef351aec251ca52eb781085e74e3c351f1606be2bb3b479244418121810d74ec675847a28c65bd2857fb572722d5244551f9acda028af1ae3d2bbc15c7fca7be888fa43fc094dd946bf4253b327a0a35ad50dd000a1d1bd00cf3e1c3c6187644b7fdc4143df79c5d9df0c2cf463ca9b677e45ae67d7d019500d63847c98eac69070b89af07b44fb3d7a54e7dc5699263eb0914b32e5f0d12378db88dad6a45b246cbc7cf2e4591afc34e1638e0db6a91eeb83bfe3cc9a17711cca392a753189485d759750db66de5cce7bf1bc700948ca73d4856f113a081a8bd7b088052ba7a85b4991e8b13efa7d6f002e558e1e2a5554d1b35fb7d0fb8212678aa0fd3f8425fc4d64be94953e00417bfce757d1d8988dba0b74ab09837248dd08c135be201202374db0f96cfb7ebf001e1ba8081f36ebfcc346701e5ccf69ca37511276224584daaaacb151106375d972ec16bdbb76b64468f9ed65ee52798edbda097b9bd38432d599dcfe3bdd81f815126df557e922f71fd74f036da18c2bfe8a67621bdfce59b7ea3205ab218a1074cb5f1df6eb496cdc19cefae9356ec3e1612b3a8d1656e23bb9eca09e84739753b0d170a87755c5b5a5e1f6e58489b63c54f1a55205ae559a5ccbfa8ea4269cccc1dfe6014ebd4f6cdb10f6e213cb3fddf0b0afabf59d7df4cc658e09439da8afec0cd82f8ba16891a82b8ff8ed3c83a43f1526094e2b82e25d9bda899d2872ff09f542725cc5bdc27d3132525dc0d6f27700a44492012c1a7e0c8b1b3a288cc49f9bc21c0b99f3e41d78870446585763b5f27e7cd9c33e4edb908b191cf985c66e1a83c40954797ca1cf7e7a768a0986d95001e96c94734d37d7a02e5634fbee42aa5fae779beff7147f87b7a551320267dc99a8ccf6b4172342d969a84e39c990f862ca2c7160cf9983d868c4ca69b6c257462489a0ce6675637c5c6cc13e84e26ce5150e279082658d4f835d0859cb9310e8bc311e79e0b301c9b1fca2b75d45d5bad8018df1429b44e1dd068a226aba0cbb0e6178ce369a9b9abc7bfb3182c5c84e39f652361ff573d4b2a3a183e478af817ec77d3b8aefde561103870f11d4b8ed0bc1c7d55d79d6bb21ca25a543d6b96cbde0ffbf8cf3440843349a4173e23b10728888a0d2e7ba1b4c27ffc216218ca4665e0b59d77a72678bb87445ec3304865f1a2fcc3ce8ab13136f62767a63e96a7cee7dbc604bb17929d18e8588224b4cfcd15a5ae8adbf1e7487139af704b09e6d64169416a7c91c54e3c0cc7e849e8146adfeae49c5300ee46a87f9e5373ac23e38cec886f51674c3a4404e2874e11aa3ecc341c59b542f0967f3c8318603e80ae46bd5718c5704c810071d63fd1bccbe1b0c710f32fe88e0d52f4e568511f9c042eebb11812a6e1bbd2e0ee22658ec05fc66cfd73bdd11e22740bbb918845286cb234ee3e45be42ac28102331a494f18e49caf131700a34743b6da6bc985afb233c7f64c1152cf879f94ca775648e29829f08e33831e74522857fa63fc37b06e426daae9f6e78d23beb5d9e7363fb93817b56c102ef3d28fda2df99a6bdd9a6acf3dfd4ec5ad667770d3f786e86e9d0e00a1638bb9d871a40428f122c84c8e643936e85cf50035bea6705692f6c8a8861f69de3d44beda61b6fbec8149513bdf60d4b858b85e89836bb36d6ac8e89470b24b6b57e3d151431bab0a12f492207d6d55c6f19f873132dd943b94426337c4067d89615183934dfdf862674eb2568fc3c75c4a5412bd9fc13c9a0efd8f54f326cd694f476dc9e06c9b2db4b5b31bf42c68a2db4a9d9334d9b1f1dd6907b5557ce4d1f07846f46203c2e75e519fd859685005d66418f779ec99ca1e50c044159bdaba04966b928eb860e761950c8b1b4271d5bc66a422f3a8d5919d3233d92328515ed468cdcfbf2b34a32decedc25a9a6f863df1848540d46f236694b22dea56eca3026d8b048f679bde18674d6a87706582ada5048055e004c6e749e6350a5fa5eab8baa5f76937ffb5c140db753b2e44e71133f436f14e3916334dab892f7a71455e99dc16ab56154dd528763894fbf88a07951cb8c7a1da166d19d65363c9f173236f2b07d02c89413f0d62d5e42c876fa07be343e8e516ff896a0d0bbefeba68c5a92cad3b6bfe4c94283703f688c4a4eab2411b1d6d37f1f3a28f9c5d4e6a3d69568f6ceb8b0221ffc8efb6934927dc146c4655228c377ead99a9d9234ffd5f616ed340a6c4c1580a85fdeaa06cb62aad0deb88297ffff792a49251e2a505953d764505c954774e3f1dec6e754eec7a35793e51afd74ae9167057951e8bfd3946575977358627bde9dd181f1373edee922585b2a33dea2b851877da3fc8ae8258e3dbce9cffb5b67aea80e2329dd5492b00739735adbf09b2279f72dd6c2c8502802afd5bd232fc20e48ecbc878a0fb358cc0ba95769f7b46680bb7f0c3955511bfaaa17355499381dcc8fc3c4901f879b81d01c6213288f2b4312655c9cca1b58bf59dbf55461171ebbd377f589402d58b0932883f905a94a578885eab5353ccaae38db1674439744e71e1d07909745684be42a6226bbff5af017c4b98e9b89ffd3673f629aace3abad2aa77d694086899ecb68972160228340b69ee9c2919deb00968658773771b772383dc71e4b22a67a4d706028a4e500cf0bd16f8cec65d225d73de5ba7250ec4fd9730b9497e91e6af9004b289b47079d8cad946c494c1e7a2395975f4ab5fa7748c63bb185b512792a0b6e6d09afe0a5ec629045feece8277dd4e3c8de0b086f48791b4190524957624b55c8dc2478aa52252977f18832b1dee9a85a97c2b9929c01ccc29709d77cf9c0f57018bc0a55974713e76bf3938741245888b6c6030498414f94211962f10b868b56816c5b8579a79812d48d350272769474804417e42c679f91d719597b7d63365960015edc5c6cec765a439c1561f3d56b3e1b2549f07391a2d6ac146e29e591eb276a01a184b917b28dcce6b2b1164e2fd236c2293eb0656226c6aea55ba315f38ab202cf6c948195194dc68f873c0da47857938c5d8087294fe0bda98479396e6b766e1a52e1710c9c1b88869bc266156e6d2b538f0ff4aa56ff152aed97a5d0b8bc9eecd8f509e21501831b2203bcf7e799f5d013e21ee39b888804383f366360b351630de73ed4d0aa3ee23f1b718748941f560e9316708b97f78fa805bc74c2b248486f6c8b6e6e99ae2590856d0367fd6e5d36a4788c20599578bd4ca022ae5f4afedd4f7aec9188871f1c4605f081ae744e8c72996db275f8a39c366a82f812fe4ad5ffe4207e5b1696ca49b838e1465041a950e46b4c3146bbce1e5dae08a268e6a5a0c92c1c3805612b6d76b0fe38402208c23348f5cbbb188635f0930dc1d0d3ec69c160f178eb35f4974d2d9b22d80be7c60b3e671caa430956c5e593ea6515a3455c7132cbf9eea55331527987a6949560f753f06ed5b549c5e4aa35b27b4dd0eaf52bba7e4afd6b3657ff1ca47aeef5b32c63245e0a34b67e0ef9d849683cc653ada0ac4549864f5db1b9ee645bb594409aad652f2cbd8db82ee94022cc1368c11ea81ae5a5063317210adf7dc9a7302cd9351cf5ba5b0d1ae9e6158b6618f3d909b902f191e876b3f582ef06aff70b5f3fc49f0307dca364195e480ca78e8b656913ef674101175276775231177a3eff7bf6108effcf6d4f00d2585b71285fd7d0e9998967c15ffdf00bf0ce3b864d9f164b041df8f636f9ed10053a60c007962ad7cf6e2848992a4a8ea100523c9f39d4e0c2205291915945c08ef39d556d6bd62c4d19274ca757a0fb9b4247eb5d2c2a1093bacc7d3e4ea6c123209a9c181eca140f03a8e4e56da02df94ad2237a4ac1f8ad2fb391464b54734434e7add111de2244c43cfb1fbf1ca6f55a31e1a77da72480c61327e6c58beba7cb0942f8197f97c326275bef386338deeaab9c3d844ff5d038a7e6e7cd26d852562b0f979c2e1d1558c21fd984d0ec5b7dccdf7a4a1d8fb47c1003e42a2053971ee87d85aebc9f5c174c402edaba3ea0dbbdeb8dcc340ea8e2e2174d8c85f8429324e23ed25393f0479fba05148d1e8620ff3eb9450128b115db953c3f12b952aa83eaadc68ca3079b8ab1fd602524cae7377cd027a96b02276359b8f1c12b9682192b4f6b1b557b30d95e6d1b0d686dd3f3c57c236fa46e771707f982a5394a972e4b0df4a466241e18441d71d67094a1fa2e43bbfa09cdb8139298eb96a07e92c00ea3eede4051db6bd8899c39d40562a792c8faac96e90dadd1ea3aa3cf59712c5975c9ca295e156611e2239c8a66c3b92d6e5620d05424160670c5657d7a790801a142387a6ab859fbfa79ce60c7369b9c8eaeafb86546e123c037a82a291b456285fbaed5b58901bbf4f2a3a0720f9742dce8e3e4335e1d3c34f09668e1d12802365b22b8c5d0ebdd5f563d617b7966e5adb4d766bf36236973c1a882e0abdafd05053bd5096973d294c94d95448874788efaaaae9cca54fbb1ba83d1332dc23e446530cdc4086ed190ce4580e3cb01fe942dc25df1018819e947d29f15ce787451a1cdc26aaafe4f7b0b9adb1eec8ad9c81824fa1644ebcf801c4d7a179bc5a3eec7dbfafccafa51da83c04573c24a9d64ad7b643fdd0a85daf2a3577cdf453c9e54b9835c3fb17d781bbe5dd94d35f38e8110d8e4981b6ee5f95dd0ace2e99773d69ba4306688ef2b8989e52fc6303e31c7c22b52ccf3e476fd8902bd6a24db861b6d50c9e406a3f02f14d42e6cad6b266c924cf90b174f1117d8410f038a675d7d1d41aff770052935464b3dc0b3b80b0a27af5fd1e239595a5e5eb110032e370bcf519f6be4d9115a8f27a390f4e420e3c4116e5ba16443d769ac187cdca78174299d43b75435d5b7f632164e1fed74adeb1c2bc42f0213ea95e8e64b9b9971349ce019b476913e44fd11e28d5d03c6e1bd46fd296cfe9087f00ea4d4fd7013c292c2106ddc7cc1eb778495e6c505589290b521f521d77fc0567bc7b321ce725bc07b945101b003842849623fa937c87790c52a2bf15d5f43b585cf238ef863fbe7849b226ba5cfdc3526b0a8c60994eb3cda667de0d9986cb7d67a125ddc34e50bea5383818c65971c01fae2ebddd0a9611ce09a4ffd4cbc8cba785efddcce66e790106dc8124ce7644a33c673cfda05d87cdbe8f84f44e91c8d55451d90711cd7f37e36ee4b5b29198ca9db6a7e4a4461f3489174d134aee1370117a03fb9ac9d2ad16b7866e0e45a9a72ea3278ca2bf3d88d2d2f9a469f8c9d450d881986204d587bb38f59e1faa250f41e44333e0b1b14b5ae37658e3fd97e0333c5799ae57986a66213905099a95695cdecd20a1e7cff3ef49b6da6a70660ea285091727f93a33cf01c0b9bd1ddb0e991173f93c1f92fd57d89f49a93a5f2879c2c959e4b700c126589bf90782924f49127e36f14c3f917bc768ca389d7ae0ff689589c85330c1ee52ceb70514ffec4cb0f3f61f602244ef47cf8746fdcb8f255700e8740b7900e0720fee56d87a980ccf4373c53a7cfe331245df0587830d2221a9967ce7f6048831ff259ce7eb9c72b126199e28d3f8755f063af98f1bfe0bbd981b7e8948ce5bd7633ab4d9a07923d44741624a6bc8e46930a8e766fb0b5771bae33aa62307cec37622caaba287a2527270a89ea71f3f60c33621d13a8cea23acfdb988622641d0fad616c8d6f24ea52325291fc7ac4b7bbe25a055a59a6396daf0855d83363409d141f1ef3bbf5a15e458e9b13c84713020d0ffc960c9e4e0ba846de0afc8c9925d839e8984aa4d7db6aecb7dea3f66e6a965956a5c453acb4ad32a17116b5687e1326804c9a9c7fdb5cafd63d0f9179d0bd4ef3bbd77fc062769efe75ff81c0a55a7dab0ebb7cc950914e36ea24f5684ed7286ad265f13ba58441403037090e95649d17c8ee053ca246ea370813409da0878f6667ed0b995254624e40b2580bbf2f0b35e6b015408a4a036e92a1316347fdecd0222db9aac0147ed585aa7bd232473c485447116973081719b977c75aef31b1d4a649fb1abb6f623f7dce6bc3f2fd28be95d48665343a0acf6324c6d410830ab67dc7776067a535e6c0cd1eab2bf183eb8ec5132a98e147a57fe91242c214d7c031e2acaba861a2ffa1e2ef66863ec45e7a67ffeffe46abe193b14e78460a95b083469c080a9c6014607916b208c5f3e54b641beb38616f45d77a9a290ef20a7c712f481f9568ca5c24eaa8ade7f8d5c178652c91590703930092388d29eb3388f555f4df61af7cab0e6fdb6f4f144d263b89c6b2581619753272fa54df9f01c8a12b80b23db57ccb7bf2581927c7cb85bba50920e71d7d1588488a6cdbd7a992f674f7265981a7b84415d50bef2888e02467c4b44f23761cce33e81d3cee9591f1ebc626cf47a25235989532d028812c30541c3d13da75cb46d85149ec0128c3bb07642599efb314a6f543a77cd67d74669415c6e7e08259a1561747fcea271e2b93dad50857d187fbf7cc9663652bbad61af68d4374ccf70cee9a878572d6f6228854de8490966fe76493a75f57083a3688c56b898c3837efb74555918d7e9fb6787822b5e4ba62878c8d8d8b7bbfcc8225b5aebd92d98248426811d3668875c0e8c0e0adc1eb7dda381e6220e2e15a566dcf8f9383dae51567f8abf667e1b88f2a0c510126be9dbd231244f676e29872a1d94cf13a60c13dbcfe9b0359566df4237a5dbb68658aa4450a4b35337197f78281036472e8b43866981934015ef84dbf458b558e2de113d422a2766ac8acbc3c27a8dde05b30a4a2c48171d77568e8ba221ed815492171f0525ed7b12fee5a1e21db07695e3cc24e9df2b107ed4f4661e0eb895103b75e1fe8f57a0c434c69c94da580e2f773584e4e67cf73c006914a46744ef5b0e2e605cd6089c946ec7b29fc094d314f5d71f106ca625259aa11a197f728e4dabf9946395c909415b1b294ed5793a84d82f1f95de81762c085154c15035a625b7855dd4a9a1af211f487a5b535c6fddcd8f91979a61b161c03a07db5c683f05c76ccc55e4cc5807b6cdb622705980de60e33bd5542ee197f80e183495cefc7ee27281fc9743b3ab0f9ffd44ff580979bc93a27ff68c2124bf855a9cf55c0a33522b65006acf410d16794e47f66f1bb29a118b1ec949cdcf6a8868bceff58df60c3f5400e706db3856bb51b1c68e108483c3ebd93ffa2fdc081309e314a72fe7648d363205fb48afc5952584488d019859744362f60ab9992dfec7ccbfacef94ce19daf4cd9b4f1b62c95022e0efb87052bd9f2263cbeee7b390bc1cead4863dc45c6355ffe84b4f637e2ea0aceb2c9e8bbf24d7ef9c6672b260c1b710f69ada08c5cd3a1db89fbf3f5d8530a7e6e244202894b7ef6cceffe70448deaa404ed5be814386ce45e68d065aabfc4e5f663167ffea5df983be5fee88c61e292cbd9fa75212e081af372dc28e74f7e59eb2821755eb108f3548113ee60344fbaa03d26f6419144de58fdce590787688266e942eeda1336f7e7f55fccde0faa95e1e812d7e93e7077a2dfefa49f6c17f11c1bfcf93f354fcfdc896214088cce1c220603bef711d54efe3aa65c480ed5dc98014e968026521c6848542e83148b2e647a1eff8d37d0418b8a51aa4e6464d7fa60626635d8e8e3c79a299f5a5448cc1814b0abcdccc70c22e819f80d676b384dc9b63638a0e5c6a90f36e1cbd80b58c280d98233c52d2d3678529d68abeffac3d2392814a999518edb87b3da1f6e200709748ad07ad2bb205515</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试总结</title>
    <link href="/2024/05/13/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/13/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c0d10fff6ff0a1c4e6946bce77ce7e468776e6f7479daba5220ea7766b2357ab">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df5ab0c48ed9c5c873bca0e2865b24ad04a37ebd287328918fbbd9421c6f846de3ae95d58c0d94b9e1478cb8e3418f57360c93364defeaade1a64d3c9b0d20a98c250a6d9fa0f377b039614c9f798cdac78a0b8dabad11478594e0a66d7d41442cd78f5c8261b126cc5b375cdaa1d47411f71949107eec9485e49007f036678fae3639a4ce64ea1c00699706b421610d0c8ab76d26515cf5619ce8116c7a576b37a6aa80434424954d400061019f59b2efc7c2d14262264b7cc9b7e40292fe0588c652b5e135a6be3a2074db244da79e896840a9c12a355e27a646a023c15e3d8d2d69d306a17d5a4fdba2216cb65ed618a75aaf47af12bd2fa5b5b1aa9c0860bb3ccf109fb4d25b02dcf14139075756fd1259cb4df4fbc5b8eca9183338345fca53b785d67e3f6dee688b7c9e9889e6ce7090abac26aa5e31d8a5809c12d2156e4fd1dd69d3dac4c674c416f7ff0718a1fc780b41304e1bff091fbf75a6efbffa1e79dd7565b4cb107aa65f89c2af225be28c33dcfbc3c5ba9f43afe431656390e57cea92c9fedefc471251fad505cd11b923c1e801175aa3185c867d9c5285957d06a728e40d6de88f0fedc88060084b0953728e29daafe1aa277de16c1b929eefc6dac6abe8edb938e75eec9a72f8ca91017f545d1d4f44bc3e37edbf26b6137d3d7b391869da6bd3fa9b3eff173ffa4166e4bd2621c7fab4ab99a14916763cc45ecb508f38c8bdaa49549c3cc8a7690bf79afb5ca9ed0c87e7e5f399db0a38fed34a66e86f4383d10b0cc025594e8fcfadad4341274420acf4427f20fea2126ede3ac234a4b441b72b3715e3e5cdc5ab8ed1566328a931a0dd9eaa5f1c6bd0c8d3a03edbd8c09e8218c605f0d4c53132f599d02b1cf0a3dc822b44a8d259e7d355d9db4cb5eb6dfe0d8a6273a60c899354d2b61d5335a3c37600d8a38bc910136d4379c0622a4b24bea65e38ac511565acbca23639ae1848f5ef01989876368d9eb5b9372dca6b6bc2d44c07c9c24af53477314fb1990fcbb9af1145fc6b28bd8ab53c731445c7847116175b250052e550ba78125217a3f7376206fcc4e1edb636b933e7f8baccc75684a061b55c62b96bfff4094517c3bd774ff199d711974fd50394a8ff03d6b83e16a0f7db35038b6b0c037a2e34f370471b023f18b732444711dd58440121972b48eb7703839edf01022ca0fcdd0dc73d490ffbe55bbaec6e736bdd9e2af9a3889ef68db7c61dbb4337c497b8a5de34d67e870082915058674219bbd7300be65cc558537bb57556247ec0781bbfe032dc2231cf60fa549ea25375a83ae50afa41c740f71be67f3fbaade4bb8fa9ff57164a873bd60418fb9757071404339e3d8e6b0bc7b52f4420f2970689a9700099e43c9ddabe5c370623301422f295a452ba2fe632aaddd01735ba908818c190012e78aaf4bc591e8e827704b3e5b669b301b622b46af616b449f84f4d4a06a1f44dddd2cd66c8bf8b1883f32bd293a50206dddb61079cf35eca9297df4f03fb25c60f23245d09ccb556abf4c29ca17c604d7ed55b8707035e6a9ab4c74d63ff5d629e6109da8d7d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试准备</title>
    <link href="/2024/05/12/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2024/05/12/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="2ca2fe6d252ff92da2fa2c17051ffeb5253a8ad73bbb0dd8418a141fcfa6483b">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df29141fba0a9677094c76639a1bf74af8cb4232bb71c798857252bf41e8d9d4101c021921de7ea454a5cc94ec98112e8853e1386c1999eb101948a11f0d855977389d0f8d0385deda2512915a0de0f2884a3d1aa38b5936fb93a7b3413f0300a536a6addc2cbe51b9262975576f487ab8a14bd056c7a34dd03c9876613d85a017433cfd5dd5be04d66bcb487c4dee4d0de7fb777d3173ddc3d3541a8fedcb7406295cecb9d77b433d8d97cd45c0b475e635507de30a8aa261e28b8a6c1e224624757392e922b91f3b79b6c13588337d9a276c1ec9217cc853c8ce021330c92e7a10cdf5d09e7cc1702be6a2ae1c22639222e9b3aa55242d676fa4007c51809f41e4133c5c5201435ecb005e22e4e5a8b2f0df13ae265dbd5f9c479027d6eca6b2ddd43e95dfd476dce38e5f2297c6a4a2ef3560f0346c62680a95372df6fbeaff3651c4a74ac66128123551e24eb85df3899ef3febb45ba034e2a59e98e2d69e614ed7edde08d4b3e62df275d4662e62daec49923bf4553bf0c92cb2bce693376058ee7cc2967d9874594b7b4d852e35c9669e6b4d0ff407052cb42b9b2bb2e8f383d9f361bfa2c68bfce6dc287a803fbe509290b73d0274af31b89fa5889488332310502d7e9da38244ad740f42b65b2f58e682602cc1f371d3f9b71a10e905c763108e308c2827e8882638c5ded2de295ed656b21ec503c9e374739cdae837fbf19165412c44f917a00e0882917d88547f9d47f671d54688c6038ac95e6168630937a4967e77dcaa983e0b302dea70dfd85cad0659dab9145e521f6cbec2e8041d2f1ca8b0b99ee5c4ee8cdbf50c53cc47a3c7ad97e11cf34f494edd515cf6b6a57f5588ff174fbd100bfe3cd89c8f3c921849533799a4836f9ef9054cd98ff6c186d06818944082e6ee9b05e68fdf97528d4cc5f7b8db0cbbeaed09cd44188d6a07d0f863d94fb94644171792971acbfbdf39ffd0b8c92178c11344058135105a6550189ada7952f628e194e79698df8c3f0763c0395999f489ce5f17fca4077c11f2a7d11a80415fac2b3f137f13d210054f581b4d0e8a5c4b158ac8cbd208a6fb478d36929331cdea230d22979b4a160f31881bc5eefa680ed8cf1f70d7c6f5016af315c3c50a1c2edd0b24bf500d3f5f9548522af52ce7a3032cf7ba9f26718ce080d602863ebe3419f81c4378f474b42f366749d6287c5772750398ed0b19c9a12a33771a41b7be647e62c8a37da5feb8d4fb51869e3fe972e40a92102e21490ba9a47ea01883c2bca6ef114999acbd74eded51793344aec3b11d8c8b2f13d402da088104d5d1d6e5a2fa0e9d217e3f96e158148a55637d019caf80f52afdf860152e95f13d3b8ce5966a4c2f318f5663e54abf5c9c2967acfab6b90b4173516007827af8a4d858f9d6e6be4222287d2659e8280c137ca0b5ea8b71eadf99d8d6a4ec197418e2d42edb5b9af1cc72b682181d673582e82f224340997ae152e9e3806d25551c7aa12eb956ca5ce3c60892a8dd59e7ca46bb622b361dce31c3086e005cff1ad0f50afdfd1eaace69c54f3c91b7cba9531c36fe3f5022558dd3f82b3f2c138e2b37964df798df1cb6eea0172558f7d489589d6574a839847c4b4accd66084c0dc610f11bbf99682615a9130fdcfb14316c11063d0f95d5f84142e397b88ca8e7974de33061996061153f9c632af0f0521b4985d947b6ebdd58e4cc16c468f6f90f23a65ca4a6336a02131cea4d91e44f33ea2b7d74c466ee5c54709a7a51210d6c5aa85e4fb898d3f13c488236cbd89f2a19eb1586ea89fe072424e96f6379f9b77d4a9c57ecc2ea4b8e757fac33daa7e015d5fdc39d57e3219f48f09a1b6618256b39aa80f16e8a3c329627d617c188dcea8de53e2b752f6ae5a5eb93dbc5eee7815727b3cbb9d786152e9e56a4689693b00749aaa6fa0a6829af3d16f2df3f75b06024805ce32e70e0691f6631c1b794dffc9f8abc322558f1aeae93e6e16eb2a2b1e4fa45074f9446b7ac8b6ed198eef30bfa39ee615f620b381dd29bb9ace1ff8193afc6c6b1c7ec3b074a9ee646f005a3bf6a3c613493d062b10c45a6648bf1dbba01226c89d3086428d0770a9e23e031a840561492407912f1da3fedd39d1340aff0294bbeded7ac0b9c6ae81585e678c7e51e71e4b5cab511e1e6f091dd4a88b461f0605fda9d85448ef3a70afe49469f640ad129ec399b7764178f322950636f63eb800c83f1271e98d3f265b8a3e3d6293a9ccd20031e858a0fbf15c23dff94bfca4f4c1eb4621e773d5a4609af1d891c26ab97c84b8f544ac6e23d1c8399a004fed6839355db49180b3f83dee958dc124050ee5d56a6f362602556e86ed4b71bf592071648fb4e78310b5eb26f78bf3d6878e31b3a12211c882a7d12c4b8cbb0d7d84fca77c5d7182ae6940c56f7302d4283b29992380e356c9a82a12fcfd618b3f8fca773e22050da82dd52fe20984dcb136915e16c974e0f6ec8fa919dc487551644b059b22fff588a178c90afa1a96c5161493cb39b4c559b988cdb8040b7a374461a85b3f2f811b0f9e48d6eafd100244df9247ca53dc1d01cc37d0eddaeba256c67310d9086d11903d820b06b223336e62d19f010953ede0d4f3bfcbed16b841660d232b74ab46e878a41c0002ea91880ceac509b5e44d5f7df1b5a3436402a846a70953a5cde1094a4616346c68ee18a758d71d170e6fa145895e1e6deca2de65af967d02fe7d476ecb996b8dea3e200884992984ad48973f18c53eee01a855c07c3c83febc630255fbdfd98a96dbc19f75718ed459dd27a7ae781ec70759f12471e2b65b2993cc71465528b73b58c9b9d7d15887c041d08f06be5ba3534bf013da17b70b85c9dd23d3a040b9860fd2b861a8b494e01d0d53e93b2fd764f1a7b93aac9964b2b711043feb1f8dfcaac232d3b662184580c136b89de8dea94d591ee43482f2c744e7c743c7bbfc8cac6490f71d45a59f808cb020be00729039974b21d100ca651739acf073ecbb9cc99282c2f340eb8b102878290c12d62770794205e5c77a3554bc6304833a512436ba17d42e8f4fd8f58410eb31b87906fea42fce4fb1f3575634e45d16fe0e4aaa87e56188d99402c266f442ae3a6a9b1ce73af2e6508732dd953229a49ba346a67b81dd220aaf4d9c926a9b86938589bf8f4e36d1ed8b260a372e3b12545cebc092ff58a2efd7f3a7a475d7e13dcc769202c4d69c62c18429414f0143fa0fa2638daa4d82edbd0dade58c36b305dff90266ba7c890f60d39dcf06500745418d10ea3e97003788b02d3ef05ad9c88ab67afccfa6f4aaea122a69fdaa9e3f5f3e2e826dae1984917a7887ce9333f1881d1eb5df0a8255275390ebb55d74ed0731cab29e6a3f4fccfdd556add9f23ea536413832ebb9f635551071a6f9239f7ed0a427e73aca13efa3ebbace611541c9e2e3f13ee6350bdfe1f5867f8101b7b86f21f39e67a72f400b77cbf2fc96c566c1ade437e781486434a505872bbe98423cb556cf9d70fbd8e0c5e5db3a69b7d1d4bd6c42ea4a9f343e6e87493f23bff9695ebea789b5e95bdcea7c99e0719492f36ea656eddd34cdd0ab9e382eb0847daef4915c45d2d98966b00cf204029c58e36afa797eb1af016659020ed039da456f7449f48d2187bce292d720f8d903c2df23e8af1fceb2902ab5fc6219a1467df8a5daf60cfe4c9742b2e3f83ac2092efe051bc991e6e1475906bccf446bbd7512827f7b1bfa44da13d952424b061b1f7a759c47c2575099dd7178512a7033ae729ebf1957e7ce0eba27938541e4f841faecdcf0e02804225a0f550c5906015a8b11c68d8dc4372975520d243cd7e2c4b1e7fcfec088d633fea8bf4ea74d4191f67fc35dbb435827b70679a6b4adfe78928da2ffc99a9df3ae425d3ca5ff50dd540bd855eb035aac9a63efec4a049c508a01b2cbd7e803258b0710ccfc8aa985b51cff727b29872ce6191fca507ae2fcf66ea9f477e4b5d3c2b892c4fb5d0c8ec12bb443ef22ae7b491d4fb8ab9700bf4d33fd0ae0abc5847e36f8e7cd2d3b7c04cf4b7f45defebe6873c50ee5b070ab563707563ea6b10be67dab2913f7252b011966ef076167b75e343444a26156416634301d89bbc226650a2f114b95074470c8a0fe81e44bfb98de3b12b8f1d0e7e25a998bd3b41b78806125e5e956829bb4d1da487a4fb1074a84fc8426ee0f8b994bbc1be0644bc74b7f2ccf4f151bab1542457109d42d66675fc64e073ed75b9afc305a8f8059a0fd0432acf0c0dfe9c7fb40a19a0b5f59118f24950865461842b540056397af5dcc58dd18f562ef69760c6315f4d732b11e903011ddaaf488ef4c34695e968e1e3a70ab362c69bebee0edaad2137f5ebb20a511066a19dc109f1bd52b6e611e8af1935ea8d34e0c2970c5aa3503e9e10218ea083641c0f40f165796aaa64876a6617cc4c860cadd1047faf7e3d2624df7a3b0a7c509b0e090b71f7aa8011b31ebd841cd21bcb7cceeebb115eeae9e197c2c6b6cd947f2035b7d066d856c386b9e7c77926f67ef81831eb014eb110f98b0e0f9473e3a83f3848f555f23549cd63bd3dd68bce7a75b5e3a315938f2b6c89261d3af6be40df31292abece2c3787977bb98bd59021362c958e37e14c303fce29c35c0665e640b64682b5076df448d74dffa098c67c9876e00c6d356e1950d5fc0bcbc22563010bc53e69980ae8894d1d2e29bda6847e0a38876a0e30adda77d561087055e43c990ca46296f1d0a02d5a58e82d4f40868d1c3717979f0ec404ed60c3ba79e76e07c00e4a46aff8d95abf3bcc13f1ef49861623cd209606d46c29972af9b87d113fab70fa1af936e1063d8c5e29599f9f659edda86f7ed02d46871ee5b7de6afbc21b2a6ce2f0434b673c56a7fd4743a2a49cdd2fca668a2c19970905bad4f302d8b9cebf3e42747b09bcbd832d67eeddb06f6b19a24a50a7cb8bf8a12efc27c353009f13973bd035f7cb0939466c160121f732b2933ccec774a788eda54e675a643dadbd44ffd5e4b0d322e8bd1a183098144de9966f7b95aeba58c692f220fd5068705ff1ec236bc9e6580e642dd12e4ca9a8e4d567d740c3c7a7147057718fae9e0c738da3d9e29ad8de0d72e98ee2795b757d5e5c83ee1cbe56a2f2bbdc051eb017093e85c777773468a9649a37f362c86f487dcfe0f1f1fdb2babc7c025ad4cbc7f53371f0c7f168f8a6f72e2caf064848ce80d4773156d4f2b4b39c396aa0584d902921584d140794647431f365134ac4b6f4c51e4c0df1b5c8263d8a097f65b46c292f4c474cca0937e70522981ac1668041f3571836844c309f0c9c725aaa8adc42392eb0673822c9830912885dd0b123155b3fa42bf54c8cc7ddd97f1b4aa235f582751cd83a4afb2b714e917f8bc764de7957068b2313b4391256b84d6766c8602007b1896362b3a6a97e0d2de20efd43aa3654c9627198c4cb10f3f60eef0e424e8a127c9e34ad833d184a954a2730c547bee945fafa433303658948ca736444ca3e1e1ec04cfa6fe9682dee333e0d3c90b38a32c9fb64436b8c3386aa655ac7a16c5e30b10aed6762ebed3643b410a816c783a8c2eabc9ba6a6a012ee522cd98d4ff3ec704d15623cba50636589a70d0a08aaa2e736efa9dd46bd59149f9f4328c4cb1880a16742e00f7bd5eb3ed10a1ae8873df2fdc2d307b8ca173cc761ed1d8894519157d56130d3a80b6aa0853d1cbb553a75140d3f9487ef41504d8e702e5d4998925dc6c98f8dac7da0aa2837017421fb4f7c93f6a96b59f81d7cb3040329d3211787aefb5f57606d8f26e5780457654ec25c815673abc4c9f6bb886acdfb7418bab2a1b84cb0d49da6cd62193412edc040e971918f8b195d616e78e872d8fe3b0a979bb3953ffa95b1b17f51f8c40df06e4d5458d5f24e7d5a75b4a5b05f307fb6c59abf19d3c400e3d1af1dfbfaefd8ec8ffdadecf8dc0961c9c944a65bbe20bebd3db249c6539c1c53989d4358d97a98d417213ee678d77b00533507450b90f6eb94a7eabc5756065b77cb67e646c6e400b34ddf41d2c29c823aa2cf2d73557e9534f1fb66b00b23113fe34bd558e67cbf0560b9bade92e9750e623a6648faa3cad57ad7ba38bc78453b4aa7a6264fd5655f78fd9069b21bbd5e4b7610579fb4241c3510177845832e08e96aaf627859315c57a62fd90d4c382d54ecf1c01baf5c899bcfb03cb37940431f7a726c921ca015c0a35a1f45b8710217c616fe07cd5eda3abaf63f3b937437dae28676b95a8470c464f17a1213371525d72eafccf5e3f0d16a12f383177482cc821389823d6738cd16968d730398d50840f9abc4c1b698af3202aa8acc8f9b9a8c174c780e7e7db74c16877a2b08ccb6dc4809da91fd7b2185cf34c6ee4e2b46ddd69ec443deb9981f63e18f8704da65b5fd22ca553a709d318f43b29702c7c71d30e9833b5d8bdd8c8bd17f0e405f44905aa505bc954ff2eee3da16f6932513f298781d9685a065dcc1214578a5f7e7a5e4d8e76081d53e9f308cc4cb28bde1d147751f00ef58acfd942fd02523b9ce0bdede9bcffc49fd08226de3d75bbe6d7c4c92a132201c9f2964830d8ce8d0501c8204f6cbe6b79bb06d05a11c83ff02b8c7b3fc81a8eae5bc64d004f2ba88c5fbe8f6b4ff6a88fe11deae4fec3df0a9ff31b517ee71064d0a824833f104ec547fa865c3b87b6a35af07b4ab7bc7cc8efa2f746315f5285085ce2417648322030f2a2c110f0a56299902640921dfcd94111e0a616c0c47464715515266fee918985ceb9c3b52f5a6d4d5cfd3b8645a73b940126324cdcf0f5512b06e5652e4ee0f537df64976455c3afffdba2add74db52abe2f05d72f20c0e375451cb1d910884323c08cc6d3957bb8628ec07635f731e271892d32fcc7bdc99664e97d31e88a21da158bbbef23f19ac1b279f18b77bca96276b056f8a3a3f960cef7e678e767011f5ce0a8ac3720c5d914eb7265c6618e826a0bfba3ef28aea31152fe3fd41c69b057219a31d2cc5b6c8132d1db41c9829a1f90489e1694db9f6eb7dbda307d66ac7a4fa7ab5b29ca443fc1b44fdd32b2333a5e30aae5468057452bc735940c52fa4abd0ac0cd0b8e7b618fc11609ffd2154d29ede3c0fc769e2c8e8fa157b0524f298cdc6def9d2f6f8218643c1da588c3ec234eed0bb3e4335a3f8da8d8450fcb73cd2dacf2a1c71c938927fa2abf85224c8fbc29342e1d386765d20a5ba2798db6afabc987caf53e3e0fa84cf96cc48eeaa23ad45d93e70be764d84afd75d6043937b7e9d501f8db966ab18afffb4c7c02b3f7b5166b0a3a310c92fe983f556193661d815abe5d2e452c1bbec9edd914bb5a66db0e2b82ea01a5d8728abc337a722bdb9dc9eaca030d111e44acef6bfb4eb301848c6acfd71cf033ae3ee30a575db098774e9a9c3d5dc291601143d4af79b9dcc6878b2255600eacae9c0816d451db111c93450492b829367339b0e0364cb2052af05a632351e6505d1267fee11463dd6d7da8f4e6b62748ca1fc705f8064f62eefed6736b34a51bfa4583fcf358bd98ee09ddf255b0c4176a6b982d5c9e6a97cccf2e508e68069e9f1bdfdc02c2d92269cd629f578e205a2e6493f27e91230054a635edcb23743c85693b715f6bbc4c5d80dcd682079ac7416eac109214d1222a88d1c465e89204ba4c26547d7b8522e050db3c3bc0d9401f36154b14c2ce7cac963b80552caa8d2bb8fa278a6d59a7aa38ab671c1733c3920dd3ff839e4a2cb987e642622f7a6d4a0d82a7fe691ce32fdd3bc2362b766586a62744d32a967fd47187d4f7893f6e8c23b98b3e3138b2d43c71ab80721a6b5d8d654fec7c516e6a398679833f2f001d84e4138a3695c8eb884099c7b2e8bdf705e5191725a70afae13f0c781a4d4c08688addb54a00aae87fa665973a3db27cf72217879d9f5c46fd63d202ce0edf0f30141cd1650e4c4abe7ff17edc265166d7b9a1f57be0090a7e0bcf230bb1e9549e145e518b14bd5886d592f42982d2f33c07db6bf9c4f50eee7b94dff79c69b55004de80352f07f0e9aaa4b1b2c4f30b67ee39e8408341446067bb6cab10749eb6d23e016f37c64281b4ebc307e3f635c2ae8bae107e98b3beb65bbf8431462a7439282605efdc7425d1477ccd47cca9c37c59e0c6bafc914886d36b27497e5e69574b39a63e988166da3d087f7103239064f0bda71ac505721fb72c44b6a683eb7949f91642c1db3fed738ffcbe1bb43a304fbe7d76a12261579a219acd24b874129fbead109d848f1c0048ca6a1895e0b4a6e399c561c8e2a5cf16268abf65ce3747528eaf5809da08a1da82eb4e00d6c841ef04df30eefe3d7a377ab9c32c581558a71be51426fa0d62c0888eb9086a69121764f6a9597e99da38f784868f1a6d540a2d04e2eace9c3c5a5d2ce8a16985991506fa905dbe962ab40c7bc293488e909bdf10909d2bd228eb320008ee9239c5ef11394e5de5a19b303abd41acff885a76afc6eea7371d20662c93040635b73c431dfb2f6fce8ac82ece9fbe4af606286bb2bc39220cd498ae2134098e111deda3630274a7502ecd4e83b18dac343d5f2fd16336bf4e8df5eddec6e278e2be98538990ad8cb1fdd8990dbc3dcfc7f0f5a75c0d5caa082ea5f0738819fe8cc284ac47f6c914e7e6893c26b61acde92e931d3185028af7680b584ae1ac65155d0fa9a0c5ebdadb7450cc90a6fdac7a0eb6d10832a2ab5bec3026f8f4b589fd4731ce380c3d6e54bcb78d5ea18a6cc0a5b424dff611c6b1ccb1f2fed695b573e93a92546911933bb6749a8a4c78bfd6405790092d0eeee24c4fee3c93b8526a835d1a400f028bf92cd041862e594521377938b07d80d2e08198fecb3f49dd60ece1d9ba31b2349e7f9ec872ac400ee9b4d59b40ed7886b23e086e223da5e3520b53bc7ac2d1a59211cb48c97b41a1ec8ad017057f54a4698e835a003af588c041e71413df80d5cb8abb5d776e20b1e867a3fed7aa8fbcee5dceab07827eec0c99630489529801685db369fdafa265e8264c9572edb5fed68eda717a640514e880016d3ae6b856b7b962dae668a669f80af2237d732eab9228bafad9e0bba9dd94f152ec3293480a76f8d48ab3e94874c591014a99430d8b4cf51872c0c5ab9c03b96637d5e5e946d4ba8913b02cf263106b36a18aae93def4dda4c6102d44e16b85ee2743be6fb7b39c308874fe6e86f1d541ddbfd535062e7954c1473935c997628ecb7b16ad984ba5151f6d52d028d92c0100c678dd9344c302d58721296c4e6f4c1c32d58841eef492722f2ef7e832dd39f9e3dee101f1bb75bfb23460f347470efac114e2f93c3df08a14ccd655304a796611b66481bc2aca4b98b05b5c8f47f77312023f0120d7d672592053023ebc85af4d2acd8d8dc909f665f0fae1d57616b2ab731489a7b9e857c7791fb06421c006b5b7094df91f41ef0c395d3ec4ab4275a55cfd30111ad381570941d3e6f28f55edc4c42193464734942e03a67eceafa09dbe282e8c1cef0d2ad1a1b13f6fcc9c7ac55bf4420a3fd54c930b8454406752005dc7f4953f8e65127584aa18c2410a172ee5a9d86986265322bac82a031579b19b00de5f85fb64e13f1ed7487413cf4be372650d89c4d85c2859564a174929215f3aa2c6c134c2f46c2a37d028d2fc2caf62ae2209fe7f46cfe62fc9b52eee92fe02532b2dd5c47b99c3d561d93dd3b7a266e2f2e56fdcc3a963f9ece0557b0b9a20ace78e5c8e758bbecb95f1a507e39b878074149c9adcd1e9b69af29a1e98c23e56771616f2f9d90f871ce22c2294fc77400bffe9935ec25b427861f41f655a8ca81af7a9f5f23cef18b12c3911b3cc916fe3c42279bf2e06afb94b0078ccc1dbba01d28c2f7a84d209eccdd2a1ccaf14d5a00db328afce6a25e3abf14aead22af67b02f71d461066d360c45d48f08c34a20a03712f358221f5da1375e8d71eb85637c8f81c80a02a1b52871d76109b48d9d3a82c513ac95d24119cb3b8042b429a4243574ba858d8d4eebece696b5ec8af62aa9c265390b04b4f95a20a0cd06c8781445c1c7df0c3e45bfbc5044650791e29f6f360c83ea59b5e111baff2841646387524afd5063ec6767ed73a9090c5891c7cb89da369a6e87f3627bfbcbe93ae6d99f68167a80cf2a0f9d24f13cf46746fe91831b5bbb3b2516fcddbc10e9cfe130ab349a229899fb51abf93f0f08995ebdbfa8132a6f07ce6a9df7123bb992b8ffb95fd75d2edb7ec82e4b919480b0b1a2276b8b0e8bb26b9fc819a3a575bc4d0b6e52ddd185cde6642d77b68ef118d65fd752188404717368a2578786ffd4ec88813fb5997fe2f5c2307acfe0383cf9998dbe0388c2f188f91a713d3458afe4c0b57e44ea029b87024b7372c88028e517d6f0730e47e4bbb5edecddf37c5fd0b2b777848181026f76405c81baf983ba0cdbeca2a7a7037ddf029973afa2ffdfb43a70aba7a2cb903946167eeb64ae458c42608a7f3d61204a7d732c80a485b43383691e190852e882bf43a0c09d588827082e7e244ff889625f8d432f90bcf0e25dd53662a6ed0c5c8a2b378236cf367fae1d96f1dfb778e6f82ee6e1973136debd3cd49f9412f6426c377f283a56bac9efc79b97f68527b0da51f3e3bde03ab0d75eb0835344be00af77ddd620430008098bacd653ff0eb37cd358d3fe69e4d4bbd249356e11f1af39c23c7941e2ba5f68b802338da2e03bc777be7bff04bd42af3ae885c469cc2972723fdc997ea9fc3ef8f665b1a94ee30d3d40c2668e5cccc72164d6e409e674c22c0d74dbc5e07ede6c2c40a669ca7d7521e3f0162775163f2cb9b8954d055ff5a19e4d72235e6fc543b53533fb5812b0885136eebb1af57f390b65f9ab05d640e2421f6abad4f88354c0745b93e432e971b2b16c31f8b9039ce096553dc306d723e31fb6ec28d2a6b91c9cfffcbf189b275eba62da4ed094d5694bf0d0ab54fe3da2ec29ae69c1250b126d123ec2a4dab564fcfc6a48d5127c751f5609236faac797dd7be5690723ad1a7c9969746600b36e370656291f07f8b6ec7e82cc01e58b2f55abd8282cd4e525df03770c637bc25f22db8a86ce43826c3982ff18789d458960c809041b8d0f0005021cef82fe8faee06bc8eb2c32ab46c102fc08bc192db409547bb5533eaa1a727085ebfd12297552da9ec3b51aa82e234daf14fd599e9361b110763de5b986d7ad3371df78e9657a6d07e03a47f1690e406da90e1d55091c665d5cfb7213a6874a9d7b360ccc6676d9021a223a6a9186725a3684263ca4b8ac1ad2bc9e63e20463f53bb21f4e5ef18e1dd4829dc5d4c74598eebbc8ffa2d2a24be390d7704c8dcf806d6671f9090da93929a13cc8ab83c579815f46a25754ddda45046375fe2b33a925f7db8183fd2998f75fc816088b0ef5961853acf329aecf4dbe5a8cb71f6f4e523e53c21d14cbfdb6c5cfd232858ccb1fce9512a7ada28498da69c38a6bd36c555fbb634fd30a07cbc0258bd4d34084304b9bb12b0eea02fe58b98e11a01fb125723dccfded8fa16bbb47d9c4a501bb2bf6190ffa7990bbe4ec742bef09ae2f3c0b19872b6a0eb6a1335650e9b5da207aa05dadc4287465acd47f452660fec1124f60ca58637fa59113e2811d9440dacd8e22552b06fed8f4b709e85d884cdb8947b3a364b36f7382f2f1546acc1307e465849bbfb0c79ab4c167cda0479dcc0c65e661968bb24b959f5519025bb2df6790da75afa562e8b3562fa7df68e5d1c390103d517f1927c2f751208280c9e3806e78891568d9142dffd848b2790ed8f8a687bc9fbd7b62631f083b16a94992993bf0fde74cb403d7133ca40771241f78276b8b983f1fcbbc7f1c43db32735fb59526fa3a311101e5af2a370adb45ce5335aae55c3a03d30d6699fe739434179460756bd8689c7f6ff409cc6896a5f249144e773d86f5b40db7b8255a90bd0e71b84ebdb054b6b4d474af67d98fa2a5447e70cf6119c028039b911a74790d13472f46ce10c1b9367d1bb4d53fad96354aa5a2290d570605576448d8a18ab28b379157e78568e5df1624296b40a85a3060ba26f2a6647577af4b6ce78f6e1061f1d27c71bdbda97f7b52167845ffe3e6a94c5e35466e6011b338f7b895db15a42deac8f451c3592d098957fdaffb2da19efe1fbfbecd3939708fde5fb6c80f463f3ee14ce2e0e46ced04fc2e642ae01a6b306dfdb52708eba5fd5b76cbd6e4185ef70e7626333512e3e90af6ddcd3d19ce8f41ce6a7c7733395e003c7a8a2f4b24655c76d4e65f6464311fcc871280b1954ae224d3e608833a3c369f4e906e2898c1d821ee11617757f38dec45d43f20196b516ebfe1a62a5a91cdfb6e2b393f4b11acda29d7ae134833611dd0a36fc5f7c04f65e9d033cea52f72fb7e2bae8e1ac95b76d37030ca331cfddf3e30dff97ba3a76bec6054cf936f0ea58be9b2ce211eb7a1cce22a0e01e580439eea3d4fedd7227fd9a4e40e6ea568d004fb15ff7a25bccf89aacf62214875e7b78ac0a7e72f4f901f26360cdb6492b7ea7e0aa5bf25f4c29ff4be3ba7da90ea317bbc663e17973f5991b0d88e6faedf64a68d5e9651bfced913bf2cec8437213561ee645ad961de99d990cd334c52c87f9a6c58b1d92073c583da45add2c618eae75e048506ef064898eb9094c670d3bd5ede72bf3a9c9ddcf3657b29089a884ddf00f4060555af2f49f3c9b2e86dc43b98ce248c73dd55d95e277b2f6ee90e9e55d879fa66caf09557b54f5aa8a6ca0fc673e611fcf1f2c09d8137d5c65a118786651b64d6d2241cfbd87cae3d06efcf2da716588bbe51ce925cb3ec0699cc2c0a664b649562e6d7f7f8cc72f8c0a59635d9c3c1ec7317489f19ae46e824be920f79a3ba72206492f83cd52484248aa3b8b45181a6f7e9c1fe2681655a9ca10df7f4615a3539db6e303e92be5820fb556e3b0fc23710114561f7a4ae8d98f37d0f77eed31204e3034b8720bc78dbc42aa19df3c2a9f5c05faaa9f1ebba24fd7dc8c39b18ba17263a79a13d4c6badf2d1491845adeaadc4b38de0b0e935230f7b5888be3df46abac27e9a7e80f45d5a56ab6b900c254de9c8aaaa8043cc58e9d82d9caefd8dcc3c36fdfb7872bfafd54d62f609cfe6863c5a012e96dcef1be44c2c44466ef7e4498fbce2ada5189cfad52418c32925c8825899811828979831fc9a86e278b646c426698b6659d2386f78aed625f67d0e60526964a6932bd26e7c96d0a9061bbea6be0cd087ffdfd507e3e437a7b1f62298d877ab9945933205094897369bd967b559f901a4f97482c1406a647ce6779e2b0bea8539fc3666378db6d636d75421bf943dfe8871fd33ccdf4b957268af368d2d3bc13484149119455c66c768b6d0c644b6c3c8e4284a3c8ec37525ad71cb88ff7866ead87f5409bae08cb9f30e6e146ae3fe643cc2ecce85f3234bb20533442cd58fd825b20cdeb57e83b5221819873f78398f9b745430b2a45d90840f92194fa6658860154f8530b231f56705db88ffaa0be0b90f4a91e468498427c8dc648c8cd833909dad9050967480c621ff5eae400a37eb4846c3c86752924474030f62daed4fba819f7923c6f2061461cca9eabfee60d7a726292bb86c42cc13c160b442385d94654666fb0e42433a4b6f9e6c8ddf9de702dfd13aa38b73c284f4253456c353552bb1ffa90dc3e4688a61950cd3a293a3c1c3f5acd8f280035f6805db28483debb2317110d08b93e02e47870eb148280c88f7ea26809977948563c65974753038387cde77555a911f77f8b557de6cb62556502d18e10f908938414d3453b97543c15867ff34466b1266eb70eb73c72edca287c2a56b6cbec0a94fba6796652a83f8f45b053a85d7e9cfce17a0cc8798beb001b7b703058e574a34f0c04a42d71fce9d0286d40cf0c54088f66748f0cecd469927e18f85a08fced345b1660c5e682ded1190a88f3d443001c4ebd81bc72da122b528f32fdbafe181124ba35ddc443220beb100d8a2d74b864497c7450f67f54c4568f8ebf1f54bbd1ff5ed32e2258f3d4bd979be19b96bc782664fe10029b3af540f47754f1fa5872c20abbfef120a572e4d79d4e41eddef2d1f934ff43c31a2ad4f43eba0f3d973cb7b9c54425c044037fe89fdc05789e200b208ba017bd07aa75957c48da2df909fb146a6488202b051df4163c958d55762b487ede5e64c5acff13f9e58ca5e3c0fc2ad696dbf0b55c5b0d6b1a7c7b080b4b7f7848cdca5df0f135c4d5292579fb31e5cf772550b802ba4eefa8af0f3c98ae398e758af6170d2938f3b2ee2c4c86e33d2575207a7d22893ed0ca09861580bc479a087378496d400ff55f6cbea7f3a4baffe450a1df4e0ca5263a42d38905f11f41279af8b3b78a053358dca93a1469d3990d4c25f9a30d79bff891d8c15e3bd236da5d6b327dfb0298fe30e7d1b66f3f6c3319e774c58c97a10ca957c808b1537b63b458a2a965eaa50368dd3fcf61d70a9bbe897426e78001d2a4ffcfce9ff90ea9c5140fa09cab55ab49ffbef57aaff6a9cc9ebeab43334c3d68dc935bee12c5e17c0ed5783210532b5500e03e1102fbb4756c3d44417f350e088e906d32dbf4e6f8352b28ab9b794b2d9d813e946541abe2433c5a33ffd3325728a8b2f384072fbfb7b8254d46e9ad2a1767a0db7d008ac82368c042a4353761c1c73ebac168c8b59add802b3eeb474880d31128dfe201dbf47255fef34f3830d0bd30ebdb1e325cc518a7ed36db71f68c4223affb4d597685eaf8fd78f7b85ef8714f68f449078b31dbcb508ce1714cd87661269c1b6921919f37a8cf22ee79609bcfb3647805b8f7ebe02549795c7542d1dc9d9114e6d93a0fedc6d220c61d41fa3d14d8702e31528877789ce37f7cad51feeed0144bb3c0756992404afe26cdd02185135a7a75747fcd31d08fcd4f281bdca98e4b9ff6806986761f053911d7aedf5db43bd438dfd21eb670f84801057f3f85628c52f9a5c8cd7a4a788ce7c18e3b524587735a44045db2e466f1093ba58b1c0c4181de1c29ccd9ca0c3f8ff98fbbdcd4f37dc6091ffdca4eba5b2ffd5ca8f249ce69c63d394527df2466e1858b1cc025e605617970d5f8d316334f445bcab0021c5501a1bb5320aaf6463dd7c4cdede5e96f40743da92ea76fa9ddd5b99605880e11fbcf29eefd3ddfbab0475f9d70061aa0ab46e5f69c2a693bab6caffe15ebdc18b0229cf72698fad4f4078cfc5dae62ee0b0518d66f022ea7d5d855732e9073c594659ad8f96fd489141ec78224925e0e9665c15577e7d13e01d711e0219da0187757bc75fdebf45a1e3afe6fb34875cfac47ef735c7436d1ff144412ca2d50b4a02b89133a279fb4b2b5eb9947e35166f0ac52697f43a8c066c14e89e8a9e8f4d7d15bcad67b502ceacd15d3e55869ca61e12ce935590d847d56d5b9e63b6d7867634c045e67500f30c9ea076b296656cdde3c80c8af3483dfd3d38383dc5f9b54856b94a7b5022b1bcc49846408c05a5d84edd2ba7a108ca172304c1f0f71d049a56d0629e29da8f3f386102e0bc1d683cf6dd1433405075ef8f67ca9e141c07d65d71e39373f17484a5174d3adf8a788576be4fd220bc4a2daf9ae6d64fdf6fd1b9d8c8e93f723333760f2d66fdadf4c8684a3fd30786f50f6f5aa9cdfa43360bfa6ef05082a0b7870ba1a7ec74fcc95eaaa1d32aa5bb47d12c765c558657dbee438ee07eefdb16b0f42536bb501f72793bcb5979d8f0392db4d1cdcdb3fc3f5a7a96ba2627df806a9d9f755fea960c906762015eab7bbf8d8c194d2167b798a81893482dcfc61eb77e3be767d663f046e39a3224b96e666449478aaccfcfe94495b7d13f552d716a1a60c636949153c0b7a5c7b742c1de3cef82324520adafff5d6e2ab19ff51a2bfe9d247e06e6a4e31cf18128a3282904178eef948aa1add01c02bbd6dd050ab37e5fd7429995531ea29c354a8267d34e41c746e041451a7a6c388c32111668ac922339634fe5cce96144e44f69e860eb171d573158228ba7b70ef69980dd4657d8874db849ce155b24b703fa792a94beee0b115647672896545ddbb87d5ef501667f8cad9d81c21a5db42d80c857e010e880579b005e3580d9127cd039d4c68a585f1081de0e6b7a846502eda3accdecd07dbf5ac4ad5ac5c0b60dbac2f18718a3e10d76c872dbdf1c68d32770bfd8e3a27525b1ef26adf9606efba44843ea1f77e86d28e70529044d097b8ba62e029215cdda1bf12426c8d1ec3b1a36cd6aaa9301263d4a50902f2915af6fcaea82d2196821d0891cf275a4cd0f8a0f5849bae79b88c78089785d9650508aac6a4fb68aba7e54da2f0c3408837f6edf96bf795e9f6b09fdf5564d2065e3d681dc14a8c991da48691776497ab67c9db527939d71243eb9d30c0af4748508e64ff5bef08a707b816d28f61d61ba6da18d2b2a44bf8f7c9ea542294d12f466f35c5c9808fbe12ea5dea0d96a87aa99a7f96faf10e1a7f6aebc859337e84e60f5a22084152a0c316dee70e08a3c75f4f498fb108417cabb664078420b0b035c47f43f3615588926b24a259eb92cc1e1976a96ae78e2d5839e8ea3e1b50d8ff358a3c5c48ed0d20a4fb7ecc3b1f127bcd6a28c1766fb2fb5b17c0b6013e9cac060f89b070a87740ada1a17238587061221be8694382190fe6c22c66ad6a50f18c6f6471ff7c7adb0c6aacd9712dcbbc9802940d52b604711fc900f9de4f379d74c24026f443ff93cb3eef52ba56a44609dfac19e6617d89d99afa978d96863aad2a43360e185e2f543e0437a24ba65ffeb9d84420b22ed90931ce9f6a98c163a9fb964059352b35ee8852628154ffa5b0ff67f55a153ec569f0ff4b5e28db3dd4eeab5ad01d8ef90395b6dbde2d7c1d88bf0bcf32f8dc9d29f273cc11f86f5252b88cb1f22e75b396923fa1455eb6764c8cee5401bd058828ae07907083ce2ce12369023874b7c0fa884b1a98cca5fd21f51ae0495497392f1c16e463b86c95e95ddcabe94783eab44d0316aea3706e484dedf55505218f74890e0ae2cd25510fcb168ffb9f4e8d0adf405e2db4a4f26fe722f6583716440d38bd75d7eedae27ca3fc15649df1b0c430c129863f99dc73618c2790447f58eafb666d24e304a94fd6fe6a142c59e023a1a87dc07dc13656795e0319b995747d2c7d82c5797cc4833cf5fa6e0335696010c572052367f41e67bc95e741efd5d8d6519e1a7d17fdb64b3014ea73a0687b70bf658700d8c9354b69b9a5b8b47cc8b8864df70e2d8ff5ac7541afda5a3715f66bad9d9c8c76300b4669be473481ac3ebcb5535c3aaf4de71cfca3ca32554f4c5c0b5d5cfdf3587f2899da26a38414d09db1b791356afe5a0d2a17dd415fb5899a178df01f42f27e27d8ed53d13dc35b1c95a44d084b2fcaa72b56d7fa38e758d51b6ab824f06b959bf5a0a41d5605e8ed2bd96e6ae2d94f3cee1b47e58ea5e1ed53c1acbb57f8ee1f9f81015811b8c8953be139f7dadafd285b4f0bc0cfe48aa6d08a0e6d7b7f494d92ff4a570e75c88b4a8770c0464f87b1eb04383e476da4dda711507a28e803f94e31bd7194e930cd04c4abd8ddda82757f1cb14d2b8cd110e0cfd3c754726372d45267085f5aa2ce93d2c5cd7e041568812423cd5a45c614b433e9a0ced83a7ff4a13ae659b5059a1cfd61c1f93403ec5e090cf4172cc0c35bd108c847374730d8d7afc9b3ee831b2dbf4d6315e5cbc1625478e15e4a4a5ad12b74f8bf3f8804a88435c052e2b60d1e394e707017a71232a07dc02ed1de16bc2a8823e935d3d19e92daadbd3208974555480173fdde0d229089f3bfde0fd29ef0b9c0242a64a3293cb9ab2ef451fb095bc114d5b4a05429a929ece416491d67a8d0052c492f7fe98a870e1706750ef79c089127d4cc073efa0635155d71b059b591204cb427b7bd04834bf79b47e5f94a9db590aa9b2ce07879695af19c2ec5fd238ec168580444c7a3b365a4d15adcc7e58b12b5269bd8d4833090016a48923d742fff59b92f134b788816c663080ae1e92c14e3883c069dd04acc983bbe0d94eee000246be390dcb33aa90716dd15aa9579c96c81466fc2e346b8af5b222f4e350afcf2c7e0544bdd5d2fb040e14091446a52a779b263701c22317386c261c8ea0e2c34ac927526652e0d3ff67966c77becfed0ecf3c36a7baa5f2b49921ae0daca15d48865d930cf07da7f673375516c2767fc23a6e4b4250391a72dd35989bcc419ab60ac168ff7ee94e3d2465fa33b111f27f3701e127c56482aaa83be3ae57e1d076e3ddc0f1710f529a7254cd6e83eb6623517f56c324d917c13f5b16a6070da7ee03d8d42428cbcd5b05ee3c6466e99f525d4f152241ca166649765bc5c95d35f21a54268483645b96b8dba3de05fe76c880e97ed3b359a7f9a7f06dcacad1872f2105a2860772be18c3e52179482670eb17d76303c5f05920d5b328c9a15c6dba1c349c22eca5678507c7fbf6c12b6ec02db5a6175e03b4f36bc8cd30aa49a8e690e1bcb48ea7cdc2bc20212368aa27960d9293d50eb808c48dab7c570e8d586f31a6340926cc03248869e7b48c1d5be8c7b0a764535cce146f3075bb63c0fd96bf640226df86a7d28799387de3a9fdd2d1e3fcd8462d923f3451b0039e8a7a53782656cb2ba2f8276b3faeb67c5a8348bbaf66278fcfa03908ba910b073aadac7010e51208e02033f1cf3bbbe99361e707e2cd9643a9365390fc1614c6b69f805f39fccbdfecef3b9b18c45ff5f2de7c6b732d18bef67132175f66bebe0af2340f1b5a07d9ef5ae36e70c9d1c884049ca7e71b70419127f551fc271b43258c2580e667bfa31fc281e78d722417f457e5faa5d3b7b2db9338331b6cb17662d0bb99fa166a3f419913dda0458d88381db265db93f6c5e63e940e37056f37fbc4ac2535c4c5c8d5f82c426aa3329cdca3c0cb9ff6aefa4af5ebd489c44a1669e5724498fe95d62799983a7d59eea951c5e2856b947d572e674d7382d21d7380c85e002a1b71de94010c1cf8a5991ef6b6703d48f0e7610b00d7c99e6ec4f3ff843a68c1dfcaea953cefc4a828fb2fdb9de7ff00e311f569114a6f9be2697e8b4fd6828d2a909835058f2971a4f16795db9201e0c43e813870f04759fa1aa1be5b56308edaf8877501c7162432c565eeb964c11d1ce6153d98818e0654dd69059a5fe4a242c215bf2d5fc90ad8ef1070999de6c5b839549f498bdfddc354cf32f2a111c7a07e16a9465c9453eda93d76708e2d5af6f79d91cccf3548a5d0f75e7b3dfa5b004df4aedffd41ef7063f3196f19063dadc851431006e04aa00c7bf2ae3f3f62cf040569759eb7d7932474b7153fddcd1a3b2dbc5ae13a2c5761103e9701d70f8b177b251bc208cb5d0ea457882c194074ae7ec4284d131938503e56f4593e3e2b2805a68dea523db372d83c79aec435ec8fc9eedc1089b03bd7d3068178c63418448268f8ce0da2b946c5a89cf63eb57d3ffb73a66bbcfb8fe0d51d18f1d21081c53f5b3157f5e4777366fdddfa8aa6bcc6ddc8b4af7d4fd17ed147522ba2e973ea60b06733ceb07abdf1a0c71c357881f769bd6d9f1a1b34baec974c6198cb9feb8b96d9422ee2929ba8c9ee81e4d741cfda122e97309d8a54c3bce9f4447e6b38b01d51a4afe371b1d1c24c458184ca888c16e225e7ecd9b4f68deb0efb50de06a74341cdb460baf6964ac21cc4069b2e6d097d4be5b5bdacf155bf8e31275c8a3a57076f31b2f265a8c3d2188448cb3a68acc472b65ce65447aed883730151e3fd04aec6e606f78945ccfd330055e27fa968b442a46a55a710056b9c9855365d8584d6c71b04f1d38ee9568b6da0b6c28d5dc1b59b80fdc95a174671dccb93179a9193aec12aebbd38eb4e1b5cedbf2cdce7006d978f0344127ab964cd18eaf76e992780c3072ca203c5ad0f7365d7581a37ea545e5c7cff9fe3069d07cf17289c00f22962b2c6d8ffca1ceace0eb4ac1f66a585b7663b11575affbab65aec0ea94bd050077ce20aa0ca59f9a05f7df241ddbda9ab24e2a1b8308da7429cdd9c489f673e0fc7664aae7d1275accee0a1c6ab9fe95d97348f98661d70cebd6452cc4d5691f13d3245206998939abdccfd9f791d7468115ccadf85e760c6edda980b96f1e0b48dab5b1942fc021d4537c75519c4c47db4feff287cad5171700541fbf031f65e1bf8c7e82986605a0c3df6254e37fb08fb4055510f57095e2b19597732d55f80a9f07550e7ae225adfcbc93139da2ce5d4f793b3de1b2bb78126efe8307e4fa27c36dc2736e15bba947d29f35e55dc2e3b19387cdbb92e6c0e1e064f360221f7fab0621051478ae6051566bc8e798c184956072043543af83baf527eb40efb52962e9c4c2f5d88684071cfbacb30ccf6c3d451823ed6e74d053d858e1ef77fc38fd0428767012b0477665f634a3e369ab052b59ee289abdf16684255d5a4617a3764eadb7fd119d0665d82c1a3cbf960c01e083c3625757547026a376dbb3168c67518afc9da559fc6dc7c58a6b98fb004b62784aae1157363a17b82216439a0340c82202da46348c1e9d312cdff26415d01669eedc89177fa67090f9b745fa631ff777afef9c48ab12dca8bca5b2ce5b3f924ee11c83122c3acb8acca2899273cd92ae8e3e77a583296bbe1178c0e7564b9593cccd5a89adb566ef0f79aaca6c96777e78cda66544c386fe7858ee2fa6003a1196882f3c23c0fc8813f08743dba384eda69da6c85f61854f6d4341f1f67e73e0316e113c377190d19915497a6035cb7bd08714e2f3983e3a002566bb5fecf89e5e43bcb26b16236ed50286899218e8cad12b5978a2902a5cfa4416f280b69808f2636145f5f176ef8996ce965c70536c28b00cf1913f47cde38e45ae4e90feeb05b7995be047abb26006644308ea98eaaee9122a5dba76da3e39f5cede73eeaa7ad215f61fc91e48287357d0594c3cc08c50c225ef3d4cdba86f9d95ad93e11b4b46e51d99b2f4595046a7377fc95a31135928a842cd7e19d7947dd7411f09fe427972354e1c01855bf0e0f64ad699e7fb6824b5f98952201bd68b706bf69a3a07d5c7ab5c35fe60813c91d518ba7fac58db1fd61a83b9932101509da15a4c413eb5135187d5a2ff24bef6268af1295c7c439b722978733f444ad6dca9f00a92336d21387f2e1e7cbc8b8a70cda9e0ac1bc59ada4b41b1b362c7020fd540e54362da3c94380ccccc219f5dfc80557278d3548a4990ce1942b0b86b1cf922e4cb2fb632e406b4345a184541670801f40951a2bcdaa5e4cf735f96f68d3870c8e957f9394625f0f2efac969dd1df9a0d9cba25f2ed51af751a1db4cbc31b869a85e9ba9d5374ae5d712d13354b324bfb9d8727a82a97d0dbc6ea6ea2c9c406d83a65a3c21afa2f8b3cf1976cc1977442b5657fdbb15a2e608f91685343a02256938dc03dacb08c6dfc631a7874e991c15fe143ab0f88852c82c9c4964458e13769209c71012cb5bac148d0d369596fcea5d2056756261127031ffd73f9dd55ddb6402fde1e9f4115cce4ef1c4b1301b89e980866d2e977166d5b5e1d6954485b4f0c8984daf8b02a856529a43d517fdbe994adb360f7f478ed211b6a325b821bc3157dd0076aba4978215c279495b3d2a2103de3dd88652037f48b0ad77c458c3f9087237754238d1a7b10d02d2094ef35a4c0a651cdcc2f0c0705208b0ec804242f2b7efd4f6a78506eeb2f2e23466dc51313f22c3207ed63defc064671657f28c64db0d80f2bade00c12fe677edc2de2b6afbf36b2bca30fc0c0a08d7db9e13b9d8bb85aa3202698c99c785344e3119cdd24169852c3d3310f3a6c0bd087567db778c8ab98e9ca0c36ca18e4a65ab32443274266ad1fc2b100588ea5d0a88cb158fdfcc0bed88963ddbf073cd3e6561810e7f32bca2a1725dbfeb858a5a8ba8cefaa8bcd75f90b643e308a3b632e2b8ea3547d3c556e83e38f043fa3b4a953d818dfbddfd2fc32050913e7310515fa78368733d69aba245f5adbf2243eadbb0f64783e87940bb824b04e89ca5296f1ce0a7db664858897bc2214ca0f77c69dfc72a60d84b1b545a0a5c4f6721413f80593dbd96fa740f700b15aa46aad59e98c4c563989ed2b3ee56fbe7c0d265ac24a552c5a35621f1d1f847a95102e04be053bb3e204420e9e91f378feb050f05c4a2572bc70876e6f2546b78e64304e61d810d09c16f5e7d464632c8830113ae2862a34bf106217ff2e8f6be7a223091733d1efadd6fca78bff80320daf9febb8504b19e25eeccf9b1ec07dd1b422cb98e6095a15151c487d9f168a15e6bd03c66854ddcd84516f98a4f90e32af10fdb601a5898d7c3a2d79e8ef1e4979b3dc06dfdfc5233e80c88986647ae052a29b334c11136b8e8fe09621f5272629e28f226cea5acf2d70b50fc16af2169ea3c782756722e9304ef6bf622afdca1c175738e30438c542a9306558e0d7cb05f74cf28ba94b608f3c5d6a07d4e8efe00b008a386e759c97a924badd00e5ce5430ab75b8e4593f92443783a94ac0e6462534928d25f8c5cfd5d238bedf2641cab0bc3f8381c5ad0c74f7c7daaff1543bb7adbb020d6c56b0e83ede501103263b05fac1bc40924bc50d8f9dd6dc2d1f46a2b68102bd1d5e7a5aa69c14ec984b31e400d75b40799c6af7562b3401186828838da26eccca1b34f60382324036fc43bbb6dbbc2736995cb4784d79436707828b74bd7761df3b86ca41e8b4ee7e976323ef6cf4c40f2db6026281509faaba4a2c9f83cee9b7a3302655935bfee71d93d2932824f86145ed84350953b12062c7a900676868a2db45d1171f95ac7e4406bb3de8a00d36bfe429437fa9dbbeb919061fe7d2540b9f9464b80ac9f8aee0337000cc240235d4f27a1f93d6ee88e14770e320f53cec6e09027ea8224c0ab9f85217348772c9ab3894738d112d877aa757a19b5fb9a4350340235f0ce710665a8cd5660d292f8bf22e21228b6a35797f0c54747efea0f3b847eeb4fe8356b2d9f17377fbc3c14d75a9d28ef2a0c262869d530596cc86b7ef7b4d82e8a942e3ca01498963ff8b0b781cd28a02dce55ed8479f2fdc6ff1bffc7a26e09a42d6edf5960b0e4d1c7a7a84a8d33196dcf00e3aa339e40490df8964661f13c8c7534455c753509a0a54713638e33dcbac0aa2a24a2deca384973d9cb325462f4e088166afef51b0d8a15b17b4b28948da0e683f9863c4b174f718214f3709451ad09e0a4594c2ceb5077bdc798be32f74fbf5cc14f25f24ec737a063d257376d4b6ecb91e553a65454a8ae931a79615a91be0f3ab33f88caffe61bc35084c8a321269518a7f7c02f272295e519a9bd7885357870c7de8bcf971e00351f1e1bd04f59fca4d286c4ebdf301fc1dfe64e822938e2a8962ad0faf77b0cdd4e7d037c41dee10efbda055e3e18feb6467be600ed909077b8761b9137474eadc13fd85dbe80aa4f5fd8968e3f9ae75a8bc2629b0d2107c15e7f78727c555073c1cec09ddbc53efc73521f67c3f010baedd4f10005c9bca7491ea00054e649138b4cccb3eb4237684c6f9ee98254ac40f455425a14fbf153d3fa57c314a8c469520179f57e4b7b3021b73d528a8ceb714904ed2d9c5c40b72066421ec38e63c7568fcd664d06d11243a50728e9f3d1693bec5d6e365c1fabc46fadcb489c2b30c05bfa9f250d97a8a83586e053f9d1d849372356d1e4f78bdd244e88a4808506b51292733316af042833c761903b4c97d792913acef69b64c8ae2179318a4cc99254ce8f1c6e20a4a2a4c57a5a97e57daf4bf7b40c81391ddc45e86a9b6ea8353d2d158e3285d304fddb2fd1c32f36849db5d9e46acb9c76ddfd03ac1a15070a94f1db9408afde701c8ebb6361f40802ff0d4c5de0f0b1b357807fcd3005b1c5aab3eacc4463f3f47fdf5aab637e5aa5df93c392c9d921f52e9bb764d2013749caa8b724c8dc2089d16427d04bec2c3afd3287ae17d6eca797e565ea545dcaba55e5b2c652ff76e2b28344889d66ee4283b04a7bf868f0df51edd766f8c2552c0498a7fca8e2b2d8c54cb08fe07cb6acfcab3f1487294a157098eb9e8392a4715689badb195e3aface460cbeebb2add32af844f8e5a20adea6f12b146dd0cfb99d05df818ecff54c11234b53e73d17801e0a7e60e08b91593e8553e1d9f696500f664f1d54d8c800389670846e5fbda48ae8b91930b34971b1152b361856f5e5664e2942f19de98ab9f7e2769caebe55e4673af3d3706a6cf1fbf4beec47d47a24a84b2acf654db91ac4c7838a18f0e425f2b1e0b9332f48fcc495be6fbe819f8b37bef3c5b79f40d390288d9b404434bb5032327483004b737b557200216824f77a61d7ac90fc8f2197c4e93181ec0f82497c328c8cf764b9e86531544692f42646f4199809cf88084b033552c94605eb2e46cd801f962c2cdd13ddb6ac425f3ada700f869a0cd66dfee3c0d8f3ec2c6c1f9fc5f4f60339c4e62da5f1bc4616b18d5d2644e18d87a8a26501abbc56c77df0e4561a7c0af09e3206025005fa9614be408e7bee3091dfc1a12a0742e3d248461fa2170f7ae05e93ef376da499b337009f0229e20b5999650b62321a7f90f6801c18c5504cc51026a520351ac03dc4874055820ba528e5bcd1832eeb5b029cfa546f4697c2a86a9105b136b46a80664ff839fdbbf4fe0935dc7633a17cfb26766a9decd80da3b93d130b2afcea5818eb1b352e2192e89c5d3c6cd86380a8089b565e1c8122a3f21f7127fae5ffa5750bf0fc0792d1f4f6d0d7e7b76c8f333ce04e6e89b058def8fcccafa385999e251e3e06a6a92c929fec3656ec2a894e81a2e955cade59af6f85cff9e372f4c0c1d0dbffa3dc32bde9cbd7e867cfa107d9e81bca3ba079bd6f2bb8138172ce2306fb027ad1b4e3679c5fa99f1a7e663e0ccac1e141330f70243a7959bdf3090ee9c13c1593fec56887c8323c9372eccb137082e596ef014bc48afb8018c14c7460da612e83ec0a539bd5b726405b0f107625c04190aeb72e66f5c491ba13c2e8aa93336797ad6045532052893982365596a26fb3bfa03ccc9ffd2a6c8807578ff60982b337d5e5a5a6b20b1023d4de18fcd720c59757b2a28c0420cd9ac8e643b6569208c25e66a7436f92bba40e73ccf0cfa6820b471e06f5c81a464fe2c95ce7cc3fc4710e07628972681bafdd6aa6089307eb8171bd7d717a34fc812e5a13d9ce31e15817c6d0a1e263d42ce4552974cb198e244de54230a81ef963ef7fbddd580b502eaeed69b2ad8fe51f8ac587e125b3df2a256a3ef39f850f241559d230aaaead545178da0bb1a5f3ee29da7f1a19598d537034be0b07303af4e288a77a30ad1521c26d4e62ec2caf8f8c1de9da124584a9e72e9d732e621127089e9b779bde8bc15447fc72995762dbbcbe8906212d3984d06f74ad8774ec76a338d3c5aae26aa675ec4197b09f39f2e0e5cbe7e559a1b8685bd2a3683576e899a4db58ee2acfa4f8c28e475f4abd202094cd14f39e60ca874ed9bca886d23056edec27b554015627249ed9c1f8ff78bd170874fad2a7b182ad5aef104fbf9662e9afea093882181304c70dad1cc0f39f1f26dc890d53d0510efdb7739c5e9e51207f968bf5c6fc0c8ae234cb54a1ed4aee23f50f748ebc723443ecb5a3ae72ffacfc3ce7391770d7042bd866296344dcbc44741daed85cb2953e7579d4a90f038fbdfa93b60fddb7f2dfee49fee2ae77072da407b1bdca6c4f2922676134909b477277bbed8121f99bb6bd88ca2b334386cb0582cd2275a20a46cbddc29c05926c17fa2eec4aae4ca947dc788b5654afabb9145e94a3ae0abf40ae8c85328c64c082bbddb137dbd7f381d32346af305bbb95a73941e7a8277179b055ecb986e7ef6057580d8ba25fad418024e43d104f1ddd306c19f767cd2ac4d18999f0bc178b714d4f7aeb94c6694586e2d121ab6b2740e93c4a75fe63d479b196e4f09a8e637707d59aeb3bd64d9f68b382f13882cdd45f34dce38a835254e711787353c6cabc2c4616093d2bc93f04962a81e9b9fc0653ff4fdc9078d301808e68f50e108bc09df74b552bb0559432ce0004192cc4924781959d0a8b664f04b5ea421dc8627865f67842b7f6de9cd4fb5dbc92c9ea158d464578b961e7c86af72f4f2b44476b681c88999fd863ecf09d9081ae7c5c07bb7e5f958b0591ac278d21cfe492e0458e5cc833cd08aac10c9c1b9cb78df49b98f41f21a2c239f4b30cefdc70b1cfd5f2a720d52a8916d08ffee37d6c823111f4f485868f1301f8f520c77f63e03fea5a0a45d593c256a7bec466d80117a9357eaadcea81d703393d6b0ddeabfc44f298b19689d7383ef6cd9b0195027bf4ec18bd1622d44a69498fdfd327f2300cb06015bf9625e43bba68f463a4391d28dcf4fe281bc9dc6c06c2fde1159c1ea01f2f0f8430eadc83b52cc6d3cd927d647cdc5b9ce017fb3a043630859981edbfa7176efae5702a8ab2d9ddc29415cf9cfc6e0aee9451c2bc495c5bbd6d1f49412eab7a49e2e4e9faf0a18d57969b158e1efed496d47e8adb3091e64727bd9c32367e2731d99e7c4f5c765ce8b6643924b3d70a57434f6106e2b5375e9362474aa47cdb0801c65e4d9c8f6e7b7cd23e08fa61ebaf07b5c5bae4399fb4a89d2166c61d560723f4b2c4c992f840694e3d5de3e3ac136f417abf07836cec50528be174ee138c7a809a782ec9c1febe7184da88b7a5936a4d59f677ebe1c269e5e174a4d484d7e85402b2ef4f3cc215882ed5210d86e807179b0b440abfbdc62b850f61300f6281ab87249683cf7f5906fffa2b698183732b7a6caecac12ba0e3b4f82c9e6a026ce2946adc592d29fcb9f4f28d0ad7f5e150eac603b91f2c3254519b12384987cf3a067f4b213ec1abb2fce12386fbfce05f9f915b885b5bd3fb267541c23b7a4eb4f9c289d32a46f48a6b19f2246dfa690ab607746a32dd9c23e649db91e5de3eb19a9ba2f9b129b0043ca5028752db56de9d6e4366600ecef0a60714651cd9aea194af0840fc33b562887ff566e949dda1316c1ded988000f2d9fdaba734250323f4eb43521de37f49a92176dc22e025774a69dca46cab3d359e2f22c02eb41cb6de5b0080dc75233a795c3acab08330ad332ba2d54e4e0ec56921b336fc3246278b1ac68391277f025f7723992821c68b886165c1426a346bf627f3b387bbde2e4f692fbe6cddce959df0fc299e5de6770f094db0448e1fcd7e9be4ca595cab83ac5ad768ee7c96c220ae7f7b67ce95cfc67a0e7334a94c940e06ad6d93f257a6fa66850917f2d352dca4b74e41399b8b52d423ed46366e09419685a2b45fb9650ee9f05e06e6a4ff5bf19862b31981e9dbec9439f7a7b6a970b7820a520e2ae4b0c0d1aecf2198a637bfb771f05d1c94ed527fc0e45663aec5121a4a3c848c14aabdd24f8bd434d18fb1b2fd55c82cbb3e4b7d0df4e711c7b4005d57a45e254f94b97f9b7f59ee9796cac07b364c84d923b80be6ec8d0a34a1a0dd842ba4f4bdfbd67ad2524c59d7cc3ca5d1c37fc0f306b4c6e36ac9a5a0a5bf14777769b316147bd1da4170066820afe27105e1e2074a340257a970e9be6df752de4b1a96e6e7c91cdfab2dd7b5e0cb87bc147f80425b156382ddd2a35c89b9c500d5558cda3774b69753a4c8b7794a4f0cf6df68790de5b10082a17f136a7021507d755731573780b54e242ec6bf2646888bed36c718d6b2a4d2020522a6952f9c11d5909422cad56eb8b6bb1caf89084dd97326489344288b51e51acaa6f7f5c07682334c103e99d8a08e8da725a568b6cc50cc92a8d443f8c65ce82c6047bd74d89537c41464e9c5b053a44be1a372621ccac67c093fcf7a03f2237ec819111aa0cdcd7157308e1a209915214e8b018b40af23ea2efeecdf73e879cf669795ceb36ac73059fa6f18ea596f4fc3b9ad93704cf9e6ac90da4c6ec71e664adae02d502b281e8e095796148a02f77478a9b66c36d73e7752c0cc75c6b6ff1b9ddb1b794fc969eb74ed8aaf227631495ed3f9896f9211150b432a73da17ac766f19255554ddbceddbe312dddbb0076d61fd6527f5515c94690bc10a00b7ef1c2f4f86b4c9526174cdd4f493877af277dae54dcc197d8aca5429bf181cf9ae373369a8fc16f435b8aceafaca879609101ff89b9f169dde4b616472d17b7725f60272d139022881620de8f2623c0b7090f4bb2d2dd31dd800a886fd5d7ff2262a15dc5dae71358854827ca30d31fd8443797910cf4378bd97a102114ac0e9f5cdaf75fb0e71a0ef6a7b1a0437e9fdd6704f144c66dabf094014a723767bf61567673e7a1707b788675f1a0fd585ebedde5186e4477b3e5f488c6b84ccea9d5bc7338edc4cbe78fa6f59dfa33876a923338eebd92b38ea9c2972cf18f634f2efda4a9277a99cafe6945cd2592b94f4f5d8c0c91a09621f8ddba88e42839b41f800a8faf22fc2bfc29d7506cde8a517e75ae2dbb170b368024de9620424ea6a67849330829c97f2ddebc0df4becd27e10237761e3687288b101f9c27583821de1a594f9af242cea8b973f170d4a4facedb159cfea5026584a31292d8c4375630c6b3329d1f40a7ec4cfc4b9cb133c84f59055ac32a3751efab370fc1bf552731e93c86f6ae713c54429afaf7ee3ad7d068b51c63be3a74f8f7117e6ba686a59664a111a5ceb2a1708354297ac44dcc9111d7fc4233c02a2aa4e98993e77db022589f74ae7223c4ed85b5336c7936f1d510799b60de287a3ec0488a0070717d86131a1218dc910c4b1d4ad06ead061f7783c99d86de49498c8c8296c9822fd80e85858d8c315d330d82de11e90b9fda9f0de8360d0fb39a16e56443dfeff781585d8a72d895a154d8b364b43bbd7e1b5deec3abcb732618c263405b5707a0e6b451c7b64f9b1147b5461f7a800bd2d617fce234bb2e19ccd8e017216ab64bfe4d9eb967343eeb5c9ab79111ce0592a28ca76ba182b614763160850d518f49ea2b9b2b84fa760205471289ddaec5bc9c3e257ff097b8f4b093d5805ebb0aa0a79980449f8576a229d77f95b7d8d29c7c9122ea03b59bf49bfe979daf20dddd345f4f176d45fdf3b4d59ada81131854343a733c517d21973090a80b0b3e175477d6ec769dbdba36db5a9719de0613fc135d8006d0cb2b372273a28a68665b6a5f30f3c8442a2a8405223a87fc746ab7b5b588c8eb3ccf25a0681527a1d5acb93113b6c74ac55fd76659cf885d5b8c4c55b47fc64a667e796ff7410ff8167672cbf164b149cedf7307574ab7cb6dd3a219e46b57dc0080ad1db90182ebddf9f04ecb739e36ec9f5893629b60407541c995acc9ba8899845a771a85b96a8f64fb10a66fdc4362e27bc63ae1460b8badfd7433fc494b852df5a8543ccda8efd4c8781033f2270edead05aa0320b564a02312415fce79a95b84b298248e122dcdc0e97195fa33ab5bd063dddcda0f0a2cb69f68ff85a0dad9510b42816dfe81e7461e0c313325e87f5bd0bf17bf932e1580d08d97e93cc2002fea7e04155ed31470de1dd7c173e2e8b0d1a478e7515311014580772db0e9a7266446129141bdaf84688069f20d28b8bb5734af4f059e5008859299f80b49f6dcc895e43d12a4bc4caa6e90f8dc45573a4013b1a4ae5cdd5cd24acf66c13bab3d63524b74ac46c229551a9a2fe288234f5fe73155c1dde741433c8d05cdc79ada84d4b2e3b4e9d2bb21bebe347f7880ad303c2ea17c8226769130374252579b869056e6b6de3d4e061423e87168ba7a693defb731e5db41ad305c02080ec6eeab047e700e3627162fea1da3e88cf7e2d3a0239fa643a026ac38b254fddda74b5839d4e2e40559950b657b5af55b705f3ba75d71ed39bab35074afa3c2b88f248495873f4d69bba942767de0d2a539605b7f337b90e94e319aff97f08b940889f5212804b63038fd7f1c41ecbfd418903599eb9ba5303650040838f14589de09ff286b217f9850f0afbfea2082f77b5e188cbb715356b20ef400a98962b69bc987c6d10e31996985ab5cfa330aafad52fb0409cb05ab5b6bb2529c036d9ca04bd65d1bc418995db8bd828530fc54d31b3c8155f84aedc1661badea1eef721f873890ca703b914abf98203f727f69b0db7b879bf972833a577d4c8b61aed7f107d48b1b7207412734800634709ff16393f8ae250c174ce022442fa03d45cd9a82dcc7d7d8994d26f86ac37e87d026f6bd4a3f30931378eca38da90254271b981e589788292be5f6b4cdf660d3dc4dda509a069639a4c5df2c9ecadb2c18824e719491ceeece17e248a8aad74b56e05bd8f333055db5696908c095f620457d597c24c57634654741c426c63df90cf8014107ee5263a0aca6e5678d1c90fbd9e2169da5c37879c6c770cdb6f125861046d37c720e38d614ffe5ef3cedc170b6b9e5f811c7a92da5052e045598e140f8d9a8ecd48236c5e4d493b98118ff87d3e5808182a118d7ac5f172ad479da736abe591acad9a16afb8c6debf549c8d01ed9e8c51ae9bea57d6e160945d00d074e1a23ff9d37139469e5de76e64841ce618c8484ce3d30f6c0b1e8496c28376ea442f64e3383b3667355a710c290f5eda9bb8054127b5d022dad28a6bbad530b3c99b0c8d9ccd1331ef19801435743fe98f787098a8891ac23c3fe717ce8d8adb157ae777425ed9b574a3da5f4f8514acfffcf5a0386fd0d316fa584747beb91bdda2646d91f9f257404fc296d949173edd7acbc5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数学原理</title>
    <link href="/2024/05/12/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    <url>/2024/05/12/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h1><h2 id="大数定理"><a href="#大数定理" class="headerlink" title="大数定理"></a>大数定理</h2><p>大数定理是概率论和统计学中的一个基本概念，它描述了当样本数量足够大时，样本均值会趋近于总体均值的性质。大数定理有两个主要的形式：</p><ol><li><p><strong>切比雪夫大数定理</strong>：如果随机变量的序列 (X_1, X_2, …, X_n) 具有相同的期望 (E(X_i) &#x3D; \mu) 和有限的方差 (Var(X_i) &#x3D; \sigma^2)，那么样本均值 (\overline{X} &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^{n} X_i) 会以概率 1 收敛到 (\mu)，即随着 (n) 的增加，样本均值的分布越来越集中于 (\mu)。</p></li><li><p><strong>伯努利大数定理</strong>：特别地，当每个 (X_i) 都是独立同分布的伯努利试验（即只有两种可能的结果，成功和失败，且每次试验成功的概率为 (p)），则样本均值 (\overline{X}) 收敛到 (E(X_i) &#x3D; p)。</p></li></ol><p>大数定理在统计推断、机器学习、金融风险评估等领域都有广泛的应用。它为从样本推断总体提供了理论基础，尤其是在估计总体参数时。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git操作</title>
    <link href="/2024/05/09/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/git%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/05/09/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h1><ol><li>git clone</li></ol><blockquote><p>克隆仓库 <code>git clone https://github.com/cs-lb/lnnu_medicine_order.git</code><br>2. git checkout -b {分支名称}</p></blockquote><blockquote><p>在本地创建一个分支</p></blockquote><ol start="3"><li><p>在本地分支修改代码</p></li><li><p>提交本地修改，在远程仓库创建同名分支，并推送过去</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git add .<br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span><br>git merge <span class="hljs-keyword">master</span><br><span class="hljs-title">git</span> push -u origin &#123;分支名称&#125;<br></code></pre></td></tr></table></figure></li><li><p>在远程仓库对应项目中请求合并<br>GitHub操作流程：进入Pull requests选项卡页面，找到New pull request按钮，填写相关信息，点击Create pull request按钮。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>语义分割</title>
    <link href="/2024/05/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    <url>/2024/05/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h1><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><p>平均交并比 (Mean Intersection over Union, <strong>MIoU</strong> )：计算每一类的IoU，然后求平均值，是语义分割问题中常用的评价指标</p><p><img src="/../../img/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>国家级大创</title>
    <link href="/2024/05/03/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%9B%BD%E5%AE%B6%E7%BA%A7%E5%A4%A7%E5%88%9B/"/>
    <url>/2024/05/03/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%9B%BD%E5%AE%B6%E7%BA%A7%E5%A4%A7%E5%88%9B/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5d31177e4b8c5b2bac801c8a10ef0c5d64c90459889cca16a252d69fcbddf257">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df0f2e145d0299816675f1a838ab97e492131b8d6268943df49588620c0f569569f59ed0203bf291ecc36cc39fa657242a608f98976db5734550c54c32c21c75539f97a0817f52aefd1dc0350ae53b8c0bfc142f6d2dfea8c205257dac2b530a45bf6e1e7c7626d10c141d28677e57649d3056ab3425fa7b5dcc335a9877ac563f46bea071e8724b609bd85fd0cfa52bfc3255d9fe1abf8d6ae625b5633e4c2d5e6c18acad0d2b4b0380b24f7046c5fa04b778b36bb45e0cce20841bb36972f3e1be59aed0a4cc5300edb72689253287d71f2a2f8ecd641df716c06f6df53fc2903023271d9d025c73893aec78fc315e5fb72a2fe7e2eef9568492b891a1f9463100788deb19d035b3e162c023d704bb5f688eb97f0c92578e39c89f2286d9239bfd91580281355237c6a06dfc3dd52527c26e5b53f28c246a6e7f9ccc05d704797c77ab3f11e1867bdc8e961ed086df246009054eb08dd124b3598adbba3f7518ed8b6a429f22d37f440fd531b08c53c7c858a8f43fb614ddcdddde7e786c1d216082bfe7fb3eb8e22d3f753e1bd0ff7f987ea4042f5d1f8232e4099ff19a8e8f76aa644bccb6312af2496fd67d2359887fefe5dce34d750f32882a265704e9ba6dcb9c2bf87e3d7f6c6a2d8495a4eef180ca01f1e2a1374a839a572903392805a94f31f5c07c86de5953feff6a177099253676ce9301ad548aa23b983c0bbcd66cad0032208698403e467167f0ab0905c1e77e5c9f5ea4d36d242f9f6bb4588255228ff4dae2bbf62cfe0a3ed31aeac3e33d21bb609afe220b3d13a52f59edc4d78a6c7c837e22a5456e2c013062a02fd13a6e109b42655abaa3a17c4521770a53dabcfecbca6c0f92c75b6b35e50e330675a793637753729d563867ce0f1502ea123e4bac5389c72ce894555c72769ed4234118303f791f055470724745a1db8ea433198d694ca94fd42349af075d8d2de251d51af2f90ff71cc9a9d54e32a8c3c4e1b31f9cf388964b42fe9364acf3c7a34b57b7c5ad246d14cf3f70b1bfea92fee6430456f6b437be10d68eeb5537d15a06b56078bea94fae3c93cb52530b8918dbfd3299bce3f153e453266bbdd6fad9b0f073c30cfc62e792b73fbebd93aa5f1e44dcd8937fcdd721dba62e01d0a3973df68524deb61d06e19579d399686d885b0a3bcb9973fafd528347d4c87b6eaa223a5a57ec7229e7f9bb36c43f4004e6779e1a7b3ef4e95e18eac0f8415d3d56484dabcc8444066ce60d8bc1ab995b77c01f43d7df5f6ee2665329844914039b17872fb0c6659dfb10997c555a3747ce0c84dbfc3283faada7273ed456c4756faba0178326da9059225bfbaa15fc54d5b03e955f1c1aada88dab14a802756806262b4cd4d514b01cf8c38048890ae618f75e1ff36681b86ba8c9dd621be8af0d80c30a63b64152ebb7c45a907d9984c4ee22fc1be2e7a17fb8720db8ff21b66ca9112f1d5896975c917954e2ace9bda28bf88371088e81d00d263af4d7c757d463cfd15f215bacb9a24c0c1c930b24a466a4844502859902a46cad31a0ed40a56647bae5cb41dbf4d9f33289086f6ef9a63f117ec8f7cd3846ee1fe4f04b9863049f77fa50f84af678d2b24f45bc87cc9f1f6088f1d4edfcfd10b32382f9bd0895b07be3e4663a0167225983eaad35ed5c193a6356557d50b371a77153639cae2bec8639d387dfba66fb9779e83e8409447168403c07cf63dda04022f6cdc42e1eee8c6fe5edb12c4ba65f5729b3e17a9f309d71f79e8f16b5284ec7902b1320db1e915221ee7dd266e99fcd3282bf9d695895586c0d431d6d12816c7a4934050ef57905f7e6e4899cf47adedeab7c0253ecd18ffb1111af53c3e1fbf64a61183e5bfa3d1376c46ffd2d9ec4f25b75e8d93050477f9cf180372dae0bcc52c0bfadcd1b736630359b37b9d671a5017b9970efcb482e8ea852275fcdad52e12363685e09d52d12b2f23dab4e15716010311f4299225e51e84c04c9d7a2c05877b94d4a12f0695cf9d031819f55324f0b31d04bfe270b84bd7e26c27a9d839f3893ec0348c22434b057e8eb3ff80fe845df21c76d52d85a3c315b16b6e1fad6fda194aa304e0dba802b0f570619dd0fd9b21ff205d417bfd5c58727d3913f7898a8b6cdf832d28dcf858fd7cf25d059d7a781df1b17be9eb59bf829bdc15981def101ea8ce108590cfc9212ad463ba08948c519bce6ec3be0aa6346eaa5227c897df7bf886e753b7e3da4f4fb914bc8e71ce4569e966d0d9b593b23e3b2f2a37796910880ecc42edf2ca8a0da6a647fde2655dc9d2655740d9a6578e00dce67faae4b66ea80ba3f5d06be38b1856e18fa08fa539aac10f357fe2960fa87f84c226dd52c757b3880b59046928485dc2c6b0a016ff9eded68ec89e8c359cc8c67b45b46ffd1aebc95d0c8d3533dab8adeaeeee07317d1b3db096853314be05ff866fb1f9d82858d5c85fe44fff7c577f75f02eeacebe4b6a5a218d44bb4cf9b7cd305270b891eb8350fb89fa9d7173fc19836676701cf4d7c4256efa4edd43887e5775dbbba9836e0218b02d47741668405fffcd9c0b23061a4a3fbec88b78e288d4f85999840c7017399b8c86a67a3f95e493c8eb3559e70d393b749490c096a19b99d2b495801945dde63738fac21fe471eb4f2ac5cd368a18a6c44262cd2fb04f46134db658e1d035dd94ff19564f22a64cc6756f6575f3dc9a7f02bd85e079c3690d026c5a0102f3f143df450cc56d3f56ae4b6e5faffab3e03aae57351620eb45d94f78dcac4b0a0c972051e244a5e0a16416378737d8218b4b10034861b3798b790a42e05001ef5e4f26b2abcabc2d3b5aa901e4d94537bdfcce9419d2e6387e6a0a7d6b2605b9d13411eda311776df7ba5a8a9a12b96d50b1a8baf799970af0013db513a1b6d50253ddd8c85fbe5d94530040c84fb176f8e0a8690775044a9ab458222d909c4db18147a101a7d6cdcddd061f5cdc6fac5297356e6dbd81960e8b7f20abb426dee83c9e8d81dc7382d243f43791d4a843e0d6e8a51af80257b44ab268f01b115cfda7b2ce5a0ca2125afab2edfbce920030490140474daeea29d4c7dbff65d792136fe8b8a9706a3007692d1abd575afc1bea52e39c26e2330c8d8589222928eb5c373c1c0dd57bfa87cf5073c68411c9106b533d456fee19b5da19ebe3d5cf4f410eece1007b86aa717170c3032e2c0e55542119b8bacfc899decbcd2512e67a8cd5c6460d746295de5437d5723e5eed1f30fab4a63105e79aa3a7c0ecb33e09067c2b0b4566be680200f527acd1139337861eacfb6723a3fa861725f907a3e39e6c136edbcdf8f3de80bc99626ecd475482ae88cf3e236c5013ed110e6e7b35ec17b17b0643e36e21b6b1711ebd9d1844fc01404b7bce572d3d7fb0e321679fafb31db6b0299c4492068d787e77fe27e48618005f87b5909cd6ae073a9bc2eb3198567249595e133888f7866aff2c9356ea69662e6c94caa4dcec73e0d910d7d71baba8e2519df56450aab17411896a18151cb9b9dd4a96552f93037b8ea5829939f88058bffe479a45ee349c6e16c047f90308ac45d29bfcca396da0a23f4a29a82d7c15130a1db60c91e7bb2c1927bcb922faae368b323b63f85bf6976f64473a2e044c64121f7ec936bc7749b4168dd790d03e9c44a6142b9676b9edf58caf188abf7ed22b192e516fb1e33121185262ff05aadaa6c3399b0d278d7f7b5f2d76ed47be8d974e08c554d3cbfc1132d25c4003b1721248c8c687a0d20ef15ec8a2c9bab8590ac29d6a03e9c810c47c64a657583d7396a85f3afdfb4453fc4e0f9a5b3e8fcff0bf14ebb05f8e95927a2b3aa2935fcd9f54ebe59754961d2c9c5da7fc33b3d5c70c7a6de0f652bc0e5a295d6f9c60c7fd01e29dfb4155d38cf82e3a51f55c51c78789d1adb9839487f82cfed22799f1d75ef2afc158b0c2722f02f3b63785062efc4e54774bc11412e96c1a28151a9b35904e1fe18fc89c1ae8c616e6954933aa60ba7a9f2fef3eda8cc7a5a35b3c0a21c234754ad22de4bd750bb0226f4f600ac634a72bd9e31e8e400452cecb9feb6d3284bd0bc06e74c11b970463793dfad816fb1d8a195c3051e0631738712116b5a74983ea5963d308f6a83fe5411c1cc529922a4f17269b230111ab39155695cfb88e10b7d4aec6dfad920cabc6ab9fea2af23505573f3a15faf4c6b0853de6c34918623d74168ae435e50e5074d558500ffe35c92c659e44aeaed51b12b5e4938d10b641d8cd9a51dea5ef1de9fece950c090519bbcbf582062d83afb8a524180644fb322331e4a4b6d44498c382bd159e3a911ed261f20a2ad040cf8fc2baeeb1da9832bb00caf35e7f3aba8348abe1dd2cc41f627781011d35794a498d97a81d793390a3428f26256261c34a4f698</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swin-transformer</title>
    <link href="/2024/04/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Swin-transformer/"/>
    <url>/2024/04/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Swin-transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Swin-transformer"><a href="#Swin-transformer" class="headerlink" title="Swin-transformer"></a>Swin-transformer</h1><h3 id="mask-作用"><a href="#mask-作用" class="headerlink" title="mask 作用"></a>mask 作用</h3><p>swin采用了滑动窗口的机制</p><p>好处是之间被分割的小窗口只能在窗口内部通信，大窗口滑动后能够使得曾经不能在一起通信的图像像素现在能互相计算了。</p><p>大窗口滑动后，将被移出去的图像又对称性得移动到大窗口中来。此时为了限制原始图像时不是挨着的窗口 就算移动后现在挨着了也不能相互通信，因此采用mask方式来限制（即给想要丢弃的部分赋值为无穷或者-100，使得其softmax之后为0）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>注意力机制</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><p>注意力机制相关介绍链接</p><p><a href="https://blog.csdn.net/qq_52785473/article/details/125804579">深度学习中一些注意力机制的介绍以及pytorch代码实现</a></p><h2 id="注意力机制的种类"><a href="#注意力机制的种类" class="headerlink" title="注意力机制的种类"></a>注意力机制的种类</h2><ol><li><p>聚焦式注意力和显著性注意力</p><ul><li>聚焦式注意力：</li><li>显著性注意力：</li></ul></li><li><p>通道注意力（Channel Attention），空间注意力（Spatial Attention），分支注意力（Branch Attention），自注意力（Self Attention）和交叉注意力（Cross Attention）</p></li><li><p>软注意力和硬注意力<br><strong>软性注意力机制</strong> 可以理解为表示的是所有输入向量在注意力分布下的期望<br>而硬性注意力关注某一个输入向量。</p></li></ol><p>硬注意力实现：选取最高概率的一个输入向量</p><p><strong>硬注意力缺点：</strong> 最终的损失函数与注意力分布之间的函数关系<strong>不可导</strong>，不能反向传播来训练，需要使用强化学习训练。</p><h2 id="注意力机制的计算"><a href="#注意力机制的计算" class="headerlink" title="注意力机制的计算"></a>注意力机制的计算</h2><p><strong>注意力机制的计算</strong>可以分为两步：<br>一是在所有输入信息上计算注意力分布<br>二是根据注意力分布来计算输入信息的加权平均</p><p>卷据、池化、全连接都是只考虑不随意线索<br>而注意力机制考虑随意线索。</p><ul><li>随意线索被称为查询（query）</li><li>每个输入是一个值（value）和不随意线索（key）的对</li><li>通过<strong>注意力池化层（最大汇聚）</strong> 来有偏向性得选择某些输入</li></ul><p>注意力就是从一堆线索中根据指定的规则挑选出需要的线索。类似于池化层去降维的感觉，可以节省计算资源。将注意力集中到有用的信息上，不要在噪声中花费时间</p><p><img src="/../../img/attention%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><ol><li>根据 queay 和 key 计算两者的相似性或者相关性</li><li>对1的原始分数进行 softmax 归一化处理</li><li>根据权重系数对 value 进行加权求和</li></ol><p>$$<br>f(q) &#x3D; \alpha(q,k_1)v_1 + \alpha(q,k_2)v_2 + \alpha(q,k_3)v_3 &#x3D; \sum_{i&#x3D;1}^3\alpha(q,k_i)v_i<br>$$</p><p>$\alpha(q,k_i) &#x3D; softmax(a(q,k_i))$<br>注意力权重 &#x3D; softmax(注意力分数)</p><p>注意力分数可以通过以下几种模型计算出来<br><img src="/../../img/%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%88%86%E6%95%B0.png"></p><p>vit中的自注意力机机制采用的就是缩放点积注意力模型</p><p><img src="/../../img/attention%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.png"></p><h2 id="vision-transformer中Attention是怎么计算的"><a href="#vision-transformer中Attention是怎么计算的" class="headerlink" title="vision transformer中Attention是怎么计算的"></a>vision transformer中Attention是怎么计算的</h2><p>Vision Transformer (ViT) 是一种将 Transformer 架构应用于图像分类任务的模型。Transformer 架构最初是为自然语言处理任务设计的，它的核心是自注意力（Self-Attention）机制，ViT 将这一机制扩展到了视觉领域。</p><p>在 Vision Transformer 中，图像首先被划分为多个小块（称为 Patch），然后这些小块被线性投影到一个固定维度的嵌入空间中。随后，这些嵌入被送入 Transformer 模型中进行处理。</p><p>Attention 机制的计算可以概括为以下几个步骤：</p><ol><li><p><strong>查询（Query）、键（Key）、值（Value）的计算</strong>：</p><ul><li>对于输入的每个 Patch 嵌入，模型会分别计算其对应的查询（Q）、键（K）和值（V）。这通常通过三个不同的线性层实现。</li></ul></li><li><p><strong>注意力分数的计算</strong>：</p><ul><li>使用查询（Q）和键（K）计算注意力分数。具体来说，对于每个查询，模型会计算它与所有键的相似度，这通常通过点积（dot product）来实现：<br>[ \text{Attention Score} &#x3D; \frac{Q \cdot K^T}{\sqrt{d_k}} ]<br>其中，( Q ) 和 ( K ) 分别是查询和键的矩阵，( K^T ) 是 ( K ) 的转置，( d_k ) 是键的维度，分母中的 ( \sqrt{d_k} ) 是为了稳定训练过程中的梯度。</li></ul></li><li><p><strong>Softmax 归一化</strong>：</p><ul><li>计算得到的注意力分数通过 Softmax 函数进行归一化，使得所有分数的和为 1，这样可以得到每个查询对于每个值的注意力权重：<br>[ \text{Attention Weights} &#x3D; \text{Softmax}(\text{Attention Score}) ]</li></ul></li><li><p><strong>加权值（Value）的计算</strong>：</p><ul><li>使用归一化的注意力权重对值（V）进行加权求和，得到最终的输出：<br>[ \text{Output} &#x3D; \sum (\text{Attention Weights} \cdot V) ]</li></ul></li><li><p><strong>多头注意力（Multi-Head Attention）</strong>：</p><ul><li>在 Transformer 中，通常会使用多头注意力机制，即上述过程会被复制多次（头数），每个头学习到的是输入的不同表示。最后，所有头的输出会被合并起来，通常是通过拼接（concatenation）和再次线性变换来实现。</li></ul></li><li><p><strong>位置编码（Positional Encoding）</strong>：</p><ul><li>由于 Transformer 架构本身不具备捕捉序列顺序的能力，因此在 Vision Transformer 中，需要为图像的每个 Patch 添加位置编码，以提供位置信息。</li></ul></li><li><p><strong>层归一化（Layer Normalization）和残差连接（Residual Connection）</strong>：</p><ul><li>在每个注意力块之后，通常会使用层归一化和残差连接来促进深层网络的训练。</li></ul></li></ol><p>Vision Transformer 通过这种注意力机制能够捕捉图像中不同区域之间的关系，从而实现有效的图像表示学习。这种模型在多个视觉任务中展现出了与卷积神经网络（CNN）相比拟或更优的性能。</p><h3 id="层归一化和残差连接的作用"><a href="#层归一化和残差连接的作用" class="headerlink" title="层归一化和残差连接的作用"></a>层归一化和残差连接的作用</h3><p>层归一化（Layer Normalization）和残差连接（Residual Connection）是深度学习中两种常用的技术，它们在提高网络训练效率和性能方面起着重要作用，尤其是在深度网络中。</p><p><strong>层归一化（Layer Normalization）</strong></p><p>层归一化是一种归一化技术，旨在在网络的每一层对输入进行归一化处理。与传统的批量归一化（Batch Normalization）不同，层归一化是在单个数据样本的层面上进行归一化，而不是在整个批次上。</p><p><strong>作用</strong>：</p><ol><li><strong>减少内部协变量偏移</strong>：层归一化通过规范化处理，减少了网络内部的协变量偏移问题，这有助于加速收敛速度。</li><li><strong>提高模型稳定性</strong>：由于归一化减少了不同层间的尺度差异，这有助于网络训练过程中的稳定性。</li><li><strong>允许更高的学习率</strong>：由于层归一化减少了梯度消失或爆炸的问题，因此可以使用更高的学习率进行训练。</li><li><strong>简化网络初始化</strong>：归一化层使得网络对初始化不那么敏感，从而简化了网络的初始化过程。</li></ol><p><strong>残差连接（Residual Connection）</strong></p><p>残差连接，也称为跳跃连接（Skip Connection），是一种允许网络中的信号绕过一层或多层直接传递的技术。</p><p><strong>作用</strong>：</p><ol><li><strong>缓解梯度消失问题</strong>：在深层网络中，梯度可能会随着层数的增加而迅速减小，导致深层网络难以训练。残差连接通过直接连接层，帮助梯度直接流向前面的层，从而缓解了梯度消失问题。</li><li><strong>提高模型容量</strong>：残差连接允许模型学习残差函数，这意味着模型可以学习到恒等映射（即直接传递输入到输出），这增加了模型的容量。</li><li><strong>网络深度的扩展</strong>：残差连接使得可以训练更深的网络结构，因为它们减少了随着网络深度增加而性能下降的问题。</li><li><strong>提高训练速度</strong>：残差连接有时可以加速模型的训练过程，因为它们允许网络更快地收敛。</li></ol><h3 id="在-Transformer-架构中的应用"><a href="#在-Transformer-架构中的应用" class="headerlink" title="在 Transformer 架构中的应用"></a>在 Transformer 架构中的应用</h3><p>在 Transformer 架构中，层归一化和残差连接被广泛使用：</p><ul><li><strong>层归一化</strong>通常应用于多头自注意力机制和前馈网络的输出上，以稳定训练过程并提高性能。</li><li><strong>残差连接</strong>则被用于连接自注意力层和前馈网络的输入与输出，确保信息可以在网络中直接流动。</li></ul><p>这两种技术的结合使得 Transformer 架构能够有效地处理长距离依赖问题，并在多种任务中取得了显著的性能提升。</p><h3 id="为什么要使用缩放点积"><a href="#为什么要使用缩放点积" class="headerlink" title="为什么要使用缩放点积"></a>为什么要使用缩放点积</h3><p>点积之后方差为 $ d_k $</p><p><a href="https://blog.csdn.net/ytusdc/article/details/121622205">为什么在进行softmax之前需要对attention进行scaled</a></p><h3 id="多头注意力计算"><a href="#多头注意力计算" class="headerlink" title="多头注意力计算"></a>多头注意力计算</h3><p>是的，多头注意力机制（Multi-Head Attention）在每个头内部独立进行注意力计算。这种机制是 Transformer 架构的关键组成部分，它允许模型同时从不同的表示子空间中捕获信息。</p><p>以下是多头注意力机制的一般步骤：</p><ol><li><p><strong>线性投影</strong>：输入序列首先被分割成查询（Query）、键（Key）和值（Value）三个部分，并且每个部分都通过独立的线性层（即一维卷积）进行投影，以生成不同头的输入。</p></li><li><p><strong>分割为头</strong>：每个部分（Q、K、V）被分割成多个头，每个头处理输入序列的一部分信息。</p></li><li><p><strong>并行处理</strong>：每个头独立地计算自注意力，即在每个头内，使用 Query 和 Key 计算注意力分数，然后这些分数用于加权 Value。</p></li><li><p><strong>拼接头</strong>：所有头的输出被拼接在一起，形成一个较长的序列。</p></li><li><p><strong>最终线性投影</strong>：拼接后的序列通过另一个线性层进行投影，以生成最终的输出。</p></li></ol><p>在数学上，如果我们有 ( L ) 个头，每个头的注意力计算可以表示为：</p><p>[ \text{Attention}^l(Q, K, V) &#x3D; \text{softmax}\left(\frac{QW^Q_l K^T W^K_l}{\sqrt{d_k}}\right) W^V_l V ]<br>[ \text{Output} &#x3D; W^O \left[ \text{head}_1; \text{head}_2; …; \text{head}_L \right] ]</p><p>其中，( W^Q_l, W^K_l, W^V_l ) 是第 ( l ) 个头的线性层权重，( d_k ) 是 Key 的维度，( W^O ) 是最终输出的线性层权重。</p><p>多头注意力机制的主要优点</p><ol><li>它能够使模型<strong>在不同的表示子空间中捕获信息</strong>，增强了模型的表达能力。</li><li>每个头可以学习到序列的不同方面，例如，一个头可能专注于捕捉短距离依赖，而另一个头可能专注于长距离依赖。最终，所有头的信息被整合，以<strong>获得全面的序列表示。</strong></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>激活函数</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><p><a href="https://blog.csdn.net/hy592070616/article/details/120616475">机器学习中的数学——激活函数：基础知识</a></p><h2 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h2><p><strong>Sigmoid函数：</strong> Sigmoid函数将输入值映射到0和1之间，具有平滑的S形曲线。其数学表达式为 [<br>\sigma(x) &#x3D; \frac{1}{1 + e^{-x}}<br>]<br>，适合用于二分类问题输出概率值</p><p>特点：它能够把输入的连续实值变换为0和1之间的输出，特别的，如果是非常大的负数，那么输出就是0；如果是非常大的正数，输出就是1.</p><p>由于所有隐藏层的输入输出都为0—1之间，这个值所对应的sigmoid导数值为0.2到0.25，着意味着每反向传播一层，就会缩小4到5倍。从而导致梯度消失的问题</p><p>缺点：</p><ol><li>容易造成梯度消失和梯度爆炸</li><li>耗时（数学表达式含有幂运算）</li></ol><h2 id="Tanh（双曲正切）"><a href="#Tanh（双曲正切）" class="headerlink" title="Tanh（双曲正切）"></a>Tanh（双曲正切）</h2><p><strong>Tanh函数：</strong> Tanh函数是双曲正切函数，将输入值映射到-1和1之间。其数学表达式为 $f(x) &#x3D; (exp(x) - exp(-x)) &#x2F; (exp(x) + exp(-x))$ ，比Sigmoid函数范围更广，常用于隐藏层的非线性变换</p><p>优点：解决了Sigmoid函数的不是zero-centered输出问题</p><h1 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h1><p>ReLU函数其实就是一个取最大值函数<br><strong>ReLU（Rectified Linear Unit）函数：</strong> ReLU函数将所有负的输入值设为0，而正的输入值保持不变。其数学表达式为 $f(x) &#x3D; max(0, x)$ ，简单且易于计算，被广泛应用于深度学习网络中</p><p>优点：<br>1） 解决了gradient vanishing问题 (在正区间)<br>2）计算速度非常快，只需要判断输入是否大于0<br>3）收敛速度远快于sigmoid和tanh</p><p>ReLU也有几个需要特别注意的问题：<br>1）ReLU的输出不是zero-centered<br>2）Dead ReLU Problem，指的是某些神经元可能永远不会被激活，导致相应的参数永远不能被更新。</p><p>有两个主要原因可能导致这种情况产生: (1) 非常不幸的参数初始化，这种情况比较少见 (2) learning rate太高导致在训练过程中参数更新太大，而接近于 0(这时在下一样本的计算中该神经元的值就会趋于为 0，随着而来的是权重的梯度为 0，权重无法更新，导致该神经元的值恒为 0)，那么这个神经元将永远处于死亡状态。</p><p>解决方法是可以采用Xavier初始化方法，以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法。</p><p><strong>Leaky ReLU函数：</strong> Leaky ReLU函数在ReLU的基础上稍作修改，当输入值为负时不再直接变为0，而是乘以一个小的斜率值。其数学表达式为 $f(x) &#x3D; max(0.01x, x)$ ，<strong>有助于解决ReLU函数在负值区域的死亡神经元问题</strong></p><h2 id="奥卡姆剃刀"><a href="#奥卡姆剃刀" class="headerlink" title="奥卡姆剃刀"></a>奥卡姆剃刀</h2><p>神经网络方面，「奥卡姆剃刀」原则可以概括为「如无必要，勿增实体」，即在保证性能的情况下，训练使得模型的有效参数尽量少</p><p>ex. 理论上来讲，Leaky ReLU有ReLU的所有优点，外加不会有Dead ReLU问题</p><p>但是在实际操作当中，并没有完全证明Leaky ReLU总是好于ReLU</p><h1 id="softmax函数"><a href="#softmax函数" class="headerlink" title="softmax函数"></a>softmax函数</h1><p>Softmax激活函数是一种在机器学习和深度学习中常用的函数，特别是在处理多分类问题时。它将一个向量或一组实数转换成概率分布，使得每个元素的值都在0到1之间，并且所有元素的和为1。这使得Softmax成为分类问题中输出层的理想激活函数。</p><h3 id="Softmax函数的定义："><a href="#Softmax函数的定义：" class="headerlink" title="Softmax函数的定义："></a>Softmax函数的定义：</h3><p>Softmax激活函数在处理多分类问题时。它将一个向量或一组实数转换成概率分布，使得每个元素的值都在0到1之间，并且所有元素的和为1。这使得Softmax成为分类问题中输出层的理想激活函数。</p><p>给定一个向量 ( z )，其中 ( z_i ) 是向量中的第 ( i ) 个元素，Softmax函数 ( \sigma(z) ) 定义为：</p><p>[<br>\sigma(z_i) &#x3D; \frac{e^{z_i}}{\sum_{j&#x3D;1}^{K} e^{z_j}}<br>]</p><p>其中，( K ) 是类别的总数。</p><p>Softmax函数与正常的max函数不同：max函数仅输出最大值，但Softmax函数确保较小的值具有较小的概率，并且不会直接丢弃。我们可以认为它是arg max ⁡ \argmaxargmax函数的概率版本或“soft”版本。Softmax函数的分母结合了原始输出值的所有因子，这意味着Softmax函数获得的各种概率彼此相关。</p><p>Softmax激活函数的特点：</p><p>在零点不可微。<br>负输入的梯度为零，这意味着对于该区域的激活，权重不会在反向传播期间更新，因此会产生永不激活的死亡神经元。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li><p><strong>归一化输出</strong>：Softmax函数的输出是一个概率分布，每个类别都有一个概率值，这些值的总和为1。</p></li><li><p><strong>多分类适用性</strong>：Softmax函数适用于多分类问题，可以为每个类别输出一个概率，使得模型可以区分多个类别。</p></li><li><p><strong>数值稳定性</strong>：在计算过程中，由于指数函数 ( e^{z_i} ) 可能非常大，直接计算可能导致数值溢出。为了提高数值稳定性，通常会从 ( z ) 中减去 ( \max(z) )。</p></li><li><p><strong>梯度下降</strong>：在训练过程中，<strong>Softmax函数与交叉熵损失函数结合使用，可以方便地通过反向传播算法计算梯度。</strong></p></li></ol><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>多分类问题</strong>：在需要模型输出多个类别概率的场景中，如图像分类、文本分类等。</li><li><strong>神经网络的输出层</strong>：在构建深度学习模型时，通常在输出层使用Softmax激活函数，以便模型能够输出每个类别的概率。</li></ul><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>假设有一个简单的分类问题，有三个类别，模型的输出层有三个神经元，对应的 ( z ) 值分别为 ( z_1 &#x3D; 2 )，( z_2 &#x3D; 1 )，和 ( z_3 &#x3D; 0 )。使用Softmax函数，我们可以计算出每个类别的概率：</p><p>[<br>\sigma(z_1) &#x3D; \frac{e^2}{e^2 + e^1 + e^0} \approx 0.7310586<br>]<br>[<br>\sigma(z_2) &#x3D; \frac{e^1}{e^2 + e^1 + e^0} \approx 0.24472847<br>]<br>[<br>\sigma(z_3) &#x3D; \frac{e^0}{e^2 + e^1 + e^0} \approx 0.02421296<br>]</p><p>这样，模型就可以为每个类别输出一个概率值，这些值可以用于最终的决策过程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习超参数的介绍</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B6%85%E5%8F%82%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B6%85%E5%8F%82%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习超参数的介绍"><a href="#深度学习超参数的介绍" class="headerlink" title="深度学习超参数的介绍"></a>深度学习超参数的介绍</h1><h2 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h2><p><a href="https://blog.csdn.net/a910247/article/details/137590886">深入理解神经网络学习率(定义、影响因素、常见调参方法、关键代码实现)</a></p><p>深度学习中的学习率（Learning Rate）是一个至关重要的超参数，它决定了模型在训练过程中更新权重参数的速度与方向。在使用梯度下降法（Gradient Descent）或其变种（如随机梯度下降，Stochastic Gradient Descent, SGD）优化模型时，学习率扮演着核心角色。</p><p>具体来说，在每次迭代过程中，模型计算损失函数关于各个参数的梯度，这个梯度指示了参数应当朝着哪个方向调整以最小化损失。学习率就是这个调整过程中的“步伐”大小，即参数更新的量。数学表达式通常是这样的：</p><p><img src="/../../img/lr.png"></p><p>如果学习率<strong>设置得过大</strong>，那么在每一步迭代中，模型参数可能会跨过最优解，导致震荡或者发散，这被称为“振荡现象”或“不稳定性”。相反，如果学习率<strong>设置得太小</strong>，模型收敛到最优解的速度将会非常慢，而且可能会陷入局部极小点，而不是全局最优解。</p><h2 id="过拟合和欠拟合（Overfitting-and-underfitting）"><a href="#过拟合和欠拟合（Overfitting-and-underfitting）" class="headerlink" title="过拟合和欠拟合（Overfitting and underfitting）"></a>过拟合和欠拟合（Overfitting and underfitting）</h2><p>过拟合和欠拟合是导致模型泛化能力不高的两种常见原因，都是模型学习能力与数据复杂度之间失配的结果。<br><strong>“欠拟合”</strong> 常常在模型学习能力较弱，而数据复杂度较高的情况出现，此时模型由于学习能力不足，无法学习到数据集中的“一般规律”，因而导致泛化能力弱。<br><strong>“过拟合”</strong> 常常在模型学习能力过强的情况中出现，此时的模型学习能力太强，以至于将训练集单个样本自身的特点都能捕捉到，并将其认为是“一般规律”，同样这种情况也会导致模型泛化能力下降。</p><h3 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h3><p>过拟合（over-fitting）也称为过学习，它的直观表现是算法在训练集上表现好，但在测试集上表现不好，泛化性能差<br><strong>cause</strong></p><blockquote><ul><li>训练集的数据太少或者缺乏代表性；</li><li>训练集样本存在的噪音干扰过大，导致模型拟合了噪音的特征，反而忽略了真实的输入输出间的关系；</li><li>参数太多，模型复杂度过高；</li></ul></blockquote><p><strong>method</strong></p><ol><li>增加数据量</li></ol><ul><li>从数据源头获取更多数据；</li><li>通过数据增强对数据进行扩充：对图像进行翻转、裁剪、缩放、平移、添加噪声等。</li></ul><ol start="2"><li>正则化<br>在进行目标函数或代价函数（损失函数）优化时，在函数后面加上一个正则项，一般有L1正则、L2正则等。</li></ol><blockquote><ul><li><strong>L1正则化：</strong> L1正则化是通过在目标函数中加入L1范数惩罚项来实现的。L1范数是指权重向量W中的各个元素绝对值之和，因此L1正则化的目的是使模型参数尽可能地稀疏。L1正则化可以促使模型参数向零值收缩，进而减少特征的数量。</li><li><strong>L2正则化：</strong> L2正则化是通过在目标函数中加入L2范数惩罚项来实现的。L2范数是指权重向量W中的各个元素的平方和开根号，因此L2正则化的目的是通过约束模型参数的平方和，使得它们的值不会过大。L2正则化可以帮助避免模型的权值过拟合，并使得模型更具有鲁棒性和泛化能力。</li></ul></blockquote><blockquote><p><strong>区别：</strong> L1正则化减少的是一个常量，L2正则化减少的是权重的固定比例；使用L1可以得到稀疏的权值，使用L2可以得到平滑的权值；实践中L2正则化通常优于L1正则化。</p></blockquote><ol start="3"><li>Dropout<br>Dropout 是一种常用的正则化技术，用于减少深度神经网络的过拟合现象。Dropout 在训练过程中随机地丢弃一部分神经元的输出，从而强制模型去学习其他特征的表示。</li></ol><p>欠拟合（Underfitting）是指模型在训练数据上的表现就不够好，无法捕捉数据的基本趋势和模式，导致模型的预测或分类能力较差。以下是欠拟合的原因和一些解决方案：</p><h3 id="欠拟合的原因"><a href="#欠拟合的原因" class="headerlink" title="欠拟合的原因"></a>欠拟合的原因</h3><ol><li><p><strong>模型太简单</strong>：如果模型结构过于简单，可能无法捕捉数据的复杂特征和关系。</p></li><li><p><strong>训练数据不足</strong>：过少的训练样本可能导致模型无法学习到足够的信息。</p></li><li><p><strong>特征选择不当</strong>：如果重要的特征被忽略或未被正确使用，模型可能无法学习到数据的真实结构。</p></li><li><p><strong>训练时间不足</strong>：模型可能需要更多的迭代次数来充分学习数据的特征。</p></li><li><p><strong>学习率过高</strong>：如果学习率设置得过高，可能导致模型在训练过程中震荡，无法收敛到最优解。</p></li><li><p><strong>正则化过度</strong>：过度的正则化可能会限制模型的复杂度，导致模型无法拟合数据。</p></li><li><p><strong>数据预处理不当</strong>：如数据未归一化或标准化，可能导致模型训练效果不佳。</p></li><li><p><strong>错误的模型选择</strong>：选择了不适合当前数据分布和问题的模型。</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p><strong>增加模型复杂度</strong>：增加模型的层数或神经元数量，使模型能够捕捉更复杂的特征。</p></li><li><p><strong>获取更多数据</strong>：增加训练数据量，提供更多的信息供模型学习。</p></li><li><p><strong>特征工程</strong>：通过特征选择、特征提取或特征构造等方法，增加模型的预测能力。</p></li><li><p><strong>延长训练时间</strong>：增加迭代次数，让模型有更多的机会学习数据。</p></li><li><p><strong>降低学习率</strong>：适当降低学习率，确保模型能够稳定地收敛。</p></li><li><p><strong>减少正则化强度</strong>：减少L1或L2正则化项的系数，或使用其他类型的正则化方法。</p></li><li><p><strong>数据预处理</strong>：确保数据被正确地预处理，如归一化、标准化或去噪声。</p></li><li><p><strong>选择合适的模型</strong>：根据数据的特点和问题的需求，选择合适的模型类型。</p></li><li><p><strong>使用集成学习</strong>：通过组合多个模型的预测结果，提高模型的整体性能。</p></li><li><p><strong>调整训练策略</strong>：如使用不同的优化算法或调整其他超参数，可能会改善模型的训练效果。</p></li><li><p><strong>模型解释性</strong>：使用模型解释性工具来理解模型的预测，识别模型未能捕捉的特征。</p></li><li><p><strong>交叉验证</strong>：使用交叉验证来评估模型在不同数据子集上的表现，确保模型的泛化能力。</p></li></ol><p>通过这些方法，可以提高模型的拟合度，使其在训练数据上能够更好地捕捉数据的基本趋势和模式。在实际应用中，通常需要通过实验和调整来找到最佳的解决方案。</p><h2 id="损失函数、代价函数、目标函数"><a href="#损失函数、代价函数、目标函数" class="headerlink" title="损失函数、代价函数、目标函数"></a>损失函数、代价函数、目标函数</h2><p>当然，以下是对损失函数、代价函数和目标函数的总结，包括它们的定义和区别：</p><table><thead><tr><th>术语</th><th>定义</th><th>区别与联系</th></tr></thead><tbody><tr><td>损失函数（Loss Function）</td><td>衡量模型预测值与实际值差异的函数，用于训练过程中评估模型性能。</td><td>通常是代价函数的具体实现，关注单个样本的预测误差。</td></tr><tr><td></td><td>例如：均方误差（MSE）、交叉熵损失（Cross-Entropy Loss）</td><td></td></tr><tr><td>代价函数（Cost Function）</td><td>衡量模型整体性能的函数，通常是损失函数对所有样本的累积或平均。</td><td>比损失函数更广泛，可以包含正则化项等，用于选择最优模型参数。</td></tr><tr><td></td><td>例如：正则化的均方误差、总交叉熵损失</td><td>通常是训练过程中优化的目标。</td></tr><tr><td>目标函数（Objective Function）</td><td>用于优化问题的函数，通常结合了代价函数和其他考虑因素。（经验风险+结构风险）</td><td>可以包含代价函数，也可以包含其他优化目标，如公平性、可解释性。</td></tr><tr><td></td><td>例如：带有约束的目标函数</td><td>用于指导模型训练和评估，是最终优化的目标。</td></tr></tbody></table><h3 id="详细说明："><a href="#详细说明：" class="headerlink" title="详细说明："></a>详细说明：</h3><ul><li><p><strong>损失函数</strong>：</p><ul><li>用于衡量单个样本的预测误差。</li><li>常见的损失函数有：<ul><li><strong>均方误差（MSE）</strong>：[ \text{MSE} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^n (y_i - \hat{y}_i)^2 ]</li><li><strong>交叉熵损失</strong>：[ \text{Cross-Entropy Loss} &#x3D; -\frac{1}{n} \sum_{i&#x3D;1}^n [y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i)] ]</li></ul></li><li>损失函数的选择取决于问题类型（如回归或分类）。</li></ul></li><li><p><strong>代价函数</strong>：</p><ul><li>通常指代整个数据集上的损失函数的总和或平均。</li><li>可以包含正则化项来防止过拟合，如：<ul><li><strong>L1正则化</strong>：[ \text{Cost} &#x3D; \text{MSE} + \lambda \sum_{j&#x3D;1}^m |w_j| ]</li><li><strong>L2正则化</strong>：[ \text{Cost} &#x3D; \text{MSE} + \lambda \sum_{j&#x3D;1}^m w_j^2 ]</li></ul></li><li>代价函数是训练过程中需要最小化的函数。</li></ul></li><li><p><strong>目标函数</strong>：</p><ul><li>综合了代价函数和其他优化目标（如约束条件）。</li><li>可以是多目标优化问题的一部分，考虑多个不同的目标，如：<ul><li><strong>准确性</strong>：模型的预测准确性。</li><li><strong>公平性</strong>：模型在不同群体上的表现。</li><li><strong>可解释性</strong>：模型决策的透明度。</li></ul></li><li>目标函数是最终优化的目标，指导模型的训练和评估。</li></ul></li></ul><p>在实际应用中，这些术语有时可以互换使用，但它们在概念上有所区别。理解这些区别有助于更准确地描述和优化机器学习模型。</p><h2 id="监督，无监督，半监督，弱监督学习"><a href="#监督，无监督，半监督，弱监督学习" class="headerlink" title="监督，无监督，半监督，弱监督学习"></a>监督，无监督，半监督，弱监督学习</h2><p>在机器学习和人工智能领域，这些术语描述了不同的学习模式和方法：</p><ol><li><p><strong>监督学习（Supervised Learning）</strong>：</p><ul><li>监督学习是一种机器学习类型，其中模型从标记的训练数据中学习。这些数据包括输入特征和相应的输出标签。</li><li>模型的目标是学习一个函数，能够从输入特征映射到正确的输出标签。</li><li>常见的监督学习任务包括分类（如垃圾邮件检测）和回归（如房价预测）。</li></ul></li><li><p><strong>半监督学习（Semi-Supervised Learning）</strong>：</p><ul><li>半监督学习是监督学习的一种变体，其中训练数据包含一部分标记样本和一部分未标记样本。</li><li>这种方法通常用于标签获取成本高昂，但未标记数据容易获得的情况。</li><li>半监督学习模型利用未标记数据来提高学习性能，同时利用标记数据来指导学习过程。</li></ul></li><li><p><strong>弱监督学习（Weakly Supervised Learning）</strong>：</p><ul><li>弱监督学习涉及到使用不精确或不完整的标签进行学习。这种标签可能是噪声较大的、部分正确的或非常粗略的。</li><li>与监督学习不同，弱监督学习不要求精确的标签，而是允许一定程度的错误或模糊性。</li><li>这种学习模式适用于标签获取困难或成本高昂的情况，例如从文本描述中自动提取信息。</li></ul></li><li><p><strong>无监督学习（Unsupervised Learning）</strong>：</p><ul><li>无监督学习是一种机器学习类型，其中模型从未标记的数据中学习，没有提供任何输出标签。</li><li>模型的目标是发现数据中的结构和模式，例如通过聚类或降维技术。</li><li>常见的无监督学习任务包括聚类（如市场细分）和关联规则学习（如购物篮分析）。</li></ul></li></ol><p>这些学习模式各有优势和适用场景，选择哪一种取决于具体问题的性质、数据的可用性以及所需的输出类型。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习模型微调</title>
    <link href="/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/"/>
    <url>/2024/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习模型微调（Fine-tuning）"><a href="#深度学习模型微调（Fine-tuning）" class="headerlink" title="深度学习模型微调（Fine-tuning）"></a>深度学习模型微调（Fine-tuning）</h1><p>由于在很多任务场景下，所能够使用到的数据集往往样本较少，这个时候就会思考能不能使用一些在较大数据集（如ImageNet）上训练好的模型，对其进行微调，进而运用在自己的领域任务上，即迁移学习和模型微调</p><ol><li>微调时通常使用更强的正则化、更小的学习率、更少的数据迭代</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python数据分析</title>
    <link href="/2024/04/25/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <url>/2024/04/25/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="python数据分析"><a href="#python数据分析" class="headerlink" title="python数据分析"></a>python数据分析</h1><h2 id="相关的库"><a href="#相关的库" class="headerlink" title="相关的库"></a>相关的库</h2><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>Matplotlib是一个用于绘制数据图表的库。它提供了各种绘图函数和工具，可以用于创建各种类型的图表，如折线图、散点图、柱状图等。以下是使用Matplotlib绘制折线图的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 创建数据</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 绘制折线图</span><br>plt.plot(x, y)<br><br><span class="hljs-comment"># 添加标题和标签</span><br>plt.title(<span class="hljs-string">&quot;折线图示例&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X轴&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y轴&quot;</span>)<br><br><span class="hljs-comment"># 显示图表</span><br>plt.show()<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><ol><li>矩阵SVD分解</li><li>矩阵能够相似对角化的充要条件</li><li>讲一讲SVM的原理</li><li>对特征值和特征向量的理解</li></ol><h3 id="1-线性变换"><a href="#1-线性变换" class="headerlink" title="1. 线性变换"></a>1. 线性变换</h3><p><strong>定义</strong>：<br>线性变换是指一个函数 ( T: V \rightarrow W )，它将一个向量空间 ( V ) 中的向量 ( v ) 映射到另一个向量空间 ( W ) 中的向量 ( w )，且满足以下两个条件：</p><ul><li>加法保持性：对于任意向量 ( u, v \in V )，有 ( T(u + v) &#x3D; T(u) + T(v) )。</li><li>标量乘法保持性：对于任意向量 ( v \in V ) 和任意标量 ( a )，有 ( T(av) &#x3D; aT(v) )。</li></ul><p><strong>几何意义</strong>：<br><strong>线性变换可以看作是一种在空间中的“拉伸”或“压缩”，甚至可以是“旋转”或“反射”。</strong> 在二维空间中，线性变换可以想象为一个网格被均匀地拉伸或压缩，而不会发生撕裂或折叠。</p><h3 id="2-特征值和特征向量"><a href="#2-特征值和特征向量" class="headerlink" title="2. 特征值和特征向量"></a>2. 特征值和特征向量</h3><p><strong>定义</strong>：<br>对于一个给定的线性变换 ( T )，如果存在一个非零向量 ( v ) 和一个标量 ( \lambda )，使得 ( T(v) &#x3D; \lambda v )，那么 ( v ) 就是 ( T ) 的一个特征向量，而 ( \lambda ) 就是对应的特征值。</p><p><strong>几何意义</strong>：<br><strong>特征向量：是线性变换下保持方向不变的向量，</strong><br><strong>特征值：则表示这个方向上的伸缩比例。</strong> 在二维空间中，可以想象一个线性变换将一个向量“拉伸”或“压缩”成另一个向量，而特征向量就是在这个过程中方向不变的向量。</p><p><strong>计算</strong>：<br>特征值和特征向量的计算通常通过求解特征方程 ( T(v) &#x3D; \lambda v ) 来完成，即：</p><p>[ (T - \lambda I)v &#x3D; 0 ]</p><p>其中，( T ) 是线性变换的矩阵表示，( I ) 是单位矩阵，( \lambda ) 是特征值，( v ) 是特征向量。</p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul><li><strong>机器学习</strong>：在机器学习中，特征值和特征向量被用于主成分分析（PCA）等降维技术，以及谱聚类等聚类算法。</li><li><strong>深度学习</strong>：在深度学习的卷积神经网络中，卷积核可以看作是一种线性变换，其参数（权重）可以通过特征值分解来优化。</li><li><strong>物理学</strong>：在经典力学中，特征值问题与系统的固有频率相关，特征向量则与系统的振动模式相关。</li></ul><p>理解线性变换、特征值和特征向量对于深入学习数学、物理以及相关工程领域非常重要，它们提供了一种强大的工具来分析和理解复杂系统的行为。</p><p>学完之后学习降维算法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch</title>
    <link href="/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/"/>
    <url>/2024/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/</url>
    
    <content type="html"><![CDATA[<h1 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>pytorch 计算图<br>pytorch 自动求导的原理？<br>pytorch detach()方法 clone()方法 load save方法</p><h2 id="两大法宝"><a href="#两大法宝" class="headerlink" title="两大法宝"></a>两大法宝</h2><ol><li>dir 打卡工具箱 <code>dir(torch.cuda)</code></li><li>help 查看具体函数的使用方式 <code>help(torch.cuda.is_available)</code></li></ol><h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><blockquote><p>提供一种方式去获取数据及其label，以及数据集的大小</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image <span class="hljs-comment"># 图像操作（open、show）</span><br><span class="hljs-keyword">import</span> os  <span class="hljs-comment">#文件操作</span><br><br><span class="hljs-comment"># 继承Dataset类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-comment"># 通过定义一个特殊的__init__方法，在创建实例的时候，把所需要的属性绑上去</span><br>    <span class="hljs-comment"># 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self</span><br>    <span class="hljs-comment"># __init__方法的第一个参数永远是self，表示创建的实例本身</span><br>    <span class="hljs-comment"># 因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,root_dir,label_dir</span>):<br>        self.root_dir = root_dir<br>        self.label_dir = label_dir<br>        self.path = os.path.join(root_dir,label_dir)<br>        self.img_path = os.listdir(self.path) <span class="hljs-comment">#返回指定path路径文件夹中图片名称组成的列表</span><br><br>    <span class="hljs-comment"># 当实例对象做P[key]运算时，就会调用类中的__getitem__()方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        img_name = self.img_path[idx]<br>        img_item_path = os.path.join(root_dir,label_dir,img_name)<br>        <span class="hljs-built_in">print</span>(img_item_path)<br>        img = Image.<span class="hljs-built_in">open</span>(img_item_path)<br>        img.show()<br>        label = self.label_dir<br>        <span class="hljs-keyword">return</span> img, label<br><br>    <span class="hljs-comment"># 当使用len(p)时，就会调用类中的__len__()方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_path)<br><span class="hljs-comment"># 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去</span><br><br>root_dir = <span class="hljs-string">&#x27;D:\ADNI_classify _v-3.0\ADCNMCI\\train&#x27;</span><br>label_dir = <span class="hljs-string">&#x27;AD&#x27;</span><br>ad_dataset = MyData(root_dir,label_dir)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(ad_dataset))<br><br></code></pre></td></tr></table></figure><h3 id="tensorboard"><a href="#tensorboard" class="headerlink" title="tensorboard"></a>tensorboard</h3><blockquote><p>可视化训练过程的数据</p></blockquote><ol><li><code>add_image()</code></li><li><code>add_scalar</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 参数：title；y轴数值；x轴数值</span><br>writer.add_scalar(<span class="hljs-string">&quot;y=2x&quot;</span>, <span class="hljs-number">2</span>*i, i)<br><br><span class="hljs-comment"># tag：是保存图的标题</span><br><span class="hljs-comment"># img_tensor：图片变量名,图片的类型要是torch.Tensor, numpy.array, or string这三种</span><br><span class="hljs-comment"># global_step：第几张图片</span><br><span class="hljs-comment"># dataformats=‘CHW’，默认CHW，tensor是CHW，numpy是HWC</span><br>writer.add_image(tag,img_tensor,global_step,dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="Dataloader"><a href="#Dataloader" class="headerlink" title="Dataloader"></a>Dataloader</h3><blockquote><p>为后面的网络提供不同的数据形式</p></blockquote><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h2 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h2><p>PyTorch 是一个开源的深度学习框架，它提供了张量作为其核心数据结构。在 PyTorch 中，张量类似于 NumPy 中的数组，但是拥有额外的功能，特别是与 GPU 加速计算有关的功能。以下是 PyTorch 中张量的一些介绍：</p><ol><li><p><strong>创建张量：</strong> 你可以使用 torch.tensor() 函数创建张量，也可以使用一些特殊的函数如 torch.zeros()、torch.ones() 来创建特定大小的张量，还可以从 Python 列表或 NumPy 数组中创建张量。</p></li><li><p><strong>张量属性：</strong> 张量有很多属性，比如形状（shape）、数据类型（dtype）、设备（device，表示张量所在的设备，如 CPU 或 GPU）、布局（layout，表示张量的存储方式，如连续存储或分块存储）等。</p></li><li><p><strong>张量操作：</strong> PyTorch 提供了许多张量操作函数，包括数学运算、逻辑运算、索引和切片等。你可以对张量进行加法、乘法、指数运算等操作，也可以使用索引和切片来访问张量的特定元素或子集。</p></li><li><p><strong>自动求导：</strong> PyTorch 的一个重要功能是自动求导，它可以自动计算张量的梯度。你可以通过 tensor.requires_grad&#x3D;True 将张量设置为需要求导，然后进行计算，PyTorch 会自动构建计算图并计算梯度。</p></li><li><p><strong>张量和神经网络：</strong> 在深度学习中，张量是神经网络的基本数据结构。神经网络的输入、输出和参数都表示为张量，而神经网络的前向传播和反向传播也是基于张量的运算实现的。</p></li></ol><p>总的来说，PyTorch 的张量是一种灵活、强大的数据结构，它为深度学习提供了高效的数值计算和自动求导的功能。</p><h3 id="tensor函数"><a href="#tensor函数" class="headerlink" title="tensor函数"></a>tensor函数</h3><ol><li><code>torchvision.transforms.ToTensor()</code><br>在使用 transforms.ToTensor() 进行图片数据<strong>转换过程中会对图像的像素值进行正则化</strong>，即一般读取的图片像素值都是8 bit 的二进制，那么它的十进制的范围为 [0, 255]，而正则化会对每个像素值除以255，也就是把像素值正则化成 [0.0, 1.0]的范围<br><strong>意义：</strong>将图片表示为数字化的数据，方便神经网络进行处理和学习</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库学习</title>
    <link href="/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="badf294387f7412f0af4635ffd70d5e8d9899d5e383aa5196136ed342fbbffc5">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df385c81029bf9e3150c23458b797522971530bd64e26ab2611c5dfd5d08d3dd2db2b46e080c19fb827407fe3108b4f9c22caf07af70661e15a50f136f7818396e64ea0044cb5d46c5f20f25c5588f191f6f9a2bb3dfa3032df58c717a4d01a2300f56101f2da31d14e02b52d1e4f4939916dbffa9c845b7f953989ce0e9a93365db15cbf11684ee5cf4e134e6c95f83e727ffe1b583c611f42b1068398876d9b40d8774a973761cb925b6739529ffd67308d51559b43d4ebd05499da32668e6a877980afcd7bde4f054e48df529bdd63507858eb0309f3f46ea461f4f7cd20498ed65ac46eb6770473ccf6f8e0e0ae58bcf6a468bfbb5b9daef7ac7353c3fbdae09d26f19a2cf162590f265332b7bc30c502a2f5900cf9c095aac1649c3956b54cd69db56641cc3cdc336388d68ccf49584da5542e6af668fde4cebc5bd8bf8d45a249547c082594779f5d2606961659e88280efa7ab0dd8c58f612d141cd631dfd1a06ede2525963f8c6ddb511ec69b24c4579b731d1d752bd9377f28dfd15e856462b7ceda162f5050dde80b7e91cab700cd4d21e7940d1f08384c1fb40da897204e467d114815d769c6a07ddd11d3f445f7123ceda6f00ffefb91d1061e18b6bd943625315294a287a414d1fa87ba75e72fd118d9ec0da605e78aac2b40ad6fcd1007a01ee0e0fc376621d6af24d2a9fd7c497fd76fccadfba083d30506de15844d6b5dcde775502f4c0a1bf314a005457539c2bfdd9b949798bb39040660e73a7d7f687fb0c864b8ef64c09d67a60d4e0432a3ea70e0845fce914aaa1236fcc267370df1f81f5c011558f501c42b23837364d5d9bdd348b4112838566060d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>联系导师经验总结</title>
    <link href="/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%81%94%E7%B3%BB%E5%AF%BC%E5%B8%88%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E8%81%94%E7%B3%BB%E5%AF%BC%E5%B8%88%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a9d6a092d5a36880c1c999bf8b78feb7665c7c040284c10467b5783db79d02b4">184d5613b7d1f40c9857b7bf904a8fe384dc586addb4cd4cfc68c98a0f1df306</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>夏令营经验贴总结</title>
    <link href="/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/23/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%96%99/%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="aee1338abe606b8e134805bc2e181176d5129582429422b5472ac97c6e596e04">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df4bd6aad46c32d9abbb4fe2d6530c5460cc50579502fd05f3c6e47bb6e86860de1bc81183e32b226ecafac31a21ab7e6ba155e39154a962ac847ae252a4b34e78a98d79dd35ea0057ce88fae752429812e5921f0fe1e460f3530412c6f1606db7303e0e299a75509818427eb7feba1e16c5edf230977553fa22f693a3b0eb364975077963954b1e95a74bfd74db273e5d0a0c683175f8daa0333964142446b2294a4d17ad04c1187cad40ba62eba8432b5b10a8b1c02f30e657b7992723b8932b6bb93c2ee2c739175235a15d39788c32e2deb020eda639ae72d7d7bf2afe83776a56a9513b0885af50f8454ae9549a92349f6de71c4ce0c0f22f600443a9e2ad77700072175da0839c382e1489425f89b0cbc37f09e05f6e210fc842db4aa929ed19afee76f45e86877ec3eedb9574aab6a3be89622204ebca1a783ee63fc70018d75b55f6ea1e16ec76f765eb80696096cc7c7d548e33501e70c940ba69f79c45061476e721063365e177f9beab93904b5fdd87c681757a9a804f0e88da79f3af927c6afbe10928de57f18c6b64d04aa5390a5b8038bb3adf43e475879f5d30dddb36d055a8dc71d296363eab120963b4292c1ff06cc707802f138e27c9c6ee45f34431514d3b89a0dc1eeb55dbddf515adfc46665b87441eecd9c753e734f4ab110cd5e691d699b8bf55151ad2207413906751f3f6b3af311dda288aacdbf687366519282ec8b566a1e406154bddf0b74d1426da9e61e8bac64418f4872e9ec56e8df55d33ef81a66617f29afea62c262155cf6238a16c424455dabc4a011ef7f3d3c37ca82bcbe031e4fa16d671f6e2cef2e9ee28acf14c27939162d95c5a571e8d29d004fa505e69e2ed913d599895c7cca4c70506c0e2d960baccf779306098895b52db2940c705a7905b777064abb4c6a22550b9ad71629072f2ecf4cc9d2eb97f61363deef16dc114582ec29705d43584160d7fc43a0da0ae55d8ef8be0d7ff373f2b8d39205ace2555806d47e65d619a1dcc83d8d8a5270ae129d8b64b681697f6b3db9254bdc515c91c1dd16c351d56dd64c8788e885bd3fe9a5b96651b3568461695cdbe4fdb698b0b9727bbb906601e4097e3e8cc0a16da8c79f1c71e1929740267018bb4f6019ec7b4dae6ff4aae01c69de3dede1d8bf7105c31816c6fc2ab89b685bde37ab877ec434083e9abfa712ba5a430241e986921eb09877252afd343945e12b7688747f3d8b9682405a6af841ed4f87909eb31ff98fc403e35f736a1607880043e1a4ab3bee013c9636bc3b265eb9139eab9bc3c5fc44fa18e293e2c929ca83ba29b3e34f0f60a8f3d6a386ea918dee8f79035327d304a42cb802abe3d10b648761d421f6c06239e49de81ba0d5fe4ee983714b74ff9bb1d6fa31619747402e869a66853142dd1cf9c54495c5698d74dd3f5477e4c78fc63010043f1c1ab00d01647133e9336aafecf229549fefe7a38a3949e7af1226f9a58c1bc37602146ed928546866bf6df03f3b487e54d17d3a2bc55a572f78667808c0a7838bd04519bce9a127754faca3b8596376241dbdf7ab0ffd59fcab61a49a9047d7219a7da6bd1eac07172ef8631c9a1b005106282bc1832b0f6ff1217372bfcdac86f40f54176a549d680da802e54cf3d704838abdea5cbb5f17bd6864c8cb3987e728de0921b2f9d634b332c11a87008356e24a5b10c3415684b2eaed9d103b65cb23206935e549c7c8a8fb1ff48c91a692a509ba23b0a443cd6a0d34003e84f866a1947fdc9b936d9c5419682cfe9f1347fef1660e5d318bbbc784f0308e891bbf74a549ebb61078d14a19aa040a382b8b8780fb8e389dca9db1e492ab2894e7736b228a835db4aa2d2e205cd197467cc7bd4d590d95599fd9966ac6c305639e87b2ab4188b1d9e250532080ab424aa83898f40015bf5c6ffa5f8308095fc58ce7ba237e3e914c3ae207c0f0cad07beff6faa3b48289917c40918ea96882ac587d5354be3b6bb7e12f772e0a9f4f34afb34ea9c375bfa43cb80231075f61f890d7b658c3efaf5dfdc51f204d96a514181e4fb96103a0062751fb9560f0f6c7850ba5bb9e98934861a0a526a1a7ac90b8259823f182689e6d7d3fceb2d7aec92dc4b58e5a095635ee163c61311137f8a2eb19875973d8e9b3d7ec315a3f775ac6177d639878e75d446e633c66fd642ffca3adc96bb3e0b9aa5c3760bb98b2b23723c790c7743588b84b1603c042b09a406cf0a9ac43ecaff15e3edb2c1eb6024ead343b4307a0e18df5f0824a3de158c3f8a69909ea44c60539d01b2f02bcb6eac354d9b3e8afa97b41341cde19361bba24118e7260d08dcc13ae9b2a6c27076b4b947ebd1a1d080977912b3eb417ae370a70be1693982239561a8144b821a28713e60caa45110c14d0d506ad8db8df3bb105b33f2ce6544b38905b7bcd41e13cca5be06684bf7b61685bdecfd82358b69b954f0141767034067536a23188582bddbb5874628def9eec4c4ff403414ac3bdecc0928c95f959ff25b02686c77906d8d37a133165ce701e6ba4e93e3b367ccb41179c6457e6ce33e33bc627f263fdf5558400295bda78ea3a8407727556c369b018caad0967d507c1918399d901e2aa8789077b430ac6bf14c92b2dac181350b31522a0ef394df4e76e4033413bf61007fbcdbed8c685ce07724d511fdcea8e3d2c00c396c0ab3e4d3a9ea1080a7aa61f0be928032309ef353bbf5e04f42c5f2ef87093327f5fe30f7ebfa7af9399b70d8f39b512d723aee0b3f29b101a3b242be7651e64186d3a8c49bd7e11714588fe3990c5d2541112b737dbf3184bf2a25031e58fb37549d80bfe4c751018b2acb671dd8c4d64df2666b609f6b6fb4c5ac79f2abac6234e37414119913de002ed26f429ebb94e8e36d7c6deda6c1dedb43eb22c11176729a0ebc6c5aaff3646fc4c82944f20a70e2f6828142c194500ccfc24ef4b8637e9f591e94e5bd188aacfd3aa1a12cdcd943d27fbbca9665c141dab28d696ffca1d60d8e21199fb2caa484c04e2652648f0155ef6ab0f77a8c613d0b6544b5e80b25c0328860308006a2c9480fb6cc74056610cc62047e35c245ebe35c214c2846603c282620da42629a63e05e4a69c64ae51291bc99ba071004a8e6e944071b0695abde3ef5c62abc0db1ecd26c194298a839c45b66ab1330acad3b89a1f82dcf1e3d1aa0c1ded0fda5074f56adc7964c0f9b4f115c85d193c776c0adac65f69982aa8d558166248a058bfa98c3e751a07057833f9219e8ccd2314904849f0e4b471163d6fa58d9c3f7bc74f3a778ab7047500f3268f252b740c93333bd05b059877aff7bc59316b3f7d6486b674364f0234154c152679077fb85623848651f23efc49bcab3e5be483e8ebf0af3afc9c9d4187952679b1456a31d79e7d38c24a463203e0064f6b91fd9a83a3c922f8727dc9db4deafa19d68167f96e97d3f23a2a0628471748aa62b9057914c61187a81895e027ace088af5d579bbc496c1111a9e5834770260d4be06cd01b1740b2cbb7b52b67fa1e818b24992516799c2db3ebaf417de0e320fd920655f91a5af70a1f9f1e1a56dd3104e7f58cbde302c8dda2e4f877d2c4e80270c3de44b75b2ff7315752a50faf2301f21f0f361a403371f8ad657a61d21b4fed95fbf02ca56e3184cfff99a57dd7c9f5b76f2c1c8ce774b9b12885c9389dd3b32e6a94df0fcc31b74d994ad5b799bd88982425816e6f9ffa09314d7a2e8ccbda368bdcdbb7bb33f07c25025cb5e97e1a47d8d12d8f910c0802578b6cbc6e5fb95b4502f3497f1f5bc0cfa87b16da5bfe3321dfaa5d5cae4c2e64a928f50ec980419f185959a659483160840859d39c5e970520029e503c6f64fc468509999cbb926301d1dd1a838b762aca001d7561431750854019a1bc3e1cdd403716ae0500e205b90a61aeb49098ca782a1b6da24de75e00c531e0e47c36930c11c89ce3fb8f6ff067e0bdba41c5676dfca140c24f822320927adde2e7bdd76f80b90869f88360e3c03a83fd094ea616056c2879236eee7b48e646321bcc77878d242f6f80ea2a768856c0de2bbd3ee3f2075d88035b09f69adcec290f2f38a96df326029f89a9b818ad92ec1abfd01e74099cff9abb52a4d88903dae381b4b98370e02552b5d37b6f4d4629f37024e5f0e36d1e8606c2b359f09d21065f4a2e6023280555002aaeda4324d96d83336c26ce6cfc76cb7a9dc9bfa5ab175f7c12cf92f2991211765c501fee03dea5fa69754a09fc8fa046bbdc0577666f11f341df1ff5133b2f0270d70866dc43c8db27d43ae44aacdc6c5ff666259c99540e346b5e7ac3204b2ee442b559a106f88bc8caabc739ff15dca373ecfeb98a31093d151b94b1b7528110435d5fdeef3b76ac73c4bb1ea967b9c652f62c651edbf76c6fadc9c1605b3533373af6617b0f2f4381e90462fa749e0e25f031b6eb68794b5bf345b5e6a86e37d65d5634985c94eff6cc7a306113d60af42385ce10bf27c59e1a9d108aeea53742dfcf33b5981660fbef2b8159c914188bfe4f262804759d63c8668c98b79a3ab2659b8c782dabb882c29be32c825206b3a39e33984380f8ad2849f83d2cf7a5a5706fdeffebe008e3a9025e15d8b3073fedbe99eb0b4888ad9b0fa6f928b28d4186f29424fa6e5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小程序开发问题汇总</title>
    <link href="/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="小程序开发遇到的问题"><a href="#小程序开发遇到的问题" class="headerlink" title="小程序开发遇到的问题"></a>小程序开发遇到的问题</h1><blockquote><ul><li>通过slider改变自动播放的间隔时间时，即使没有打开自动播放，也会使得轮播图开始自动播放</li></ul></blockquote><h2 id="页面下拉刷新"><a href="#页面下拉刷新" class="headerlink" title="页面下拉刷新"></a>页面下拉刷新</h2><blockquote><p>1.开启下拉刷新 ，在页面的<code>.json</code>文件中将enablePullDownRefresh 设置为true<br>2.监听页面的下拉刷新事件：onPullDownRefresh<br>3.停止下拉刷新效果：调用wx.stopPullDownRefresh()函数即可</p></blockquote><h2 id="页面上拉触底"><a href="#页面上拉触底" class="headerlink" title="页面上拉触底"></a>页面上拉触底</h2><blockquote><p>1.下拉触底刷新事件：onReachBottom<br>2.通过.json文件的<code>onReachBottomDistance</code>属性来配置上拉触底的距离（默认是50px）</p></blockquote><h2 id="小程序生命周期"><a href="#小程序生命周期" class="headerlink" title="小程序生命周期"></a>小程序生命周期</h2><blockquote><p>onLoad-&gt;onShow-&gt;onReady-&gt;onHide-&gt;onUnLoad</p></blockquote><h2 id="小程序常用API"><a href="#小程序常用API" class="headerlink" title="小程序常用API"></a>小程序常用API</h2><blockquote><p>显示消息提示框 wx.showToast({title:’ ‘, icon:’ ‘,duration:’ ‘})<br>显示对话框： wx.showModel<br>显示loading提示框：wx.showLoading, 关闭loading提示框：wx.hideLoading<br>页面路由API</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++复习</title>
    <link href="/2024/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA408/C-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    <url>/2024/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA408/C-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="444a4f565112ae414d400289229f876993f82b445c3942a88c773494f97d4dbf">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82dfed3686d8191a1da5a49013128aac7420aad8798de2c4b5939dc3b163bfd07f48d90f2e1be6b177895ff836f656ee33e5285d8477deb2b9e143c1ce3cd2f6c3aa260cf318b42646d4afa2a8375214aae11bf3ae964fe7e8cf2a04c1a46f8ba6afb01e3a8dd5fd8c47c5b8d0434e641f902c8994a5945d617a4d5610664790ef70dac691cfe079c2545608a80298caddfe160597a53e81cc4beeafc6fcfdf0b42acca09f5275fb1567e8c976dd768995f2b3c6a4a8c91848e1edc8a8c796417ec26cd0fcf694dee784617cefee6c9401fa34b90d17cd0486ec3c6e1efbbeb12042afd7f0809c061ac56fd4b763fcfc0716d4bbfe3b566bcf70c7de10e2e87cf8fde572afb715186df59e46ddd6bad7c532ecb72e8cd7887cb86aeff53e07fdb87d4c1ab3512684690cb8d90217102c9f2c790c4e0012183fda13c72e34fba8b815865f5138d2baa0740a4b9f805b53af6565e879ae9e257caf28658f68301dd8a83d26253b8798a445411ec0f564f8c5e04769d4851bffa6e6882fa46f3a1c1ee1601801a7d8c4a97f59ea7e2f567268d87d4b9a308bc6f4d79b9b917b948fdfadd52e93a335850bab03ec3545412e32fcbe5367f9681f086337cd02dc92fdc9115d4538867521cf130ab9206ee06ea1f12093197b24cef75226933b884691ab762045dd2d351b10ef810f0881befefaba32848bcb2c6dc4e9905fe2e210c27cdc97467a2638984476d166d325fdd147db97e527d56e1d3ac17ebbacead1aa56f95a70251d42d2d035fa0bbed3e3dee9dad08feae6337023737cab8525dca9cfb184c6667e91620fd45241ff075b07d668f262a6d88945784b6f6b0c11d825fb3e4398e5a7764e91cab05f344be0d6fb680d01365dfc7a9d40ecd2546c8ed83e08ada1681442048b86eef78b8943c62c8eae404161c601dfe64857afa70b8ead29dab3054c4de530e0a1cfbb73cbeae7f88bb714dbcd5a2b1c2e3d3162f29d924050893840c141417d55c0b5bed88874b572c235bbdf78da054fc598725d6d59cc88800a8b176ac7a881fa580979f24ae2d6218c9cf2758be6dbeacdf0e59f3e28156a7dba2e831bccdc6f0abc93d6188d2eaa502b45d603d5b6cfd9889dcc5ae01704409ab2d29673963b3d33a3a0d8f389f008b8df9dfa6c1186e52fd2db868a908317e29c20440bdd8943031a392d9e036c0e807ad26dfd19d6967d2a39e35aa12d731ad1c85ad5012ec1960c1c3f049cad523dec916d7959a18ecb6eeeff667a4a11a55f39214365c42786c8dbd76b1cdb0f967fbd88b9c23689070791800d62425d07377c14884b71edbd80ed75dec7ba6f68e1b02cbadeb3c307103f5028d571acd7feb0f187c18c5f8d7530c295d001dd74eb1ae837f4a20947a5799496cc00015a8f5775f13af17d9a47d57194e585e9273a23a9927e41b41bb75eac67a5ad48541b8958229b79649207b90fd630e74abedc1e0de8dd22f452ce73e18b2c227299cc686d70d3f166bb29e347beb71af05efb13223c593d1ddfe662b9eed0fa4b9faedf90c635eacd22b2ebe0ca21c4f7c8a179bb00a8bfbfc19f3a2037baad2f2e5624f9677d49ac609631934047ca62a342502428f230c211de51ee888b3a3d4b83b3e103bece92313123a2957af076125fc82555f72849d1b576bfa03c581f9205c3b738e4aef088f155273867df150a6ee9ba987ccefe17323d70d7ceba49a10cc30fa41b871142c1f193e3d588b74798b802cb718b7dd464746057336fa65dbf8e78b9c0363742996e38abf1d0c2697d4a215f563bdde47f9801272f2f2df10142e779b8ca8dc30c7956c634b371d3feaeb7d852b5adf3d87b4a4e5d460d9f8a5cae97e61667566a5f08c8c0dd5eb0a6df2431c9d264ab6b0c60955e1cd868594b040fc35e752ce1be3598e2d4d2076e2d84700074584658231a616f9d483c61e7514ad4fcd30edbee42294a5b15f10c3000a116dde6667012f9a8f7f4a94a2b36d4d3512aa83750bf389db5d4ab457f81da68b57e8191be4395c4fd253c189be3162b3e95be344cda365ceb38c31755e6a49114c0e2322ad51be05d71844ff11b7d77301e89ae0da8711a07b404f20af27dbe473b882fb3b271c629ca8a3647c5e47274e7fbaaed4bb17fa6cb3f96c1f66d1a39566cbb98371b21b099bdf8b30ead6eafaf8f60edb528333645626da3a98c566fb9b5ec00b880a5af93dd787511b30353502e878858abe567839aab58f94d4a6b247ecfe5a5919ac6f1dd165909ec860a6ebdcc3c1d4356c9d5cd73cfcd26d405fe55ebf39bc8c351aa56ae24e6054d32fc054bce4fbb8fb3c0179475f072c3df0e543af7b1a3eb29d899c74b7c6a05712d2235503f9821b8db8318dc099b7429b1bd7c3fc8d1fd6fea3077db044a30f52bde638178903953939f80fe09d2ed211cca51dd64175de4250a572d48cfecadb1811b3bf129bd4cceb5ca45f493384a8211e604f2de58da7f418efe476dd432f583f58e5294461f99957f3ef0e3170741ce4bc52f3e6cadf5100ef8924124c700506fc016e8b4df0e77f160267c754776e9d1d8d6349e4cc9adc652ddeda6dcdb33044894bfc80db68f07994cad7d1cfa6081dbfd8720b68e40644be6c7c2fa5b3d925dbf9839522382d2010d37e0e4ec9963a1fa31d6321d3069376d9d0c562ae060565a931604e0526d30fcf225d5bb9c351052f0eac54075a8db5ed50a4cb8b02e251c8180a636bced85ea8373727daf57a19d53d8dd566552b2bdbbea4e09af0be9596f06c334d12ad5fc3f55a0c340d008a823af4f2ea382e7f229491e496ecbe8debf7f2b906bd81e25e8e5724837e66d1dc89e07684feaceddd51ec99af37eefe20ab8e63787ae82ee730acdf00252443b0d72af974924f5c93224306171481152885c9514bda8575fe1d5a7d1328b8f609563d2d6b827a59a48576a9d75d214e7004e7e6cbb1944640a31b950cf34de2f22931cdb7f19217e28cb15ebfe38d8aefc07cb891ee76a88bd75caba9ca427c6aae6779d9954c997c50191cc1172426d6083b821179916cd2c0bd658ea086a0ed40e8f4b8502c4049cb6f8a084a6739b39fe97a4b72230ca99c3c39a69dcb3c5caa23967da9da00992b819d067fd079ab0c6a2f429d6de1b65ea6d78f3cd153d95b877a1cbad76d61ed1ebc36fbc02be0ea1832cd2b5d0d1bce0d3f546c6ab25af07dd50091b2e6c8a70d17e74c04bdbf91adc1c4bd9fe564c5a642265949dc40463ea331df22456da5683603f945588c31063723f4c07b572050cad306499bcc78599ca9c70f9f8bb105b5e2c872d18014559db179187bc69c7f031e9954a2280810473ca9c9bd3a4b8de8303c83754c8e236230d6bdae7de33979240049f1e83895aa8d62ccc36a7e47cf8bfa60de2a991caa57bcc348352a91c2337e6304cae9f186cb62a33657989bb13c674428a291a2928c026dece93a700120f655144d4c3e3f565ab87658eaea26668c0b30ecfc6bf4f3b30524970bd934c39db76f264b01d213b4bb4fcb04f31a8b078e262428f48afcc5f5a92cf4afcd9da79e0ab2c103f5adea9f5061a6097ddfe8e6db452135e1383e01e890c6287faea43f828fd353b4b294c220f3ed73e7304e5e8fe7a7c3dfd43c92ca2532e0563ff5007c6d09ff099900b99aa3a114f0b36d28770ec101933718c89ad497c659b1365c5f81a5c7c037f4b5103d98d02309a361801f9d8294c5165e6ba3546935f860cde4f901a1e7acc10152c49bb0cb5b158aadc22fd8599b8e6138d2a436f327681bb15ce066253d09376de2852d4deed84ce959beb3f9c795d1b2ff729bc40ea1a205e4d8b625acb3decd0abaf1bab1e440e65efb84b9bdbd9176ac95e566f005ed4286ddbf8444490762061ff3280a63da66797170fcf849480e7bcbd1185808e99e4e4759e6f4f0eb50bf9725fd9cbdce43ed1cb671d0ea3ed27955f8e8b99b75666c297f0348c52c8a6bcf4d80fb3caf25f60fd22fb3b215a50f1a8c482672bad0293efe558484622d79d8b6495770a707b23c7fa64e7a56f84a6296f8f101c7c9976869d5fd07d1dc55713572bfdb8a36c1b3a4c7cd761679e47949181cdc72eb38f248d68ebc5cbe8ff781121b96670b90d88ed9043e540b3921fda3270a1d6e34d7eb0df3a11a6ced78ca7eb9d2d227b2576d069aa40eadb51b9bd977e237cd21d4e0edde92326e704ff637d3dcaf87542e9cef9af0557d73d0342a870a9b43725720c8ab93ea134767bf16cb78f0fbbd486116f9ef62362e73e760e4f7ec05441fcfe396e1d07dfcf0b6fddb027f3a0de92dc0b85829e3cbd8a792961bcf7962cc2a645a9de63733a7d770e5bf1e39f048b1a7e78a77379107d9fad53900ba244e79cb6d64f3952752d70ac5729808cf324605f0d8b4b35c885f0688b3833931522dfa9fcd308c8beba97355bba55729181d313f5823a3a095455e33a6d4d31fc4c363730fc6b4ba022426931d05e90a4f542de55bed4a66f70dcff92b8fe8aa396ac7b5b427f0576dc87a97a2cf78012a8c9e857e3bc82d5628fefbd24afce581237253439aabc7a2933997bb388e9747c4e0fb74a44e0d8f650757e99ad9fa95ae12c51f5a4ed73f692f4369b0304febf6be097916ee81d2fff4072bedb2e8af382838419e8f9d02bf5a80130d3759b4291a2538c51e019f985a0761ac4fb266d77f969d35e98b1514f89db55ab5ba7347541017e624b7bd2a2aa1984b0aa8fdf4d28a99a019633ae73dd524a19f0e21e5804e06287eaea246a7fc4ed07bd5bdc1d419ecffec1a1f28b8e0d7d508cbd5f6cdc88841262a8835685ea78798b71330d7dbd62efc722471ed8df9319f82b1d158206872c04e82bd3776a97401c3444bba7059b44b8e6703a7e344d6676ce5af32c17616d60522105e48ef419eca7c9f90f9144645603c41bb365c18ba70b55527b77507eb778397573eaed7b59bd0da421ba3ae758bc0a523e20868b7cc1184d6e93a52edcb73485deefdb905209b5010cd971a6ec65d2bedc39fba15022aceb3b4cfd37025c74574996af14eaa112d83256a754b01ee8f7e86af1e88fea9a3ebc80a0fc13073fc1ff1ea55f027bd4e91acc7fd310fdb61bf41d4038845b690cf0990d48258fcfa95e08a88e906c3b21c18e56745eefc88b2d2eec089a936219fe20a0e7f2228382a871bd301919fd6acb8cb5386773cd57c29734e7441af434f4a5bd30268f2362c15a9eabecae9de6499cb05a0d962422f5803de50002df930aa484fa031ce1890077193b19ff5572764433b2562376d59cd4588df2f85b1cef6ba9a5870e5e26fa0aec6b062b1b763a787a5fd89eb045f0c5f71bb53c5cb51f7c88e96cab361b4be5196a3c4649b205c1d18e53a794c29d086d649e8718f9e8e3039bec75e435117f64571d902bb64dd3f55d4a7de1495a43855e676eeb255c838824796de3d9f10aed18915a80110eb51d3d4ebc5c91ad3235dab0941524fa1a4763b48b1d4915af46087e04b945d595c90540269331279f7710b9bbf5d76ea53281ed3bbd1042f2fce4ba3c0ddc6e79473b88ba6becf0e88455d2f0ba29b06f8f157e6b57393393e6ba8cb1b4693fdf6e4c86f222273946295d7fb341b591f006a15632ed8f2606ebee8cd0937c3e3265c16a8e76638d6024230769aac14613cdd060dfb6acf6cecac75c86d9b128234be8c85d26d78f670d21327ecae2fc05ae935a7f58f187ca817bf8e704233719870bd9352c7cc33a1e9f4db1ffe58afe888690b4716fa0aa77ab8363efd339cd2a160cdd36a442f7d60e1552a2d009b1b3d9d338e1c973ea2a10bcf8e3edd0390a3c10e39d8918490a5d6fb8615667aeb26b9a2c46e52764dcf8bb91c438dc2958adc13fa01bd329a098e5ede97c12615990de7662ec4b4c764c399b9c786d484b6615afb7eb93a78326c7bf7dc38819621019d8315530fc3e4837e5bff2147888c71520b7a79244ef7f9f0c1b65c57123186e18085dc870f0cd687371030e831849143a1032be4f8c77a522048a1f6feac36fcf36d672ef2718cb8fd843c0d784bb0c54bf173378f10784d4b76701db22ee8d66ef8d2356c070b9150ac188e092a1b5e649776eecb6092832277d65c7abf385aeaf0de7c89a9e6bbc1bf27f53477a9d81fae3f0e50e80c13f5b3e8fe13b86e0a9efcadc2a5a11018c418da0d13af3ae4182026b61087c3df826b3af48f3b57e485b41beee6a3c5c678eb11543371100ccc2b94d6a1bb8a09258be4320a47ef09a45e5c96c2ded19925a8e5bc6e588259050e492090a82b8f356fe32e0c9c38c46bed6ac65ed98dd488c1302438031ca1bfdce6362ef175bc3b6d0c85d9a1df606c6ab360f40cc41cd6a8156e20cda4e91c8034b6185832ca02c2d68ab5bc195f42e5c4ece756b41686e615a10468ef2b1e78053862c4a222ac0b32e3a249123ea04d42fb3d8173b3869d4619fbac40fe5063c20c24c0a5ab2ca97c9b08002d06717a07ba0e9a34dc480a54b4b381aa43a3def22b7743e9c002652ee261cc2b3cc2520055c4cdb988bed980a9994988957814280243c3f72583a6549cca97a0a3b4e6afc49bd02d51e4e3f40766963497f1bebc00063199e278130515481ab0d608f3f4a009e4872ee19ba18258ec415a81dd5a7cc7a37ae4c2ead7e180ee587ae5cc7c1f3565f086598dab0d50b20eb88aecf10a1155e7d906c517dff70cbd00e2b5cd4b266f35cceaa487b376ba7067621f826305c997ccbe2b674b965f6f67bffad589677099abcdf766f1f092d3720fc799a8763592d4fe43359f8dfd927e704254a9fc11ac9ea40c029cf932e31164e0e3410c86119f35ff7f245733b7b75a0610781f10f0f3ba76fe3b7785e89ba0fc463560d3b707509e7dcf5f72816f30ced6d03206315c8b1f1377c76ac58a37eef4eb394a4a3587719d1e21d3302479e6d3c3335f027d4353ec2f4fd9c751abc6e08f32b26db645aec34c70939a9b03c8a574def491ccedba7bf69fd115180026f8b375fdb21c87f2d1b4dd01c9535ecc601755c057352964e6dedf025a2b2e04a07c80ff4eb27ccdced9c4df8eaeca0335d46a2d2775cd974def165fab5aeaea73aa75385fa0a75e559b0cee1718a98a1280cd84d9dc6cfd0ba68c5df671cf6d058c14268a35f5fec064f6c4b3adb39ade619ddd417ab7974b6cb20b686b40335a36a09ed02a4aea21b0eb468b4d234fdf6703476606e7570bb3ee4919d85d0b41a2caae676f7377941f3e064d8df7c5319c2f78f8b8f7bf446736c98feb1408787659fd30d59a042ce54dcd0d156314faa0e9ee788c65e91115b031f8ce8530795466456ba279c9214b740e53eb647cc3a34ffbc3afc93bb1be6b71cd18a9adcf2dc42756ecb21ce44f99f138aa9fd23fb089688b4b82aa9a81a35428ee97d22e09490c0441577981604cf42b82134fc7332fabba84a561089f31af92b80ad37e874f21e0c3603a51756569d1ba57a5a2e675286885f84d3b6de5b7a474441e4251e7cedb8446cf17c1c14c8588073fe4db5e239cb9db33dbd39b8e52e47645386ddd5a7719a8b30c6162c21f2597ce33262c7b640822c325d1c00cad19fd5457d0e9af2be03d0ce128f6d8fc8d9ede91a5141ea1f911010327b9a4be86a842bce09f6ea551b08e4faf5c54120592dc40179cc9324e219575eae3928c03f600a7d6925a31932819ee65defbcfd371663c34e64517e07836158b33993688513d5a07ef6933dff828ddc5a216595599e8f844fad4c15905ebcf707c7adbdf240ce098219f4c773cc6502866741d302ade30158e018b4439014d8e19ad34eaffd45f5c522c268cbe556a715d27da2c9e72e33bafdec6ea9dfcc76ca0cb5102e664b9fe576400afabf4ae53111a3a2ec64039e142e9902ac733c38274dac8cc246d148299f0a976efa04fdc74d04a2a945e82e2850862c59a3ed5331250603729628bce6f71ce10391dd9d6436533faa01e1128958242740b67aa7ba67cca493bc58c3925b9a957bb6beeb7bd9cfbb5bf605fd42b01e95b4e8b1951a60da06ddeb714ef54599687cf0f3229e93538edf1a2c6eb342aa43763091876e0644a502c9a87657795b2139626f80d7fdaaa5eea9122b238c29f513bebe5a224cf3e26bab3846d1782d73d7a5c91ec27262059e7d7ffe72d3047e51043e78999b8cb608cc2eea478862cd7c158c3711e431efa5b182cca05a43ba2ee943da781c4e37f01349f6df9240bba499cf4c08590c9228a680737881489c7affc448df16e1083a22fcaef1ea5e9b3d9acfafd5bde96d6e10c25aad23bb49592d7efa96522f2dc44e89ddadc3a271e2baa5144076056688d30e736cb29f913e0f5646629d7c55e007bbbb4e75fd1ec4f60d8cfb0de70f4da72a582a5522d4b93b5ec9bf700102b8585443ac04fc7e16e55706eaf11673144e6d23a78089c4dc0f8e815104478300c6770c57780a2c1378451718512dae21d3cc2f7ea1cba695b992be8f1c2721bee8b72f5ce98957779b39f4c7eca76094945510b870b20fd27b8314fec3f00c8df7a344e0735c338638aa7332de62860eea3e2f19623016f66b6fc40d31067fb79a6b7a89475369317e63c436b03030c1504674b3b706681066678e28135a631ce4f15e16a185e148860a85df3df518c7fcffc3cff9a0022bf03af9a8e07a1f20d3748c2e8b3e8d321e69337f99eed5a90f0d8d9a6d625fe0f18fc9ca96aece14b32898c7779adb43ec4ae69e5bd895e2413bdcc0238d75b1819546d04e5fcfa2cf5ee22f7a4f620776e6cde6c6557e0ad04cd7e2025bd0477685933aa105aef9978fb79da0eea76622a92de8ab0d3a2ced46a87d7327181528d99e86e31cf5b2da342b692edaa4a5fb2c9ab17e71ea69adfb0974a88d478fe21fecf28fa5b2687ce5c1689eeac8d2436b77bc574387e299ccbbeb9df8a51381f109462e5e13b34c0dbc4153184c802b9081605bf3210333c8c4ae9b43bb74aad8e391b1bd0ebc8b1bd204c35346de015f4894057d271841b54539136ec3f0e536f62b22b520df78a47b0648bb9679e01bf45eaac393d3e2be1f0e1781e01b1d96fdf8eba5da9080062516f0c0e81d50e9d684d19bc19e7c49a161bbed20732840bf0766298dd64a923485c3ceaf593d1031d3fc78f56c3c58bfa093a0ace4dabcb3d29e7d629839fcf59ce46d910cc3d66290ec4e754f78e2b1283095c19908452546a533162ac08627c0645b6f142e7a50bd7e6276c1a320007708a8c24c114612f39e910e9a8b248a6c431c67dcd92fb17fae9dcdaf35e3bfc56df908da39a210c02297dd277cc7579654d7679614943611a07ba81bdc1f6b01cd0f649c56f74041a2a970a4b8b504a7ed2cb8e3954d6c66f8466870f53185a62812db091070085b1f6e29d270f4a1d634b02dcb603622b2a14d8df000e198f89be92d2caaaf6a69a59d617d7428bc90c61d87d1068dd00539e31b6dd2e465fbcdac446d54e321bc498c476acab67bc35a551318920493c223caaffadec15916b87558e873ad3788477b2b7251af2d37c939e4b7224dac81b0020157641b248190a6e765ad0b2d9011c4df1b2f6b63d7d2061d81ca32ecf37e83827e9d5e5db60c462822409257b3049d1a8be8d710d38fdc101fc875e71db561459cac65a5918763b4dd6526f9d15707e829850cb8229de73000d308b3230d397e7174371d21a9753e3d558357bb5f3df2426607e32fbf62e4cc1bcfe29df95a6c6db0c4767782db9f4eb6eae7a6dd1361722a19d60e689b0d0d40f76dfb6d9850086063e7e5cc6f63add169926b41d6e8874693572ac1c914276ad60b1220cff534201dac82d49fcd7bacb240a7cceca486a4daa3f79de7bda08d803b9a192197904ba70a1f2f8dbec93b64e36545a94ab3e30907695c5323408d2adda5408359fa2b7bb13accbec0c3763aadfd6a75ed8b24b749eb47e641829188442c6c6c370764c05f0d607f4e9e6e2ef821bbfcf498f46d40e24be0775842d6af3b1af5b385a48aac6450d6875e0326ce5f94d0151be08c2ab757091dcf39f6852d8efc5436d674b71b1d6dfbcd7af04a1937aac077dbb908378430f9926a0177f587d95c13574c9fc5f6917eaf4dfb3be78908e44ffff8efa2ee1f5e627738e97f54aa66a529eb0a3601ec2ec238fed6cd6906cd960767fb92047803bcbe5c2e69199b7e6265e963c76150ce6fe588bc17e7f1fbc3040026b044c4de1bd509af6ae1b1bf44a3dedb921c9090d8f3bc6c03d032c3631ad9de4af46c7638310d9eab4d45584df9fd1498859516744396459478f2127413bd0849515f2cf74723704f7af965cc0e34a0565f499802545fc017a9fd2d85d65feb4117443e83d8b9bb8e5cdfcda12166dc4e647bcda6359089f43c263400eeaec0f2c7dd8603bea03d651e8e9f52489bbd89fab4e77c350f09a170fe7c06bbbea44b1ed57491a6baf2c1d24c31ab3883c9093a676af7506c678e4607942a1f2d5c568e08432e22d2141ff833b780ce49677e2cce1a4c94ab1ae433892cf5239cfd19199c96bd012866e166452244c15dd5f2f7b66ccbb1fed5ce8412d863a16abb9418c8de657286d10e352b93fcefd325f9d855b147d289a7610e60ad85c488fc34c6b04adab8f3ec60b6f19b9b803dd0073cba1048cc16fc6d475a4eb11f28fbb50ba7a184585916efcde9f6946f6a9124c6010c717a94e4f43a2324db4ac885ea3245fb8cc906df0f1d55ef3c900caeeed08ea8654dfc418399d577e86594a94d16ee1cb65cf61e9793c310d52af73c6c03f0815f8775f32dd414e040ab809a9bf76253e090f60e344cc37bd1cecb3196127caf1052a1b11b072a60ea7b65d03920ede17ed7dded90f3e1a546d9042ee7dcafab3b90f6dbc43edfbe442d9aae6b4d2c188775e4562616dab4b2fcd8bdb99ace200f4474d6d9eeea7b0d049865a06968c87b7950eaedf620a5a568b8b875002dd01b1e54cdae701e4d94519aae01cc11afe9f04e267cc37b4c3da04268da06bfa6b5cf7ead15fcfa2581e6cf48c2a45a6978b251d4104a52fad0b1f9904020735e2fb3abe11f75ae96703b926f80932d6639feb17cea6c767bae39c987769f155cb2de5f74397832b607dcaafdd56eeab4dfdc1deaced63e341a20886d304c687f15c42198a20a3e2fde35ecead07a07957ac4eea4f86025d9430c5f88c48d5b88b6f2b5702b590c17600e8e1cb25003fd7dbfc531d6d1f489dab1c35c13e98fdf5c907018455f367c9c00a47bc44e512f876b57be4d646a09e5466251cced09a1321f1f0f0f06719d4228828486da418ff57768e052cf6116da04f2a97985534cb828578826ec3e54cc0f5d3022dd8a557d2a2f92fddfe7de7c9df091c8015b00ea0a132baf2a9188f5127684371c507ac6e8d8773ea14d78b950e50d081a9135fa943df5f84ab15669501283bd16db29fad251c7f880fde488a95040741854ead64c0d33e837ad8be1f1c4a9954732d60789b5db215e04453a66d7322067cf7f0b0db217b38fd471893a46f67915c3ccc50f6097fb304492a7ca318bb9d009ed2cb7eb5a02272bf3bc2635e28449b1527b03c783b926c5fd828adff351b64abd480111238c9147440aa819aad132bbd09e44f7853a934319ec7f427dfcc94e9a205eed3d3caad72079b18c8e6865496d0e6f40e7240a15d4a3f24ac6393ec2c9197edb106e2d9780225526622be151f0d35dfadfc32a8be35902bc42240dfb251c4b449cf661fe2185f7de8439316d68bdf26370c376915abec04b812cb5d7bad77db1d8dbf920fb195c8a6252dd7d17b25cb92f13164415998cd7a2e7ca1fef4d20457bf2b1f2337c84a3ceee9592fd09fdef491229a7e1b83a3b9ddd1e3c88560bd90bf17d3007185c9725c6e7f790c943161520d9ce6f6fe74bdc6eb81685d3ef8282a2b77919b4f76a138d558d46dc049c6bcb5f863f6ced2c129c4ef14de48385160f391fc8502212ed0bf775a0531e16e1bbfbd02bff11b557f97e7fc3d021e70ee19009f68072c1377111ed73edb6f15c4181284e14d26f57fa71fa17c2f0f578a6cb62564471f83c56faad428521e08c3829ff733e00d5a17cb7d1dd19c5a318590235d6133b5b3af50a8e8b452b9ae3f1e04df15724b2bf3a2690556fcdd572b69dc0088048f6d6c8edc9a344579b0541dc7f6a3729d95503a2c4cb22e6e3dce20a293e997e292a6df9cd606de2aee8338eba057f6a10cfec818d3a79db40e24701dd29345f1007ea1d5d1bbc4b2662f22699e96689c8b176c0de167d3800071231d0b48f4567f2adbe703949d957e138ac4caf2c87ee10b07c6c8913e8f379e7e24d48e833336a82f2a49bb52dca31af4bb844fd5e085c508784f4a91a9baf43cdd45c6490ee05d4287b2712ea2f63d964270105f7cca1664070482c56403da81dce621bb1d6c1be532f93411e041005901b3067428aa89e1538cf14115ec1d836aef9f8876a563443c9fd79675905c0890661fdc545cd5a38562a124201e6cfc7e78ca30b400bdd3f1c15ca8eea45bda5ed8b5365b7c31a3ffb34780b83f90fcc2990d44f8ab2a5127d4761c7da6a83c5fadf37c7d14deda7bc3ed7db1fdd432f9436430bada36d1d7a050ecec18df89f4fd8c41ac51b6964194f3bc256c4ccd2a4df7d5ab77908f7c3c7687df6775cc590e7b12f3a55aa24acbb616eb1822e4ce7f49448de1234b960ed1a17</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/Vue/"/>
    <url>/2024/04/22/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><strong>初识Vue：</strong><br>1.想要Vue工作，就必须要创建一个Vue实例，且要传入一个配置对象<br>2.demo容器里的代码任然符合html规范，只不过加入了一些Vue语法<br>3.demo容器里的代码被称为【Vue模板】<br>4.Vue实例和容器是一一对应的<br>5.真实开发中只会有一个Vue实例，并且会配合着组件一起使用<br>6.中的xxx要写js表达式，且xxx会自动读取到data里的所有属性<br>7.一旦data中的数据发生改变，那么页面中用到该数据的地方都会自动更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;初识Vue&lt;/title&gt;<br>    &lt;!-- 修改页签icon logo --&gt;<br>    &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;../images/vue.png&quot;&gt;&lt;/link&gt;<br>    &lt;!-- 引入vue --&gt;<br>    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    // 准备一个容器<br>    &lt;div class=&quot;demo&quot;&gt;<br>        &lt;h1&gt;今天是&#123;&#123;date&#125;&#125;,这是&#123;&#123;name&#125;&#125;的第一个vue程序&lt;/h1&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示<br>        console.log(Vue.config)<br>            //创建Vue实例<br>        new Vue(&#123;<br>            el: &#x27;.demo&#x27;,<br>            data: &#123;<br>                date: &#x27;2022/8/11&#x27;,<br>                name: &#x27;jyd&#x27;<br>            &#125;<br>        &#125;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h3><blockquote><p>用于解析标签体内容<br>写法：,xxx是js表达式，且xxx会自动读取到data里的所有属性</p></blockquote><h3 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h3><blockquote><p>用于解析标签（包括：标签属性，标签体内容，绑定事件…）<br>举例：v-bind:href&#x3D;”xxx” 或 简写为 <strong>:href&#x3D;”xxx”</strong> ,xxx同样要写出js表达式的形式<br>Vue中有很多指令，都是v-xxx</p></blockquote><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>Vue中有两种数据绑定的方式：<br>1.单向绑定（v-bind）：数据只能从 data 流向页面<br>2.双向绑定（v-model）：数据不仅能从data流向页面，还可以从页面流向 data</p><blockquote><p>双向绑定一般只应用在表单类元素上（如：input, select）<br>v-model:value 可以简写成 <strong>v-model</strong> ，因为v-model默认收集的就是value值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-<span class="hljs-attr">model</span>:value=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="el和data的两种写法"><a href="#el和data的两种写法" class="headerlink" title="el和data的两种写法"></a>el和data的两种写法</h2><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><blockquote><p>通过一个对象代理对另一个对象中的属性的操作（读&#x2F;写）<br>1.Vue中的数据代理：通过 vm 对象来代理data中属性的操作<br>2.Vue中数据代理的好处：更加方便地操作data中的数据<br>3.基本原理：<br>    通过<strong>Object.defineProperty()</strong> 把data对象中的所有属性都添加到vm上<br>    为每一个添加到vm上的属性，都指定一个getter&#x2F;setter<br>    在getter&#x2F;setter 内部去操作（读&#x2F;写）data中对应的属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>何为数据代理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">let</span> obj2 = &#123;<span class="hljs-attr">y</span>:<span class="hljs-number">200</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 给obj2添加了x属性，实际指向obj.x</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 通过修改obj2.x的值达到修改obj.x的值</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 这就是数据代理，obj2成为了obj的代理对象</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj2,<span class="hljs-string">&#x27;x&#x27;</span>,&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-keyword">return</span> obj.<span class="hljs-property">x</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    obj.<span class="hljs-property">x</span> = value</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><blockquote><p>事件的基本使用：</p><ul><li>1.使用v-on:xxx 或 <strong>@xxx 绑定事件</strong> ，其中xxx是事件名</li><li>2.事件的回调需要配置在 <strong>methods 对象</strong>中，最终会在vm上</li><li>3.methods 中配置的函数 ，不要用箭头函数！ 否则this就不是vm了</li><li>4.methods 中配置的函数 ，都是被Vue所管理的对象，this的指向是vm 或 组件实例对象</li><li>5.@click&#x3D;”demo” 和 @click&#x3D;”demo($event)” 效果一致，但后者可以传参</li></ul></blockquote><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><table><thead><tr><th>事件修饰符</th><th>作用</th></tr></thead><tbody><tr><td>prevent</td><td>阻止默认事件</td></tr><tr><td>stop</td><td>阻止冒泡</td></tr><tr><td>once</td><td>事件只触发一次</td></tr><tr><td>capture</td><td>使用时间的捕获机制</td></tr><tr><td>self</td><td>只有event.target是当前元素时才触发事件</td></tr><tr><td>passive</td><td>事件的默认行为立即执行，无需等待事件回调执行完毕</td></tr></tbody></table><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>1.Vue常用按键别名：</p><table><thead><tr><th>按键</th><th>别名</th></tr></thead><tbody><tr><td>回车</td><td>enter</td></tr><tr><td>删除</td><td>delete</td></tr><tr><td>退出</td><td>esc</td></tr><tr><td>空格</td><td>space</td></tr><tr><td>换行</td><td>tab</td></tr><tr><td>上</td><td>up</td></tr><tr><td>下</td><td>down</td></tr><tr><td>左</td><td>left</td></tr><tr><td>右</td><td>right</td></tr><tr><td>2.Vue中未提供别名的按键，可以使用原始的key值去绑定，但是部分键位要把key值转换为kebab-case（短横线命名），如（CapsLock &#x3D;&gt; caps-lock）</td><td></td></tr><tr><td>3.系统修饰键（用法特殊）：cltr、alt、shift、meta</td><td></td></tr><tr><td>(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发</td><td></td></tr><tr><td>(2).配合keydown使用：正常触发事件</td><td></td></tr><tr><td>4.Vue.config.keyCodes.自定义键名 &#x3D; 键码，可以自定义按键别名</td><td></td></tr></tbody></table><h2 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a>计算属性与监视</h2><h3 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性(computed)"></a>计算属性(computed)</h3><blockquote><ul><li>定义：通过已有属性计算得来</li><li>原理：底层借助了Object.defineProperty()方法提供的getter和setter</li><li>getter函数执行时机：初次读取执行一次 和 当依赖的数据发生改变时会被再次调用</li><li>优势：与methods相比内部有缓存机制（复用），效率更高，调试方便</li><li><ul><li>计算属性最终会出现在 vm 上，直接读取即可</li></ul></li><li><ul><li>如果计算属性要被修改，那必须写set函数去响应修改，在set中将计算属性所依赖的那些data数据进行相应改变</li></ul></li></ul></blockquote><h3 id="监视属性-watch"><a href="#监视属性-watch" class="headerlink" title="监视属性(watch)"></a>监视属性(watch)</h3><blockquote><ul><li>当被监视的属性变化时，回调函数handler自动调用，进行相关操作</li><li>监视的属性必须存在，才能进行监视</li><li>监视的两种方法</li><li><ul><li>new Vue()时传入 watch 配置</li></ul></li><li><ul><li>通过 vm.$watch 监视（<strong>要加引号</strong>）</li></ul></li></ul></blockquote><table><thead><tr><th>配置对象</th><th>作用</th></tr></thead><tbody><tr><td>immediate</td><td>初始化时回调函数自动调用一次</td></tr><tr><td>deep</td><td>深度监视</td></tr></tbody></table><h3 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h3><blockquote><ul><li>Vue自身可以监视对象内部值的改变，但Vue提供的watch默认不可以</li><li>在监视对象中配置 deep:true 可以监视对象内部值改变</li></ul></blockquote><h3 id="计算属性与监视的区别"><a href="#计算属性与监视的区别" class="headerlink" title="计算属性与监视的区别"></a>计算属性与监视的区别</h3><p>1.computed能完成的功能，watch都可以完成<br>2.watch可以完成异步操作（如定时器），但computed不行（因为computed要有return返回值，而return不能写在回调函数里）</p><h3 id="Vue中的this"><a href="#Vue中的this" class="headerlink" title="Vue中的this"></a>Vue中的this</h3><p>1.所有被Vue管理的函数，最好写成普通函数，这样this的指向才是Vue 或 组件实例对象<br>2.所有不被Vue管理的函数（定时器函数、ajax的回调函数、Promise的回调函数）最好写成箭头函数，这样this的指向才是Vue 或 组件实例对象</p><h2 id="绑定CSS样式"><a href="#绑定CSS样式" class="headerlink" title="绑定CSS样式"></a>绑定CSS样式</h2><p><strong>1.class样式：</strong></p><blockquote><p>:calss&#x3D;”xxx” ,xxx可以是字符串，对象，数组</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;style&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;changeMood&#x27;</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//阻止 vue 在启动时生成生产提示</span></span><br><span class="language-javascript">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.demo&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">mood</span>: <span class="hljs-string">&#x27;happy&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">style</span>: &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">border</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">text</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">position</span>: <span class="hljs-literal">true</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">changeMood</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;happy&#x27;</span>, <span class="hljs-string">&#x27;sad&#x27;</span>, <span class="hljs-string">&#x27;upset&#x27;</span>]</span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">3</span>)</span><br><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mood</span> = arr[index]</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.style样式</strong></p><blockquote><p>:style&#x3D;”{fontSize:xxx}”,xxx是动态值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleArr&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;changeMood&#x27;</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.demo&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">mood</span>: <span class="hljs-string">&#x27;happy&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">styleObj</span>: &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;40px&#x27;</span> <span class="hljs-comment">//这里对象里的key要用驼峰写法</span></span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                <span class="hljs-attr">styleArr</span>: [&#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;20px&#x27;</span></span><br><span class="language-javascript">                &#125;, &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;orange&#x27;</span></span><br><span class="language-javascript">                &#125;]</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br></code></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><strong>1.v-if</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;n===1&quot;</span>&gt;</span>html<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;n===2&quot;</span>&gt;</span>css<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;n===3&quot;</span>&gt;</span>javascript<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><blockquote><p>v-if可以和v-else-if、v-else 一起使用，但要求结构不能打乱<br>v-if：不展示的DOM元素直接被移除，适用于切换频率较低的场景<br><strong>2.v-show</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div v-show=<span class="hljs-string">&#x27;n===1&#x27;</span>&gt;v-show&lt;/div&gt;<br></code></pre></td></tr></table></figure><blockquote><p>v-show：不展示的DOM元素不会被移除，仅仅是样式被隐藏，适用于切换频率较高的场景</p></blockquote><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><blockquote><p>v-for用于展示列表数据<br>语法：v-for&#x3D;”(item,index) of xxx” :key&#x3D;”yyy”<br>可遍历：数组，对象，字符串，指定次数</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) of filPersons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>    &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="key作用与原理"><a href="#key作用与原理" class="headerlink" title="key作用与原理"></a>key作用与原理</h2><h2 id="列表过滤"><a href="#列表过滤" class="headerlink" title="列表过滤"></a>列表过滤</h2><h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><h2 id="Vue监视数据原理"><a href="#Vue监视数据原理" class="headerlink" title="Vue监视数据原理"></a>Vue监视数据原理</h2><p>Vue会监视data中所有层级的数据<br><strong>监测对象中的数据：</strong></p><blockquote><ul><li>Vue是通过setter实现的监视，且默认Vue只监视new Vue()时传入的数据</li><li>Vue 不允许动态添加根级响应式属性</li><li>如需给后加的属性做响应式，需要使用如下API：</li><li><ul><li>Vue.set(target, propertyName&#x2F;index, value)</li></ul></li><li><ul><li>vm.$set(target, propertyName&#x2F;index, value)<br>三个参数如下：<br>{Object | Array} target<br>{string | number} propertyName&#x2F;index<br>{any} value</li></ul></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.$set(vm.<span class="hljs-property">userProfile</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">27</span>)<br>vm.$set(app.<span class="hljs-property">list</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;lemon&quot;</span>)<br><br></code></pre></td></tr></table></figure><p><strong>Vue.set()&amp;vm.$set() 不能给vm 或 vm的根数据对象（vm._data）添加属性</strong><br><strong>监测数组中的数据：</strong></p><blockquote><ul><li>Vue2是通过object.defineproperty()来劫持数据，无法直接劫持数组</li><li>数组中的每一项是没有自己的get，set的</li><li>通过包裹数组更新方法实现，本质上就是做了两件事：</li><li><ul><li>调用原生所对应的数组方法对数组进行更新</li></ul></li><li><ul><li>重新解析模板，进而更新页面</li></ul></li><li>Vue修改数组的方法：</li><li><ul><li>push()、pop()、shift()、unshift()、splice()、sort()、reverse() （这些数组方法会对原数组进行改变）</li></ul></li><li><ul><li>Vue.set()&amp;vm.$set()</li></ul></li></ul></blockquote><blockquote><p>向其所在的节点中渲染文本内容<br>与插值语法的区别：v-text会替换掉节点中的内容，而不会</p></blockquote><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><blockquote><p>向指定节点中渲染包含html结构的内容<br>v-html有安全性问题，在网站上动态渲染任意HTML是非常危险的，容易遭到xss攻击</p></blockquote><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><blockquote><p>本质是一个没有值的特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性<br>使用css属性配合v-cloak可以解决网速慢页面展示出的问题</p></blockquote><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><blockquote><p>v-once 所在节点在初次动态渲染后，就视为静态内容了<br>以后数据的改变不会引起v-once所在结构的更新，可用于性能优化</p></blockquote><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><blockquote><p>可以跳过所在节点的编译过程<br>可利用它跳过没有使用指令语法和插值语法的节点，会加快编译</p></blockquote><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p><strong>函数式：</strong></p><blockquote><ul><li>函数式指令调用时机：</li><li><ul><li>指令与元素成功绑定时（一上来）</li></ul></li><li><ul><li>指令所在模板被重新解析时<br>参数为（DOM元素，绑定对象）</li></ul></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>放大10倍的值: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-big</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;n++&quot;</span>&gt;</span>n++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.demo&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">data</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">n</span>: <span class="hljs-number">1</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">directives</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">big</span>(<span class="hljs-params">e, binding</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, binding)<span class="hljs-comment">//e是DOM元素，binding是</span></span></span><br><span class="language-javascript"><span class="language-xml">                    e.<span class="hljs-property">innerText</span> = binding.<span class="hljs-property">value</span> * <span class="hljs-number">10</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>对象式：</strong><br>配置对象中常用的三个回调函数<br>(1).bind:指令与元素成功绑定时调用<br>(2).inserted:指令所在元素被插入页面时调用<br>(3).update:指令所在模板结构被重新解析时调用<br><strong>总结：</strong></p><blockquote><p>函数式即为对象式的简写<br>分为全局指令和局部指令 Vue.directive(指令名，回调函数&#x2F;配置对象)<br>指令定义时不加v-,但使用时要加v-<br>自定义指令里的 this 是 window<br>指令名如果是多个单词，要使用kebab-case命名，不要用camelCase命名</p></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote><p>Vue 在关键时候调用的一些特殊名称的函数<br>生命周期函数的名字不可更改，其中的 this 指向是vm 或 组件实例对象<br>常见的生命周期钩子：<br>1.mounted：发生ajax请求，启动定时器，绑定自定义事件，订阅消息【初始化操作】<br>2.beforeDestroy：清除定时器，解绑自定义事件，取消订阅消息【收尾工作】</p></blockquote><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>Vue中使用组件的三大步骤：</p><blockquote><ul><li>1.定义组件（创建组件）</li><li>2.注册组件</li><li>3.使用组件（写组件标签）<br>一、如何定义组件？</li><li>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别：</li><li>区别如下：<br>   - 1.el 不要写 —— 因为最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器<br>   - data 必须写成函数 —— 避免组件被复用时，数据存在引用关系，防止data中的数据被修改时会引起所有引用该组件的模板里的数据都被修改<br>简写方式：const 组件名 &#x3D; options（配置对象）<br>二、如何注册组件？<br>1.局部注册：靠new Vue 的时候传入components选项<br>2.全局注册：靠Vue.components(‘组件名’,组件)<br>三、编写组件标签    <br>    &lt;组件名&gt;&lt;&#x2F;组件名&gt;<br>    &lt;组件名&#x2F;&gt;</li></ul></blockquote><h3 id="VueComponent-构造函数"><a href="#VueComponent-构造函数" class="headerlink" title="VueComponent 构造函数"></a>VueComponent 构造函数</h3><h3 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系"></a>一个重要的内置关系</h3><blockquote><p>VueComponent.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Vue.prototype<br>让组件实例对象（vc）可以访问到 Vue原型对象上的属性，方法</p></blockquote><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><h1 id="vue-脚手架笔记"><a href="#vue-脚手架笔记" class="headerlink" title="vue 脚手架笔记"></a>vue 脚手架笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><p> |—— node_modules<br> |—— public<br> |   |—— favicon.ico: 页签图标<br> |   |—— index.html: 主页面<br> |—— src<br> |   |—— assets: 存放静态资源<br> |   |   ㆐—— logo.png<br> |   |—— components: 存放组件<br> |   |   ㆐—— HelloWorld.vue<br> |   |—— App.vue: 汇总所有组件<br> |   |—— main.js: 入口文件<br> |—— .gitignore: git版本管制忽略的配置<br> |—— babel.config.js: babel的配置文件<br> |—— package.json: 应用包配置文件<br> |—— README.md: 应用描述文件<br> |—— package-lock.json: 包版本控制文件</p><h2 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><span class="hljs-title function_">render</span>(<span class="hljs-params">createElement</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;html标签&#x27;</span>,<span class="hljs-string">&#x27;标签里的内容&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><blockquote><ul><li>1.被用来给元素或子组件注册引用信息（id的替代者）</li><li>2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;h1 v-text=<span class="hljs-string">&quot;msg&quot;</span> ref=<span class="hljs-string">&quot;title&quot;</span>&gt;&lt;/h1&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showDom&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点我输出ref属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SchoolName</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sch&quot;</span>/&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><blockquote><p>让组件接受外部传过来的数据<br>一、传递数据<br><Demo name="xxx"><br>如果是数字传入时要用 :age&#x3D;””(数据绑定的写法，<strong>这样的形式代表将引号中的东西看作一个js表达式来处理</strong>)<br>二、接收数据<br>1.只接收<br>props:[‘name’]<br>2.限制类型<br>props:{<br>    name:String<br>}<br>3.限制类型、限制必要性、指定默认值<br>props:{<br>    name:{<br>        type:String, &#x2F;&#x2F;类型<br>        required:true, &#x2F;&#x2F;必要性<br>        default:’jyd’ &#x2F;&#x2F;默认值<br>    }<br>}<br><strong>props是只读的</strong>，若确需修改，那么将props中的内容复制到data中一份，然后去改造data中的数据。</p></blockquote><h2 id="mixin（混入）"><a href="#mixin（混入）" class="headerlink" title="mixin（混入）"></a>mixin（混入）</h2><blockquote><p>可以帮多个组件共用的配置提取成一个混入对象<br>一、定义混合（在一个新的js文件中）<br>{<br>    data(){<br>    },<br>    methods(){<br>    }<br>}<br>二、使用混入<br>(1).全局混入：Vue.mixin(xxx)<br>(2).局部混入: mixins:[xxx]</p></blockquote><h2 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h2><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><p>1.组件化编码流程</p><blockquote><ul><li>(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突</li><li>(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：<br>  - 一个组件在用：放在组件自身即可<br>  - 一些组件在用：放在他们共同的父组件上（状态提升）</li><li>(3).实现交互：从绑定事件开始<br>2.props适用于：<br>(1).父组件&#x3D;&#x3D;&gt; 子组件 通信<br>(1).子组件&#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）<br>3.使用v-model时要切记: v-model绑定的值不能是props传过来的值，因为props是不可以修改的<br>4.props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做</li></ul></blockquote><h2 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h2><p>sessionStorage&#x2F;localStorage 的常用方法和属性：</p><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>setItem()</td><td>保存数据</td></tr><tr><td>getItem()</td><td>读取数据</td></tr><tr><td>removeItem()</td><td>删除数据</td></tr><tr><td>clear()</td><td>清除数据</td></tr><tr><td>length</td><td>数据长度</td></tr><tr><td>注意事项：</td><td></td></tr></tbody></table><blockquote><p>localStorage需要手动清除才消失，sessionStorage随着浏览器的关闭而消失<br>如果getItem(xxx)对应的value获取不到，返回值为null<br>JSON.parse(null)的结果为null</p></blockquote><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li>一种组件间通信的方式，适用于：子组件 &#x3D;&#x3D;&gt; 父组件</li><li>适用场景：A是父组件，B是子组件，B要给A传数据，那么就在A中给B绑定自定义事件（回调函数写在A中 ）</li><li>绑定自定义事件：</li><li>触发自定义事件：</li><li>解绑自定义事件：</li><li>组件上也可以绑定原生DOM事件，需要使用native修饰符</li><li>注意，通过 <code>this.$refs.std.$on('jyd',callback)</code> 绑定自定义事件时,回调函数要么配置在methos中，要么使用箭头函数，否则this指向会出问题</li></ol><h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><blockquote><ul><li>一种组件间通信的方式，适用于任意组件通信</li><li>全局事件总线是一个独立存在的部分，要想实现组件间的相互通信，又是自定义事件，那就要满足两个条件<br>  - 满足所有组件都能访问得到全局事件总线<br>  - 可以调用 $on ,和 $off 和 $emit<br>一、实现全局事件总线<br><code>main.js：</code></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span>h (<span class="hljs-title class_">App</span>)<br>    <span class="hljs-comment">//beforeCreate中模板未解析，且this是vm</span><br>    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span> <span class="hljs-comment">//安装全局事件总线</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>二、绑定全局事件总线</p><blockquote><p>谁要接收数据，自定义事件就绑定在谁身上</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;自定义事件名&#x27;</span>,callback)<br>&#125;,<br></code></pre></td></tr></table></figure><p>三、触发全局事件总线</p><blockquote><p>谁要传递数据，谁就触发事件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">methods：&#123;<br>    触发事件方法名()&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$emit(<span class="hljs-string">&#x27;自定义事件名&#x27;</span>,传递参数)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>四、在销毁前解绑事件，提高性能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 销毁对应自定义事件</span><br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$off(<span class="hljs-string">&#x27;自定义事件名&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><p>1.语法: <code>this.$nextTick(callback)</code><br>2.作用: 在下一次DOM更新结束后执行其回调函数<br>3.例子：使得input框在创建的时候自动获得焦点</p><h2 id="过渡和动画"><a href="#过渡和动画" class="headerlink" title="过渡和动画"></a>过渡和动画</h2><h2 id="Vue配置跨域"><a href="#Vue配置跨域" class="headerlink" title="Vue配置跨域"></a>Vue配置跨域</h2><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p><strong>1.概念</strong><br>在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信<br><strong>2.作用</strong><br>多个组件需要共享数据时<br><strong>3.搭建vuex环境</strong><br><strong>4.流程</strong><br><img src="https://vuex.vuejs.org/vuex.png" alt="流程图"><br>5.getter(类似于计算属性)</p><blockquote><p>用于将state中的数据加工<br>注意要使用其前要先在 new Vuex.Store 中添加</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getters = &#123;<br>    <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>) &#123;<br>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6.mapState &amp; mapGetters</strong></p><blockquote><p>写在计算属性里，用于简便快速生成计算属性的<br>使用前要在组件中<strong>先引用</strong> (<code>import &#123;mapState&#125; from 'vuex'</code>)<br>key-value形式：<strong>key指的是模板中的写法，value指的是store中的写法</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-comment">//传统写法</span><br>    <span class="hljs-comment">/*sum()&#123;</span><br><span class="hljs-comment">        return this.$store.state.sum</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">//对象写法</span><br>   <br>    ...<span class="hljs-title function_">mapState</span>(&#123;<span class="hljs-attr">sum</span>:<span class="hljs-string">&#x27;sum&#x27;</span>&#125;)<br>    <span class="hljs-comment">//数组写法</span><br>    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;sum&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>7.mapActions &amp; mapMutations</strong></p><blockquote><p>mapActions 用于生成于actions对话的方法<br>mapMutations用于生成于mutations对话的方法<br><strong>8.namespace</strong></p></blockquote><h2 id="route路由"><a href="#route路由" class="headerlink" title="route路由"></a>route路由</h2><blockquote><p>vue-router:vue的一个插件库，专门实现SPA（单页）应用<br>一、对SPA的理解：<br>1.整个应用只有一个完整的页面<br>2.点击页面中的导航链接不会刷新页面，只会做页面的局部更新<br>3.数据需要通过AJAX请求获取<br>二、路由的理解：<br>1.一个路由就是一组 key-value 的映射关系<br>2.key 为路径，value 可能是component（前端，用于展示页面内容）&#x2F; function（后端，用于处理客户端请求）<br>三、路由的注意点：<br>1.路由组件通常存放在pages文件夹，一般组件通常放在components文件夹<br>2.通过切换，”隐藏”了的路由组件，默认是被销毁的，需要的时候再去挂载<br>3.每个组件都有自己的 <strong>$route</strong> 属性，里面存储着自己的路由信息<br>4.整个应用只有一个router，可以通过组件的 $router属性获取<br>四、路由在模板中的使用：<br><router-link>路由的组件名</router-link> :路由的跳装链接<br><router-view></router-view> :路由在模板中的位置</p></blockquote><h3 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由"></a>多级路由</h3><blockquote><p>在父路由中使用children配置项</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [&#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/subject&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Subject</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/students&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span>,<br>            <span class="hljs-attr">children</span>: [&#123; <span class="hljs-comment">//在路由中通过children配置子路由</span><br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;lb&#x27;</span>, <span class="hljs-comment">//此处一定不要加&#x27;/&#x27;</span><br>                    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Lb</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;jyd&#x27;</span>, <span class="hljs-comment">//此处一定不要加&#x27;/&#x27;</span><br>                    <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Jyd&#x27;</span><br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>命名路由</strong></p><blockquote><p>作用：简化路由的跳转路径<br>1.给路由命名</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/students&#x27;</span><br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.简化跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;router-link to=<span class="hljs-string">&quot;/students&quot;</span>&gt;&lt;/router-link&gt;<br> ==&gt;<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span> （此时这里面不要再写path）<br></code></pre></td></tr></table></figure><h3 id="路由的-query-参数"><a href="#路由的-query-参数" class="headerlink" title="路由的 query 参数"></a>路由的 query 参数</h3><p>1.传递参数<br><strong>to 要加 ：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in p&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;`/students/lb/msg?id=$&#123;item.id&#125;&amp;title=$&#123;item.title&#125;`&quot;</span>&gt;</span><br>          &#123;&#123; item.title &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 对象写法 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;router-link</span><br><span class="hljs-comment">        :to=&quot;&#123;</span><br><span class="hljs-comment">            path:&#x27;/students/lb/msg&#x27;</span><br><span class="hljs-comment">            query:&#123;</span><br><span class="hljs-comment">              id:item.id</span><br><span class="hljs-comment">              title:item.title</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;&quot;&gt;</span><br><span class="hljs-comment">        &#123;&#123;item.title&#125;&#125;</span><br><span class="hljs-comment">        &lt;/router-link&gt; --&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.接收参数</p><blockquote><p>$route.query.属性</p></blockquote><h3 id="路由的params参数"><a href="#路由的params参数" class="headerlink" title="路由的params参数"></a>路由的params参数</h3><p>1.配置路由声明接收参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/students/:id/:title&#x27;</span>, <span class="hljs-comment">//使用占位符  </span><br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>2.传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;router-link to=<span class="hljs-string">&quot;/students/666/你好&quot;</span>&gt;&lt;/router-link&gt;<br> <span class="hljs-comment">//对象写法</span><br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span></span><br><span class="hljs-tag"><span class="language-xml"> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">    name:&#x27;hello&#x27; //当使用的是params参数时，对象写法里只能写成name属性，不能使用path</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">    params:&#123;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">        id:666,</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">        title:&#x27;你好&#x27;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">    &#125;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml"> &#125;&quot;</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><blockquote><p><strong>让路由组件更方便的收到参数</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/students/:id/:title&#x27;</span>,  <br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Students</span>,<br>    <span class="hljs-comment">//第一种写法(不常用)：会把对象中的每一组key-value值通过props传给组件</span><br>    <span class="hljs-attr">props</span>:&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">900</span>&#125;<br>    <span class="hljs-comment">//第二种写法：props为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给组件</span><br>    <span class="hljs-comment">//（只有params能用）</span><br>    <span class="hljs-attr">props</span>:<span class="hljs-literal">true</span><br>    <span class="hljs-comment">//第三种写法：props为函数，会把函数返回的对象中的每一组key-value值通过props传给组件</span><br>    <span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">id</span>:route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>,<br>            <span class="hljs-attr">title</span>:route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h3><blockquote><p>作用：控制路由跳转时操作浏览器历史记录的模式<br>历史记录有push和replace两种写入方式，push是追加（默认），replace是替换当前记录<br>如何开启replace模式：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;router-link replace to=<span class="hljs-string">&quot;/students&quot;</span>&gt;&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><h3 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h3><blockquote><p>作用：让不展示的路由组件保持挂载，不被销毁</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果有多个——  :include=&#x27;[&#x27;组件名&#x27;,&#x27;&#x27;]&#x27;</span><br>&lt;keep-alive include=<span class="hljs-string">&#x27;组件名&#x27;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><p>这段代码写在不想被销毁的组件的父路由上</p><h3 id="路由中的生命周期钩子"><a href="#路由中的生命周期钩子" class="headerlink" title="路由中的生命周期钩子"></a>路由中的生命周期钩子</h3><blockquote><p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态<br>1.<code>activated</code>:路由组件激活时触发<br>2.<code>deactivated</code>:路由组件失活时触发</p></blockquote><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><h3 id="hash-history"><a href="#hash-history" class="headerlink" title="hash &amp; history"></a>hash &amp; history</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署</title>
    <link href="/2024/04/20/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/2024/04/20/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="前端程序员如何在宝塔面板部署Vue-nodejs前后端项目"><a href="#前端程序员如何在宝塔面板部署Vue-nodejs前后端项目" class="headerlink" title="前端程序员如何在宝塔面板部署Vue+nodejs前后端项目"></a>前端程序员如何在宝塔面板部署Vue+nodejs前后端项目</h1><p><img src="https://www.bigneck.top/#/article/ca66d3b6-ac5c-44d7-b1a8-464def149ff5" alt="前端程序员如何在宝塔面板部署Vue+nodejs前后端项目"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>卷积神经网络</title>
    <link href="/2024/04/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/04/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f898ae34ff7f38905be3f967fdc9e07ef8555e0866d8a09f8dcde9bf62290b91">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df75c0e3690dbcc249f2964f77d67927844583d6bf34e8f1c72e165594f0bca0e7de95287a1e9cd72442919a1c04e5268753fbaede16dc3e2d9c2fb957ff10ee4564cd07a3c12ec69e185d2b34799cf751ae0d8fbad5d749f0e4bdf44deda9396b2e91857061e625a15abf0df48167c2d68a1916582d26b0d035af6b90240af6dec2a62b67c70a0305e579ea1abefc4f988b447b0c71d604291fac422ae8bc84bd0c59c910e44581841fbb0cf0115cb1b2b310755554d3967a5c66af94f87e3f9c3a25d7a730bb6963f48f3aebaf3b22018f94d8a32cc071375df1766bd0c6ba35c4992834f2bff4894123d469cc6ca33c97b18c58aade10a7df659c47bb710bdb0770491eb9b8f8eb1c3f0a4497146d459fcdbe0d52c5794c93a7a2bc99e93a7c865a93385339145569fe9d3a9e2a79c1b908531336b7a098fa0c1fccb57be775df0deec2803ce827ff677a2c94033b1d692da75a60aaa6311ac1630079e58d74763701e4e0bbfdd6a39f84adca2b57b279566d3d6a56620699a25bc8e51a4f8bd7b9eaa12fdcc2d641e1b31daf37803b25f2ccae2d1e4b1acfbfa01f63420742feb62fd1b0f8fa19abba27a849c17ee5edf4410fda32206c716f25a7d65361e9ca240459a9a9c267f5eaab4bfec722870b2849835b37b73254ccd83e7c05aca7124c1f7f8b8f0306bcb40cd2e7641295e3b3dfc1073ce5d8f603d530befbd2aa4f869222a3f2725b57a81320ca14dab9d156f0de38f33739d55a1f3fc6b2308c8de9b55462b892dc42956d01864b3116d9325fb554feeb092dc2a0430d587001dfd4ba8287b82e86639afc0ebb4ac5dcee80bb378d3abf218665a0c2ae527270ac98ff3a006faa963a4a7242417e353813305d35504cadc747a5ad8c95092015b6c4dce30d60bb2b582943e0d110c28c6d082359e4673712bc8d30fce9c1500c13b9be7d7804b24c70b11cdfbe48dfd6e26fd23085dbccb88ea12225306f3c19044ac74e3749d89d3a617bdd45c583ec5a221a52cb2468bd46f83253c537adc5b06f174470c68ba094daecf0ba5020b6e680cf808c7e09d767fb0b892b6145393ef81da2691105a8df93ffaf0f5f6d02e9d9c87c577ce999723186b12787bc4c4f057547f1db73dc72d57fefc0b65cb391566060d1007ac9376096315bf0a80f2e65fd9cdeaa7a5e5e2488d972518cff072c9990619818af3644264d464ccfada3dd71c5559e9cab52aae69d49a176ef32f39dfcc7ba796224159a657ffaf495d56b8baa77292d114f5e344f9f2f6ec3f89e40b19d981fc6cad99c87aff22fab44af86a668565fdaada396abdf77f28f3a10afc639257ce76d48192aec88622b75762308ff168a40b8a9cd91a20b5d86b81fec4840540e6bfcc53785ad14e3d95fe73583a8e760e8d2dcca01d32e380f878c3bc0b1a06464e52f4180c10ec16cfd13f56bc0c98d3db4b7287039c2f1b0a54017c2c19dc8dd6da5e71953b610c9e8cba6fd13ace62a8b74b432650a467ad6c32b9210763488199ca6efb17f40167a8dab008f617a5facf6f9d4cbfd78d82ad94563a5c4e505966ecce26f659709a9251fcd8e882d36e7da0d590e810bb8bdb0331583180a5a508c549f289e6d1d179cb7120422598fd7153f03264ea6f8e1c14f5c50ece5d60fa0960ba65ec599fa80c4e90bd152a0741228eddd29eab1a823904f468d81e41583ced3247fe79353ed2bec1ceff3188453d0b83868889b776f8d21098dc93457dd39228d6cd57ed56e405d517383f3499fcd131b1ac8c407d60bee7b3cacc6e7a9e5ffcc795d4a510106e487fd721b11470837dc60951e7aa4c742becdb425058846ef5fe96cea13aa9ceef4e465731886e00e1c189ebc9089ed311e02e6ee97f4295a5c5d9cfffefff243292736b4a37df2f79848fda5141368915dbcd390bfdedc08bfe5079bb9838db127216a8cd7d5f857f238d9c425cc30927ccf13b506c4d329d7d5d9d1e30d81afdc0c4097eaa17f781cf54a0b0716b916dc13bb4e2aaacd202d4ce16b95a0683f7d334fe5fc52dfd892b3e6899e67af46dae7347e13d5f13a77c40ddf35e4ae8887535fd8c8bf3f3fcc397cb0f29f7be619837e9b76ca055d45bf969b8eb4beaf82d40b71adb51c5d6a238c6e4d080e5bbf45fc0b6f6e1d40dca137d57d5ce464a98699377d1dc7dfea6eb6f34e351d552fbb00f66e4ac7956cf53d783f587914f17eea57e23cf1d67ab9f62019d77d5ae9e85336246253d7848e1721f20ce6b20494bc98d408ce1d11de9677dbddd8753c3aca8516e3ba1c8314be06d59125f407f8dacddb153b4a0c6bd18e48b1602da17901dc089dafeab448fc8de35535fbebeaf66894bf35bcbca8fb8dcb81ec1d45d12109283fe3c81e5323e121faf55319444f8aa945da9a434081b9ec08dfed49f9a3a200994dbd25d2e418f27502c8bd0fe57bb650f41d9db096a0bc4d3f7f07971981ea2f176403fbd172c209076283e608da24d4dae7a64c17daeca995d1faf2c76a678a462a3c974f7adb2f1d4cf32f82d47033b0ed74ac5fbbc593ceb4555b7bfc5a5c32bb642496003a4c7f939ed3eafbf34b1dda22d130d0b79ea2fa6add4103e1fd9b0bdef350dbc4b790c1704f03cc1ed1f161eee6cc1ed1a66267c18b0de5f9ffc96bb286ec80fa1dc42fd0590121088489b5d38ddcbe9df93bcc53d0de6d6dbe575cd95973a10a04e9f87325d9cf2f9a54254cfb551e25fa7df3d604f579ca30c9871b3b4aa87b52dfab6467f231cbc8c1f331b74437444c8bbcc575700462fbdb3fb4c7dd25233bec971ef34f05941ea9281fb6eb3c6ef7b3db7f480183d7e1cf96f21c200ca2ad7646ec836d93494340fad2345153d867eac60c3d216335501a2c6948d7b05fa76a8117dc645ad88902045a49ecd5355cccd1af1251fe1e7f18fd93847a698145b20e9a0da7f9a2a4dc2f1ab14e7fd4348b4994c7202b145dd019019931dd529f09b468c7b353ee37143dee5d4d515eea1e54c0531e945621c24e0a12e019397bb72004c71acdc58c74dbc65a2f424f57650b241145c8797e0b5e49cbcf51f31ff3e4515e66aa12a7bf884e2cbcc1b807a68733894c7d3b18572656f82894982ab1d2e7856dadf11875e9382b947ef1005f259e8f9b804d1a26cf476d13c69734c7bbaefcecbfddae298b0478fce76f9ad2ea3e2da9d1d3749c385d764d2f56147c5d42aa93ba5ca2719131c6467595da6a9bcd2179cbb31537444283ee07eca88031c2bbc203a06790abe74115f14167bc1730bddc25ce91561f61e9696d4a66a85db7b0bea9816fadc3186e9147b05d403467c84e032b3bb846cf863ad1d4045473e0c290817a2e83452668812dedd431353f98a7a6d46185c290daf1680650fb22fd83403dbf935a69ba291b3719e6e184f8118a8233cbeda043e634b296eeebaa41ff414b821b8a1d113022a0697529f3f4efbe0e04e08824cc06fa6dc009fe401a31b7b9253dc544efcb6fb10c38c66b4a1245a741c1fcacdc0d162b5dd5e8886c5e89e31daaa6fed1a8b59910c87681658542aa5c584e964c9d9564354e4a75bdd43ef6306c8cc7f02272e4ec56f1a19a83588405862cdee29daab866c5801bdea619ba10f7736f14dfe3116eb0f1db1264429b90acbf9136e8ba80595bbaa3affe76a499dff2b36e779994edb2c29c44bb3fbce3a0eaf7ecca9470c7e6487cb7216d48dd40e8e427094680df4e452a5eb29646573acd94d51afd7045cdfdd0b964ed9fdbcf94c2af3cf7c03fefaa26a0d31f4af380b2d99635551d1e59d2729d4b6d26328ab45e6054d6216749399755b4934350d30cf4bb3463a40d6c40264eac9744f50a1a486290762f080a8a27b246ec6c3b269373b0a8e2ba4bbadffa435dbae258b56ce359be6f7ed9523fee13bd16b581713f9abe3ae383c8c74d217f894b4fac7a307cd416398d5628c9aa58f04450bb5e242e24430b0133aa594a4ba7ca803016e7aed64c2564c8cf9b5375e8ad190ec22737f5657a0ff614bc201c56235c0a44c4563d2c48bda66a7c0146e7cdafe075f8ea0b4efb8d5d797fbf047f0588864bf61949c5529c943b4b136dc789cc0bf75bf6ade6f4f7148fb9c77c4b2e4edfe166359e6e0dfd507b847a762dd0295b1fea674e918058d16b7aa9505b65ebc25804a2f26bb034fdb0d722f0db37cd97684417c6ac685090158761f0392374e9b72e2d0a78511c1210e55bfa9ebd96e6afc75dac912ce8c8cbd738da944f3a3191228fb63c188bcd746b2537a64fa01792e301e4d99e8233a7ea9e24fb6cb5c1bac841240d8eaa62c96eadd1562d1c8bf3cd8db8692de9695f733494566eaebaa22b238f35172b1831751ea39298f834b5527e9efa2c00a417f0f001f55b359b7f3eefdca0ee06bf8dfbc858e67f48ac55978838e75f30ac58760a7878952441b8164c7e8f5cd07148cbdc483126a6d0e740938fbf92833564dcc07aa8c47edb9bf9f227cede0512fe90f45c15cdb1328114cfbfdbdb1c5f3232c42913d09d6d6768e1b58f0f4743532858312f77c0053818d5f80949f04eeefcf714706fd507644f657789d736cd60e51e011e9c44572d0c03bd501400d5feaf7b781cae3d061443dc26598c6d524d7b54abd78764850f4e1a0bc8cc2509f9c698b752261e2b11ccdfb1612e16152b9e6a5eb288189add49c23e69ea7f18c833e54eea1d92df851b3f46ed32b38d64537278542bb1efa116cd403c3f9ace8d4686292642933913a73b1cf22638fa48f7746de78fa14f20def83b6affbe23dc83ed25086ad4ef5dc8ce47f630dea5101143022808aec4671d63221f2b63f2316a0ce54b70c8a00706945b7527de3db58c4599a696bb4755e8e5a58a627d09e0955c7af9a9161773383bf8b02651fe71f6c18d5295f595c1605710213e9eb1afaf7deb00b3824e344c61ed2ea469e977517bab85ebd1f7b5afd8cc4dc4abe212dca4d9f254cbe592ea10e31ebab3ff7f7f6bcdf74fe2e2b0777e8e937c23fb5035fef360508cce2e3488a878b9f89ed03e60b825a620904833087c3713dc54796c958b853a34150aa32a5616503dba2d244d3b9c4b24dbe1753cf5794f9c87d76895e6216bde8ac0de47c868a6593ba3e6ce3d07d3458476355717b0f7426267ff0edebdd4da007092adcbe784dac93dd0478779193289dd0fc41b192115fb76dcd06f2715345e5cdb5a0b862214ec04641433aeefedf7980087b7f1eb53e790135b9b238a24a8a584cbcbeb4ff8fdc838e896b892738e47f9e3c319f7c5285dcc83ff77a77f9b94dc150486735bb2080a5594eea4af5a99e321c1c03994ddc064ee4d66559f8110ced8580bf04a42d15e0b5f0b8b7fb64462137ee9775e97e0187c33def65e4534af65549ac9ba31219c1b64b7439f3377edd6cf411dd787a062cc6cd05c71bc4eb86c1898c097fe7f5f8e8e944d6fb817254aa4e16dc318e5150c921b821b9a1af34b5b307a1027f2d5015c8711bea15eb1630e43d415e3787fc471d2e7e288d64188a931c5bff9a2ce41405c29c6f3a84d1d17bed5770f2d24e9ada1d382a6a282f02cf3a01cf3bae9a9093417a091d032b59d8e804fd6e1daae16264e1ff7fba7123c63e70cbfa1fe8742e748f6874e5c2bb461846922a6c824ecfd3b33cf1b8088b7ae823b6aabc2cddf0a6b1a2864a2f1c0862ddfd97fff71c3eb9b830c78432740b670abc08d27cfcd3765dfdd4b880d910648696e0f0a602c8927f255cef919fcd818ebab7bd7d0d9c8e4e20d8b0743ae60207fef153712a234aeccf994c202b168c6a306f00a16e3e72c00582868d37f8f9bf78923e75308ced84ec043dc600059f308adf18d1f9be2b9430c806f66601c505bc9becb6c0474fae9e8c27b343a980c817ad70a9777a0e11e9f6d91b36f563ca1904f4cd667658e0a9c48a02d3eb5599de88ff5bf7a537090e15cf6369f312f668e57857dca1abda9eb4a55c61e5deb2e309f0d0522cf6cefd5574a3e07c796dfb656428f8d09bc38ece065fa670335ad1a0dcfc128073539bef97afe87032f19e1725fedf9184d4a87cadbba2f1718cf261ef43fb2573745090db9421c5b2259109c93b8f880d20097e66c9e2fa6b5dfbb3ec87b02f3dad6cf5f6885aab0c45f4fa27ce616462822f11cf0738f55ceb9706e39335081cb410a0321df811bab92df615c3397ec8f3358e90997d14c63052cb217a640a6a1a559de1e7c032ef72ca06757243f5c73c215d83bbe19383bf8b8ab1ff86dd60dc6f0ed7dd38a90ec72fe9b9be78570b6c612784ff4ec04039db62c58eae7c5afa138e0de6b0e263d3a975c9f5de10fdc7b322af422657702d66f2f233f521d7d7f5baf5ffc6a133100fd77a57dc5478596916626af91b1f27e6c7a7d007308da0eff9a1719654cbe8391dffc976def014664fdc45ce91c4dadcce6f551eb9bb08513c80db8839b15a430baa64800dabb56b110b904387f359a0ffd1b94c5547f2a2f394f81ed96322fc7dda909e3158df94367094f6e065aacc76a33e23532f2e49c4753d93968ea5b2ba8b9428fb58d69b2278da84b2663cc6becb40215c01d68cd47bf39b4236f028a19f4cefc45f0a902e7d2fc2de3fdc69c1b8b9ebdbd297cede2a5ea384003d151906bfc33ace5c8c9d8b0c4ddd5eac068b065200171d37b1fae3fa22c11e6c9232d5dc508fd82f89e311d04034a70da76063445371899cde2ba069e16f984c12d4e367e70f136e5daecedb8d8f1ab9d0cae4344434717a75272f856c751ffc105f265e99c7a76c6e1f7ab167ed4cdd1cf22a0b8fe48b6575d63b8cd634298297b645506b965a494ffd540884a42961230ad3371250820e038448054f67a32c1f48fed5efbea2029be4d697a60ceb575e921d2d7c97e4cdcff5c7b1b561417d39f7ad474ea208a85ee35027e677361d0a6c03a5d95650829e1d59d9984c91001679859fb7983051d85df39115af7f13155d9d928f421936109d722078830f6c0ea33e46a6d904b8ca888fd99e297cecc6ff2372558bb6c9731c11610795072e92e9d059fcea54380ed4cc4666ef3cf16d257a5bab41c1f25dfcbee0e5ed4218b77378662870de4fb3109da8a3309f5c30a42364999be38db4e6d575c95d64b9e6a6ff5120cced635ffcf0eb59aab2ef6c094cbdf990e8051a1709483754d94ad208b6391568498ed73688210b76674bf0cc0501a6ca5a9759801b33a396b7f14c380c4984d19638de8493a95834525be79a77f58078c9dcbecdb52be609782b07c73bafcb75e1bc7dbc469d7021f6dd5c6075c71a607229d181671d09330605684466e83148607f79e9fdf85950a5c4eb9286eb1c0172e59f4a2ee443b48562d736f1341dce4a3931b574b963d7d4e032c6d567718e21573bcaa03bc58217228a636c3899c297c43797441ed221f429fabc1ebdeb165320bada03328e83ce3adeaf705ef12671d27c402007758c7063caa99086fd58984208832c4a3571415fd75781c94141d8eaa69929022fbfd7811075adb883a6fb6d7fb0f76c117bb62061f58bdd71d622b40ff378949fb7a8d8ec9baa071f1b507bb2bfc6d12e5985634e4f24b0c5837a77f062812cabc900b7d4cfcc88701dd2bd19d6a5f4ca49382834154e6fa9e4892f40bebbf7a65698cdee9301b1a36c4382ab59bfb3d5a642fa621e8b2b3a0d07f152df508f8054f858cadbb9647b999644513467e4df2e995c3f578eefefaeb543e795504c3ee7eb844e7e8fe5d2ed645abfa330cce4c33fed99e7eeb06a99338a8a7258f883884ac63b2c23a186f556f6bfbeb8687e8b26a3a0348ed01064ddcbd0229c59aa9441e2c32add4a42f3b476c297abf19e97ef0dca1aecc2ccc34ae5a4cfbdc935f7c21c0ebccd6138351028e23f64c940a782dc0e26e83f14c790b8ee5380fff41ee0454132c40bea1e97f14751fb14ef7dc2848e24ec275fdbb81397bde77492d71d1db2004863a3c8bd1d48ab31611e688b79be8c0675f6c4974acf1fec5e34c7f52b1cbf3905782aa064d4547ee81406962bb06dd888e40598bfe287f2d66818a01bc41421d910c8c482d6d53e74632e132506739517febce36f6ae34d1e827117cd97ffd47c3e54e60d82897bad0aa5cc4c603f6f2393465d59caba9f430ae128d737e7f7bf72bec39c60a09da2151c4cab89971b44898a4f4f1982b007592bf5acc53f402c883e433ec471cc1f37ad0b31b3ebe9b3701405efc0e348cf74b529d5d36e9534ff9f1de532edfbbe7f7c93ec5b20177307967553537972e80240cfb4e6c244788a23bc13c85eb077425c7a365dba2de92d4b46a73cbb96176d29966a27f2e9d77bc7da3339a1f1c57e457f891b3107abfee966b2dd5424009c4cf678610f3af4095fba43cfc932ee07310a3e888de79ed3863119581247e032bd9d2890ee4f30d6c6360c3db99dbce0d60900e275e515b2466bf036df12c6c2209ab0773584754fb7144504c288d4631ba93f1dcb20fec0e1b963db1e76ac8a260347d1e22b45b2660c388c8e888f117e25b13070e32d68c1de08cb16c3ef06f22a7d462f9e8940c317a99da59cf7a1f2e2882bf24585ec16ced0a7e63db55053c21d21e8c3aacb9dd072f3c183c98ffea2c8c72921c043220e7ae892b80431b74f69a8d6d2021225393f606acb4235b135620b5bfc59e2d426dd32bdc1020f4aa22014e1dd9a1dbf98b598c2e8eae993ba37e8279c1c44b4ecd184d1ce900fffa077a6d860c934e91c6ec1e323653ffc8fce369e80b9c0cfeb05b8f76f464db020ab64036495319cff27451ef3193fea08ecb616fe7af0f875e950ab96b51084856b211aebae59945d170f63c19191d8a5e9adaea501c16abe87421560ada3363fb02f986afa5ca691e2e5ea353f2312331287de03d7dafafa00a56beee953209fa0efae905ac803bfd7e8cd64eafb23b694cae918b67c9ad065d3a0a3e5e432eabd8878ff23d53f89e7135595db24bb34c9eee6fdd5d833ce47e11e4cacf9201d689114bceb744fa793af13b2a67162b8ab6b2362f1c0737b2ce40bf0a2113255bb700799e18727d50f980fa26e83e24d6c0437f8891023215935992c993dbb88a4a23e3a87e7149f1dd9ca8d36a44366361c508556fcfc387d802283691dbdf7e76339b27792378b60f9adb94a7412a812d08d312433cfc5e76be03a43234c45c8deb6db89037c348b66d5c88175f9ff9d3dd2572522046e5f1998641cce39babaa01aacf918c091e8c9358c2a6e56b362669b0c1c804556629641697780a9a5ce5f6e302af2d1936c39fe40c48e5a67c458975784235eea0461dfa3a368f03c26e33e312792028c3ba8fc9c9db17f905395d49b87413e0682054ecd7ad3b71a058c515aa0cf9dbe89ecc92e521d3319f094ef7e77d4053f560ce2677e51a2aad9a3ee75cbc8fb1cb63d45ab22dbe55e5241c506554b077cb53a0ee1959d42eab01534a77146a61d89c987861961fa527c73b6ac9b298696a322ffd45de2de334595507d993ff7b9d9f1f05d0faa89d25d3889781a83c22a37ddbe04adc4b5e19d30938eccdea884c428c36af04ec1270721d44c55033739065a89ea651ee3d36485295866401cd8b654f0a6ba19d7d3de94e85298e96ef190ff8de42c37fadd31c0b05307bcbdc2d27086fe4f80fd2914d3beb2df62ff233efe81936658d4779e9c1883c33a334d5c4d9d7c056499b1235dd933c155260a447e87b3f569f3928e4fa1ce9f76d4c44db39e69646e9ed885cc3ab18e23e6354f65a43ed5a529f2512c816ba6046168b642e11cdc71e3f8856cbf3414b1b3712b10522630d41d23990fd0b4294a9d9a902f2552097b0e58273e1b861bc0fce201ad2a77cb5491257781549b8a70434342445cfcd8882febee1f23ff591dd7f656c79c85f41b68722e5022b9a3c374f9e73a658cbf9d40344d2af49b2d7895e7ff63638b1f56bb3fa2645cc92443f357a166e80a5ffed3721c7f9b286f21e8ee5ad7bfe74daaf04a7a81073c9e4dcadd24b81631e634bff34a97ebdba01c2e1d91a573959abe7bc7d7b51e36b7f2016696f76461bfe29f080a7b1f1635946819aa3a3e5580b4a89c7e85fb9f1fe8d5ea4f91f5ca6d67d69bd9e25bd12ea7823610a3383f81a68c3ff01640d34524880b8348a27127bb0383603f36434d11d4efa61d7c933db9a08fa2c2de2467046516056c2326e2e753e1c952badb6daf3b2f11e17273e34a395284990e2fe360b3780af27a597d8b627eec98dff12b88d18a1d9bedd0945f4a4131dace7cbc42a15b19ea5cf774b585d24bb52171a8acd12d50c3c907d9c00ba835415387795103b950d73b783a3ae22f2b62b5f2b43efaef589be12c77a1a2ea385289b95f571504a2ef1ead06a9e9cfabe0d351f7a5144f7b76dcdbb716e3470f3c202296b509b57e72d877e6ad2ca29211733563be2988f74c9b81b80dc11923f2fe74c7a22bcac08f3cec9cc8e8cd67f8e9834abe468b2a473dc7a0854d7880699afbdbda2879fafa4bd0e9d9ff9c18875541a1a75b6f9503206d0e1c95a16131c389e602f8b16ec49c5ed94631e53270771d9bad1bddbb1d2f0e9a6415b4eec91eba9b32c8a53c8d7e2924daf40858d1278e27e2f0f7c5377161facd92433ff33f03568ed307700c008cf7c42a482fc244b673b7b5d5ac028f05223850693aefffd5d7f2bee00bfc55baebcffcbe215741bb7f0df2732e5928b3b46098dbe26ca17cc03b86ff394ff909f69f149b87158eed860f1d38f10429f65b2ef08d02077762d277c6189b010fc67e4977665f4dd74b309427879a4835a7202b7b9d3f69a135053334593a86bd15434e5891852af4f02eb3423841e6995d7917cee0a6c8ca52af636dac108da04b8e95f4dfb759b0ce479f039e008bed66c2d827d43aeab73feb8274cbe4a5d49340ce9a27ea2ddcb235ae4320a83742b693df5fc607ed301349cc0ba8f0fb16486a048da5f3f7e6634de0f2ee4dd9556084fb4e4b2f40a6cfe21d4ea8ad714708fb84ad0b11c4915ecab890c7aca04e534984cc5b7d277e9cde9263f711791079e102065f753110fab05c49b6bdfe09a1b5c0b1b94d62b3f3edf7fb04960e872e1519afd48f0254d7391740070bfb5323194f052b6f20e4a4f5fb2c86d9200098a5820623f4fc1a61c828a4fd568c80a8af02d7c7e4fa11100003bb1ae004f00d48c3b7e14099d497034878387804503a85d40df7811693f789bc467bcd6e8529484e4bea230943ebae3db0a858b8711d2908a37173178e0a3a3f557f02d7eac1137fc2a0185c44fcaecbebdb9f6df9bbd0d16d2d0b514fbe2628ee30844a8939aa3d0d5b87576693bd59985eb337f0ee7e24c13b89462a13ee96aa768cc0333eae615cbd3c9cf5a9674f7aadbde8d5cdc160a8037e708d5b29eba5a076aa4e0811f075366d224d9669d4963c5b2a5a593be5c6362b8ed7cd3706e48eaaf7842b37884fb66e080c3654a45b0ea643b4f9e17860058ce69a24495a48648ec397ae76bb8c50ffd68c15054e88f5f7b92b4c706a92a67ad6515f52e20e3433b737a652f618cefab8bd002cbed52899f138febc8b6aa0c076f334123cbecdfb6d359609c4db859c4e549e30e1092ccd1ee2a00e7900e28933c25634ba316544767f1250779fc8d4eaa3c2e0f36eabedcc584153dfa056ee4e31806c5326eae86745c04e434aaf19fe5a16c889167cfe351af6c2070d949a785c20f53f879e65cf9b8af83323f568e92dfa525365cb119814dacf611940bf9dc83dcffae6270e34db796326121af0e6be63a42270c5bbf277e05c3a9e0628bbb3dc1ee097c5bd2c31b81734c2b94f587e821c792bd5f9d580a4de182a9889a5506348c602240626c736e94756a96421543916f0c0e18817417e732cf1039f02810dddfc2d7b34e19c3ab6626bd10e1913d58edaf2b02f38a5af0d1794cd48971b7d3c4bc9ddfee2fbcf27e299c2efee650ad22de2c5453769abd56f058207486b24d7b790ea9fdc84e23bffcda6d7cd48e2eed2dd79f168a4e7e2ec634c0e5d31e8f91bd007bffac7eb94d69dac0b97ab0be2fff163f5cf4464efefa94da644d9697732b150077aadd927ec2a9d5227d4efd5ac383f59cff5dd5314e52641d80851ccf6653720999d7602ce4197060b840cfda8124e1dfac3aafd942208a8d298b20530a34e29c506692a94b1ee9c93fecadf18bca5f9470179bd158497742072bdda7d01a74fe2c06e236411ff049e4e83559c695052dbe38536b2f0a08299d505e39d9939e2e47a9495e342e95c4ae8dafd742774ec66db8265c1842d94aa27b0f57802959c3ae7127e91077b5f3f6b9ba76d8a3611bb09196da351c496c873670e34fe8b072e77774cb98dc988a8ca529fcc53da95c28a8c356ac1e3b0d813e43488dfc47372e0510c516588e9a78460697435fae216c04009bc38842f5719c863bca58816795ce526a476fd2e4f7f2a200eac0718126e30dafc167c4c456cbfafa82d6bbd9cc5559c18241dd74d51a33b879f66e6500b53174064c896e3877714f10e04e670b511a9dd4df26773a6b59467cd78a60f34776155e8ac2aaf2e823610aba479319b19a32b50f95a58b18e93c10a159589853d74ca6e1cd0387478d8cb2590d5600abacccabee94908d2a6ea001e564890c179044a39722fea0ff04e96c3be81e75dc1107890d12bfa6e23c62c097d3fe4314b8e9599096749c2610d1773c7f2de7d3686942fbfe626136a5f6edff18a69d92bfbe98dfcd88bef47b51039f33d0c41170be19672f2fd80a33187091807d8f8f0c02d7fcf524f7b5525bfa527c800a18ac5083d474e59228ae8d6ee69935879d3d7c464c5c6640b0bc90061e13e82eb2d638397d739c0dc4f5922bc1cc1f6b0930b73ab0077a1c80261594927665f401f8fd8dc30f37b1ef0f2ffd071e26ebb9ee1d0832bfe60f7f1a48471902c774ff0bcfa8ba598a45f64c2bd54c3cab0b90c613f76be91cf94494c94f7442408b2c4377e885894da883e71cb2915ea92f2abbf7f94398f70590ccc6751d5fe5640a2916051b2120b04c8d1f5117058ce0c3fc6a7a6e619ad2c8e56aa7a6d619658bcddc50e1f6eb44eb90cca969931ec2dc325e5b8586a9ab01e5bf370e676978d2c32510057637da548522635d19946a868690b1d1d2d716836eae61d6d880af27c3969bfea856ba32a9a064e65e77954d9d3605c3b73277ba9b269a9d0cc8d7db6001caabc3229f43212acf5f33284810a3b92d341abc74b5b52001bea0179266fc4e80aecf0f1f4d1f47f8fd4120e41df81a11abe0518a825177c3ae6ee4aa0f6c8e7e9da41c09b9bb6e0888dd696fbaf089b2a2522eb3d1ffddc9a24877a5a570da002c9a5979768ae4d70f3c0efa84912a4aeac8407e1991628b28d4fdb7268a338a2472266f4d6afc259295022312aa02a58f312ad21fc099cd94beb01f60469bb725dd5994fe1b44e608ff154e073fcb4f56b6ed5d85ad91692319f75d7d82b223b0a7429bc26dde9fcbd7b8c9e657e15501a6d8254ab01089fe981dfe6b31718e8ac64aa49cd0c4c4236dcc8ee25850fb482b7f8e3b80154d14b36648fa54a4338aaa825d459094a62f749bbc3c77b92a697aad064ea463dd4890dd947c38fd4bf2af824743d47881629f7ef0178891d28c97788de0f44875bfde23963bf843e412fc255ab7f895fbb581b75112b140b6c44ad8cb033340664a6e117b71d7c8afff0b1a80e94ca95350b000b4c4ac170c2ecf3587b24def240faab732bedd76759a9f0eaa6167a96c33fa782a876e58930fcf2d0f299b0acda4bd196683d457d6b7b269b2b72c726e518bfcf2a3afa0fbec62165be15c2a26de61bbc0b114e61b28a4cbe01bca43a37785c14f8642e90260ea83eecae43ff5cc06fdb32d0a048f3930068cea74c3a9b6c15166b1c2ebf269219734d9e2bce24d491931b11deade2e6d5a5cd6492069479e1b715640ae1f7cc08c32df418dd77d9e02140229bafac6baf8fe9435b364734b5bcb5cd3303f6c2d15f033c31e7007f6364f130075fe2e1d22c315c7ffce31430851481a2b4d4530224c1dd210d1f89ac25dd98baa51b474f59b9e7b24151f6f6ca527869d57be908f4ab93d1df1a0f487a7716e9ab5a20ee9c9ffb5157a97a94bbf202c5a26ceafd8665569af91c731ffd206b23ddf3565cc51ee45f3a80842c14a3df7be561f5c6e97b36e758cd81ad81a7d44dae102d01e08230b77c2a3981c297cf891c127cc1dda20f4eba2b67739273a32e94953547c646e471fcc7a801e2d777a8fadd87ccf90cf76ecc81d35658aff7543fb9be8cc4caaf33ca38d3c4569a81d38b49de5cee11a878e18da5f4f2cd9c21c6cf9ae7a0ddbd5974f26dc9137726fde98e2355b1cdda7784f50f6c5a638066053548a72fdc21643577773959fb581c08517024bd51704c70d4f8407d85a4c82efb27ddd60a5414d95ac9851c5804090d114de84cd944ec9784f47918cb954e74190eb73c581c9345b167896feeed05e8033019cbdc43dc97279c78af796c5ba32b4096ab19384383a22222472f045d3530dab1a84fb477293cb553bc842f463f9ec6fc7a185a2032c9100498091528cc788cf3f18e7a9b3f63f6d1fc07d296962930a7b3608e432e8761c8a44479e6d57f3dd98c70c14b7e6b78e40142e04d1bde1f1049fb32a94f96e4fd03f2d2d4382a0e3eeb7a1dcb58b77091fbb8eda619781935be3fd8d3de01d4aa020673f95b36add017ed5976f81ba833b8bea8d032e2c6a825c2b6a14ecc1b25f5456fa598715d33c376df10960fdf1278843e684361e761fe1dcbffe1abd144f2cdf3f7429bc19c11bd2d24d3e85a121486acd45e2e70d5bc7dd341e6789e0c32bdfb3a9e11915fdaa7ed5590f69444daa76f51637b303e4e3b8751cea79f1df2e375ef17d5d9ddf8c01919e792af1b1949b3effc68b78398750e360d382ef5d7afc51d7e7d6ba93d8358635b5e81e1dc48c8809a07108e0ce3c3f534ad4d23a5ebff8215896fb697198759acd9a57acab73d686ac5642bb95683466e09af6cb3256e350009dfc197b87b4149a395520caa177121d1b47b4b1ff74d9a58b975c638d2c0f458c58a418ee3e18ff20998926dfbb71a834f9ec7a937bd7b88a60114d3910c34d41970356e6fc2343950e3333f7b88e4aadc60248b23702636864273d2c62e6a64cf9822315218683589edbd02931e13dd4d7a8c16c360fa7d95ca8f2e462dc83677fe2b472998f62dbb3ff0b19872007149b85346a4aba9d9e5c298d3a38e8321225da4fe7a5b4d173ba72a6f5abb143a310ff272dfc6e4884ea81f4cee210f4d1cc95d2435aa31162b3780c161ac1a16e7be4561cbae453a17a389085d6ccc3c6e5c0f4bfa8ffc46633d42c53eed4beae3edf6e07795b377be87fc50b75d6560773883e78fa2ef8b87f05d3df353b8d2b84e462a8b5a90ccf167ceaf304d212dc7c40ed98a737ccb072b3320be1bd03bbae654dd5e242a1651cfb82d61fd578294489b53f489de3fe0c004d67f7e783152fb76820b69ba44be6af7e5b22ab7bd6d4ebbf19da5287e359b25789fdabdedb0d221c47e56dd6b3702beb44f97c13465b64ea1e541b37432cf6600e034fe2244d7025227aa7f69633959e7ba1bc30becf237497584b95643e84b4935fdd46a22421ca1a0828d4f2a4eb7c7cf5159788b6e349021e934fb685fbeba3e465d456c573fefedbaaeb8961d8580107b6a783043176d322656ecd71ebaa3f68dc4f1e3ce0f4e60f4b4107ed5f10bc45e419945537d7b02e748d3330f0ce5a5c51ab3ad00a67008e85add2418f0c35cbc41268cad890e2afaafccfd83d4b038b16cd5fa76c856da8cd81236ec1e4f133afe84d0a84a4d2671b75ee7edd5d8489a4631317dc8f68db0b8649580d0769352378b8184ff7f29bea3acc33cb5c0b3c01a46e8bbb577753835e445722d154cc95e3a30411ecb95f2e57ce3158552c25c29067fe2063b34215e274935c20a458f107e8210b1fe6aac2cd6d08783c56f7c797d5456af4849496b8a3b9af3c9bacbcd0a2c29e8c5c707251cc9430b4b619f28c5e288ee80831378d36ed8c9d6f984a4b0524d9bed63cb20edffce35ae29a91178cafcee941a18766280dba3dde4d2079215a88231b6cfc0e19de63a5a1ce17723501f86924b08bc41fd831b11d68af920e171d73a6ef841615a9bcc6fad595c56576c9bba4a6bcee649e5927eaf57bf7a8f8ac59a5841ba5cea85211ccd38e7782b389dbab6e11c8bb9f2e99897df1689cc0be62804f7b27d2356b8a560aa38939a0cf10d6779e5a36a9d8d32aa30b4d1fc40fd102c9f6f5b2d7f33e32d0e27547173e5c3ce0c9418490fae6b027eea44b529fda42d343e133ddf70c40bc3d28671fe2d4f1d8702606c0451eeb7a51edca287957f455b72995f8fe9b4d7646ab31b5aa9b5ac2faba2eda35acff4b36f01b892713d8f487c50fac338aba50a6a3aec7c75fce054e432a2d66ef6cc0df71d2a52b7084ae09652390927f6e731798b9bffceb7b1cd6c80366748093fdfde863906ef9881ed284e795d441f5e2ce3bf7b3ff5ad91807e0a391ffd4832a24631345909563306ee21960a42c686a5b0dd13c4c537c0ae1f434478c2d7f805370cd7fa94aea51c0c6c13b8543717295133ebb474d4d4823cab187b6fa25bfc186d09b0eeedf54b2c29a3ac0dd85d69eb4513cfc1265dc8d3b5c7aba542917141279dcbc8eb32543855739d100e2be6b47faaee6c56fdbc44ffd1be9e3ac023323bc57877910989aec7f5165e032ea5c091a0dae7727bb6a08969e67354b2303ed37291679511eb96a993bc57e07a6b30549c59fbf7655275435b994e5589314fc46a34814ba25a27ce6f94f76e1ac9c66cadcaeb83cb768332f880d9ade37cde1bc50b3fa22f54d41b9543aa60a0fe3dfd951906f4195cf2466a69cfa0612c36f59ce8ab940acde009c04af86c4395417f860becff5c6bfc22be273906410bf0bbbbd41a171d9892eede822e3bdbdb923647a78c8f16e0626d948ce2c855fbd73c1cdeaa2ae170fb833dc9c5b3dda7494846e2455faa59dfbc87a4f6ad33242c6e23329e6bc16dc3fadcd05545bc742fe36e98fb7e41e60d641b2c6bc827dd46bbd822cb3311bfb1f2a1fc396adf07d855e2ad374c75e78601780cde93930e9539ffd165190980e96707716190b10bf4375df6b68e6a3e82628edbbef544efc91b5fa754437f6c7493591d8281d19a1b0e1aa8f7876cec342d1604b4636725cc743d56dc7b481cf99bdc46e58d38b9ef4af08006d07490bc99f1d52c57398ff222e3b1b67c8db7d58705c5ab203feb0daf3ea37bcd463428d1b6331a67b3ae86f68dd067492ca26143375907f2851c8fa8ab22134e25945d02a75fe92399cc99b4ee4c99c710e06392f5a7ea01c2af813f798a9fe39ee2facdac0cf56d887b04be92dcebda5e9cf7c09f77546cc5553be87fc7f528d9641b03574f7163da9cf773f334e07ba9263c9261a7a3082c80f52324a8725e8bb236fa35e2807b78ae6ac7bfd775d0adab9f198395c3afe6316975d7d19d6a551a57f8bfb8eb87632860a7f3bf33aba95b1a26ded3c0b633fbbca607c2627b2ead3ea7ab756e34891326d274650cce3993b89dbd322661fbbb7432d80dbd899167999cd337eb977b8c987790e99d370867a2cf88b253ff09204e8163b3836a64af632410ba85758e8af1314002bd612fae227574540e6ab9c04439051c6098b82ba4ad21b6c4bcbac5a53dbebdd0b5819eaa75fcb9c7956b93f7a2f3c592bb308fb471d4135983cf57184c7a3cf8682c617736358f38fdbd28274f5fb55c44b028aad1216f43b3159ca70abc324abe5a19591933fd6dad2342fbf7a930c8d8d0bbe0a9ffab700721dadac87a62f88001aa6daeb1faa1bd76a7cffe172e585e98c790403e59ea3a510803cd9bb8a25241decba173ccc458d7e8f05f63041e4ba8f52a8c89bf7ba39c55183dc42a95a2d2cd0d4d1d524996a660cd46564ef7aff06a93a9ecbfdb9ecfc520dfd03e4bef17ba820ef18bdd555c42ffb6bdd47347536ee87f4bf0f44e605fb29525b7f0de7df65f34248c40e26761a8ac93824f86aa9634b95a1bbbb6987d6a80bb07bb935620fd51342773c01b09f40ba08140092a93411fd908b47b421d50dfe73fc62c0101d6d64b2c69fd1737ece84920a1eb5d46688f3a93085c586970416e30a29937235f754399e2934144188a37ed1b81ba2a0906441313b930d12b7c5c3d1293034674fcbb72f9e1fbb4051d41869b3e914ddc563984214c4c287d4773145099091fe33c803e8a718d847112498c7f133030d9533100d2ac99dbfc1a6f95bc619e7911aef102ba3c1f454ad228e218452ab41ec3c56627d9432106ef001680f8f821111a56a0be52898cb0068e597d32cce12e92d49c4c01076e431f1ecfa0820e8ba136545e2a4fde39f8a398922b6fd6efe06d8877422b3a2d0c878cd388b0532e4eae641a1dd260d73c239f0b5a56fe3d0da94b1055a7ab44630bec3a47dff8c356751d2d2f03b901080ab5e3740481fb266fda4295911a6d32f01aaa4c55e605e467e0707c18cc409592f6864fa92383f5ce55cf20e2fbc55f574594a16a75c3981559b48738464c78880dd6df03a880126bcaa56991d7dac07984c3be1f22ad2c82bc070f0f58a8e5df7fcfa1cecf272f9f482f9020c712a3937b8684d067b73b3ba86a08c37f99a42d377d540ed947e9395b20934ef7b438fe26b30accc3d987d556146a025f12acddeb103d4fbe9a7494c53d9e862438ba1931c6823d1cf86349ef87d2c888717654f33977627eca543b0f78729e8dccb41c6373f96156f82fed5f01a00b7dd65ea98918ba2a6336170adde1530a1234bb8923cd83557f3700057e2bbee43e145df1afc437cc8797a7c6708db591d6bf9c718796210100fe6c98039004f084458a841521d2e4ebdd5efda9de58197773acd4560a87036db980e4e35e1002d30c07c5cf8f61d1c3adc78755f23a0f40b498a66c1fc99c10db857a8fa58904ba1d961a960379afd771c3aa94f0165c0705dc24c52bd46796b087ed5a0436390b678ea7ed5b0cf778e7e396e929c9818dc3ab8d70898c78edde9517c48263ceea26dfcd6f9e6250e5eeed1ea6b6b876cd3d1ecbfe026d1044f0c7920d966e5442e345a81aa86061cc14bf5f62e530004b5fe09d630b22d6e1514049fb560dac539c8d1fd7b2173740bb181df0d006b8891ea5152619fbf66570f06471dfec85e4a2333f9665f87747e73601ef9317096a7e872ff2d7c678a9366a112dbb8956458a611377ed8dced5b3335ba9dd921d4752496b1c6419db8250fdc76967c3c3ddf02f3482731b4029ac6eda06343893cd702789e5090839cf55746bea44fbb78477d73d16636a9857a14ee50ff8cc76dda2e332f701e4f4edbe420a72e2d4eb67b26023263f0ec992d832b09d5b0b914c4266fa62984f1159e4842fd5d3a3d824daada4b671b9935e9f09df94fcb21783942fd975418c7806c549becae9e92703d10c22a29c40bb99f8e1325a5c42b1317a575b009d56855f5ad8d3369063d2c45aa23390a6f00654fbe5bc11c55773cc43fb86650fc7c45696c34e4399a1189149d537d2a5cf4e9744e71521810240823c005e23cec29e1560e721e38fba8614c6b3ee723de6bc4d97e06972972b4cd596bf473a9ecc4e5f4279fecfa59661e52c1e58c3318a0df414f0bbc765bec669e245e1778198619bc020d9888b0606067570067426e445c4bfe3a9fa75199790c5fba25ff4e1c1de81a81f964c8a11e9315abd4b7d22fc918a7e4de5ebe7430da97524f4d9c2c6d4d4223b23c4dc96d05d2bd75d99a22a2a2985aa22681d128e4e5245ddd9f584ee5eb63d96d2a87ba80e6beeacd239f424920a12e398dfd400bfd9511a333beac908afae80d95998d45a586b1189ad3eb574a97ab7b18b963ad77c72a3e7128e6cb70cc1fcd64999a418490602dc1331188db99da3a24c34802bc6a9e63974ab15942e75634121efed5dac8d731677e809d87e3c4348d922d6a1fde85159b4a6df5be66ac9f48d85f928deb5393d5def11ba3ec08e8a7e2e00e3228c5749e30301cd8231236607e06cf9c37ca5aec067cd75027e653ec8e573cca14be970f7b9ba3b5a9fc80c52c0b5ddde81158312bb44a13c05389f66827318c996ba391229150c573d1de2b620cb880a0b727176b92d25f4f6caf73229bf478b11d563da9d9989c02901c9857113eb7f05da85b335caf9fe70d13b2e753ca37183b448b26ebdfe15ba8ab6b02fe005cce54f20ee4178ec27168a067d8d64ecc2dc71e94bb82f12aa562ae9641f17ec9293c2e960a9d8fee4c8e353d38627a0e19cbbd9f0487e50e67cc7a7ab15db67795214a50de1f5cb010f158400e4770e63aa0ac3411f758011d7d1b3059e92f0fa9eb7a0f197c8e0a4ace9bb2ed947b46d7bdbffac9ea1d5c76aafe6c1aa52fa5abaf8a1846f43df7e23f64ab7388ed2ae7a3d6d0103710924e1e30bbbedbeff96b1e9cc18ade02f0df7e691b19f0263ad31fa7611e788f4f41daaa1f8985e7c179a051be7c77e1eaae2271945a1b02be3847aba53d47815feda13bc5abd59779059e922dedfdaac2dd1727306140a1268f603eb81155ac2e6109e1f1d9d3fab6622231962a4a45ad302ff00ba954cd4acba06a8fae53e408e63bd31520dd535be501f05c7d169e74c4358951b7b945da6ca223b18df296593193e8a0c8cfea62a21a1fe5a6d39dcfe0e7cd7e7fe70c88cfcf9e33d1d354a9d68133e48d68a69648014c6841de474856e5c864e4a587c002cf13d682c0a44a042c19b737e36673cf199a5b0479fdb64e7ec5b661574a37f4c9f4463ad70fae1c733a03b9b92869f417fad02b6ef9918ad3efa54834cc2b3a98227722bc29b99c5099354032b49fe0e54c3b54ab5daab29ac867c403ea31fda038eb3ad3e5a8b59acfe4cb4fb0704f53b87b01aca8e72d0c83d2e63325892e2c1cf20d23b9e139ba37c4af19c2a93f18bdcaeb13e6af3b52def69179bfd7f06e570e564c383abdec09a4cba0941e0e0494c45f7a6f2998f06f41cde8ebade01c3310cb5c90e301a850660ad9f20a590e52b050224b868bd88c991a519dc50fb1cb86d58603fd24edab3d6e71ca35a5e958e8c3c302cb69ab6b8c70b2c791c9c7764191bf7ec2d5d1b05b79332bfe7393e2884a8f750a63c18002d5f6a66ba511cfcc55e230c6b8736c4cbc69cccc5dc0a40a2f2e009e41d675a929bc3b2bd48a16941f290a8fd1876ae32cfaf6f2e664557f44aaee0ebb752674a369c6df0f0a14183768fa1cf57f41fe6da0d71b2ab92b7f7b8bdb6aee701ba78c86a70772d5bada6df180ec20c7aa5d6c263deb89022003686d054db107e1fff1ac9173345de3bf45c6367a582b77e9a85609ef270cbe6c13961ff08e57b06ba01c461076e3beec0911946fc4d4d3a657b28a7d34a58786f2dacfc8e4936240684aa43ab3ad39131838da97234d7cd91f05bc48a7b441baeb91b5ecb379f7f5cddaada2d7cfb2efa91e91545666d24d479944ce4010f68e1293cad7d83a2d055218ca3f9a04ea3ee9d9b3243cdb0d487fef358c3365f8895a95ffc98189e7915061e76dd606c561eed04808b3ee567b0b50969c5b6688046611fad80d1454da2639f6182b4c963eb891d6dd374806a0ab261ba80c70118a6de1a66ac0265a4854855acdcabb8c23e0a2dc89820b6b6d6c469b8e48fcbca5aa922bfe812194987e5354f5c2570c9ba0486894fadb297a1f16114604a8c78b14cbf49c043fa2119d5a0d639b38f7d5a7951086dcab08ef3f0d7d7e33565725cb931d3c777718e62ee1a794ee492188ad97a17cda07f1cee90b7efc3b0faa23cc27c5a0c76bc9caab1ebe3a2cc4652ba4961f8374e9f01262c3c0b873b08ab95321c8053b541c695753d6aedaee4f6cb4143fd2572f6fb164761901ca4b722cd4c53e3c22bd37eab2e26ac364bf3bf69041909c0feec95b6297bf0bc6bd2aec8c2da7187270c0877c1ac2c25961ab9dfbd0a7ed8cb0d9a0bcdd0dd46c6d0700729d9a7fb7073eeff636e257f0533ef894e9d1f9eb0ddbaeeb279d75166a4c2cf5a6bea64bbb131d62ea1094521ad1ee8148bfbae41119d40381f56e23e1bd1a865f6a25a2f2ecaafa454bf40ac68c1286937f4883d4159e65e196c5a50fe24defe16e9b9471c02e916de4429c88e9a6d20be0147207a2b2d79f075152b7be6cca20828924e08a5eea1444a07aea7b7b3ef16c3846146763033d4454081049927ac6eb9aacef31fab9480a7bcd3c4cc43dbe7178e247fa72fb37b6a3de47628e72ce77ceea5c97717ead84344196f373cd9e0eeb03a860067b58ebfa5452e649143637a4093668bc60a2aeec321c84dfbbaf3a6c1c6f39798a6dfe571d00dd8a31174047159467c5ec3a2a3b0d66e8daaf061941ee605c3f46ced6024194f758e6f53d25deff28b46bf387ab3f5e524f946c109a5b989a13fb983888facce95f5a9ba443bde9f012b790226cc9537d9c6b4f09ceaebdabd351fdd0b055db41c1f625f65abea79d53727a3cf7fbf5b5fdb01714c75e97186229c5fa3cfd873f35e555df3f862c41da4bd3e10a7842f12eb2c08e197e41a200e9b34d2176e0d9bbae180a59fa43a8f0f09b523f0dca67d1d60e841b712fc20b1695d1af9f765b8b21c69a93c9a735c9b1e8b117b4e58063aa4211ab1d21cad2bce0a0842ffa6ea8909768abd0a260521d0f2cef046747db52e9348670b684b27f2f6570c385a8fff8dbbcd74292df04d06907bd3058168262d0ce6dcdd776a9adebd8a144d6121fd5c2feb1c2621ba5c58cbaec051300cea0a31db9b21a70b87fdf012fd1d1f7180a1d142c11f994d6a2497c1296cffb9b771dbe954c5cd877383a64966c9248b0e3dff589c2d3b3f7950900d09b25c25a593be181cf3a475d6c9a2ef49db34e1109c4431575d95360cde58b9c7ee486d8eef45374478438843792b1cf82de4f812c64073078df3fa13902b5e7db63c54921740cbb063d2bcdc3641635834757b46baa17c68cad0d20ec8592d70b2a8ac7a225d3475bfd8de2a1dda7ca3d512e920aca443276546ace51589f783786a4c9f34b90514b4f5fe51222d6049f027b52a59b679ec1ebca88fc2b4698dead24df3e20dfd7a9a9bb402a63c7b61451f8868d76c5658383498e48ffa780a04acbc90052d8bb307bbf8154691d43bb33bba4493775ffbe8a3d2ed39204afe219c4c75d517d458606e6c749139a7e6d61eeef4fe9d4d79549b4c5922e4e24df49a82787fc37e9bea4348a40c3c8387114664d7d68abe58c0e4bb217400e6cc28b14a7d216330d2cd4f3121d3c4fc5ab61c095bc2b3354028d1e122f1fe107e8c3643631f407cf62b162bed4181351ae2a56eaf2201bc72efb1b5fe681e031dfb1737a5e41d9dbc8b6de9fa202bcb3c3ef1d25cf6089e70e3b6723741de3d3c90e5f7f8cb536619bf470fcb7283dc17d04d4ab0916fef42f6807cc39ef69f61acb122edda086b9224fc90aca746339ab0219fe57a8ab16aedd845966e4c6f3634c1eff9c81cccdf62fae52c549237ad338e87faabef8cf65453b5bbf487dc53cf5c3a82b6b549b7be603824976dd4e1ec42365341378b05c392350975be9188a63cf1dcc7e658e7beb67db7341ee490b61d328260ddc43f8c868d955c94ac88c3a70fffbfe09d6f25fe81c3c0517b7115d38582bff36b239131cd382984783e5feef8b93541d93f3fded07dfe7b74f4d73504193128939f6a5368b386269d9cbebcea65edff9d2fc3dec6f2aa336e564970be32163d01be4453ee8584271a314af6d6d66c321a067ef6d5b5215dd7ee5e12b824282dfd12310393dce5fb71be625ed3cae98afc2c1e0802cdc2605550afc799f32e446dfb5dac1ca584985cfed16c0c092d994aa87b73f9fa53e7137920d409a2546256283af1c21bf3aef6a2fb6ae591adfdcbf187d7694d64d8fee27131985fa8b51f9ab331e86307cdd9225e752a34042455c0819c3bae870010389e8aa8c7c8fb72ac638b717acf5a8b9cbaafb69a6b87264942f4bc48164cdf6baa36b3d3825e29081694fc50c44deb746d9dbce3be07becd1a9fd9066c6afedcfc578b5cbd468de842ca665bcb8821ed2b3a4261d85cf7c22750b8db2478304f79d6d101460d62dbee586d37d28f5f2ec0b8d93a0204dd67f2e0174c12a891ac33afa3f6d980c88d0b7de2e9f009b20ba31e5790b6a8e3949a2b43f3f889e942c5f93f296c96e3e135446af506d1155e918e4c7b4ecb111ac6081b7e5ad2e0f91e97286203d045b646586710a63d6849aca14097742decb35950519e0d9a1b2cb981c26975b94a4d5e4bcdc49eb0a41a6c5ac87be741615302428165de83ae7fcf85879da3ca4f307dfd23c9b03c8941d4002a671b8e98815a6ee3613da9394937914d2cc1e0094b69cb2f1a12c4ccaa92462ba7ef3f151d30304d7f6a300279de248f9e5c100127a248916211e995f843d515431c49b540f7930f4260b2220707a3493e087b860628c632e028627fd8488ce21f6e35cf57fa2fc6908427587f6290d82795dcd8a85b6df00c706ac57d025a5cedb570109d659b88156b078328f7c55b605291edb813ec0b6acbe46012deb5045b6549bb7af86dc2c89843b93e855f20bf25f5fae2f2c3ccaaa298a4fc053ef4ad3e80f9290d6004f683dd66c75157ccba69ee22440e16d4a521eb14edf99987b12ccac5691c0539408e69fd80d3192338658e214d75a4e2d843496b1dcba2556b7c49e7c8eccb696aa857714e6eec0e0215f252e7e6810895f03a48f793c2654c83a3e67d54cebcf7e54bef33cf81dd85c3f5fb02e9ae39044cf1a2a680a11d1998e8cba3631fd057abc06ac6de89ed329e45d42054965723605a17f45b9838a269c791d54368a1f21bd67a1e741ed0bfa1f0331a5e66773faab4cf172243c8b42a15005f2cccd863a048697bfbc6c1377372a765d7524e3a5434a1c96ce51a9ac69cf03e802a9b3ef9c97cd94711371673b0f7d648284332f24485b37b0891edcbe44543e5c8d2e91e997017458f1d1880953fe61345d34b8426567794e123c53bec0eff41ec660bae4ec0a3bd8ab101411f5337e807231f5e6f7910899a2f3b5328ea18d6b1985aeaa6ed22a14387b9674a4bab12f00917d8c3b3a547d9dfacbb698968da33f5659fe2886a3f2a35ac0fb3479863e6126e9b30bb99e5e92db7a73c8fc7077d5fee9a4f0a0a6a648e1133f169f1a1aedf9a0f60b960e1b1738b1b610f4f0e5896b109e4d1f7e0ab2731f5ad9e63ed7569dd886e5e7e372f35ac054ed8788098689f2ae54e14a86a01a89e8e1750f2b50d33226bf8ebc7ea59f0b2d7b8d626ab36111207a0d736c0cba167e3276c5c7ee2b522e3d3eb88112f95d03664f42c8719a10b93a345455d1cc8693bd99d73b33c2c9ddfc38c6df95151f835b3d3887d267ab1228c95eb4d204ac5fd0a5d7f9299216005954cddba001f7f39e373208ed574fcd659f2c36265c26b37056a2e2df24e32e519086b7e4c13d8381e20a8e8e0027a72ba62b8f6cac24afd9d9cda4b24f60e30455f9da53b2cec27ef384e5a411b23eb50d343e9fdd866b030c372fe11f0ed860221df06ea5593a182a0099b76a428dc876e64ea8139f79d1b143d04cda54bda925a2176c12b1229bfc3ba2f89269af0fbbf053adbd30ac441b08f5482f87d65bd7e8d84c3c8c44ea1ff5a07cdb6c5aff21ecdefb18fe4bc77edd9a813d2f48e5720d303cd5bd8686daf671ed8d110fc7b85a7863273ae1cd35c2ebf88cf5e0eb957f8c7904</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vision transformer</title>
    <link href="/2024/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/vision-transformer/"/>
    <url>/2024/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/vision-transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Vision-Transformer"><a href="#Vision-Transformer" class="headerlink" title="Vision Transformer"></a>Vision Transformer</h1><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p><img src="https://blog.csdn.net/zhishi0000/article/details/139795459" alt="一文彻底搞懂 Transformer（图解+手撕）"></p><h2 id="自注意力机制（self-attention）"><a href="#自注意力机制（self-attention）" class="headerlink" title="自注意力机制（self-attention）"></a>自注意力机制（self-attention）</h2><p><img src="/../../img/self_attention.png"></p><p>计算注意力分数使用的是缩放点积模型。<br>Scale（缩放）的作用：由于进行点乘后的数值很大，导致通过的softmax后梯度变得很小</p><p><a href="https://blog.csdn.net/weixin_43312117/article/details/122922513">自注意力机制手写讲解</a></p><h2 id="多头注意力机制（Multi-Head-Attention）"><a href="#多头注意力机制（Multi-Head-Attention）" class="headerlink" title="多头注意力机制（Multi-Head Attention）"></a>多头注意力机制（Multi-Head Attention）</h2><p><img src="/../../img/Multi-Head%20Attention.png"></p><p>tips:</p><ol><li>每个Patch数据通过映射得到一个长度为768的token向量，即[16, 16, 3] -&gt; [768]</li></ol><h2 id="VIT-和-transformer的区别"><a href="#VIT-和-transformer的区别" class="headerlink" title="VIT 和 transformer的区别"></a>VIT 和 transformer的区别</h2><p>Vision Transformer（ViT）是一种将Transformer架构应用于计算机视觉领域的模型，它与传统的Transformer模型在某些方面有所不同。以下是ViT与标准Transformer的一些主要区别：</p><ol><li><p><strong>输入数据结构</strong>：</p><ul><li><strong>Transformer</strong>：通常用于处理序列数据，如文本，其中输入是一系列离散的标记或单词。</li><li><strong>ViT</strong>：专门用于处理图像数据，将图像分割成固定大小的块（patches），然后将这些块作为序列数据输入到Transformer中。</li></ul></li><li><p><strong>位置编码</strong>：</p><ul><li><strong>Transformer</strong>：在NLP中，位置编码用于保持序列中单词的顺序信息，因为Transformer本身不具备捕捉序列顺序的能力。</li><li><strong>ViT</strong>：同样使用位置编码，但是是为了在图像块的序列中保留空间位置信息，因为图像块在原始图像中的位置对于理解图像内容是重要的。</li></ul></li><li><p><strong>应用领域</strong>：</p><ul><li><strong>Transformer</strong>：最初设计用于NLP任务，如机器翻译、文本摘要、语言建模等。</li><li><strong>ViT</strong>：主要应用于计算机视觉任务，如图像分类、目标检测等。</li></ul></li><li><p><strong>架构</strong>：</p><ul><li><strong>Transformer</strong>：由编码器和解码器组成，常用于序列到序列的任务。</li><li><strong>ViT</strong>：通常只使用编码器部分，因为许多视觉任务（如图像分类）不需要解码器。</li></ul></li><li><p><strong>注意力机制</strong>：</p><ul><li><strong>Transformer</strong>：在编码器中使用自注意力机制来处理序列内的依赖关系。</li><li><strong>ViT</strong>：在处理图像块序列时也使用自注意力机制，但这些块之间的关系与文本中的单词关系不同，它们代表了图像中的局部区域。</li></ul></li><li><p><strong>训练策略</strong>：</p><ul><li><strong>Transformer</strong>：在NLP中，Transformer模型通常在大规模文本语料库上进行预训练，然后在特定任务上进行微调。</li><li><strong>ViT</strong>：在视觉任务中，ViT也可以在大规模图像数据集上进行预训练，以学习丰富的视觉特征。</li></ul></li></ol><p>ViT证明了Transformer架构不仅在处理文本数据时有效，也可以在图像识别等视觉任务中取得优异的性能。通过将图像分解为序列化的块，并利用Transformer的自注意力机制，ViT能够捕捉图像的全局和局部特征，从而在多个视觉任务中实现先进的性能。</p><h2 id="为什么许多视觉任务（如图像分类）不需要解码器"><a href="#为什么许多视觉任务（如图像分类）不需要解码器" class="headerlink" title="为什么许多视觉任务（如图像分类）不需要解码器"></a>为什么许多视觉任务（如图像分类）不需要解码器</h2><p>在视觉任务中，尤其是图像分类任务，通常不需要解码器的原因与这些任务的性质和目标有关。以下是几个关键点来解释为什么许多视觉任务不需要解码器：</p><ol><li><p><strong>任务定义</strong>：</p><ul><li>图像分类任务的目标是识别图像中的主要对象并将其分类到预定义的类别中。这是一个直接的映射过程，从输入图像到输出类别标签，不需要生成或重建图像。</li><li>相比之下，序列到序列的任务（如机器翻译或文本摘要）需要解码器来生成或重建序列。解码器在这些任务中用于将编码器的输出转换为有意义的输出序列。</li></ul></li><li><p><strong>模型结构</strong>：</p><ul><li>对于图像分类，可以使用单个流的网络结构，其中输入图像通过一系列层（如卷积层、池化层、全连接层或Transformer编码器层）直接映射到类别标签。</li><li>解码器通常用于需要从固定大小的表示中重建或生成数据的任务。在图像分类中，不需要从图像中重建或生成任何内容，因此不需要解码器。</li></ul></li><li><p><strong>输出形式</strong>：</p><ul><li>图像分类的输出是离散的类别标签，这可以通过 softmax 层直接从模型的最终层输出得到。</li><li>解码器在生成任务中用于产生连续的输出，如文本或时间序列数据。在图像分类中，不需要这样的连续输出生成过程。</li></ul></li><li><p><strong>计算效率</strong>：</p><ul><li>在图像分类中，省略解码器可以减少模型的复杂性和计算成本，因为不需要额外的网络层来处理输出序列。</li><li>解码器的引入通常会增加模型的参数数量和计算负担，这对于图像分类这样的简单映射任务来说是不必要的。</li></ul></li><li><p><strong>自注意力机制</strong>：</p><ul><li>在使用Transformer或ViT等模型时，编码器中的自注意力机制已经能够捕捉图像中的全局和局部特征，足以进行有效的分类。</li><li>解码器在自注意力模型中通常用于处理序列生成任务，如语言模型或机器翻译，这些任务需要考虑序列的顺序性和上下文信息。</li></ul></li><li><p><strong>任务复杂性</strong>：</p><ul><li>图像分类通常被认为是一个相对简单的任务，至少在不需要详细理解图像内容（如物体之间的关系或场景的复杂性）的情况下。</li><li>更复杂的视觉任务，如图像描述生成或视觉问答，可能需要解码器来生成详细的输出。</li></ul></li></ol><p>总的来说，图像分类等视觉任务不需要解码器，因为它们的目标是识别和分类，而不是重建或生成图像内容。这使得模型可以专注于从图像中提取特征并进行分类，而无需额外的解码过程。</p><h2 id="MLP"><a href="#MLP" class="headerlink" title="MLP"></a>MLP</h2><h3 id="Transformer-Block中的MLP"><a href="#Transformer-Block中的MLP" class="headerlink" title="Transformer Block中的MLP"></a>Transformer Block中的MLP</h3><p>在自注意力机制之后，通常会有一个简单的MLP，其作用是对自注意力机制的输出进行进一步的非线性变换。</p><p>这个MLP通常包含两个<strong>线性变换（FC），</strong> 它们之间有一个激活函数（通常是GELU激活函数）。MLP的输入是自注意力机制的输出，输出是经过MLP变换后的特征，这些特征将被送入下一个Transformer块或最终的分类头部。</p><h3 id="分类头部中的MLP"><a href="#分类头部中的MLP" class="headerlink" title="分类头部中的MLP"></a>分类头部中的MLP</h3><p>在ViT的末尾，特征图经过一个分类头部来生成最终的分类结果。在ViT的早期版本中，分类头部可能仅仅是一个线性层，它将Transformer的输出特征映射到类别数量的维度上。然而，现代的ViT变体通常在分类头部使用一个或多个MLP层，以提供更复杂的非线性变换能力。</p><p>这些MLP层允许模型在最终的分类决策中捕捉更高层次的特征交互，有助于提高分类的准确性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="97cf0f9849d806753560b741de47e5c72403a04e4b92afdc3791f80d30d7e5b8">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df9c1aeaf2ec35a00e7cf192d6721e1dfe4b6de84310006835ecc0ec5669c93045633ba23863edf073f8e1dde46489b3a6a8818c26435de1980b0b51e79f55e062c096247a4c4a9ee248fc4159db5763145aa74e2d4d6ce2219bba0c9177e327b0aa8bac1ca392903cc7854e418a6c274b343889d70fe0d6cb21adc8e822c06ae7c6647635e05cab5f9cf51577302630251c8769b838ddb18c025285575b5ab3411063dc260e2d5128dc1c90052a290d53bedbebd9ff788457c1bf5fd9ca2837485ad60414b9ff0f01685575c58e984ca1de8b16f443f79fe4d2cd63d4df1884d6132a4675485716af66ab49d19a69742c300d7fa374a03519d88106785c896eee1a356c5f122abc158e93ce71b76d5f1bb94448a081b0e6bd0cf804f668746805d40cb7c6ec5b6caf89a27b6e1dcab0dc47865c85f64e283626bb02198884da22833af149ef484b6743a12267c76ef25deead95d3e95a47c90f3d51b612a9175717ae6b080bed8e4c6570fdd2f3c19ef792752c5f4999df7f4e5818b9e1abcc8af6effc4acc006e4d42987628d6efa84bbe2753144987ea9f8a5f55c87bacbcc7f52f7f4c523305ce9795fecdc6a7648df022b85e5b8b3aee1237bff76ca51af88aa9918bae0619c847d338d39677e9d168d31654553bcf9a084a1aadde0f0ca2f1370032b5fb238269b83c7e0d2c5155b2e0c6b84cf8e6794e501e56a3339107dc27cb2649a352be0bfbc3d6e6ba38c875e300116de514b5d882b7f3090202146ce2373eb8f42a3a40a41951b483fd318e1de7da6504439c6da5e8f8bdd708224ae4f46a34ea8deaae584469fd5c286f21ad1336ff88581eaecfeadebe40c813298252d48f9c7511492f3336cf80f37f830fe520722b8b0ed13797159d2fad19b2f711a4b2228248673837ede3d5f4a93fb80c95d33830f096077523b08fda815f57ffe77671a72b37adfffe7726c5a8636bc04a332d574ffd531558ad598bdda44fdfd9b40b9bd582ac847ac1ac3e3582ab281bb8f8a94bde083037bee6e960764bbadb8eda69526413ffbae98b0655c22ce9e39020cbc2027293565df9ef07d1dd63e1d0079db725f536efc03c46006e8126a3f3e2a022e964ac1b9df26fb71a722108b7b9100d511c5fdfb2ebc70e899c94fd402772b396ca03bcfa2fc5298c477d301a437312de4cb511fb051a58ba9c86fc741c61ed8e2d18828fac63f5aa7deddaf10af2b06e2b57f6069d0103237190dcd44afcd4787fa64f099f6d41e5368c7166d1239ba375ff941beba1127a70c9ebb7f34f2ea7935a00dd6999fc135fc127511b8e0413d0eea55c9d13839e334dd0585f5a6b3e554ce51342fc6732de872137ed635b17e251035e9f3828e42cbc9e5b08aa7689d95b6d882dfd80754774208d4eec922462d4b773063f73f93aa2ec3b9d5fe7ee60ba58f4cdea7d0c7ff161bdc533993aa25a4ef35627e4aa82dee73dec9259048217ae87287429e005c1ecbc7ea09c43bfabfd2a0675d5bade53103a97b834c3941b7debc9f35945ca258ecc4c3cacef6f7d821820b97c54f42f6b943d25385cc75d7415920127d881a757e496cbea0cdcaee20c099659bea07c2a405d8a45359e6d503cbe7de471a936e3f4aa21065513a85803d20386440ba1181110bf0df8dc2d045a65c0494fd98cb1c777703040b581d467f6803368202e2a2464a3c6bc183cb5b57e63fbb6015197be07fbdd855d31fde9e378e8f32203e23e7e22ee5783394d28140d252bbb034901bd926fa722c5fb06797b531064eb5ac3e7fb1c1f88d9fdadb229215bd17230cad46c13e4389d1bfce2ef303ebe8cc03792d6f756c9f60e6d4b888a89e81d4fc9e95aed019c85c6adaba4e79dd5b15cbfc12385ccc2521d1739100f5c1502a629ce1ede6edcb3f9edfff3aed0e689ab2f351db84c43d4089ba8d7f220b2ec9eb00230bfe79b3c1e6dace74f85afef85b91790025e1362b0372011d33e5795586b9581b5b69828aa146f03976d915d18f3f7ef29887e40e6f4971fc76617d5fb47fd931be432826e3dc50b31dc4a8a598b381c89410abcf1ac64d00b299f45508f0031d093eb8f155055ddabf3b2b4cc97490ad377c623bef585850aa5f40f5f0e2cb7c7f1e5dcce92d62f51cbf8e3f1a8a4f075233ddafcce736fc4154b64b1f315b0cf440725423631d357a5ec7920c8630bbc5d25dbd1f20ac69e25d51a21ef7a3fe87faabdf124a981ee51814aa93597bde3612971f4fd810802e8d19baa38794831b180dac26871def2d1c13354ece66f9f41f0bd18902e543c834e5cc272812ee70ee4f7aae6dae6442b18864da170015e1ae1f455f7e35807415a5ff8b8fb047028a8465bae37a668a95cf04919a845dcdae376e2c4907728c1247e810d433dce47326ec508fcd824f85609780168579a6737ac1d2f20cbcae1de5cc7663ee017b3580e625625cfb4334bd486db4d1bf7f0da85eefee9325ee076f0b2e2e79852dab48473c14b13f0b4b5069b1e25c1e36549afb8bb63bb5d14ce9774098637478685549c243931e3a64b7f09a34893d8ec301a5772061ef74a1e143330cdcc822931bb35729fb5abe13dda8999f78b7a998a68d7b3aa48fdcfae85aca12e6358727ecb33b37c639489a2c643ad0172d1c6571144008f42cbe27a7aac624566785e9a5420cef753d8a4d3c48f717f928a2e61377989978748d6487f64a82e895a1bf352dcfa5d1a55c4226f616271279faf4f707d398ec721f623c03bc4994cce03f718e0298e349d98fa8c35f66b266784a87543ec57e61aa57230fc3b4897ca32246030ba13eaf0695698873bd7588a7e661e588838f89307fe7615a06ba919bae1442a1b9dd9c0dc52edf9623f0a325dbe333046b6474a2d0a7916daf25616792fb6285a04c64dbeb34fc732f97fd2c15d1d1273b4b0c9ac8936ed7fdad2ee078e3e0abf105cc42196c88a2f2f89effb1265666fdd8b7a52df5ba02d8d309abd782eebe050dcf1797c6a1d05bc170a9683d46c6fcc9576940baedf3ac43b718262bd5bba7087b08004f9c37159a700c790fa8482cf292e26277ccf1b21e1b0d22331f91d13b69eaaf4786cbc47e164d936f6dd7dfabaec9652010afbd634b6a91a29b3b2a96b910464671db1e10c46e2d4e0154966c427738d3909dac9aa871cd27a8727cc14946d699c2ece59eb001d3f1d3d2b71d2526be30967deb9cbf4c1699b08c45497ff23bc8df82a635d1d9660002aa0a3e59aba49c6a1f9351420e9b13708caabb028a66b7a18c22420cb97b6223480ab71010b3c2b4448509883907348b1261b3008353522c4ae514ba808c1253b8984f0fab20ba02d680cea7b6a860a26338f7d2033a55ab854f67b5a3d410eb33d612e1beea8f494460605e35010b0c42b10ce64d77616ac5cc1f93a8cdb7692ad32c56d42fb8951a0c091061e21b7bced6a827d3b728cbf13012517317ce757aabe89854f27cdeb555da16859b4ab75fab71b11a557e97ec3e4c78b951f7c1b659c436699443b397b9da8a6ffa104b5c572edee58de4dead88bf4806c83653f6a270709296e31c843280bf008064f7468fee2f7b6d6a91e6e095d233b2f1bd726f04ed33fac9d2bd81ff84dc9592af12ccff76616cd752459a7c21ed7de1cb6a65c06022dbea3f23073c031106016e2606f344b53b1f5e242a99365a160ba2c14104ffac3296916edf5f48f357391d966285e44a0959bcc19528dab8b4da4458993c1c056e1734d457d46ba000b837d656571b6a241c62750c2481c3491dfb56634a85572b7f49911b5c489a99822a21890445a080f153a30a92fc732f9e0584ab734f4a44d4f3d9c63dde7ae70007f9b6e4f8aaeb0f0c3312bb1a5d66570e6b468195a3e13e217ae15ba912c9e9864f97041edc49a3424af64da0fe6268ee82c15564094789a9d00ef552b18d5a35614b31de1db4ad58a42bf19714daae99133fd5c9dd97320982de5182870a5d0a6e592d7388e48ed80a1269956fdb8570b4ba50bdf88aa5428891ff457e7b2a332013ba5646354775bebb60185c9aca8d54ecf5096dbd564dd78b636767af8f2d0b7a17dcf6a517d572ef261afc3ecc43cf1c45d35bff9e11c1e1b63631c5d2f74b9e22499fbf2d4d894a66d0b8f83036ec261b87cb8113fd9c62a25986b054470fa209f89944fa5c704c7fed788bb05e8f78eb85e15fd13ea8cf10a80f35bd93261f1645f92cf24e34aa6082b8f4db81217d9b41ac45f259ea516a87d777791d0793452bc9886d8cc8fed35e9cbca8c52844f8e2a033709415506e505c6845129e4debbbe36bf6daf3c2c1929bbd86a1b9e08403d503736fb8b035717e40c756802322e2c594181344cc0904300aa4a4c6b47391771211d333bec7d750252ae2c0c102db919583badaaae45c4ea9a6fe079eff4c3e7e77cef8e1445a7450f67ecf78af18e6c48fa004d32d74ea51fb9646d2ec9836a967b1503eb8f36321f857295bd0278e0a34237c38bad0d29130a0e95640289d5104fdb6fa3396df193c3d2c01fc2933997520a4a1e16f84a889103346aa2e87270aef0b73e766b6f4e0c5db9fdefd685c2bed17795959610011a9372ad5d1ce944eff466ccbd70422c769abfc3497993243aeebf83475310e6ffa80e9f0206c046c72df2ae18646e580568fc6538d44384bfef50cc9cd93ea1fab5dc355a51cbebd7455d0086ca4e37999eb8a66402e3a598c0515146124949c9b5b251db2cd0cbc4a3066830d821a5cc0c45ca5eca0553b462121b03fe9829beb01692ffbc562dd8ea529c076a913aca6860a48b808ebdd242b5abddfab35fc1d042571e279d81c92a2c31f8f6a04b617caa1b73cbb27cfb79b1927dddf3c6043e108d5c66bdc30d41b015005f5541fc7159c46cd6950c0c3c2be32b51f0d70cf82cf3b6172cadf01aadc00fe43a158cfbf454918ae733e17a4a4d238ee945f6bc947147b67e2f6f94b7d7f9474872f95d8739fcf9c9a2ab7d86aff71bfaf1e4a3e0699b998ad64a81e834512fed1cb592ff5bd15daea72ee6f0fa5a05be786b29297d40ca5915f4ff9523baf1b9812eb89397b23ed464698dc7069fc084e47032057c5deaab379f0af90e97915fb13b8bdb8c61d29e3ec06e1def9d9963dfc1926241bd2ec1caaf35a23c56395b4a1558a493cfa162223bdec65f891b591f711eed01a9d95137a30ef119b681e0a5b6d39aa773c34f4666298731dc281e541e1ee85cbe072f546fce005ef27273b7b14943baa4f895bc9fd59818523d7c375987a352ba139cc52bd8b7a70029b6e5fba6872202dfc69fc8f416603b0e3e80ae2112590d5a233203c69e018eb7aedcda277be349770577fd08545b0e0a7114cb6594a2f4221b272076f4a90312fdf8f4dd93a9f90e97b508ecbf76d8f0c2af5e749e6a79aa3a90fd8e29e9552b8eb7c39ad630f57ffb9aef1bf684567b5152b0bfcf007ad3f9b0df8ed49e346d24c356cd02d574f07aae03273dcbce3cf1be317db45acc87aba8d2c7f3a1440b5639c820a4263b69c9ba79712e782c8be30c295c0c4de281a836469fb954c17086ff7a83ae1dadf0ea987a9f7c63b0038405f727b3b233530067fbd0c20e843680267b0277ec1553734c55fd34859ecc5cd04f0dd42cf086e7d42521b3098014eb92bce87ade05ab7e67762a540949cb9ebcf6c5f39810cf723c9b6bb34df7d35bf881f3fa5d836170dd30b121609226b432dd5bcc287e8a6806157821e81170eb5b401a8404a193ddc16972192d118c313a422a027af6f7848bd6a2e9e16adcdf731716e85b6efbf874d0cf3e7d36d8f6b87386783b36a0114e8c517701897be949f08740ce9b57dbfd29d1ad086fa85a8f398554d0ad23130654449a0310b1ab648dad0af390243d04bbd9ec38ee3e5aabe00ad45f0c07d3c5488c4d7fb338e569bfb742a3c2617d4e54fecec001cb5f88e9d3fe139960475ef2ab4aa63482f12a713b7d782948bf3426f4fa454bca8ebe96e964158ed84cd0a5820fcc200d579cbf0f4007ce0fda9a12e58d9fbc4a8ca8bdde168434d0024799c86d0c03721f0bd05f4c5dbf1d0ab1f655e2b5b545361a8cc199139262295df70cb708472f0e3a9dbf14b8fd9efa809fabfb7478d4d8b0263bf1b43125b63323abe61f8e142a4370f81253464fbdfe7210c9966c0ea629cb49ee6b11f7b0f5db62c65a951ed018a461b059643ae911342880364de9824c6bc1a90e75969a46561f0d3db967c55beb8f60d1258693bfee59c86a13cb58266d342ead06b22660d041fee0b8b1e8d90e756659459c314a06815a7ace498df333cbb21db664403e6668bd08bc4291118f922f360e7ebe92c9b244f44687398fd4dd1181e4441449ad297804c0b414897ad983acb288bc596a85359ea8d2a0f88cbce813967e3567bf56e3e904a4b29258198287b2aba9cd05f5d044c94231a2abfdf3fc14e5ba05ffbf59b2d97e9dbcf6588e47b4aa800d0be05502df3a4c7a5d77652f1bd3801206be73ad1b9e5929bd2ee23438657ea285abca952da828e4fdf6a61419eea534fc6b1d93171c88022a6892b277654fab805703fe7488a3f88270f060536e2a470ba5d5d4e9434618cbeff0f8c0bc23863856daa0f39a2604ece3f46abf986539af063784bdb29d1304f90b38d20752c9edb9e5893ea71274051d0eaebca9c591e552b92bb97ea14ab3787a13580252af6b4310c2e835b2f3157bdcaa5c99bfc85d7596b0f581dec2f2501446e18864dd52f841375be3de9241a11f27d96827f1daeb340da33cc8e008b854753379232d26fa9067baa2a0821f8b317186a401ab7cfd258e9b6c81524a9b9e9f602cbf320434714f27b430eb5df4b42bc4125a040b1e4f85470e116ca2385f163d352a1dd7e189615b0942ce54344a3ef9d7b9b6b4f8cc89da48ff19e932719a55dbcbc97516d9342b5e9ac38cf1679509d22b86017525e1cbf2cbf7d495985b8e764a75cf7aca7c3d46eb86f879c46f003360e4c10a7c7e5cfc1d41e872f0a37cd168ff4bdfcc3ab2359f2829118c9fa2c847d8043d8cd77a772cbd08c23e4c8bdcac0fe72cc804632faf612d11b640e5e28d542217b77743a0726697051f4695da94a1fdc0315059404b771a9cfd8b7f303b60e4b62734a3a4d3294e15e12e0c2fd292c9b5295b1724b7f736ffeeb883bf694d7bc150d06e28605a036742763f4a6ea23204857ee4f1dd6043f24ba028b4cfeba4987689bbcbd1cd12232705a8d8666ae1dce2f9d558382053b4ea264e8d29c1d90ed046e9eb659d2274b643172b6c5664a566f2f9dbc50b8da92792791a9100381c7304e99c6eaf2ba55fd74b18661985557d8cea39595d20d5e79cd9d9e0f31fa4ff220d392456d821793c9b597f160f3f2a9cfb1e0ad62394ce2d57f9891d223a4864f9b451a97a9356f7d6cc634a006784f4fb5d73220789303137660ea24228aa487382db484dca9300bc7af97a20a4ed9832e27e8d6131523487e48c9d3c0cca1cac038af1ac734acb93bfacda582524130c636e40462831962aacaadd7733749f40f7ea9d6e1af327eda1774bd3fffc21d9a5910e06676e912253b3ba1f160160c672ff1e6c29a778d2763fe2360eb5cdf8ffd4e27167967e557fc965da0b43f931a88ed6450ef4f74bef0edbd5852434e599f89a0e11b0a66df4e8f8361c104061a917235ce7dd9c5b27cbbce79f8eea0e14b867d88f6f387bb03e62aa9d0f3f48fb6b7fe1415589dad4364aa5f9fb2e65e87b3f51bfd8d051af6d1082deddfee33f7fb84e43da5d56fb19a7a5870e107c140fc53e94000706d29a9071d5c5ee53fefc73ae5758d66ffe73ef6d85e4bb362cff22e9a413ce4fc27390004b3ba7083671900d6af06db384ad98b6f6ae69e94d3c21059a4a5f2d2741c52a5f2ddda760d3cd5577a8fbdc2d2b92ebf50d160e361fb4ac6d5b55d22296521ba0f44cc156c2c5d3cab7fa120cf111c99d2830ff8f992f11b95cd3ecf3510988c2d2f22ac6797c66bd895023420c26b603331fbbf9fcea88cc1c9cac60b8db2941806cc716b7009d4b916ed8bce1add89bdb06aec923fd72a12bf830a5d68d9e50af9b4bfcca36d66c7df37990a0405422e9326dba2cec9f8d3bedfb8876b106fbfcd935e99fea202a0f1dcabb0ecb77617172309ac5d60fb8dcbc57ee9c4356847301c1d7b94d635d5712dde1d9571fffeeabb13e7b6d4ce3a403ebfa978ab28a721f4427125b12596e1a543bb7729e688d1b9857a78827d428ee3798a301da751c7796f9fa61df43ce23fa08423be95cb722aa1a50ccc2235e85d0b01c283426bdef57c3f6b10895127d66e0814cfc0c990e7374922f2c9da943fd673f25c1f788fc0ca5c8e80f4899c409739647ec61a86b153e3f348798fb31a27f847f1aab916ada5baa7e82b20d23f5aa3f6ebca259b923ce3ad60195e560e5c4a9ef19c7420856b2c192f8c3ce336aaf634e6b4c4ff235f4587b1cd832a73e93a474d2f77a4fac11a0dfc02dd519a825b2f8499a55df99d842fefc61cdd4e8bd9e22eed2dff855a374fa1620bddc95701a03f4e946940f399f55ebeebd8ff0546614e5055e5d19673b6347da24ec76f74e5c405e0f48993dc154ca8bdbf2b9f34a89550f4625511867bdf8d47289f0cd3cf6ce4975cb64ddbf34a55cb17b0f70a87ca581bfc88e3ba56607f725e36d1bd833f64865e9bc7de5de808f6e957e41c249b89c30f41601cba4b4c080c452b90338216b97ff58fb86ad2c9129e99d0c947dc3b9608f8f9f3fdf9130df47d124c7b4fb0858cffda46426370de467f67db8d9e0451542db87ba7dd0a30ba3ab9dc8777ce84c6780fed5779d549f333f675f46e10d383094fa8920856058e8532b76f2141e878132451fd4bcf40f49932b30366cf1923e9858ec3be1211c8e534df1817c11bce67d94004b37b1ce3e209c00512f111518354bfe68bc3f2b6c1c9c6e23687bc4b1687283e33b565b5418f97574b89f651db8bb5ed1a19ed151607a1965b403c48cc9a0df208e7e651941dc734366d95b6e2a9bd28bf91cb332b39c2a59d06a3ec6f1d7cdcbed31a2f7cc19f3536a40730e6c920f1efe554fdfb0c06a553c040b88a898fbcef38b9c16ee66c2004fec4f32819c3b298de3d5d63189b354e26ae80e890b2dfb90ec062d3c87a9032bc94b1e776ef8c96cc6120fd62548fe42133dbf5e8a13f3f3b61b9acc82819481f13a51de7cd414d8a367ac35ff70cae38b4823196c7e753251952e1bf74c8f225cc443b714cce7e32e0922f0749a3d55c02c772f315c8a448455afe885c8639b6e800b3c5b0cb6b80d36a123556586b1da60c56a62369ee536fce9cae6714f9cb37a74fc0decd203a977f7f7ca43fb34acbf489934df8d623b9e296a6ccd02f836d69b94a9fe542e21c7b9b644cb2fbc78ce6deebaf9c4549c1b2113a2eee2f48d3426eba376e96d68d1dc4ae38b3ea6d77754ee856a899a909a6db798bc228092b7f48707dba6a64eb436c297e38a8a1e05e0ef06806ce95e5a37027ca256242880ca9d15abf01fd92aa05a98a21513588b815c4229d3244807e924e495d8f854999f4d146a8e5eee54cb6c88843245da04e73aaa17ef9fed334a2916915b18282bb0294825bed55394a4f94f2699e1c10c1b78ff98e3d6714ff1a825118f6d6a3607023c7a1fe719abb4fa615525b3b70b2b71ad3b3e03e8d4af54c635f25c34935c079d8dbe71210ac8e60102d3644f2ead2ffbcf5b88a6e06609fddb434520773430812a96271e3c34f91c829c5a5554999db17ad73f0052628cf67bb700abf9a90399bf1ce67b1988f4849ad83c28b6e3210ca61a7610e93a562c9119ffee8c679c0a16e7f8632d33d2f3c77c2fd9d92ea5fdc8501e85a8d007e87dec6844eb579204488dc6d7d8cae728eb1785df450f20b5b2ed6ae4ad1aec4c22a15f78a51ad101403701c589f66ed48d4b18f84c5f48b12ce7c923b54efe60cb87f9ae522976831c3a71c9cbfdd0e6150e617c1a22c0d2c26f9865f0f8150590a67406fdd3424f8e72e6789843a2f47491cf1f63f31fd40ef36fa438da9238e7ffcfe6de68a8b99996379dda445dc0afbceca3009e73894ede17f38102e91ebba19c72ace46243b0ecd4f2bb8f8b656a19821e0e689e70a89c40ecfbc51ccf372eab6558ed326f019e5a060fc8581eb75edd16150ce84c719e64ce5010dcab84745a44805fcc8758b823fe331a2a400268ba7403a8b8be0311d62d2a05cea6f8ee1afba5f8dd4f5b013428741b8d4292ddbb2649fa55af0ecf17aa5f99f951171b06b3bbae18c25d0df0da43122b931ef4489b1f2fede64537775fd9e356fe36b9670eaa378b220c279dc40ef50e89a932902d4c2335c93fc143c068dee4b27f7218437326f58d507ca8b0b1830360d2d53d2f70badcb77bc8a98f6ab9bc7d3a91b731e5bd93243b4b6e17328d149a335d9ac0b37d19ca708fc63417e99e1d8319a07d290e788298820f894a489601e4401db65d47c881148aebaea7bb690e37e55a3bac9036f24444fd352bbb762a94163989f204ad2a84693b02d7da57a4236a8c3c2c4b1dee21119c2dc827ae0f616c359ede2db30e9e61c0c330c6f811b8927e44bf60eca2e4f6bd3de0e13c78e98ee74902dc152a374d6b01f0a49993e34e4671d169324eb01665ddea66be6c4c5cced527999a7db1c714d5b23fd8ca5e5918a3ae14cb7cc56546ca108a57654163f3600195c1c3c5062dc20bfca8d385a471c4df1d54ca0d29749163830865bfcde5da1e12ed0bfdf8ec1b5929567dbe91d498fb1842e84a22e6ec340ef255d50c12c7cdc35314fccb3f5bc3642f6ea055a67f551047ea5474bbe777066308b84ca3a024e11cd63f4f18ab7db9137c3c07397a4e21bed5ea896731d02aae06575a7600bb8b2ff39eecaa98951c25cd4d1907fe44d0fda0b93e7b4cc329d3a54c098575c8e6bb59e39ce6dac82469e1ce1bf68d5d151ae98eb4c5bf31823e22768899f8377c1c0bb73f4c894f17f2fa6937618352a6bc6964732f54b9f8e5213f052a7de71aa503ee11ea02035c8dba777fbd2987106a31656506cf0c46d6b0b336f54e181123574ed44bd209e89148a2f99909f3e49ab89a034ae6eaf5915cef0bf24f32bd1aabaafff14207cdc0985747610e35fef1e3162cbe00e4c7b18af5265138f9fdc6fb7546ad1b741f3eb557c233e53e128cdfcb11c146f2c5302b93d859e2218debcbd8f0bd96a77b543a805fd9a6db98b9b3335d85dedc2dfd8e12d8be19b472888c06a77809bb0dc1b780a9681932f4f0d561305ffd197f01862f55a72df4a420242c0a0ab715e6e3bb317388eb408b45ab6cac6b0546c1dd71c3c48c2d97db64d974b22b2d0fd33d235b41eaf40f11cf74de26ae94ada9c918169f517dafc980aa77e1672c0128b825407ee4d1976f0ad6fdc2e17e872b6ccaff599c5628bf966542eab8df65479ae508f22f5abcbfbb7d0d6d6984590883ebeac8e1f877f42d369a14eceea43b60b12d64c1aa291f84bf6501fe100b1e116892ff447ce90a083fd27ff315711a00e37dcb728bf63fd0adceadd6462b04c34041bbc113930200e0b436baf5e5b435c856d2282c3462c7dd2085e056dbb990e6fc18b5aec4117710c20b07942bbd64f3c8bf123011ae0bb950c25db8e2437e652a54fc6a904c79d4c65342abb0439633381c5fa1541a1ca21d250d026dca9bea1286013196328787f6f90ddbbc76897ffd0624dae0e73c6bfdb119049a34d9a872a392995e80799f57707ad6bc214add3b7618d80c73fd9fc1b99508a4e5a536b5da3d23b7ed4e7edde01605edd79b5ca25bc4c8790cfa703176735de49c29574528b77b35199f2de7ca63d132881b38b01d42915aedb802fdb062a18cf9548a5b52876af4e07eee41991bd945d30d17c6b1819829ce3f632ea049580984180dfb3c96881e17890027ff62cd365d5ee3028dbc82425137de99f923c976fa3be2fc258ade57a8a956b17660647aaee6f01b0e3ed3880fbc6ed1cbff35883df57f8e9ab01f3ed7bca0d8fb6be3179015f6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>408</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5005be7b7aeb98493606b4ae7a379c65363ff592580bcd3f54eec6cee5d189cd">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df1540b2db49809a81782455749a9e21cc82e906a04daf954a529bc9003cceb4abc0b75a9fee60cd225b11d39f33865546bc55ad27f4e56cd47c97dbf545e47e7987fd7df1285b5db059eb8f8255681e4cacc94da9da81f90dea245f1b3aabd7a833b16f9c6961a540ae6c10b167718ca44c86b4832d6040c6e442f52828ef8f4134318e89818e2aae01d93993a28be69dda61fc0c927a7148fd89d357c10675fa3eba87a8d3ee26908bb77f41add27c88bc591159ed7d77c5249dbac1f8ee5c106e006f8d987143c64ea48633db9401718c7e8f771449be90158f2d5a4bb780bd79ff50c934ca49db494ffdb3ccf4bd76268162a7492d44cf487a34fc66ac09421a9e1e8a7a0c5d068a0f6ef936cb805f78ae8d689eb6953fcc245d45c770ecdd6201d3000832c3169ec0934c3c5f327569817df6bb491113f8978b30b0db3bc73ed41d1f808d1e9d709f1d23c6ae65d184881b1f26301169178c36a96c9c538ca7f239612fc47c0bdd35f54c4632c0f059a1a6b8238b3d902454040f6b369a31207e9e59fbbb2d905450defb3fb7a17c4dfe7276227442c2a07fc162348badb8f58ad07c3c9aefff571fea40eae335b3873293eed33ef81d0fb984f21ccac624490835265c0e1d4cfc890b8c0aeb0901</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d840be8bda052786f7ea794adacf2497e005bf34f16834a0b5599df17dd9df31">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df57a2840fcb71090bf4ea3802a85cb36f85d0e2dfdb10ac848557a364f8f4d83acfc988df3b86068aee93c4f9dd76b83c4af01a094405abb758e3a21f2e7713ca4251dcf715cb5ae3eae4d6c9addcc159549eb645dbb5fe6fd128eb3c73c8beba8702c18db01e33d04014b5aa87e45d107ea853da2a765a0bf6ab6f766d1813c5e931d5c4a178cba4c6d50492269951e90b89639f56993f4e45ccf66504f7ab13147bed686f865d46818685057f3c277696463db58220600694752b194302de4528b941f1cc21c79190a6c5b0bf9b9250e8f981727c5fa7d4abe6117bbbd928b7fdaf5fa30195ab2f82374857b39b01e373564dade22216b8612f89a7c3bf036080183e4553cf417be4b405389c4108734f4e4644f2ac68a0832d6f0302519985d3d6e488f5d38a64d5f8f329363909ef26bfcb7a34754f6095c2027b9fc770de07a95e3c7440bc4e0fe54d708cd42d4bfccc784cd17fe36a4fab1db716c27ee6b4b8b93f3da151ec3e28aa03700a0b01c7e99f8a4acd3438fbaf10a888892dd8992cb6700937c98f659fb91800cf867404873565c4ded9d0569b27b44de919d313c6f88c3e8ded826e7663c3ea73180941805dab87f412d8a3d229409a9750a3d027eff2b6c9abb0df6c27f7378cd9f5f7d1008b4e1746840e0e3f14774b31851a1d0796e685335325f5200b67bbdc3ad4846f6292fbd51e13611cf715d52ec77118408e3d5b7ac3cce2491a19ff223df68f4a2feb15171756afc04afde8dbd979d99fd752e7b8d72f7214f7e64f6b9e8e1e1ba5ed84ebb9fc0dbe0a4c9a1229b1a915c15db5f9832047d16eed9830e31220c645ff34aabf3c9c699a9a2b42bb3e67647a5e6bd7caa649a062726814300ca73b16ec6bccbaa8a76a2293e67f98429f7a40b18d101960d292d4b266211421877ace47df10cf996c92a9af66c5dbf1922ff682e9ef3490860a56e230889ca4e6d83807d0e4fb9c0afd9fd992bf9fa5a24bb65fa98a77d63f624e4a23e272655b06f1eb6b89622d859b30af5d253edcc0cdf8ab8245f599ea014c4d13cb35afaf551ebc7456ded6af2f1a0edb0f03fe8d8be70304922ca361ded74ffd21b56ed4c1845dd4d8dd2559251d6da398cb1f34188f5aa22f75e4ce03e197f137e6e5766970bd745afec8b103a63bda5d91e717d311dba8150ab86e7f1c07c870b9be5aa2180ca607dc38d89bd442b300112b4e4a2c7343bec393f43b80b4d287d6fcbd4d60249d03082bd9c3b29e2c0fbed34f20a77db849f8835679336fd56f8855b467839444fe699dc6dc634e24432de2daff2bc118a360a4cf40711b6d446ee8aaa5d945b9af392d9d005abb79c814818a42efb6fea2b24f18b66c5d0dc45dc2b75df7d4293710565cd3448c73c7f04a9bddcecc20611df9f8128e318bff9eba1176ca46c8309a0be031937f091f663bc1199657b936904307c234dc596a0c81a0a0cfbdbd53ff239114d8eadc4de0e66e8b065036e675b68db80d772337f1eb79af176e824765efae2f50eeae9e8118f545b0ca9e1bb11145de0c7a47179220bbb1252777da05aabda7d3f867538376ba41364793fe6913a4e9a3a4cbccc67e6360b5940037251db107dbefc587958b8ffdef355e4bfddf3fd7ce4299edd45a0eaf0c182a3af2152be887a85bd3610f95bd024f4732d6cf0993356528e741e132ac6f0588f97a14be435fa8b2635dac04e6c6f6d165eca85437f3e898e11e8b52ad10e8d537d3b14a8d9a7a9d2694ce74d6c26efc61ee6c54b2f378b85f5a3f5ec123563a88067acf8afa26ce869031fa9b0ff75c92b19acd7371cee54465b84f22b57a35a65b756c221e0cbe3d170abe27bc7a04f5b24c8be3afd71119d6e04acc304aba073c32968e1edd0dd8258c755d6e4112fb24f9920f45e243c70ba51a0fd55507bd1f9e0dd9d2fd71ac63d9f01115e911e130c770539f2aa79dd6c91a1839a019caa2f9daf607636573a25e8451a7c5e3656fd9c6d5d4d528ab05b00b4eaf293a9ed9990c1ea9787099270525044f6ffdd4411ea40129a4db85830ae72dc7660383cffa411bb531a2c8f9fb84463c5f4f432ce6a4d952392a7e1ee514cf60cc8f62bfee7012f8e43b6a45b8ff6da97140aa72f99ad3b7021e3bd3a038ac7a0bc6f38c6575b9621e7cccf95df899d0e22ef83168d89b2dcee55a867b25490cea8f75e0eb837188b71a2b8fbe608d4d619a674288e1b3397b645045e235942ea173c617107d1328fe80f031eff3b4b4bc8b95e816ec9365f0698d036ca056fc34220a5394c2b6f411f932a4fa622584ad3dcc21f51f8096789a5b8f46d02aae34134db1a3309764af0e0ddac5964011c3459f721317cc85a25dd500f2ce560730ee34e5f8d2fca8d864ef1f91bfad655113dcda4f405484f8e4b8e87773cafa93b26e3e7da52eca9159c4109e4db18530f1198609ea31505f4f10ba888b61da43015b9e3f2a8a9aa9229bd910e454cf7bf327831cf3a5bd710b6df98553c1e7ef4168bdd0ebbb4a3c3af599894500ae5326094f836ac7e4d23b0c863bb8fccd3eaf2dfd398b4eb84289ee4013f8c1cd78750e30a6d45f706f996f971ac7f192393c2c9af9d856668d87cbae82bdcabb04182d1f63547e4989bb9f63164f8b02ccff9745ef531286fb2367d884ace950e0dcc0606e67e3ea42ddb10b6c460fbe9b8e786e60a1c5a403899d385889342bd5060fb603b6f42d92f2ec86fa910d5c401bf06123a0d21c1bfd6e994a06321b3dce6f4f3b630a82b6ef836960a279fbd7b314d9692503d469e63235a50d7a01be4e286ffa9be4a90568d9ddcf56a0efb88ea6ccb1a5bb395e0278b14e6a1d56691420dd99bbfa34c48ecd1e0e84c2e7da56cfc5de4ebafd3920a88621e39500491663c3c2b09c52a04d14a233647280f56a4faa0d3fe4dd189be4fd827656576758aba20950e64ceb7082a64ecca715312ada6a8188eb8f05b9e9c95ec8d6b9832f95a90f179da058639b46578a9aec18ab4e75342f07ddc71eebadaa117c379ab92e0b1a7a8d7f9d66c537f33fd7b23fffa640fef94183f8ce9c9102cc87b7fd9be89a56b8470d6fce8154768ff505e4a948dcee0f308319d3e23379fb547f5779a182d08435a2a3dcb86222e761a41ade0d389c1e258454d653bd15d69a32353b3f9a0835209716931c0f1030ff6c93b924a79f333edfb2367ea4fd75f30e2d04377a8d619eb7b217042cbf7aa6b19498c2e4f37eb251744d6ee9fd6558fec4dd6146944e471451844c8b9760e1c920b5c68f63bafa4f1dd8a29b1210a14d4e02268a8b4e001cdb6b726664d845dd7bde553b14b4b72de12ce3c3d3f67c1d31e16311dbcb7d6033883387ced4e01b631e78b0b5563530c2411cd904591c63076a165d5d2d22c705986bb1a773fecbe01a990f2dbf61e268fdd5525bb7ea9900c0c864fe6f31b755d8daca901944037a2bc419cf4f25ed44e82a0d57a1911982fa8f0cf18d503aa954cac675577a094067de8d67f29b026479344e95b63c66b3ff3d74fb93b93302c7e8f71bbd06c3958e00c44c7bd0f9bf262d6ea0464501cefb564a0799ce1a9358f9c363b3c4a2cfa64de4c67a9906c16bdbc00304a199a3943ce2ad9f663d923dc06d2239da57139b5e17f3d2db894bf33da83be3b7f24761fe040382757ad9c577604a431a417d454c7d68d588fee0535919143477beae494221d3b5474c3429c3bfa942592b703453a84030ea7c5c59b3af43aeca54131d4592969f138912ede324bb9e75104ec45980a01944fe76fc80dee71fbd11671b04dd2eb306bce020beefb9d9f87882e848a9b4a8d86e1ba9fa3f179381dd88a5c0f28db83a8e373cdf0b7654646fc6468eccf4fabd27bb5aa8159ce7e946834a27de3e26dc8cfd3fc257dc479913984399b4c17954e5c5604d7c86225075e19dc238a827ab6349d822f0dcb27c7c35b8c18b72efdcbe8341df4f0d864cf242d0a5c219b0c32de372d5e0a7900b2eff5cb3eeefa12c93ffa5f8e8b4786ecd20deed7b806a87c6cb16831b7d25f3dfa3549dad45bde394055f64ab971f75c1c41b88095fee00f95df527e8d53460739648c88ffa1f70829b81602034b1c27c0a8cdb06f0a878798ef67cb9322ffe2f42de7c813764bc9544ed61ef33199a749aed1439138f2fcbe8545e7cda47382e4316433ebc404c191ec08c9573a83768402a7a45f2681993d3910b57ef6da4b14541d178ee7f871253e858278395f5c2d467ed21c234181ba241139e6f06231a7c4e21a9cf2ed160f8dd9e8ef325276f0062da43907b9bd700690644a80b2f0bf49b6960f5e09363ca154353372d45a8d4c15368361f3526cf159329b62e699f1f32e1144085026a8191224f60625d261dd3e5735b92c5ad20d5588be9b236a84ea742f6973261fb6965afdd908954e5f24416d33f30520e10f609b8ebb59bb97333b105f939c4bd706431673a1e3151cbfbf2a8dec014719c01a601e49185fa0d3f85f267e719231c7a08efb1282dd040f5e379deba3f906b7b529b216a2166a951520eef1631c3d67971bb80ba04c832ebe0ef9da73940e547b98400dfb7cd00aab66f17bfde504b239d808d8f2807e4c6244fd60b6572e55886952d2494fe8cf56044c3fdee5578e390923fcf1e8acf2e194f615fccbb1ad0d92f23e6d5e9fcc632952b7165db8cb09dadf2b6ba1a55596b8fa52d6b2ac3d8f8a7dd6f43dc49ab7f2d0e60f47e5580185117809889235b8f01d7c5b00d74617901b47bba7896bade58f332cf214576968c10dc30849e688e99ea9a29f81b334bbbea1a536d1ec1d9b383249fe40b5a17c41b2b89c69ae533773d0f77efaa7dd117d0662707dc76dd4b6a1293e2de836450408b403101102f3c20dc8066e662339e08cedeefe36e9a75603b8df845bfa52c9d3fdc58e2bfb86792e092a58d89803cef520df73dafffe20f0c053eb56f261b12acb49b843979f2849c9bbdd4fac4f199ef1d50708ac3681e455ae9175d62c910b2e56fccdb6c0f756c148ad4ccad0a713567ca51c7a09b9bbc5c38d58ed1f0799065e313d4c253b2ced5e7f39bf6a04db19123f489ac70f9cae0c5e45694205cdf89dd3311ea59b2717577db8874aaf71d6a759622e22b9e2e15fd453d91e22b2ad4ae414a8d01bdfa80233a0fa37c882f1a9badcb50594dea233786cebae3ee19178d0da70c181b2d36361bc9416c0d0dd6a0f9a323e9171b02598f47a3ef5e265b7b1e0a097892193f9cef09602d108ce95eef64f4b22e529cefa1d536c5938461b3e9936c01fe4e0c56656288c8ced9ca62a4db004cfcbc3c0ef4c66d2d4b228e8ae49824c335b4f9faa195d69fa3c685755fa6982b23954b7f1fbf82cf205216e7fe2b083f6adcae01ebb7158ecfd23075f59e128d798e80db255bc053b4f266dd8c156b956ac98492f33ece07827ceae391e79e9c4c42a80733421161b5575bd408732681310aa6d385bb5660cffb3d2e9d843a402b14d71b2fac02ee0193b0935f6ae094b9b3394887a8bcb00d31667a9f981103ceb6226b2a10377b8d6823aabb7f444a25f6fff358ea4c8eff518fce539e5ecfb8bd19cd476b3b242fefcfcbe2913054301ae404e59088c6d33f5b1c16b92f451d9d614bf34fc48f7c2c30cd7f27e38d7eae339a8c405df00f1755afddd9bff508d3f7ea7661a2125adc810d452070d647c9e16f7c695f88a52dcfa04e2d3c3009d268d7a2fbbb820476dcd90603c2766f587bde002c4111d1f989aee2478b8a294491943795af00f13c08c7fed718e948b15e108fd120eb2284f473d5373b75791a04e594d03d35c0d1b533a9a8eb25fc5f99760a831ebc2bb5d28167ea17edc334eb3ffd6248d4d984601b743e75f69e0409edab890ded29514f6b7b546d15f171529c8693f7092dd62f2e66232984f56c14bf1c730ce863ccdfe53dea68541d173c7b814993c74facea1ec678664bd022048d1ab36e3b9a633ca1dc53653f486c0db114a73ad86bcf0d49782e7badaf606ea65c98fefdde14130d389b3cf7f55bac9dd8d3e40f08c18f5d4fa92459d8d9fd4209baafa6ee38b0f603cb25f8d90637c28b9831b14bbfb936bd16d84c26fbf07c3b7d9dda21ed0efce9fa5f1067d7a2f93cc20909141e20cc0791cf1caf69f3312613c5891a38a909b6d16f87961a0f58bddfe8aa21bac024cf2620160c1f9146c609415cdf51ab323ba1708c8bf8ae5a3d33a08068043a6730ea2b08da39cb5de2bcae95c4b750c5072e129f601c0493647a54c553288778edbeefeea1169ad3d09fad94ecadafbdc88a90fb8b376f988844c67f4979135f49005561c756bba245b8cb69bf31f20fb76bb4547bf6e79f3d047e19c01dd2103dd4e7953c5028bc52b77351c7ab1cff3c13ff2716336313feaffa2273c0069bda5dc5ba007b502786093db0c2c676f9fb230e0c76f9c3d5b49a62a46115f4216b1935fcf7eec5be0de776fcdf578c39b6dfbb537c660ea2d138c98068d6bcb09581607e2a0c0cbf7e531c3be303ffcfb81c45eeab6068b98b6f3a6b4375a231a9c3796575381778da462d5e20bee7dec0cdf037addaa270546315662ab71b1a008ed6332bea38fd3e2518f2ce1e00c4a559e120ea45b6bffea853e383dcffbad9c757c543de63bba2b736e8f1a73d47e5b75d42e33919c07160e60cdeeb396ea378e5f12bc38ad6598fb7ccea17a630d162c4760b1320964091828d4f015fd9adf65e524c2150d267ed92587437bda857a344175d87900a5944502c08f2827bb3f74ef1dd929ebbe0e364ab3bd07334fae98348a3a706f3e8bb2c3a60f4e81115bf914069bc16406e3c927f9fbf50483a03f4a99e7b2475f5a8c0f8dfdb5752c16fa2365c455ec5b3f8d5272fde60ef3ff8c2c703b92c9861fd3135794a8aa44eb4b1df5130079a249b9e9a3bd2735a189cc0ae3fd535b89d53cea6b572df96d0b115938f9c1447f8117ae43eb212780db586b23f0415a5f6c4eb77248aaa5221a2576ea5c8a9648d71801b8ef6c17251b5b04a717225f1a19aa0d15b941404642750758f2e44ae5a571a877ee9983c7929e91393a64f3d23264f603055589351deae31d299cc0684f86c6ed640ca37962c193fa45d639f1c6ad0bd6c21f614bc3cb65ecd110482f973dac3a7fee6a30effac5e8c5bceed4bb72f08148133d3567344956aac37a0050ffbe99e2c28f920470aa296973f8e1febc01348578e85cf8d174e0ca59d12d7ddda982202fe175db1d8a19c16b925c0463fccd1335adfb67ca7f98b3053420ebaaf0e7211e3210f4292619c3d018b4be8b8dae4148eebc8aec70ba40b20443f375f4ea65b50ba9fc6694214ecbd931ace6a9d48470b299f64232e1f6d33bd4de7735bd4c582d02e8d4ec6b5144a259aca18012d412bb3fb4ae0af3e16b93daaddb774dc2a3387190e91991874599cc8db1a33740aaf872bfcc9fa0f0907845e4b53b73bd563f514827e42e26251d8a9552973dd520ccbc18fa10a70cdec0e037908c275be3b34b71ae9ea686779b4ae098ee0510acda1abda54baa295fbe014579f3cadf11bad772dc33e8d9a8ca6a6c68c5c3e917cf98a0ab31423b0d40f7254a211a725e3f6b2693b3704d83ed3e1bf0cd1c6bf7753598e2bd5002b2a3292f6dd2e824385c0365e6a6c2346c35efcfd47b05441f297f95dee679b531c295debca9b5bc7143ba79e7326b6e4395ed917d108e0123e512d5c21717ea1afc9431b1b7fb54c802a18c5a7e719a9064df14ed770ff7ef8e7396d0d062b7482d14e08e78e43951cb93f5d20b841cd95d38795a67b28b161d2b36774c4bd003e549e89dac927744f44e3ffa108b7e101addabd334d04d6ad922050052adb59e7048c60a50106f5ceb9e99f139be00aa7ba891c7f37cf1577e95db560a2e918c3f5e870085793bd29fddec653bcd1e4fdb333098336c98eb23bcc6a20dd64a4e938857c63430d44411dcf07a91f081285878a144d238d512b4ad15f8b068b182c7f978129cd70627f229519186c05c640e5a57b2101616433c4fdf1a2727b4d10166c00d8432340f1aa0f9a7ef219b0cff1963c9d6a3d0b0d10af335a8c61c93180a36843afbbcc6404378674319104abf23869c40967210ea8813a54275c90b75df1211f0e799b62c70c3138d0730f711eb11aa02649395110ecfa66e81f4c6dc0a0ac417d77ae920dacfeb9de936294bcce6f510e4b956ef95cf0638774b4251331b4796ae348820ef29ed92fbf70ea5243adab6122fe78cb9aca95435583d004b6e57a3827a03ea35990d03003c9bcd32cad2217664a01ed0f7cedb5af9c270885ffbddeed8340239c078b787b86161f686b7d37c97f533a9a952b50c50f453119677fd85b447701349cbd3f25e940507bbd7a263fd912e73d72379513a90392e643ef077850c57988362a84a7c236662645276024b655a900fafbd4046c966071402598ecec5fbc95d74760ed8f124a98c70fb46dbbc92c54900fc2dc05e4554fc86c364feb1f513c355a357baf510a17edc18e6b242ee847ffb6e508c81f53a51b666c620f3e1b79cc6584b1d943b66ec040553805393926fc6b38bc3f66e4bc3cad60c0cfdcbffd5de825fea1a846a13e15329620346260591e674fe1d0c35925f71345b8dff85fde7be07ed8e1b18d58eaadb5a78cb9460e937f7b253053ac27db61985ea760fee5c4f0f4912fb3d66a958df61ad822ef69610fb48e1483077832f13b6215a2d78333ee8f8d27f3fbabf1c8326e5f15ba84d2a33f523bd4ec4fe5114649c851e5a8599d185739c5398ddbb27fd086dc6d6441243e66293727644f3d630974160b1b504a44c62f8f137c1f7b7b55d894252748cbfd59052843ea79e925a2c4b39491bd20dd4dc29a338b690d4f87c95a695afaedadce35b8efdad17f624793de005cdb816b400245f28d98790a28a88e91443e16b93fcff09e89c569bf410803ddfbb364f0b2187a80f1b1513939e32750efa61182076f6f2080bcfcd8b577f7c08cd150afa263041e968f17d232745616fa1bff7e56454360cbdbbe13519d5ca3bd9f72fa98954908032a75f4fa20b11f554f640c528696342c3fbe3de1e63b17842cbfae909237cee436e313ad17cccbbc0629a908832b0e5080eea85b0b6bcfb94902b6bac6ea447cbfec6093e51aa452c0c9fe319ca165b6ade82b471f6f35b0cd9c83a27d9e99c79ed8591248274304d903c46214ca22a7e85a877a80d7a8b7784df18258261b3d1c60fcddad3fcb6d734ebc9c9181a01607356d9489f4a603ad606f732db291721546800b29b6a4f7dcc23f323fe6813de209169c6bc972b469ed8febdfbbf9ad5c0fb2444a9b5987a3315e86ad15b749e499e2c389a3f4ea3e9dcfdfc8fe5c47cc121bda9053b382920e28478e6bb7d4ef8213ccb886d00565a265f7e8c5e54ea29a957d981ff3b52b05c0fb89b3588e95434c50937c897cb5f1a0d4c15d3f6b0e345a29f2e65d3fddff18445538d75130ee297af8f27b8ccd7600ed1e5326cf03810cf05776c59dfda590ddd5b5b6797a67cef261b14093700ec4efe3a8b4aa4dc507440061597d1b778e3c86dae3e6a7fbf3989b07f9526267f15c509dc7a3c3ced2204442fb9db0a2c573689e479d9235853559289f3f7d44ae18094620990a1a8a81b16264c8c85e4c5799663a9878a6ad5829587dbe6fa586c4000350de2a76cedd6f401afab698e02add6342df4ae48a5426691a3ec5622f09443c90f4af1cc9b3d0d8789ea63c60d8fbe24229269eef32e2cbcdc17777fda93cd03305e406e3f59b056eaa20154636f3874db293469b66bc712b80df2f626eaf1b8cda00b506f8728e8bdadf813f6fba256aebed4c878cfdd2698f6f0defad83c2f36e76dfdb9f6ce76e1b3c9ebed4c37c65f0904dc9027ba607d5ac862266efda201cfb14cf87f4b3ad1d2eb8dc55f96d2710ed60ab955d7722b2789bcd0b46b0e555b6d9ab93a8ba0018981edc18d15612728d0c962b98d9aaf9e884121d7ee5de087039866f649cc964e5e9da1906e079c6fef7ad6ea21661e22bd2b3f0af222112b55dd3c4eb12a1a1387c0377210063979c1b05eec4e3b38eb75fdbeaf3dc4baae0b15450d85731dcb8d274cfa28710f69c945656cfd4259504b766f9c9dc85e809e48ec25a99405c5e47edd0c9879bda11d54dd77acaddba0d8da3e22ea9dfc4b0ede71b7c84080f41cd3f5412a072537e29d5626f763be7ff4ac9682141e89278d73adde387e120e6d85207153d7d8e3b28a40081ba73b19d48a6ed33c460e941c279e6f231dd24932f5477607f365955a30f624a3d72c8df76f7ac6f913c21ef6e841f4f8aff3d3b65bfff3d3732786c9a5856142e15770e51d7a9e73f8c512fbd60c50c9be2431c4c0de9aa0e966a19f54ade509bc339c0d50757acad0943a4dfca369a232e36caa14d837e64155623f7260a49d63a104e003e0c3cbfb730e32e0fe5a37c98c46a5e197e63970ed4d797d5b0abebff99e9a04dffa872fa34a91bfe225556e16ba1fba64eed0060f3a59dd90ffabeac54bd140b2a3c19f3eab3a1948053635dc9b2fd04d0f94ef0bd61271c5628a5f86b4baa2729663f84636ff86b84a1c85417dee0d2d45c91783ba9a64534feb83ba5ecdce4b2d33766821b39548ecd1f56b4113f8031042cd3c61928a0e24927a99a307cc28abeb986ac6cb310b24ba1ae4378c427b34d4fac64491c0897f5463423f17befb940bf327c97f2d69bf94ef52e9a73f5646f1a1ec4fa9de47ed2e9e562b9cde028d360fb7c27eb11c32c21e25c54c776e74ae593bdbafb9c4c7b9f0543936bb1f55b391e1ee5d4422f768bf8680b3c98f5175f8a9846b3719f092deba1dc83caff3ce831366d32d043a44da2964cb8b4d28f4948729ca6259502bb5e708c9bf717bdf7bf01a073affc3faa5213a3aff8fae7502fa71889049a3e97ce7f979557a48cd35deffbe760329bb2ce5ef5a591fb79c3929ffb2cead863626587cfd40e1937f265c490ffdb0c30a0d40d733fe2dcba005a2eac3831505055bdbb4ef13971f8554dc4f3f792d814f5127b0295c73ca776444056e69abf9fc3716c8bcc1b969f59206e5c7e6d62aec154fedebbb020f209803b4362c2c2dcc7d8bce7b261a1d1f59cd6b4570e5755402440113f04b3ce3cfe76dcd1e4cea2b4350019e700b75b5ca7b4b6169716f1aad47fab93f4c73e3d3f5ed9c92a0bc2995f64ca2e9365bb0276d028d935ad014f53c4bbff932983e1b9a32c25367fec2415b2947b29b93ad027daadd2c48a1aec8f07bdaaf95c19c8261cd8addcdfd04bd5fb10a0a664cb103a46f38b73bbf6caa3882bc3e61a35beaefd5d11d995416dcec4ba55fa8a3edcd40685a61ae05a98bb4929a2d6aad8c13db6ddd8b7a23237b615841cd6d10f047fcde1bbed996ab179acdbf461c6c5fe9479056663474aefe1bba1305dcd1d89c1d4886a4ee47e1df3c475dde7fe2dc68975cfb8dfa7e78881ecebc085391d5a2ac9bbb07635d21b8020a81079ee95ef8f1ad1b021e053c0e43f1d007889c611ecdcefced440b8a5a5d3f04f4679eac95df52bb95a5b9bcaf7181c41836b83ea83931d53d08090199ee880e008c877bee02d23af98d9a33417a358d46b1737fe1592ea8d73b0b6794bf818cc0393fe36edba3fc49e7034656250a535a80a31da52cf5560328627fc1dc297d799687f1d075cb835f32d0fe441b37a26e55f8276e96774895eb60955a42aa086bb20a154508f3ff346da1ef2a084830e044fd89fca29e0b7e212648790431e3b0e58183dba5101611aa5ae046dfd46c49ea8b6fb3db42b68f96d77ef7e89e49d7aa96e61df8fa613faea996f56b428cbff951a5c3bed63e3277726ce4e5003a108144babf4e1868f8ee0326dfc8c51b9b6e23336a151c946fae6a3e430fd70a9972531ec87234569080d6a224b4cd64472af337517a9c2d1c885b81c2276ea76631fa82f0da2321566e8500abf8d4c57f0a30395fbc1aa0a27d97413b0df20ee9576c7a143e184289b5b2cd38642a814a167d45f7ad79c2a79b061bfe434cd15ab8bf74005c3866c58a73f631b19b04e88b4083e3bc362cbee9bd45773aa837df1caba9d5722adadd360fbb474509bc2fa5deaf79a63aa60cc5da2d3995afb651a735f4454f9b9bc79a895e067c47cbf688fd41afe9ebf9b7872603c7a72b749dd6c8439ddc5f96c07c96a97691352a099533221f74c8754506ee222e158f308deb45b727970af692dd5f513f7d5b874e60a005ae4c21dd8cd4ccb5cc0283bbcedb4f657296baca675fb970dc447686821fbf99dadd256f4cbf09b25f8ef92c9c150acfa6e5331a6e1d73bd10efe8c9d14ad08cdf31a2b10f0f3e01a529c24fc6a7847eec2d5998b1a805c87943789a64f6c431125ea50fc6a3e7adb1bd98fcd70a70e21b1abfa66ec8e02133e8af46612a4616d7a741c6b2b785f19d0328d308e86fe5bd86586a3c0a7573e91a814f81f2183fa97f54c1fd7711c0b8999a22de66123b7872f62c0c87ea9f1a6994924d4fc80f9b21a5e44ae52b7332a5b1cbf76b189c22c76b2ee917c99cc4e1f7a2c48502f0cfbe03dc690e562902d691f39c8a987b9f7161733ba44464ffd627949e0fc7baeed9e392b63f467feff8e57eb864509cd95137e5f2a91d0a1658d92c20639e012f1f09704e3ea49b326ab6731d33141c0542d4cef68c2d7cb3d3f7c6b7cd925fcf1b8631a90349c7401adae385b3a026fe5dbafd55c2f349975e31f4918356d6c4bcee12bfa178b15278654ea1be101ba330a66733a8918389b064565a18961c222022f18dbd9e0c81161b9b4994875e12d3475c1b68ba9ad6f8caff66097d0f54e390c006f74379e2f6f1a46b32e5d5329104e6416670eeec0646320280c7aecb2ca822371ba6b0e7beea549613086b2faadf0b2e4fe801564c1e8961008fc3cbbd960186a15b079bc34d8d5029bb85236a3c09ed8e034dc220de8faf21da928e4f29682f11cc0dd07143ccac7704c30dd8ab66ac381572bc8bbc5f1da40ac425190bde3819157b950d5d31da1c60784b165b8be40857aa82619101e78dd4da0b21d71834d451fdad2b45c1d6d616e1efba3ff99db9c0aac05236e2f9456cf7e134a0b188898586ab89763fad2579e923ffd6aea5f7e543028decc6bf6f6ea73bc01cdb1d8a6fe3bd0afe5b199b21a3ef546ba1489fd03680d33f6b2b58961eff1cfb4ec0d79e9f8bb62d68bf0f028825959929547854c9705bef7a27318dd00216b8fd6c2cb99f0d08a8e0f378683f04b19c6eb700bfa64d64d5e7917892eb6788f8e226a0d4c317bcd640dc037da4a77110fc122c63036416d0f560c818a8e58f6bc0a535f738306b278ec1c3d2e9f13e79032fcb03ee7047f31fabb9bc2760463e1938171ff31830024571579cac87804e881dd49fb504fba95050909455dff14df05ec32138fd659683411e448facee352dca2db1ae7f3e7bddd4a943f5dd59f0ac73c15f74d29151d1406c75f305e87797d471d38fe70228e51cd253ad3ea3bcfc0ef1b41e63880d78b9325d13ed6ee419467e4862e3576c7cdf100c5051fdab203d5309fab09830212a6d2860d2e0fdc2569f9721a75d4b1ff506b875737f4cc2d96b0f0aff66e3da4ac7ff4c27fd7437debb79a2e913e2747880b86e6ca853236b37a2f3c44849d3f7bd6e36b6c9fc93ae41663aef15a5139a9c1a763a08afec9c41fb8f88eb00608cef0527f15a746349b6862135eeb792efc86c6ebd070b3c9516fbb4a2ebcf9a7f942705841e92572d61326dd457f132402575f5856ee40dcdc66db9747aab02099a90503de6422e3dde11283995fe2b57b00d157c3da10df169616a86e5495897b61451a219eefc5467d21700049be0086edbac33352a552bad8f69995ebdda155d051fb85197afa88399a578041d824a7912ecca702d0453fa0760e4f63976cebe56fa01faedda76c9361efe68ca9425025c6e4625a6eac6b780d8c044bebda124a18058aa16ddbe097ef4b126314a683c3d14c92bd5cd2bf971795e1b26cb1cbc4d8ab61b4a0c35fb412c11330f4cefa9a521ff0eff5e3b221c699454bb30fa1f1329884382ccb0d6b32a56e35e2412fddaa3033443cfe5d2ff8e7b5f998ce744eecf1fe4d988f95374e0fd9d53ec124e4484ab2bc19575a8c9c84daeac6a6287e3e8521f396a26dd575d654390332491e77146da64823b080b120aa510dcfd369fcdd5c47e0e2f2026b2cc8808590d8802b882e59b93e3565bdd50f61b27214dd671f854b1ccbdcd72a13bb4f872b214cdab2c0aca9b4a49025ae709105d7d42ce0f5997d02fb763d87b05239432c23885a5fe7551612157cfc2e9cbf87dbb8ede03fa23e64296ec208f5d0f8d3616089bf47bfd49384a2d854311987ac6c40b09d03bb441b5bdbbffa8f6561a07eadcd098fbb2b1fee82f3efd95d0ea87e5304eacda91eb9d41319efe81c9ecee53305e0c3e0451e05a04485bed3e15cbdeea58999edc48ba2ebf1eb3200f169cd6b501cb06f96038e533ea45437175a699ec48432e3b505daca252976e72c3fae9cd9bdb2f5e2d55d927f5efacb7d25349f9b81a5b193e13056a5d16a1ef67744fb4a20db1705e0fae678eda468d6dbf4a1ee7557ad4934f95390e159fd2a4695fd91e49d6fef2cb4653684b77931d02c9a69d23d09e20971ef436f4d4d34d77cee5e4b6d11cc23df8a0787f5b5d4c24c7c08b41a3f325f7daaa2dc03e314dcde6373d6b44f932b2fc7cda5383798d7ee0a18ab6f2006ebc9e6842b9c7bc25aa4904a51b9af9112cf8892bdcc4a532af4f79eff10ee62f21a26f7d6481ce8573fafaf1f451f4dca249d10f508e5c4d301030932b91657c701d14bd74a9ad18ce2402ef98c2c0d89569bea44bfb86cddd71823d8810e825a55b70d11187dc8d418f65b4f9ae2e4ab730c274363a6d83652b3d515b1061dcdfa7689f413276d3f5195985658f39c688c55740f4be78ceaffb6b9b5cce8b4d0457c220db7067c82ba5467fed421406dab87352b0b3712b6c04ad34284667fff500d09a1279745e0d5be7d75264c72b6f2b528298f36a2c20c6953c09d0ee4109b93833882ab2c2c0232af01cdc72ccb9857d89f49dd556392a219987d5aaf3107e2f3db1b3da1e6308153a0387648e9c08feee90261cae55e030ba3b3386439305b64654295365eb1518a69253796b0bec14265da6d0798a5c1c4c27a2a005d92dd127502f8a8e9ec80fe3e8b0cda1f33da540aee63de983e42add2b821644d28d39ea8363ded9100f6ba2b0dbe446ef535449e48de5ab5baaf3a45750a42a1867afa5a75e6f933f510d6ec3d66a201bca68dcfcf2a92b9e94871946b93243eb7d4c70d4b744388dcb2c0b5989d869e0c5169dc4f0260d74eea62f9b28fa3458af9bcdbcf4e244197e9901ef9c917d7217bac1251cba2d60c44525aebe995eac667ee328350633ab019a14284195b71cac5878427f43ca55d30efd0d3f1db8b86f670db9c9b24d71785c99b770a0e7cb0895ffc14a6f9150344c4dfc3a3b9618c49768560734db2afa7bf367830c46bd385a36318c4f8762c5b5060a2610d569490e9be9cc11a3e55bd6224ac0890b3df715161eb7a41937142af660e6320251ed3e4007e5c80ac9445ffe31efde953e5dc8d6642c7123d1e438623e2bddd650609176ceaff3b7c5e48a278ffa32be0436a0f7d82ad94ce9709bd7391879636809eb69c9e7e8e0171619560d3f49e2c294117c9f37193c104f5f90c2b39781f3d2cf5f195e0db2aacbdeb76e4ba12978de247f8bb9014f27b8255fcc90f49717126a4cbdf47c14b849bb87a76768389f9ae89776dbdd23b0ef2967a2d5c5d6ff3bd66beff5bda450d164c58d7d038eadf0479ff4c2147e7d8349be55fd0301ebd72cf2b0da72a610c31b6f0653173bd8e869b937b0eeccea6b8a4ed1235bd2aa4899bf0f35a6953765d19274cab36b668b07cfcdeb371750b308bb600fea6f6e91c59e205240fca6b32fb51d2db322b41a2f2afa75a08457cc10e017fdb16411212161a75fb4d6366eb02c7a8a3e4596c10a64ffcb9a6267e1742a608f905f1dde770c20f19811c5329362a4c3bb364f903febcbdfc0fc123e0995183100e873a7939172814d06d3d2d70f21a94b533b368d504bcda022179273bb2a661cea63ae151970b48403b8d20bba3070b8d48c975b60ae04b5bff969456695e45e417d99e9e6346932a6fddba842053a3ba9b9d99359c7f55d7702c51caa4d8b91f909abe92ff989c854e19bd3339b3e6a8c88dcee773aaa90ec13271c06407c49b288c146202b068f8948a4908753f177c6e12b753c86f69971249a68ce2d923818b830d8ec7d5d72a773de5ec5ed045cb98ee4419c96c9824100af8db1e957300fb07338a116c980f3301cb9fb60b424de4243d979bf83689df5003cfb2ccdee1e6b78da01dad8ed51cda0e30b030c8e4f3f73e936377866ea79aaaf36341509105aa566adc046ec96476f4de2ae68da9fabccb2abd8f81e98b51a02108230256825f002d86f01ec0267d5db4648115bdee14e233d6a51e55defd978f0428d0125f082719721aa69d023195ba692d40c0136fc99d5b698feab613a619345f402e5f63e45b12e587341d4161eea5ccbb0f667cd02e18a754119697bf83b051d9a25f2f7c32a99171377026c0b3cf16aa708aa33b8c50fe72d826e15ad5a0481a22b33c117e2d1c9414a09190884975194590aaed205e833e879ea2be94484f90f277de9f621a428fab206fc582e70a62e013bd79351beb370b435149a5f17f0661507e9d24d675e9bdcf9095491ac4ec3f613e3d756b8af2107f4b998d36e9f7ccbb006711c9d628e548da2f5de971fd77cbb7438e12105f651ddf61f750834e5b1ad467a1ce7e7dd7c4ccc0e18c63a82c61e88a93bc31cbc57395d3546cfcfbad0bb2399f931e811b910587bb6027e903aeb3601c6722a329cc3b1732b4398ebb6a7757a434595888cd027581d82b2953b8d84dae3555d8be6c8556c73ad73d8340b4c53ab784c093f0fc995844f8e57c5aae41f9e07e1cc938e3e902d178370726b238951f9f7a4ed6349d2ce9065c8a11df5c26435a7f2e2717c7c52e49ac6ed1fb1d53b6df3faae7700f7c1e1308d3037632c966c1e662588bca1422d08e4f3baa7156822a7d138042bd2ff1e017b0645712aaf223b4100e50b4723abb6b842f728f1b81566ba45a2abf6218bcf61e13a055e0ef2af47ed08d5644300d5926beb9e2ff17d92a9e77c5a88335f63f60ca5cf650c3c0ef10bc68ff4e3b369e7bf57841c4851130a1f67a29ddbf71df9c62d8ca489d633fe34074b6fc921833936bc30132086a74dee726c377d55c036d9e2f46d536d45fb9e34ebcf3eedb838df4effb58490f8d090616c432eb703a5addde55cb64cb47a887b8b8d4ea474496c0f699468ce6a0db80757303ae7d73eca2483a70c4b1aba4873920bea0f488341f712cbd12189a823c2bd9dd53646d63f7a20e3868c637e3e091681e8b7c5a2ef43410735e1489c66865091091fa27e80ebce04aa6cf3db7942840787e4bb4f4c70b32c7dee3d87260f4fdff0dae985d377de128244fcacb9079e3c02e848f937a278feb192ed1fc0292bb4653054cdd5f16c9a6d711ddab59fac80973468cec1d834e2ce151e1b274b9ce857ab242ab560958c5b1f2dec9f24547b225f35ba1e77de6988bfceed8af722cdaf5306cdd583babde11446d7e37c60e90e0748600a4db8ac1f2cdb009d0321661c2867d31323e0398b71065ebb58344861b71d76639740e90133b3c5a60c72891310b63e69464d90a0ba3f577e27d19baac1e8b29c2b105e05b02c976c49381a5a05ebc783f9369f881fcb52b3e61a6dfcf59634801f8c0739690deba0dec5c85c0245afa12cbc221e8de5c0465b1959bcadf2fa9fa97b77d750836a1a3e0ac191104b04c00f58e5c4c3144e0f09722a7cc763c1291461b3d731708ab51a410d22ca9a251b6069ce3ac537aa09f6573700c21a60421b953ed5f480dd68677d32bed740497dc28deebcd1e61778100e1ca21597b828842a0b7cf4a10f19237bb7713392b62fbd5daf6da3698cb79bfcab4a56dbb36f6f40002ec15bc873c73adffe67ef68434715fcca2f03cc5e95a813665894f5c8ccd8549406a7dd8c7ddd108eb331c0d289f71eaf2ff881b59ae37c3c61506f2bfb92af6962d3b746ae0a36b593175696296db833b362f3eb865ed9dadc2b4635edc06baae522822c7d04f7a0542c2dcd248ec51d1c447c5797e44a4267e0e67c0edfda2bc045c37f72dcc7901fee5fa814716e50c7cc2f976de7df393de51b6ee755b4b090be272db930d1c1ca44454d8c2f43bccce86d45b6d33ba30b9d9d8400437d2a57904014243cda74bc1ce5dc1b85fabac05adf138789627a2887170091b0a3d8ab1c4e34a84177eee9f2954d64bcede108a01925631c308be3647cb1385bf6ca1a1348c18d95ecddb4a165e36b2256f0726e4076424a9a1198ce90b15ee1f1def0ac987421d81b6832d0eec4b0c6e02faca5110e3e56402045fe5f41ae2ec64a7b6c6a5f1273e53468786300d60b7c6ba6eab7602c0e715db3d6a7055da86fcb20eea538e89b24beedba4794dc71e969d14baced490dbea55085f4ec037399a299b71641d046fa6cd424eb89d128162bfb55ac1080acd3eb542738cd0a9c68de3019889d4a98a1c7ccdf0813edd07f5082fc6f621225a9d38bbe512292ba007b4c51f64784783fa4d6517faf9e1aa8710a91d1138523aaf7b5b1588ed1611fa37fded6c88e93e0bd46ee24aed0169c5f9350987bb872bbae9b73b36ebb6dd42f5f195218a7bec5e97ee81e3eafe88f2d7a45b8b4e0302dee79c86eda75ebaf1f231fb1370133a330b1b42813b7d439f94d7384603a4aec7eb579defeea4bb6158393cd4906f57afd771634e8447d06329e5030099f88c345dc675c0a162007077b3f95f59af9b81acc3e76a628bd6927aff303ff11dfb161200ef2e75bf34bb46f13f5c5df1e96ef3f0ede3bf6277012ae3deb19f77c96936b202d2eaa77e9fe1df6b0b91b9868e908dc01ce741cfd7864b0d7d30ec1a3043a6e0a316d55ab1585234936e74eaf4b6bb2e14f058ff8618ea23820991f4f0757da2263b285b7e5114d8299225943691b196d53800d2ae43e301d1564b9e5151eaf8e13fd67d078b76f28f1075d6979e7a2c0a6acf06febe4ba5ceddfae576bdfd6b9fae268e4b42c6857b5ee6fbc6edc3ada42e420db5575f59beb48e9478d93096847b543e5661df529b025d85e623998370b9f017fea7dec12ac7df3a70586dba8574a61579a70aa33dbe0a8aef8606fa24a41fdcde9cbbfb271d6b6a4668bb46d7619df3170ba4073b4297c8d12e0b602b8577ade2aceb996b7d6aa6a494b4ade6175002dc2b5c068d4492b0bcf415001b9a8520dea93665693639491227d52e3b54fc2199fe54cc9f404cea1478ae60e6e36ebf8472f0a711d7399639c90d2fd9cd6f55bbfb750b5b04d376da947b062b019f0cb4ba3c1c659267e5bd095e987d0604a9a563269bed61ac57cda3ba904f7b95b406423197a7a92ebe971e95b428e615cf038c3c6296640af96a8bbb6a3cc9cb8897f0349b8f2be2e81a4563bd6f39bef798147a60e4424ee7f9b4e97e86016e891851a4f8c3735b999da22b6212ee124abcacdfb9d224ca3dc9a259622d1f0c659b3f00bbcc5ef5471ad846fd663b3e04a45723c7b08660f3463e854c329999abc7311a780474611008344521346c8000d27c8908919a46e1b68ec59cf8ef24267810bf857565c7b0b989a84471ee9a236c5d66dbf55cd1734f637c1dc3d407b15d08011a13139cb5865b2b32ef1757de89fb67aba2a157f96a86c594f0f0826e8476db107c982e908558fcd181f5bfd3bbcd994bfd47871a1e8a78b1717731e9a050bd994d9601a65f6ab69d1dc6404512b83538079258bc5119af0e1752d3e88f1487b903ece6168d31b8de468a13ff8e5360b5304e4435e69cd3069d79ca440d4d206998f6c3f21766c2d4e3df3ce8951b8026d9cf7cc0b3252feb282c60594511fa355b163fbfc4222d4e7b83dcd98b36b624a5dda249503f1d725c171f2dcdb807d5196539ff3af5fbdc3b095d9034c0550427324bdc0ee1ed037b9b1b11dc78e8caf3aeb4a4f9806801bb0da934ec0e51acfc7aee163aa484afdb5f3de44efba761309d9660764b4905180c19eebc960260cc07f16ae32c397972daf68d9400d56ee56171736d5928e7dc967026c5a9cf521d6612da64e06d93b4086e90a883ec3d7adc619d5662247ec5eb9a3d8d568938be664d99728ce87d23a56f1b17554941f8cb0432e9b57784a9a98f43aecbe19e623cce5cd34bc268770ce4cbf4827ae6824e9190ddb766c6e161ef821e9184bec542952af38b49b9c3bc3da238d8dd6cd0a44ba84eaee8fb15a99dcb078b41c39ead42be00700466b59b3bcd848f3e076221dca941b3c9e7ad2ee05173305c093b6af433f1f4026c97a07af308bf3ff98dfa194eaf4268c9db77cfcdfbd847082986e1efaec67261bf97e42ff3d9d17e5166bca3d0e8955159b249093fabcbffc0186519b32bab5298ee0c1fb9138c3f91d60e24646ccb2c8a87487ff0ce650ae136ac81e416d1931d508de8d8995a0cc3d4aabcde740b1c2e8a2906a38d5bafecde36419338db2c2e960cd7b4e716a7e23c026897e62f35655071512b25102fd44ebb877a1f04049170fd2bae4172332125b39495373d082343d241b1fc388116513aca99b005c5d8c3ce5a5593c0d678e62a0a59f84f830a4aa03a8a177047b323206ebd7c3fe1c1b79c866526ee76a5e44b561209590e76a33339f003cce4effa9db4a68146d008aea2e5cb06de3f191e9fa1f7b7384fab4a8101bea137817c1db27fa2c2774bfa79c626c4c4e01d6b7e4908958c7f6fbcdfc698f33722568b0ae0301cba63f9e74a178b03f4fdf4b87f1b6532ddae0978dfc91560493254e2fdcea608db82b2b907c759bca8692636b131828791fd256928fd9ba8a26a41c8bb27a7259a44e4847fe5284cc9264ed988667365317c0fab03eefd81e72bdbd966af61c60097ffb9774543ba4768be4cd2cf28108ddae5252ba29709fc2293dc1e6e7c09d09c0c3c54054ff296fafbe87c70b8ebc297aef382f1064444140dc3ac19a274e41cd81e0f240ef90a65966e5aac4e769561409105d8922aba9b78839323b2b8d184626f89205b1c57f2f956897c5b1954b7a5dd97d40edb93e9563bce81edba819f9503c6737b056d160eae3cbe5a2d9b4bf5aaca6b63b706bc26388e29bf1b97034aa18a0f71a6eba5784bc60f566cfeb5c510cc8ac7592681cb7580e4cdf19c6a6b734eefd8cf3aa3d5ea151d097333c1a3ec21cbd659cebff1353b52c1d7728bdf55ad969ecb6bce9292e890c3cf4664d7d6fb9e8b44155d01dfce98a203b5f13378950686c374c7ef7bbddcb80e76d8ba59b44c08f967210e354d69af9f68c639d354cea163571b2d293bd673bc6350459773a8accfd89cbef388e23a5fd2ac1fe9014ae2fb7805520d3f189ca17ce9295523db80753917fc73f314a16092673fd790ac3d9ffcac4bbd2530375fa40a7db4edb056fa1ec7b4447fb05441fc6c0db6bd12471267a544d27f1844cafa0e85c94d04c9e40e7dfabd33a632cae6a9345d6f5aaca8b04ac6aa64c22b45dbf26e21fd0298c837bcd4f8df05205e4784788db35d0b9237ba0e4df8a74b8a678ad6e3f6b5bbf49dcdcc51fd9d3b29af89171c65a432cc9f826256b54164da08c19172a1aea073b11e3055e27e8a6ec78afa361c8fec0d92ac9675d278691448f8c3d5609cb96dcc0c02811214a5624826c93f1102e812382f2ac5f409274267a587afc3357c8857d530f602a8c12b57e32cdacf1a64959d0ad4fec1283ccfa2869f7e832c525985f81b44ecb5d6f748558b5d52c79c9c3421e04fc0b1dcf22154393c8dad7046ea55ad5c5d51c3a74e87a84be214e15d88fa01e0c1bb001e32524b72798f422fc35370ea28b7b90991cacc8b81358f068471f075da52c98af5fdb752e00b88220f2dea43ec6f006456ec777799eddc612a95a8c884714e5329839c87cf89118124906595e4e4f5f2cd9b05f723d0aed6ff2d4428229d61ecf8c7dff67f49b6707f99e804323218e910e61fd10bff33c965457470da0e04c017a737f4ee72ea529dcc3e0e4a44064fe0dd786889cdfdc5651049b3dbf7afeb5b0c8897736599b5fc34fef3612c8521f9039d8f560dd0088ee77e72205b2bc9a672bc344fc79b6b0121797eb5f05635a0a0bf33b75a61dbe6f8c47458e216c46c4d2ba81299749c426fd04a7b45bd8401f08cdd882ce2bd89325dd47768e48d6e95d716a968a7d950b6e194adaa17c88c7dfdb4066c03ace1207e68ee1e353de1dcb94e1e92961cec159cdb45409f1735f05f7dfe7052b2ed5fad889c357ef3f6f73c59b0be699466681ba4edfbd80282d32f3781047a0777b4e24be7122ea9c7b79cd5775d8135f9f98ed991945b4d64c55c3e102e6fbf173a22c48b07de2fb829fd7420e0c576c3de8efac1186549c69ce47752afef55176299ce5510da10a9ce7192d90be0ce75d8a5729f2e67f8b65dcfd2b10ad1c5760138bca759774b087ce7b46434ef1a0185cd1b00cb651a914cef9d869e5be66b56b46d02f7df94d9d52b02854227bef6a6eec4f7680b5c9699bd321140cc69a44371b59b794b97f5a911e85b50e866ef865daa1d26cc0caad5039f90fb3e268b38cebff03f373185ffbdb1b2bb81c5950f7fbea44324f5405ce89fb922534b764374f125852ad0b1cd2a5138445d0134d447310bb80914f324786148be4e5d242d54a353b9965e3ba5dce3d1a6a7908402cc619ac48e752e27e66ff188a68a6e29aa047bd000d2e481b24ad31c9515e34f8fddca78c04076d0ab41c8342fcfa285c622edc564e882b0acfbcdc84b33341db96d42da3a7b47b54f1dfbb6f37ca0e138a487084e6a80cbbc51d4ee137f8d36b0c55ea662c3d372308da71c1cf92e7ef9c90745a67ccc35cf9be1ec49f05f574a26f31c8ab3ef6450b5c516bae3db9b237fb61fb78b031e70abf1bd6b0a918d418c80d42cb70434325da7ec59bea7bd1f43f880953428453dfd7e8e5dc9e92171a73ea00e5d065679792c9964ae20825ac3c09624d8b89b557647b8880ce0ade0482ada5cbd8381e0882820b0845a2d5ced3102219bf8a04c056e26fb7dc8bc5f32dfc9be202381f061a444c5f47cd521ea836851be9ffea4b6c605fa1e291265728d7336f6058e6b2aae0ebadbdc9e46674f56d0f9c5b09e1fc7c76d35101424bdf2fda8c79c2c4f5803ae076cd3f1827296624d04cfc0be4cba8e1575c6dd905f44d58565cc89d03449a3b5ebda01c7bf1c238771f2bdf9d0709ed72b698a0c7bbf9af47a061b6c6a45ac6b04914ec074205b03b795d39597b1c105c212d7f1e46f5b9cce37315cb542ff6d54aa8c35981ee6b247662d739befbaad004148b42702bc1bc7b4f480b7814473f2db293f746f6e2ba8bf6d8e9a488cc9c27ab9d257aa831b3c6b1a553c60315e88cf598727a6d8df8ce37c7eaee75a453ebb552c51031dfbc8c00c5a170774b394f6a7e0737481a36de2892fd03fe439dad67da1faa0a52b3fc3a881ace183c69ee77c64a1927a4fa2cf376f11daf074123cd7781ea5964bcc77e1a3b9517f2b11ad84e9584a3e989ffe3a05ec780ba2d971f518d68e1356c576f820265cd0183a0e4b0a21c2db707923b75f040722f55572cafeabe477ac84e84bf2feccd67cb995ec6b2786e9af3aa2c96cf524e26f22cd6211a2c020cd8bb1e6dd10f53ed2f68497f81ba034d6d6fd956fd45fb90be9f3e2a8f27ebaadffb96c8fb1581c64509afd222db461ec3daefefe2c6677f0b6f93ba6fcc9a3cec607f3d15a6adb65f217fc4023ebf2595116d42f6d37058bc0ae8aee42e264a329510aa9228b52ec9cbb73056ff9698adb820b9d3a81eab24e734eeed65b39017d21afc99c2ec76cf6f805bbca508a595c1d67ba699a561dfe88c388861925da73f136d645a526cc6744b8b3e87699e0ec7e85f157f70fa3784a864d1e5070e38de0564d11c9b2ac033988940821b2a41f22831327324d843e08805d1d2266f522f21d9a8084367dbca592be6fe8f369bc6aedc4592b017c29728872f3eed1cafef0140ad4181e904a9cd1c72937682fbdc159283b2b373dd23b42c8b88c098333dc6bf2bb0a678e102951cef8ec8c56cfeac5f720c46ca778a296c2b0c81ca9f48dd3dc133d68caaea89628ce415560cbeb01a43275dc1b5796b534ce651f1be6420c9f5571945cc89edba0718b5a44b3116eac5693f15d2a97dbc7b33989cf2fb8f60378ae7464cfa47e42393ff75fad773ba0b23618ebec082a1c50f1d043b66a58642ba3f2a4b62b332823d32bcc6784acd5007aef3eaec235c086736a2a59175944ab0e23ceee181efa6647a377f9c0f434cfcc34b1a848294d5363f8b569daa137c681ea4686bec69cdf3d873e38c820c04095f41592f3b73ddb7ad7ba5c1b7f10f8ffe34547149cf3bb37cf2f47fb84e4adb589cd192de735fd875e8c765e308215bf513578ac5253721fae29a3a48f48a0fc912f046532d8926f5ba4cd9ab47474266468e970652094bf46875de0356de1bf2e230471cd599b2bb483cd1e529461c825025b722c72dd8a1672d79a69405bf4f96b8eee3c8db9bb2040d91614dd664baf6141f562a01624727b85c29de9efe290062e2ff511af5fe729c1d42c8684a133e3dc5fd93f279cc9de9b18e09a87aea8cb0f73c5ac2b3e2ad8c76b4001cc304f991319943fba46c8f02a012dd54385861a19aa66366788631ab6047befea99dfa9889b8ee867603604cb3ad2e970e700f4caded8ee5c169484acb8db6ff1a808b5beaf1f39783b83077739ca97481a385ae2db51c8dbfd70295d6ae44836fb05ba4c15ef636f13d081e109751e3d5993871748711970ebbe533be0a770b40569386b45fdd2707652d5dcee9b57f82855705c190ea93a415eee0722783499a1094c3579e1a502a32d18ad5dd364efda92344c6872ae8970b4bd7325a32829800f18cb4182eab3b70b89a04e0025114d7c622c4e400850a836887fd79bb35d662d7b98b0ea7d694c4324e0c20d0b21ed9bae412c8cac1000001372a8f747974b98bf598f5567273177e42340b3b47b12f464b2c34a8af61967bc789ed9be7d2bc3bc6efd36254363cb60095039f7decee5695e4d3b2e10b4cbcec20d0b5be6d50743f046c4303cc7c8ff1b3f351ef425d75a3ad0ba32fd7ab5f6dad0bcbb8cf4d38a384af85a24725797a8766d7cfdcfaeebf2286d17c7617e713417b886fba855703463a6ebcd555edf87a1a867106aa97e562ca54681a0b6982763ebf316f3c1138efdb6c3f1566a08505f439c57c73041679622d01f06c75bb83c4f80d9b8c24169c8fb05e7077af247ec7e21538f8530eabde03c46a6d8f44cd63f11e9638bba12b3699e2d672fae9485b44062bcc3b7d9071eeea498f7f353dc0a9d179eaa506b71dc6b82a7922a2bd58a43830018c7abd70307618ee0a635080f64f3ed268af17d397d47e6d3aa969e1683f2cb5d0ae48f9af0b282401da490a8ecd48f351e717ea3eb5c2081e98e2bd562b8afcc11875bae910be42243163185978a1f6105a90ca256f2c1c976875de51b51392c87f71522b94d077aab1d36af2c6e8d784f8dcc323a69f8d78724ee5403964ffef7f4d8e5131ed65d74026e738a011d8c4b9e6f20addeef2a1ecea803529ec1d2b73757248316fee8a4904932d8b3dc8f15ac8a528a339c8623a829eda025cb391f0e70681d2a268f0f340bbeac599847d431558ece8597db7cb548cc3949969f3048284cbfa24d14a3c157c265ba515cf1b6a30fc9cdb7ff4cdd50ab816d4366a0c264893fa36364a156a1060a570b4eba936be12843d1f8e7badc81676786312766d8715a8c97b8862964f7eed45e485982532d545c47b10b10b16d907897766b2e194a957d90a8541ae1753cb5961f82228c068532277202e1b4d04b5e004dd02213db305db10354924c6cddaa99f7fcb58c121d2bc7a7505baa71c040396cf52242e495201db7bf5d86374aa373571b8733adcfaf04c75941db78bef6ebe21cb3c963055f9c3989cb564e789905076e56f4212334d4bde296e294303140a5532595a0666a18a6e4cfda681a6ee11b089eb97c873837380639b62c2cfcfaea4d7224aed9c38dad3fb20f70e09297aed323b17a590ebfa6a943e0750b9e3dcd7e88bfed954bb3a993438aea399292fad82ff8ff9e3e1c888a670cf82b42c08631471a86a15af923529ddb9e06a2b6fa9fb820cb75f8b9ef0b20641ccf982746277ae1364b55db8aae605747be3c6b120d79836be860b72464bb2e2a9e15d491a5954fa060851e267c26312fa3ee07fb3db15415153fd73aaa584aee5c6abe1881be15ee1b23d5a729553235b093d0a98071ab054e7181e5b9003c776e2a2c8b5032b85ddfe809ca82bffceee6750f0fe7db6ee427ba2910df632737d3cfb0d7abbd4c5001418e6f26459d53ae4f48bb97011748ae5bbf81c172f01d0db647d647e9987198324273baeff59eb774786de181ba7e0e5caea57fc89ffe5d4326d2a6128db400ba635fd62120fc0796eaad0eaede11d4c29c972904d300eb3a3afc5d60a96980e3fa95944f54ecc24617152fecde58219619f25ca80d610beab66c9a853c470998f6af636849932e71e0d532ede9ba6627aa8b1267c1d96a89180e74b7ed728e671c038743984a2510663e241f5e07c47d1c8802247c0d11824cb06bae1d488c2b3a0f5a100d42af00253c87012127096b1715346b8bbc8e04e069b2778eedd95ddd2b4639aa704f85fc75c64dae129ec95cde0497144fa5096e670bc862c891a05e495ff7c1dbcfb8aa201fff0ca69f35da85ef7e4179a49fb1da8fb48828a5e4bfb46b45f91da8aa7c964707a750bdce9b74407fcd71c90714fe3bd5040db0e0dfe91826b448114a6c52aa61d2f480007997627a2bff7c99b07dcb4a548b1f0e50bf86a92e5c742013933208a1a9bdcd751abac7015a749b84d8f40d1c25b48fe06a255cdc3baf3eba39236194aba353c110199ddf07774fede84cdd6c6119704d53dcfd89903a95526f3cef0cfd004179e04525f1629fb825f4507ee08fa77a2a7991fdc80c75a93ae70049b8360619cbc01215ce77b91eeecdf72121e7bb403557a03a98afaf0ae37597fc81de3e9d25b846e589e4f3f2710d4e73e6fca7d9f743538b7220c39946bdc4d4d6e22dd2474ff87fc9436f137047c16e6e4a46e962fe43c24c6302592e0f411fa0394e55bb3879cf6e25733d3dd5421f5489eb9ce7f5c8422b264d52ec734576a4a18480b0144c2c258f1ed85e7f020aad37e07f3c21d51cdc66e559d2cfbe0278d8f2f9ae227f183ec7ea4a2cb13da4705ba46d7376367a51d389a6eb5d1c9cca1b7b4f3a181ecabcd58f781c0d9cee8347f452271111748e07ee0a714235cf1a80b6d829c465d33979f23df92247de452aa5e0ff43a0bc091e9410af1876d7a2e857ca94cf355a6e21c39af47a6f73d5917903c7deebcf18cd36a7aee962c7c3395a8b4683b0c8856510293e3aede5fb6e27ccde2d860b3699514aaafa6928be7fe9f6b3fdb5a6a3f3f208aa8d3e01700568b13477f8b245b3fba9395e963dd2edbf012258058468c3ee38dc1cd729356fce0dda3189116af0ec1206a3989ef01deee2300724cc3f3215012ff377a56d672d1683a008a56e9fb612c752edd684dec707017e7f2665ef80feb7d46428feed50be1523ae247a55df52ce98cf56f7ca13a49a163237de47b2c8d24daf8575b56518042aa02dc19a90ff5d2019613ab8050b8e38e3550b12aa3acf1090a176e6a49ecd846f3c6e7bb6f1bfc1e621ce0f152dc8252debb7837b59a46afa91279260bd1ffe8f1adcf3c33eb65574e4b98e8c4539e1ca5f6daaa6e7422cceba969c0a7cbf38b73baf114ae8f003580ad9e6417a08d2575ede2cb83d33f437a663c39690039a10b89ebc124fb192d1631d098068e794bf1cd516fb47cc14f911a989dbc0240c463827975eedf5d8a1ada100cf1d24e4654ee96d7cffa21b5cfbd01299ff65ca7dd4d1301348b19d838b2acb9431071f7b77ab9f98f2c1d4e5a38b6238e8b3df2c461b4dea51fee768fbd9ad721a873d1a2b214d45dd20eae698b4776b46b9c2e1e2f571a12e749d51a29d5b244ff2bf8bff71a5cae47c8d6183daa9b7e797f5a0dfd9f2f7f918a1fb23673534bcce708b1c145820d1caff8f69b33d94ad5c56a97603c1b49c946c07b9fbdd414898de9c7da2a4aa4a282e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习</title>
    <link href="/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f63c9b57a65e064605c133397e088e4d2b5d7798897f494e1e51d39f271676f5">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82dfba35bf055a73fb0c5057120481ebad58d49d95221ab67efda99a9daf011997fa2c4e2be8fac0e97aed831459b7859973c20ab35feb109d11d8b551d60f702649ac15154499a1cf7e745ab22c40af1afeb8f25a7abd8fedf17b506db9cfa11dd4567144044100d149d665ce99c1a8b01efbdeac8855224fdc8f6c4205c0919dc81af43a5f7293dc3b72a2c64d52df59daf095c2c6e2748ab9a00def7c2bd51b6053f7f8f0c0417a8b871d6348ba613f0c6298ccdb6ba15029aa236558b2dd17a5e8be11ef278b2f8d5e0ed5e4df8be4c329952c91604b3d2ac50fde246f2c34b77d025cb89c378477654bcaa476f0bb9f98cded797727ae49202f8b5de0ca40b49d13c61779c8e7223667f27fd5404085981d2f41a3cd02c76f731c98b7f9e1c401ea1d1eaf71ef04caeb48d0f832543bcada7a18742f5169c484a6f7f9bd9c525c457136ebb794afe4b801f347e2eacd1a03ae8e2f62fb72af29d973df82863488455d61a1517705ee3681b73326b90e082978d0c1f71f6fb3550019db79e9f60501d444b362f352b8cff82761e7c1b951bdd36f2536134a42af4cd947c0b4be006ee6c16f388ff1b0fc36799f4becd80007832cc7a22b7be8045c6b2a494650b597ef873c6cef3b255f9f90d175f2ed505214d18155c65917db60b0b146641e6dc11c52e2d7e09181dda39b9638a6b55c54650cc5acb5ac27e2602f1dd102b427261050ee3cec04c86e9438bb9c992262744f5eee696dc5f54b8cfaae475f3f684ce686abf1adda7580dc7901cc0b2e46d3d15a9dd92f5002112c1e6ae078d2458106461b8b310f58ff00fdfbeb1fed7d2f0e4398ba4e98a63c997d2e08a5e49a3e14a4a432ff22c36a411baa89c7e2b3c8dcb9b9665b6954cad39060c839abc8d98f45d9f3fa275bc3fb6a41badef0bdcd380d2f95fc5d174ec0f99935a638992fa909ee977e36c3d385507d40aa1b6ac0dd02e9c9ae030a148495f748749963ed24f49643d195ff3a7ea7b654dd373396d0c53c71c8325c815ccb44b45bb717599f85b70cda3ef63b4647482c9fa90c0dc2697f91993402d9c57c9dd9c01f7b1b5dd4cb7fc4b83c2f31ce0aecf2c6f845191c7bbf8f91acd4b5a63d1964bfb69924ae6bf49fc1eab8420a872e8cd3ccb6410135d549b3e3d5f99cfc13fa6a4d34df510dedfbb39a315509d43ca907aff85faf6cdac6791b5114d41fa84b671243d695ec448a42d7486713ed842d92f60bd4bc12e8cb3ca607b1fef618f052c2d9a2beb9c75558cfdd715b4f21ed0444b66d9ce0bd5d3b2f63d9f41f604f9435a5053897a9eecc90b20fc33af1a4c0406fa90e12671d3a24983f84656683c3bef58b8ca9721f43759cb485a869477d1ae17713f013484a1afe9796b6ad236fe986c10a5274f493de8f6cd4aec15f2b745de59302b2b67a3f666d86dc142c210d62fd8dc885a71a93247d318f714407d4400a33fcaab1d83a3b00928d0abd5fde482a762da807fb538d331af4e90fea6f4d505bf1efb239f6cc9646311ec98ed2d9a53f78a9972fa6c92c3db4fe529f214b08f3ba01116057c83d0c3b1ac208229a3471c882983ceec770b350cdea9c1cd84672dbe6fe94af986e25be3a8076ed704428642b85977e1b2971b9f866d7fa10cecd2bea54d5a4da1407254215f6920d1ff96ccc7c7647c9d2ce3b578928282f63ec27be2592fabcb464fdaa730f2cb83a18af00588dc8c1a6ac24804e63cfa8fdef48a610d13e4c65e5a9a985d71fd71e6ded72061ff916b2592003d423268c89d120bd71a74001c32814bb309a444f0b874e058f9ecf0b1da999cf4068ff98bc2054d39f3bc579bf8db5e5973fca9141f017270fe7ac7fd00d3d8d68735a98437e39c5bb66ec7faa9c3dfe56b9327f945e386908730d3a980655c24c692afaf996804d4e3a82079d59e9da541fe1ded7d424574b52638bbbd4da2f6f7b49fcd0f03809d479d81d54dcde747d9392bd2532575b3dc551ebfa0fbf541393ca3b206e42908115e1d6a9de4a43bcc6e11528c0c2f9ea418956ae2dc241700dd0088b3cf2d65b12247ebeeaf34abec0ee200f5acc9eef60f53ecb2629d157a5362ef2d93ae421d92575e14c7828a9fc36d6f2b9107cbff65b5ff888dae339aba9728f336ba77ca448a155d1cac5e5a28f0f9197b0ccd616706737e9a7716dedcf196d8dea644126442549a244f8a58fc4b10db328a0e9b7d52b96cb81cd4239c31c68e3c54b038528c03191486a97dd851fb91532b0ed85ab67b953388220a72f9f136c091f1818e7dccb111357ce6c6d054fe9187ec83a3f281eb653f75b4f408f225f5c26ddf13674e5b46eaecdccbf56b4f69ce4dce08262594fad396cea4000bf50dc2e2e6b68f3e34ca27ceec87d0d2f4821d605a598575cf0df328041887b9ba968de8e0b91d9f95095ea73355793262521ff0d23d60f510184d2e6289bb41af22880facfbec46dd13ce219a0dc875786e43c6b85dc720995b697ab493ecaab721607d52e47c9781ef9f129cdb7dbd949b9c7c1e68ac2a99f390bc2ecabee5fe0fd46a18c34ad43c871230f684f57a489dfabe2503147d54fd2aa3010e85d5cd3d990b09c0d693eb813a20caaf442c97e672d93b0efda605ce4955f8adf7c2a3d64a320135c30509e6c7f7ba2f59847362c7eeb02c641aa0b6b455317efe33816148f442945d8c90107a76c8db43dac05d117c767e23c05ae6aa5d69aac0d2dc292af7c2be46decaf873d4801123e4a32ba8ce026ac09a3085eabb4ea635b1adc20caac814f2433650101f52b622735590b39b56306a192ff40018db7303c6038fa4f7c7212e98e19b816859b10e48df834903896dc656aaf0672c08ad3f3b01b716fe2961f0407f6ffef371efa7f72db2687f3a94fe89218fdb68206061b94f4c8d56b7e6ff159454be11a75401cbd66703c40554b766e36b2150530d03b893022cca3f1f4e28b9e76cc4af21fe76124fc2609ddfd253fb3e62f3ed4c13959979395383aecf70546f1546b02bbd500fd40ed945cb60a4b399da71256a169116759f5dff5e160908d4b001b5c05d0321279f027856b6f20bd190ae235170dc5ea628cc0eed4e23a1d1ab51d1a7ffde6a9aa0bf3695454df768f5c6bc4cddfda1b907438e3bc954aff0d2f567c662cde89d8779cc2896c457b87d44cc868ba52fcf990a254c6f24e3dddc639adc5ed7672fdbaf10fb72f38babbba7b41d8beb8435367c924807338a1dead993645f3dd76398840cb59bed99695bfc6ef4c3cc7a6cbdf4984805bea9e10e8bf4dce19ad79b6da24fa30e2ec4d8a761c7982e3703f49be73c657c34c59ebfa25b356ee9ea98a14f3eb2de15949ecbbfaef1bb5f750e2d5d76e08a08db3ff9d09511d76e003bb5cb4d529cba6d427ee2c0bd4615dc52191abdd4ec92d19192326267cd731c0a44fce21b1a5a1782d498e1d97c60badca5ad4d4e3069895afff927550a5b30c4d22dad1f669b7db4e42d418bdeb4387e411b94c05801a98732362b57a291cb760369c6c16832a7a445bed7ca3340a56c564c807abfd39e2d8eabb946ee294375ebba1b3d18465f5aeebe8833f5ad8e6c8f2106b4d29b09f468482b5013ed18f135e2d0d2a4e63aa8ddaca2bac8aac571e393ff4ddd14e104d63937f49cdf8c2d01dfff4a92d29ff40f4afb47517fc73d627d593cd560ceb2d19ee31148fcc7693f136398f9b87512a6bdc1365cdc85f77d20aeae54518d5e64071e419e214ff2f4b45ea88ff1b3730dde8c05bf211e4a537f9d64a751074b382b43c51a977e7b719ed48cc61923092123f2b264a4fc54eebcce58e16640f29c1a25cfe4e73efabe70da010398620baa700c8013608c24779dd82caef953379f3cf45a0042373eb62142ca932e6a3e376c44d8f438fb681c584758071ce377a0766d4fb65bacf41105cdd43cf7e40f5e3b58b7dcfd2258ca4c43274911d48f9742a185ed9bb34823ec8c4396e7fd1a55a264bbc1b215b017e714c4434208da144ef67b931407e9ef5c667890c66face2ed54dbd09aa64b0e7d3689fbdf9561f17e4c55877273a20543ca2b6dc50c40e39a4040e6740c1d0a0e6f489e898683b6b2e6337940aa466dfc0741e1a2f783d2621e41ca417c65cae58a4058fdd5125901c7ba7b9056d0b2329027dadb4eb4f389dae2da72045c03bc62db2b5301aa3759acbf0aacc258536daa94806201747f7ede171c2e417f4de608a824ec6a0f07923734a7a4b0d650254e97ea466ef37688f8ab87b35e5ab0ddeed1eb960feba6d2ca3a11e3e62475ab2ea4d012dd26ff92cd4f35b76c971cdd8e1824c0baecad2da0488843b26fcb474869e2c0d04a372eb65fc2117e3d26b4ce545c2ca85177ea6f08f2742287a0fac69b280850e3ec339f4bfe83bb30a70a172afe77d166eb3319351f2f907b665cc4cbc6a18353f67628eb0e499f99a3e42d92db096f0d35d7fb0ec4f8fe9fa23c5f3c89b4c1fb47a79cf6ead3175d2ee48dfff92ae8a070da811d768f134af454682361383ab70cb687168ab9300d19358b0e26007dcc41554546c663aaf68645550af7d9165b32caaf4ad6b91dde40977eb6744c3056c64df341485085d6992b7746fe3c36eb2b7ea0026794fd74bff61719384cbb47ebacc8ec83d2495e26b58854e7d24f4dfec56261fbd289cca30a36832450636a9ae489a039fffe3e6d619dcdd52f3ae745ab97d888046357f0e7bfef52276d044af4f9ba96b4b90b919ab51cd6a896a273f136b8419949937888cbaca9238ed9625dd216d5efecab469a9eb4034c84970d5805002eee63da9fb3d04cdbb9826d427d46bba6cf6605d340170c326983ceea151555318ace8cc6d06932d0e3fe9a52cf5043f79eccb72cb6ccc771d10b7b0443f3aa5c2441bfd74563520ab5abe2ccb2a384884f31f1a087a541b72a7478fb2704b803f7921eba1d1c9e7c1410c4b774569cc3de5bdc3b920dbb5be7f027cf7de8e28180d69930ae3246eb3240f97c136077889a2ee5347001e4e71935ed345bdeb3cdd0666c2f1e0e7e376594bfeb52a17fff0cd44a1873d16f1ebe09fd9b41de747d33356657d65ccfcf36b4b672340f4b2188961b93375521364c1e91fc5ef14b18c00ff617fc888c2fbca1f535a0d36c3ce65bce67b76efdd02e68632d117b6187928ef5ba3a3755967ad4dbaac5a9492e464425356a353014c6eddb1ebfcaf8e166bfbc4e3e9510499315e9d615173bf569ce237241fba2b49b22dd7ff9f567a800f34a3f37ded5a40c5e97a92c73550332651e51cf52586b85e4773af37c08ad75ea36615f816a27c8ce263b9bcb46fd5a835c8ee5045993caf4987f36926d52f83cb10595393b2568b3863cfa897593b71de01c16aff2d07ee5a9a7ffebfeed0b3b1149b53f58790f13083f07660735026284f45585fa3f767fa2f1802d380cc57f9c12dec3666a36bc9f85a4cf9b8a757b85110aafd0e122d8ad8ddd14daf5a7c179403de6396acf72a3dd0d053a8d0c06d8ad1451c144925266a1bf8b98c2e91acfab1dd7bef881f2e19ee6636278a101c60e1406ede5850b2e021a7c89340bb1bcd05c8f5b74af3af26d841f80e8ac8e7546424b6e95bdfc9ed5769f88b735aa183f075827628983f9df8599ba4e341ed1eae8eac8c5beabe316e4c616fb634e7e133cb8946cb87c96431a55b533267c893eecc8ca2c9c13978aaaf3645b5c013ece5e1fb1fdc4198e7b88ca987c226594bcce94c60fbbcd6f382bceb1a76b306c80e62ce36714696616ee5b28f02cb29e0dbf7fa5589443dc6579178c425636743f58fc9818a007747add85f463785c7d9448bb67d8176a09f40dce379f6b4cd16fc54972feca3097807d82793a3670816ce840fd146dafc0a4cee3a0b01b6b2cadf6b3f6b27ad012388fec7f5829e2f2cc0026e79c795a32457d01954413aae27b58937fd87982139c6477ef553de264d30d6b0a88fb09df6cf43c2abbeba527891b3c2d58c7fa4cb25ea7b83821db609bff9740208e430a082ffcdcaa94417e838d6e01df4b3ad50350b04b99c09387ae43cc800b37b778a23febd491c1b14ed1bc60aa914f72d209e089ec2f76c184a04c17e008e49cb0d323b2c384e49ff76d26901e5d5bf35bf08fb9afb6b3a7a544c534cccb4082ac5b3e90877e99390306d3d9ed5e67f550e1148136ab47c14c5082b5653d6c4111c2a421b14437fd31fdfd3c93c5ce57a102936dc630ecd3850c3d35c45e486feb73dfbe83a3c3f3f8287c358d18312a05e62e2a361dadf24d7efcd5f37edb5b5f26321353cd8a729396cfab200308031b4e6e2562b0637a26d6d481beebb1023d3dcfcc8962170c075c32f2e84c6f80b14878ab94da06bb980e0eb943c3fa3899387df2cb1f4e92cf475145e83d953c0376ab5b3415e1bdbb5a114761ef48da558c7384ce2fd63f383afc88a5946bb35aad656d448e6574c5622ae1b2061fd3dd91786215ba87f1d4b6de3b695232fb049358e1a350d047e509bd02e2176928545a054fcf0d825ff30782288966fb6a8f87fb9f10310b20a6c196d43f5d8c1f3e045167a08a00f539d2ec803b07d31920250e7f147a3ad72f74b10dabac780818e372e555f56023c02e90d83ea8527dd5d702540255deb17f7504aa24dd7b76310b46102b6143848fb5ba18b84a00b0ee153114bf54597cbd9204f9479961252602a4bb298695308ad60f0f3e499ec06529d8a4a285bcd19f96b580d34d1b3764c40deeb6b0ae090413bb85847fac060fb64a7ea25f887749b01d18892d8aba5f9fb952b436ea403342cc0e506274d974c695004756cbed70b38be7796340effd040ac87b7c855b30663ed9a2800727b5f7abe1e07422bc54936b825ee8f3c1a20bbaac48518a2a7c54b186e2aa4dd54618d7eadaf99a2467fe1961a2e69e482b46699a320a4609ad3e6ecccfc5b3958d3ef1e2303a100325ac0997926c215d12ab4f62c5d97dba81a91bb32f21f7604ee9ad9f95468e52ce4f432719e8a7bb0cec3f0dc8540c82c259fa7eafc44037fbb176a9b2e0ea8cae36fb8892a865354c4af55f8b2f192e62aa9eb92bfafcc9b3ec3654795320b0277a04e8ecd82b74c300917008db4c80ef7b0cc6254d0720447d7bf7da5635fde993055f6d6722ab3e7d5d5c321618c71c67b96221b2f7cee2fd37cde3d62f07d80cff060dac8a6d3b46b3116116bf0b237a0a7839f430981d4abf976ad41602c7631a6171714766ddd385e0b7e667a9534c98ee3e4535224d5cc297a6b5902bf72da45dc3ddea5c76a7d1cd386db13e0d137ecf7ee7ebc70bbfc05ca306fcfd64c128b636446cf770e27f80325dcea164a210e59ba69023e2051289056ed6e3717b76bca5e19352ea964770c7658669a0ee08281996da503e3447d452693baaa42953e7f4bb92f47dae6a5cadea0776285f6d485e29773bf7a2b98b7dbb691539c8fb57d13afa690763868589b43048af19460bf33fd29d7c728e92f8f4347d84c04e3df74f5f195de7493d3eaf391b3992a8463913971d984e2d723144cd1d3767cce546b3cc3cc099008735555c47dfd64aabe0771ecd15b136213d7cc12955945bffca4e05830ce9facee40a60153406462545ed7b50ca00f976e6936b77c425ce048eb33cf7fdc4a99c3a375b47fc9cb4eb19bd47bf3f3e9beb6763365a40e0572fbc465c03c32be7a7e5af1f487fb0903c6491665b6bab87d9498412c132726d84e8be77717523616baf82e7a5daf09400ae76ff05a93b6312183d9b51200c56b05eb0ced1ab785ee311ecbf2ebc5a1bccf5693fd1210e28cea09aa61e83fa1acc919d1a17127a80d0d22a905086e7093ddee59b51a45fa1aca8023bb1d68c012a02288a97c371edfd2e8855ee411dcbe02e9eda974278d8ab7c925e64d4a675096f974f809d58b8f07205c538e30131243b00e36b515e353c40f759d6b40895b269fa86f8a097f478978d8dfec515405216ab5d43a51d2772109fc5e4392373bea6164d92186bdf2dbf67d662c9bffbc0dd01bce1b1eec2ce2e03ce18d839d0f2c21126fe98470b428f7620a667dd415fc252d76ed6bec5ae6badda69f34d077d308a6f2883f73b2d271aea790667cf1b76775094ae3266c1420d37ab22f3623355e3409688acf5442ec0c6472b679d1e3efcfd012b3ddc646e1db466a1d7b91cc973eb9d70124e0e1fd40925d3484aa41072eb8ca1da70930055e14e82a58cbb6c3e22a47e7ee97cd5ddc91b81f23afc9a3bff640754a29c713f1f0e06f64385d9090ecc69468129fe7107ef8ab951543e03c20ef4109a4251be304dd0dac3efcd91d522bac1cf5ddb11b65347d6c7a5740bcafe5fe5bb0f6715103bfb29a324c6f1e49d9f9f3f52356c34e821efe02c796e2c0be90bed6365c8ee5c5208942467d9d74402831d8e0000c23d5688c8c0feb24d69508bac9c1d4508cf31c23b645e6c1f82d24bc29e1a39957242cc35e5aedf22bbdbcee4a1b7363c532b200c2a6966258a595a5e55b60733d46ba62e3dbdc7ef4afec999dffdb6b567d9465acac3d3da4786812554546a92e28afd33c883e7cb7c0b3d897dd7a0aa1836aa2971f79a5822235af8cf9409fc60035d1969f7d8bbc0485d4b2c837e3e1324c8f3542bbb79236c6fad413a40c6d554d27e9e5cd6bcd48dfa2dbb5eb2c80b977e3c1e02a603144d645fb12c2a8918b6c282788ceb401de0c51a68a77b7fc25c4e946133dc5ee12d08f0dfd72469b21fbfb86357cc475c9958673255c2de55dc6be7dfa6837e19778e0d7dcaad0f8e46aedfcdd612bbda30cfc3eb4269e02a0ef1bfe98fbb63b31d2f442ee512958391b8c33af21fbd39a4a29f2a38ea597563cb00d76bc05583d6a0d355db663b6a8d11069b154f076d4f017bcb1ba998ec64c55255aa149f39e920ccb8dfc75d052bb7fbc4375dc3059125185297dcb27240d11d0a4266f2ba22c4befed40dc68ae7f201b10c03d9cefa976e13de1b32fbb9a7b61ad9c1a191ecbe22939b0e4a3a6c13ea69c345476173d1c6fd88fe46e9942c49186bbf78e3bfdca275afb9a89e5d6954eecc015f9d4dc8cbeaff8ca2876bb621dabafde8494d23890080d5ff91b042bf25d5622f92d53b60ba1d44c1dfaf03919037430b247ab1c2b38a8e6b92359f2e249f5888ebdc962b3f7b7e35180c881e06d11b59c3b4c388037148d3de28f718195e760cbf8d309d04736e5f2ac268e122c62eb5cf71e2807d0e1338ddd7b4a39d7fe0580eb89eae66b59f90f562b144d671479dd51aa5a2772caee1235f409a4d78b7e16dca333cb1051a82f6945b3bf5a35483d02c07c3a353091745eb9fc5dbd1421a8691c3e0152693841c0f488608396b3d6cc5844cf935716c27475b400d84697660792b5e8bc27b366a794bb463a17f2fe86bc5b3e29c9dcf526f5263c7ba72f1f753d182cb392f89ab2fb13c4b3bbc7755ec35c6de1cc1325ed0eb326f768e3d96998220fb97a4fe6bddf903c466205a5ab2c8e7d5e40507274ba3e2ad8df3e19e6eaa400c38e57f12a6a31f456dba4074a34adee654bd93b06373b14ea0b10f5314914a27e5c7135a1a6b29687981a4425e1bc88e3f724ed6b118a4762835423c34790bf140d5fb0eaa18ea665155deb7b98415cdf29ef4f0aa3c0312a4556a6b3fb98d4ce3612d9e923c04197d5217e0ff830b1228cfe6bf955f637d3730353d98c21b7384515cfe8cceedb11cf1c931dd37a41b817df89624442abdd46170f6f35ea8c46619069addf17e17a837d836e6237e82847f969d03f53cfe1fe80cdbb49a3e2062142938a9404218e76bb2e8cb6f5ee01c405076d3e33e5f1a978f417f9cf9028ee818705c447050e090a9193fd2c775f667111c8996d77e11a8444a7787453d6854aec67ee3f147cb6dc46968db68d4b6704cda932887d447a903f59271caf07548fae52663cb79fcc7f0f6b4fdc7b73930549fff4055feee2cbd722a0cd313eef4fbeeea358b6bf19b85fb55725f0303371f488d3a02e38be4cd92a77ac2551758e8e4e743bfc3c81bcaa7bfaa3fb4f32a5bae0b549e2486fca52a5f275ba931b25e1f7f5643a4bd4fd091ac5791c533ba6bd260a547c48c3f7b00874285db084aa69c5fec799ce6e360cf27a2845b680938293db68a15d74428da591225fd3d45f75d881ad8f303fbcc51ffa01cd7a9547153043a5a5774bd6cb08f39ecc997c14a53755b22fcbde780d135b9a05ad8aaf71975419e5241398a57c8f40284a7529e864e42da9add3479d6c4e5a7233ea60adc5ebe1d4e4d5bf12cf753fbef8f2f4bf23485452732898833911ec00038a62b17e0a2b60cae309a5b9b3fa00118278415484c61219595e25a2a24f6fe16081090d67b11bdf3d9419efc0560dc8eabcaca5635e12b53b7ed6281228e2ed8f1640f3344f4b287ac40d4fd2f46cadf34cfa8a970e91a84b3d78b01d0e3b82616c5433a1ceda206a332f1011cf2bad6df2e71344ab645ff768d47e393409d648f45543695e2ebc25df40fb642a0f83d24c946917a600bd59d535bd90713f5a8573f2e161b5794da908b2d2f1094593237842adacf4724a1dea46150219a7cd2229b27073b42fb9d5d4e47c8c48c430accf713a4607262d2ab40badc0e4c0356686b568d4baa57a3f09e82765cea0f7caeeeec807c3748db080365653a23148ce259278fada972e26cb749d7a92062d74ccf3b3a34eef0e474a557d2a3fec1a23300e380cc53d80ff598ba02196e9bb9cea78a8741ddf35f180525ba33813d610be1ce3a84125aa1627abccbccd37fbbd41dfc94fb880e43852fd3faac4f7482d7d778e496f5970ecd0e9d0ff7c8f8d78f9a85e9a442b9f4f298368abcf27b2f2ae10bacd534fcc79d24857aa6724324ed602315b188a070ac90de58c1c9ed3fea0cd97298d98792966b34b5b77098266c95cc31a64757921796624a97d4f24283b72964321fb31bae72552fe94d5ae1d6d6c559f83d3cac949c69ed4a9b627dd9e8fc6b223f1bcda717cea55df5c8bd29a1be3654253d190d071bd5f1b09a44f2f6377fc7fab2dc9373bcb36e198f044a691f755fa9dae663d422fe49905a040efc070d7cbe392041d501514fb681265ad3650a5adfe83dd796abc0d59c3f6b60e9b899a8d38c7d9487f7f7c81eafec7d83c1cdc01efe3107e37932f609ed70e1f05d38f1cfdd7c7d475efb92310ff68ec7d5ce7b0d7cc3f010a322d53550c420ca076e99282e2ad0545e775e609701cb02e60f3608a7b84af9cf7819d4dce4bb7759f1106b2681f052818e7680739df3f7a074530c54fd917dc1a3b62b8fd78fa8813163709dfb0a62dcbbb095079ea1d59a4f9a14faa07f7b9d62926f57bef1dbe53b8c2dc7ab24535379f142ce2274eb5168bc7a83bae5089a2647a187ce43fb29ab409d1c73c5680f77cc8975b8df7aa178db2de8f8948a08d90320f01ff232a10f6ee777ac05a184222c1524d26d9f67d2f77075ab3cfd1e7077032e3a474a8f48745a6e3bebbac078dcd22932d99c919b7e109c7e0579f70a7f4eb70ada1b60898dc6fbac151ad0fab36e68e40b3d9ec42448e89d79fb0eff152c8bc8421090f1b7c1e06d6502b509a2dd1a5f1967dca39036d82279f336f9ec5f72e37f03c9b75ef7770cfc4ed1cf28a2f1db4d2bec5953dfa8f23840c86f62bb55f2f3408c219eba149d09e8129ff0999c43f63cb389b74cee996189cdd3fdd337166722a02df54cf403bb0683d8ec57e32f217336f6dd038b1a46eb0e7088e54d79034a695eb2f116a7270defc9abff6170a26fa74b936b6ad563f7abae4d4d13e9470681594927da6f26c8fc72026086b654a662b5970b63106bf2736250a531b785c09ad9d093e7af71e54e03b89a6d4b7a35fa48c660a269acfcac2c4728505ad6cb9882ad455e92ed26064d082184a2caace9ff2f946965d086c502d4dbd82b2e8bcf776aff15cb648ba2ec98c1338b83b2105a39915c7951633cb8bdae5e020741b373b52e16a7177e2cdb10cb6bf0df778c6181fa4f1fe1f7501f635c661e656e76a2b6397726fa0a24866410cc0b5c76ed0d7c4b9714f9c0643c7f0027173de904600cf41ef55e0ad8e6fe881949d6660024df4c2322a83007ca9b2276ea98738982f146e2dff6cda67fe07eb18bc9c923751098c48ff4cff470dd6e2664966ee4f487d9fe0548e5e2536d8e7c16527c81be27274f73bf114cebd36b3bd3430aed2c95653d5a33a30d9c7090db7d0832ed8abf903e4381fe4e18cc2f49242e36a47fdf0846193bdd6be736c70f9da87cd80a30458d5ebd5653c7101234d59455170a0aaaf3beaae583f28a959e2e1fd59da9498e5e9de4d3fee517972fc28005c731612cbb3728a824933e1f0e2c8214457c0f958bcfde64bb4056a3bf2227f116bc4d9c5f89bc6ba5e495494bc67654340f7d6075ffe73997c1ba8a1e58cf899cb36c333d9a388741abd83a02007940208258f4c0b845a9a77f9df07d9491e04bfe8117120c37fd46a69e5d376f2dd00479e5c404540a7b5d0f9c38ace8f1be572ae53e61f180e94d35da80b00e43c75ced91b915ccdaf7cbb85935865ab59620d629671a575fcaa8687f24737d038f70bca8d646a5663227341f30f5b70fc392601e1c3242350e33e37c189fa1e1dc9fdf8743f3302ab96185f904b2212fe14542bbd8c073925ac70029c1f1d581d17350b9c630439a483ed9b9fd3f814666a40592628ee80d299a85346daa80438061994d72ea7ec92ba585ab8ae5ee34fd39dedb422ef210857944749d851fcc4d8fd8117230e631cd002bcd88dfa8d2c1afb392965b5ca4ca8f113320e8e123e892b70f66d94f5c950e5463753202f617c44e42d2242f4e0eb0ee131a8dcd740ed013a47923d097bc89780e56dfd198d1732d1973ba08c13ed194e30b851957bd2c55e71cba5d9ae5cb761d13153f542d785e723dfbf48f16637741b69f1fb794005b3c70eff063c94ad7aed77d6f4791325df6afa9715e381c8f25f33c92dd3c6c36a657a1c950c797406a46e0693c57c8bba5bb68bff9c45fac1340f3b8abde932e022c1aa2669cb6cc84e2387209d6eedbd7b27f9e27a89928f84cac39bad6076c85ae9b8b41b8eec3fb366dc72e6a16afe5c5a72c37f804041a819ab2ec8ee78891d6b6f372edae44d1c25873f03cacdef31620d460bdefcd39fa2bc260238d0c393bd8de52ce941f12a339681424be34fbf72b7cd44eb3b97c95e8a36b72a2f9ebd74bd0b51a366fcf88e4df6a09dd4e063ae61fa5f1be429d607e617ea5eb5c67919bbfee29103073e9268b8923937a300e022aeee7df53ddaf181bbb6c441b609a213832ba04d5677267208b172a8d076ea780b0b5c7aa8e13843a117698d6732c908e8f4a69dfa48cef43f80650c5525c98d3f3a74c2f8a4a92a9488548944ffbeffe7c5f77de7237bc90495bfaf195e71a74729393756f2e4745c169142ff57a3610a86bc3f31e87c44da0f4ccee92b494910589eb58438e43a531b47f114d7695a1ec038c7b6660a435dbd903f99362760e01cd26059680a86162f718c8ccfdc9b56052e66b607fa58d505bb2c41bf1b43e15e892d8c0f7404b693ce4689ca0a184add143c808034cacb61b43b9c3f0a2d4a83bf381fb47c46c61e6fd1457043e7470994255feaf3fe6ee386d9e37c8a685f56829c746cf3de2f21f07b6e5b684a82087f669254137288011716739f944081ababbbc69d54529c16578e91a648d346079ef5577c927bce2ed7c43d3a16422a58dda8f98e53b9afe61d4feef4772fac91bdf380c2a071ebb95a50feb13f0cdc58e467d9918fe0fad90b7c7ac3bf0ac3dc6ec928e4b1e5685bb086b6d5ece692e4ebc29239eec4a9064ab35f4174829418dad5f5237ea0927de7acf5db96b6326d1f3210e35d123852e214f6ed83c7fc6f6b9c38199be882228aca7d58f95334bd4791d26650be7e4950d550f0d00fe40e7812e11a803a595c20561da7e9589469ae3e29ad6b6a496adb9057164940f3a860377fdf8adb0e6e4776294a57056241518a4dd9bb36b5a3c43b498c1d2b974c6a31a2c2c1fb0887453330a0d8ce09fd39b51efb86c611116b598afb76604c3c6450a8969cc5da13b0fef74af6cefdd67b1ee0a91106a304df7666047a48de62f7453f96e595de2bcad0fea81026d3fc981cce7aaf6b85bf9ae0dc24487717df873197dd7c64cbbc1279a26cd3fa6ff3672903f64be6fe447c24e8a043e2c768601364ce506c7fe5dd11944ae45a14aed9ae50c0a196d962b37627a460009944351e1148699918c1c2c2d811d2d8c3e0892beafb1e3bd8d48d7d34215ba6dcc1be37e2c6a2ff77e3b98f16c8a78848284540ad6e774577d0add9186a9a3495528751a7c14644af77a22bf84ca9d574f8ced96a7a28d83c6ba7da89c1c53d7fc4dcd4cf5f9f9dd9ce8f982433bf88593702eb1a65eefdea5dae8a7e2f843fbaaa3de1ad8dd2a9fc71248389ed7e02d8ae21c08a78fec9e9209453521ff829b15636a644ab735addb0893d1ad6daf7afd9362437488aba5c9fb209dd05f480f2ae67d9cc0a930dca7e8fbcecfe3cf0775fba530c6b72393cd78de2bb21da8a157d7c54e8a0758ffb06a01afb42d2306e32f054befe63ef88ea9a7e7c8f8c2a279eef8d4114d2c47b735f53b6db051385994bcf57c2023b7813f80511fe3b3192f8a6297f614b12f1345bdeccb968346860069f9a5aabce0c8871a72a2f199bc8681eab1ed9c0bc2972ade25e2e2d27f63da4f56a9463f1de81c83e6c75e75bcf52c9f085b224730bf73b77759058695844456c3e3fc275795be9ce4d60ffcf4b7719097ffc2aa2384e02b3176eb19dc17161f2fba1e7a89a709db0ae2f40eb8f4b6ea103ca550c5fd18776f0c7203c6a729f07547fdcb592fa8941e6c815e02fa110aed09e7b32537b65e3ea808d8dc05794fccaa6c9e6a67296aa8b2158232c742b6289791b4a540fa0afc2a2ea34762e8965478f0d688da80565e32bfe9c1f92b5d1400d51e3c7102383f85af75055145b60d1975745c70a95e3c3ee1965ffaf91223c416f31edaa1c395a35029df7bfdb6354482e7988506ec894e7eb033a87f9b115047c46a114c0ac9bbce2406a36a085fac097cbd821b3bf6fed0cf7e32d9d2a50ae4e4586de1e1d285d86b030110503a72ca5eefa54c39ea30edfa5e064bef95cd9382b7ac7ccb9c3a930aafcc42f1caddd619c2212e6e40639811f6ced73294c8b6f089a2ea89650bd6bf41d7d01dd8a476e89baf87e7320850c4ecfc4691cc3ff683a2f606e58f2114bf4d19857ff6386f9203c805536a0c8440bd1a431d6d4ee12effcbf604b8384eab68cc4cc24584c5d47945d760b44db2e99790bd780aff91b1ee2c92ff4933e6094d1020948afcfe8a0d4e9a944c2a92b19b6a58ddf1bf2cf97398a2dc573e6e1187a4b50ff7ba96ecb80058fc03326bf299dba6d96748aa03125b266d15c3e84bceec77f58f7bc23b6da75e44897259c22c2a1da50a373b84a5cf2d735a4fb4b1bd793c00002de3821912db303782f7fe2723194459e6ba32512bc9f55bda1e2fbc2f796674fff4bbf92d1e9895195e3eab0e024bf8db8c15d8d8146179b428c88a6c8b18a9fcc0f7e665d148afb2b25c8f3158b29ba5ac6fc8177d4a33dd7d11ba6311722d472111d6c6849dded847ad5065c446c19f543efe6d07fe04d13be843b12b000e9c23d8000d07b9c584f51df462419555beb7ef70c483b1d0ce45bdf0c8685a14cf64cde8c08d8d7dc78e8b96d071292682e94d5fb767d34530d93e32bf8be968c4a3d210d764380d6cb60bd91f81f714c1957333066c29a840c79cbb5c8de565a1dedb267799e09369ca727c4beb36855db1d2490e22906d09f4f465055b1056a113529201863f9d9e3bd23567b9008d65fdff1804d5d9a1106f3481a45db35e08b38ddf0ac54c5756fec7e11837b26520a6da01466d9a3c9bcc9941a6f54f0b987680f591efa1e1ca8a93322225dfdcc9501dfc97988a68f3ade75b04184a9ba9992a65c936be7c46be94d8efd47da04e4be5c18e25ab5dcb7020e47baedb1ae89de4a237b61c3ba9d13c2cee85bdc3106f23a6524a5dc92bafc934d13efaadf9bd848ea368a01159399923befccd34f123a5decf20c9f1814d028e8a799ac162d96499cbee7462796c785e03e11254239febd5226e0f5ffd740156c887af4acde8ee2d2964a30f7a73379aaf49b55bdcd17c060394230aeea89e975e443ecc4d7522b5042dea683dab460d4e74990cf68d5165819a9514952a8bc634812c23558917c0293164f47fdc0be69e000d0472d0e11f450942043fb6508e477855df4b961d97f9cfa2eaf485dff9c2fd93ef561d5df8bef2bad109572799a0f0fd414aec239e7a557e8d2f573a1413dda2055ed7078e8b3b4a201dec5990d90923e0c41c207bad2b1249b275863ef7f2781d64189d2620dc501458e2807c0670fa11a44011a7f22a837a80a9a148a7a2404b9bd5719b8b69fdf24aa29119a652c3433df6fcf09c758fa7e31014a74811e627f2b1b6151d10c55d34e864db8ceab2785d088d01de998305529915c95734e40f82793d08cee5ae595413d9aee192c903e8e0fffc2f3c4a6cd68f3b78c43ef0df7c2cfd139609b0f5b7f24296e5bfcb4f7aa5a683039b96569259db80f83ab4ced6c0820aa664717e3036a90c93e04605c6187118efa3f1dd28bfb52ed03f0c08aba147cfadafbe6de8c1af04584bc62ce12fb96eee8146431cc130927956412d2f690367128b0fed860122dd98f1b7d1b172e9a32056e027ba69083b9c7c7b8689857f34c68c8762a807665b73eb5e24a4c4ff4467b7c591dd1c05eef4f1199279fd30178f1524b3d4d3f303064867fe54c5508ee4c33c563bded94b14e5b492d8cd78b3ea31c74bd699195721fbfd1a87f26a949964dfb8261cfe2f40b416f72ee9105677a8da1c7ecf8a51cc06ca903a2416509491ba10a8c786c11bb41ac43583f03a6053c7275ea6bbc91f34828973055e98d79ac79c2e684298f6497cb12c5c53e9f040e4281130e3dbdfb8317c4691cd3cbcc5d305a8dd7eb615749a17c7c4e04ac8423b978ff15814f9de335d051a0238b06925793d3eb4fecdc254e9580b6b6b29a916d7271d4502ee8381e87c13521fc39bc4bf4548f6b04b9aead5104d9c4b068f23726fe6c1d9c34750cebf00bfb119e103a7cc857229b1f1bc98b7cfd9dd0f376172b18221fa7f520a3fb5414cbf2c217b488c0560fa1ea3c8eca2ab1d86f4913ef1c067932598837816b5971e1f8f69d55b90a1c79505e8a52752f70c352f53d6fc477268546d5c9c89de5923ab04c2d4618cc7af680ad46556c498d9a3b918aa0abfd8b8d2249bf2f82edf0b3e35bdcf9faabe4a27e6d86f9c6695d47be6fe1d6ee95bd596a7344c1fffe27b75539a4217bf0a0a4d7d76c68dc7f687d949629c2984392a3c4de49d69e69db9bcfe6267d80a8982e3a6f5a20fe38dbb2c8d3da7c60cc875d46503207166fd271abcc96990fbf5e804d89aa02337a94fb8f03cf3bc47cd9107b6d12379a24357320395187d890b71860e8e70bbef62d4ac45332752816c268951f479feed6b463502e8f7ab29141ff178259a17216c285f6cd4749a52191ca0f7e24af2ecdd3f02de5b9ed7033dd7ea6b3756fc9c7e07d3a8c068f4802d528c005d31bc2b6361467dcbd3b3da9533c122f34c93084b018157840b651d928e1db2b67535fb7cd96c01fb5def830c72a322cda533c021970ab2e89b7d8788dd3bf2725da4f358d2ee62dd95ee6959753f53ea04f0a27ca49fb76b98b9d572d6c1b83eecd9ec614001c4c2b421cf439ee5334742cf01dd7f11764c122b1e8c383ef1975e3653f83b4efc8fac172628ad4ce53bcc434112ef8efe24358bb88a4599ac3631b4cf150756d6a0487b53fe750c1e3da84c2eb4e92e1cc659da50420a1cc7837341099f10fbb3531d24b8be19a71a49d8f175424588a49b63e919f83dc47672358d87bf2cf4755d87bacc27d1de8387e5f1dc60c269049d8503a96d1198a78b5d19bc91c224f8992326ab009777a650b33de07d947782842828508d7c936756bd87f453b9508e9b332232472a78e09a201b20351889efc988a7d233137e783054a8bce4b11fd4ae6c878ad62fe9202c11756398b247499cf65fcdc912beceac88925496564dfe4f7a6a4e4bccad2319ac21a3c14ea90ab9ede0fa74935d43ba3819b43152ed407dc0894af778516cbec99e72ed45f0ed73d5ca31ced29229f45b7072eb79a461b9b34ff0581a3be3a4dc7a582882b288a61b4af6e452d2dd69d1c8363a50f19a086ab0af7de8117a8e0d518def561cb0e98e6cfe43af0211e171fb2e208d395d424cf0b3fcc4f9c289b915475968183e9600be486907346b67711e5e4ebd0eae1d36b6f8ecd2aae75525913680331d673c6ce3f134c94b7479188d1d3fd8e986a77041af3ae36a4606487d6c56066697720343355e36ce0964f320cb7e598ffd422d6976b4d73c150e62e884d6acfcb42522dbc0c606da5c72491aed8245e298fb34487c56e2c68d773811e7fb86b7b678c6e3a0708b211856b1478cbebc1428ed02b8b2adad1f059dc455862f5229674d74d4ab167de747061856a921d7ff1f25ecf651a1f11f310c812270b2959e02b5b38af71b9dbbefc3831e84d80be324155e0392c844c662c503a4c82e0eaa1ddf58d0727a1e252aad22ccbe664f54fa4275a72a55b27b9c20bcd030d70f880b71fb9624c324c4c54530b47c4e4d8fbb18d30ad439067a993c3a3c1a9240ec4f826255bac85a54b64ed4b78730992784bc49ed292cc4089b35d940591761642360650d5789b28a52eaac9af23d39af9ef150cbba23d698d15e752904855689cafb6e5855859e3d41c52efa3dae137fa09b8e08aad7c973006de3378bef2c3d34113365b80cc0fe2153e5e07fa7cb9476f950edc9653661dadb5d0716f214de5dca24c9a0f6d54b3f3142f8cdccfe2fc5a827654ddf6eedd4de03382a28e7ff0eed1577e92036cb847c32ba3933521804d052eb0b011ef80cc3566f0d3e8e9913c2a86f7515f02300b0189358acd9d4f32ee33cd5176c0ce6d88af7e43a4735546138c86b0f44c1eff5228fc85c0acb6a2440158b565b8fcdb686c5244baab05366cf1d0cc354c7563bebdbe490394c570c72f8684f32450f24eb16aa81696312ff6b50d28111a983821d58ca6392fb71a39efd575fa4d2f384d4a0a0744f57ea39c13086868924e852183f17af00b35c626d08ee82a9bc14630ae726fa705630d6f4b853e483511a85ff700a429f84c4c1f6519fe2ed6dc1596467c11b6c1f11f00bb9ffe8314a87a4f051355571c586cc67178f1046c6fb7a8c39bd12d30b28885e7d6a89d212458a98b0716986155d3e5c4aa8fab489a8480922f449c1aec96a11dbf891830a637fecd0adec30b97f47f78db1c52e2a0e2f2e2137f6436d01b872210d82a781c5f46ca056f443e4eb59adbe1ed7a85874146f713aac9a3ef8c69c744189a7e944444c838f5d7400475331a32f88d69d50f165e4cfaec16421c5db7f891b58eaee7e5f96efacfb608c141b108678dff248e7f582b166b712aa63b4d67cbdb2f1871228ed100fe261c7704bf2ff76b8b43e7a066338480b32b52561004f77546019bd86878be32bcf76cb7b600d3ed7655881324e7b78ecbb25c2badb3fc20d6464b45aaccd1896fd5eefa0af51f2f3b95ca90f1d2e2007d1f91d03abdfbcff824670738534b92ae0b892b1a19c4a70b6a469782656a1b9a4d4054ea793ff1961103fd2ff562ca794859bd41ce553085f7464f2596c30599626c4698c3b511148a8940cf8ea4593bec4e988c66a40ef6ddcc124a0a72f90a449e642cce4b140ad96137b80e65690d4d3fb7e8a2fb04b1ad741b3cb24a93560fc3b0a88ea995fdd9cf0a9eb3a19011c81562e6862f1f864ddc431ae06e6971f49cd35915601af9d02530d204e94bcf65173f7cfc5854a82d4596a008f71a10d8bdc61e18275a2a3850dd19bab3e039ebbe45ae92f5a6e99784ced4d49c3dff22f9b498fa2e41cc56dbabda43738f1d56f8896eee0217241d665164b1c6b3cbd49f2ca2f43b226029a3193126622e56e8e989cb20f459dfeffc553ce681886f7ab2bd612afcbefb1a6140aed5809a8c3ae3905ccba562c8b2f0c3e1d450959f3da848d4ee7f0f40201257471225c635881cd89fbeda9235a2e6d01586f2dacf63ac4cdca65ada2e1f7202ee519d4c1600be38eb3bd559f94220ab4b474b0d960e23b3728ca140a656b8dc4a2a0e06041d6ade1976d4ddb5377f83259e1717fbf88e49a7bb8339386d0790f1b2985f63cdb89078c2592c314c8245ff93f289bf470ed11fb43fcce8ffb628e93aa3fe99de25f2968dd553609f99b41ab86a5e1176d6ef2c0750d130a0551d52e76d1add4a7833dbd822281fb135f5351ea9fc756a80e989044bb46a8be61af793b543910dc93e4ac6b80cec8d7e54f40d9227e4bc6500995fa0b7988b9fa6de41ee745522265a3452b51804d69b8b3f17c6b0cefa25f8da70fa9c7d709f0057e8e83ee4ace198c84d1d7491acf80bb45597f1671cfe4873f932140a77fa8b6b1d4c9eab57bc2754f1187d15ab89d3858639e7cf09f86f29643e3127468d63e444a173cb984f2ba3c40c60e3eecb96e4d27bce6efcac5cdadc87c2b7c902ce3be70bf1fb3b3035bc8116e08bedf86c3cb16bbd440d6413f342377ffdb269fccd253582301e1e78384fd84e93d6da660cf2f16540b42d86e00170f1c7744a4dbb6dfbbb3a8f2fa3ea56fe05208e2678bf89ab1df11adad2dfca2297d7306d305ab8e34fda7699955ed3d07e05e612ec2f77d58688bf6c7e6552af4f93a6e335379ca79766b34deb3a1fcedf5371e1f0dde827adca2716c1b75e25f87553570d8412e3cacd0760cd600413f12fd786d20f41d13ef27400255d716a63f13adba33611ebf5f1ad02ab9d025b28fe9a2e30b030b69638478a71188e187019d70d05b55f1337057fabfb602d1140bdd74eb4dd6aef58763ad2a3f450b1a42a18e4278e00d0e28fa412e208481cd5688b03fafe1241fde4a28fa594f1903d4ed7afe859646c61b086f029d821f5511a8266b23eed6792587508fe2148c4494ceeb7739b43fc91b7aec6e592d954b3ae334f4c29ae1eac75034f7c22d187eb7d2b2e74904a74306255a45b66fdb7ad4327ed28968cd16be671e6cce85abf6ef0c19b64c1f0f14f4b02b25d3231a913b17cca90dd1c06a784d1578cc224fb1e10794460af12bfa5afc7f5a50a5feae55d6a574afc6410f6d3676400d5dc58f1314e58df138b7503982628c68fbcec78ca3fdbdf46250fa840f2be2370bc6735c6481e49bd921892028ac1ef6fa85cfc2af8b4c5e873e284e8356bafbe773bf7feeb2a0570e5b6021726d280363971bdae395f148fa7d2c92f310c63b9735165e336d6e696234fa053e29f692c5a7d11ea4c31d9ea6e637ab3e60177bd0f857570b3280c6524bd823be2d50a0297a2b8bd128b449223defb83d69180136342d86b347866e85daca2ad24cc98ec8d817c262bb86139758b30b27a17f93cb4185da6140e3492827ba9843f3540c460e0d2dffbcd636acb0723a4f8f62e20fb3b824185d8d727b28607f5cdb8b6c44eb719ce9d59293a28862d738627b12e35f7fe6f09ad63b79b23852bd5eb9f7a9e7fd9530474a689378bec7ba9da85fff04a5b088a5ed816a4c1c9b5d9a01c0a8d7c98cad2858dcc59d7dc1ada4f55938daa0b2308a12b1fc9ff01e068158f9fb04ab1609c091c9d023a548be8af1edbe4926a1fac9f3b5d11e08562c5fdf570d731f1bd65ec94348e9abefcad06112d6e4bc2ec0cf174a40637d6b8b4bc18369727b6a918f4625996ec21da25cf523453ecddf5b0ecff34b388f87b1f73ee198eb805d86e5888610fe521f35b66e052decb8a35f0f1f31b48e1f244f0ebb46ba8097d41dd7af389e1b44b7a48349fea0551e2d932cc8a0c782ea4d21ddf94b3edc5981c2997c64ae45a9025eb7ab4b751e0e6bdb34d1d76752432932e139323ac143570b42e189b52906397c43a3c579533c071a4c143d1168c72b31c294507c98b474751a51adf14d7ffb8a8c8e279a4113340d1f2ec873f1233c0e13de7867b8d865e218e2e0c34871d34845f37ccb0fe98fa631c6b69676278fbf319dfbe758b163dce6e227f5529eec9e04e0927548ae44e070c02954b910662216abbf890a4c26f23564abe7979f73ca4cde559d4cd85e164cebe4c286cf21faeb4c85eb38016651b86e44200fdad1712087d5250c4dc7f980a77d576f045e7386e9569fa52dad5500b36cfe658719fb89c6ef3bc022191bb08c4020b3d309ea1b6d8f96a250bef20a272668267c541e8bd958659ea0a1c04ed4a3c5da9dc3841ebd659c21b0d41044d9b167b8c4ee6c53a113b90b41184f102a76f15353bb52cc8ff006792e75d1b212a6b0a0b2373cc30dd620659f543e5539720c45e551c84e4dba8a7db221142e5d136bc3cb0e73c5508c435d11e9647820343a2222053634d5bf123f020afdd78f7160ddbcb5296f3028e25dcf6854345e4c1cd984489ce4ef300cecc4bdcac16a88d3d767d8b533e1062d7fa1c2546e2135ea9205133c61e28ade20901e9444869900f787513d5e39405d49aa4469f35099da49e78a1f1e04373319b5f53b738f821b57717410e892944a8ed0d7bcf6e4762fb4f980384cb3f8a30abc597763aceb9dcc37f3676c35eb828d82c3e70989146dc16d0c332c052cf92f1106ad9399c50e530a7e081194bf428e2830b58752c102ec3f193da2ba811dba26c35973a1144de293c69d26966f88623b6f10074895e0dc58e93d73fe1fcb52cc023aed17ce3b8e4670bac6c1e8e625808236aa4252dc6955d5e3fc9c7781fb801f30ec18dcd285fa2d235e50f900d1426f831cd144bd01b75e109df6ebc9d3e9f88d9d6de5ff65ab43471b912d6325597631fbae0c6b2310d8bbd37358021aeba8e70c896e36c418753cc5acf1c0f2fec1da7b546f7970a7683bcaa46e034b9d776146f72b45efbd34680f3e09520b03624d2907b061b1a57a7c3b9155c87c5a14237b7e96382da7add2c50e878a4e14bd7132f6c5ee905c49c926b094e0702aef0375fdead137e268f23fbd0935abd8c04d37417b31f9530cfaff3892e2180da3762037fcd457d0c219044c39fc8e0739291c10bfa1a5a6a7d621946033478dcc3ea84417a505866c278ef779ec48f27bfe73441a958f9f60a06b02976e91780f5cda31c9efdcf6e851cf1046b4777ecac637d30d66a3f89f50e0483796d330cd6664a5718164d50ea73a34289ef7ceca91fbfacb8935093ccecfae970b9b17115089cca0947642e6e8cde0774c1bf4020fe9fd323754d08bf1b447a27b072d3f99b64376e815ddb76f58c7b032a1c4157daaf3b8ce2af1a002720c22eaf2cf418d7db7a5245b2cda8b4b0bb5bd9a9c9842f5b40fdeadd5909ea5a90056b5b401b9457a1b12446449469fc0b161a253bd9acd1f3794a938767a22e7d519e398a21864adf78f5e40be8eec8e59a9aabfb8d45d1b5a90f732e7e662251e2a6cda7ca5736e904361ec784a37210c29b3e1dec45c702a3aad55814aabd36e8c8e05bb5c1a951a7f01db38441cd1ebe4a635ad465cef56b5cf737d179935273b0e5d8b92f7dfe8863d65ffbcd70b3fbc4dc338b5b4e60e315fa1211b5e3e1ad9dc7d9dbe620eb9b3b9e7614c033ba9231acc988975fcd11a644b5bf74da142c8660e8f408c6b8e8349d48b7a2322a87396574adfb2a716dd693d9498db8e7d1c90fbeefd39a9decff920ea708bf997b4e08651b7ad2c3cf337d9afbb0938658756cc4a88b0ce87775d6aa58fdaa6f15d212ecad24f8d5e3ec8ade09fc700a46ead1fed9b90970895badc96b23e81dc2ff2b818f27aec98f759b617a1186ae2a5d30cfe1e9a00b4ed08bfc0ab2ffccdc47c7ec21702851da1cd4b266e31b0f11b6f10ff1b866eb1fc7a11fcd7932282315d814d3d9213e39551de2dc79901ea2125d149fe66b307158c568c166996ec4bb4995ad1d88eb317be073957eb53c44219f7750bb636ead14a2a0545857439632364b13d5e5bd74c254e0661bdb1cbe172b79be829623e05f9d77bb17ffecf4cf6ce2af806756437f72921ed3f284bbbf8086d74b75a710896eb69773be330f2bd96f0b7e4ee90f3c33cb613f1f03afe99d4ebea62abf8eb0da99c5039eca36823a837ae35afecf8b88df8b22e4516ee488c99b9a6308f9ec197250863158cdd3a1863ef8747844aed0b2b32a462871c2727f631d0e9a8390fd7dbe646e18ad00227e27341e68913b03487047ad77bbc52783775a46bcbea54ee64daf87e65242908f3a84b0fc7b8aa9a8adeec8772e6f80e1919e39dffcd9d9be5838c53af3c9ee7108ebcaac70bd387190f47bdd62d36af3c2e10677d6e9e699b756f81170a064b2e2f650aa471af124f174c38cc520d8dde956c0f6e8543689e4186742f8c63b076b3bd595f69b2f8fe9e55013e82dcabac345071e47bd014ff0547540a32ca077abd8cc9a1ba86aa054963f375e2332b2148ff8de9a176f06d7bb6bfd3a764cc89aa53813eef3f33c5d4811e1270e4d7bc50b7d2df689e8a76a40e91715bc197040c717c46c3815d5178e1aa9d299768510f0c182f6a06ed5b0ad54e2dc2acaf865ebd25fab1f15bbd5b553390e1e459b0e53e77ebea85ce4effb1937e5bca2c9720da06f91daead1e5d5cb752d968ce66d50d9d2ef5e995ea5ccbe0db1916388eb9a8e84fac09be76ca269a25c200f451330e9bddca9ee46f9ee2880029fb507b5ba3eb97c4ed72fdd40299f7f034e2fba9d19810e478d01998c35a80a5bb52c5bc9c406af9a0125d04c8e392edccca677a263ce24762183ead60e915b14bb91cedf6af368a08c8bdc9c30786debf22771b12f840e0ac78d4b6b1cadfe5d9df8045d98f751c63a1f84997ae03b45a0384bc2548ef3cf0e36247955e5e818d2047bdea93cd485eff29d227e6774d176d1be32ef6620ab819df2a1d388c55d745b702542d2d678060dac992a1c0ca135361ee01dc24ec09d408db6b14eab754b4f7900512e8b44aa3ebcb1e8a98c27581125f1ed2dd5f09a8ce19c5cdddcc79e6e3c3c1d52c6c770d0b450f6733a88e976a05695a683f44b6e43693c932bc6fb9cb75ef76e4cc16039a5cc443189d99b08e535ec89a12494c0c92a35828a833da0a6fd6932703e38a14e121d0a70c002b9917d2f94085997ad7ba05bd38b7d06a98dcfe2ba4c19338edf8b056af98c3be1e6df47f674b1ed98d542eb3e7d8f8bd91b4d0ccbc7fcb50fd7e95abdb25b1391bde0d2612de80d041049193ef6babe01c832b0f2b6877f37890b3b2fe472bd33ae7feb01e9363b051eaa4c3ac1f7f288f551fd3e684c08b1bb14d9956f900fc5c9e1a93cd9a6b4e7384c0bc46fe4db69abb82ef01decb582ebfde5e4ef16d6b46fa0302d3d0bdcefc889fd3bab0435e5d717e843d46b7c337f9b589bce110c2ca3b6d3d444d516e4d54702ca5c098961b3878fc837ab28e735c45f072455f7741d123f569ab69070dedf84589969e0bf272b1b6eafa6e9005fa7de65a69e7b554a246fb4bbf32b6372c9404017e6cb94bbfd4cace1519af261b478c12241bd1c441d671d01eb6029c7fb7d54c55557b3116a689315721d7a94d29f3ea2908b3be29c195a2574914fc49d00f0b792c999f1737b6462e952025db2b31c507364fb32577da8012db1ec559f0b2f36497f2496b5e5e0698906450d1d3bd4d63183f96ffde928e8869820549490e38b97a2d3a9d27e69861bbdb2e3c4714db8431f760b133abbbf3e99f64e4ddd1a57326ae26e136707162c5eba9cd69b8a302d8304dfddf07de2ab9622cd859a2eada6ac525d474ccb8e5df2389a73c07c5abe3d1ccb126c4f32cef17d45fca01919188e6e76c7e02f35af8a7dbc7629fda8afcd177828403c122ca99d86a77bcdc797a7dd2b8829dbe26782aabdbbc39b327f4f1f203d88c59fe17a2a02823e7df283b7708227d39ca9ef38c7d7a70633da53393f6d8670b03303dc13f06c3fed82dd8cc142e9b377e2a4200bf32013f8691427c4904eb1abde61757cf1c5c578493bf32302497e4ae80f0b5f386280682b2fc753b5bf1da381cac15702a8b22c2fb8775bd63616de266b09c3b1a4a021cee9208f99040d262f09a333f3104058d18f103b28c223737e192b2668c5e1130afbb2d21e27ce2b34696c7fa4bac4a02947a8118863ecf45fa705ca98c41c938e82657e13d49e028567ab1095a6ccff19fa8450661ef681f7ac1da827346ca76552fa73a4af0783e50b6da27098be421fdb1cdeeef4f1bf06eb0380d7ea1d30e9fa98a2048f57669230b0e49e63f8805e0e5a78d8a3f1ab70db3e252a0c6fce5f91f388ce96cdcfed2190e65a1fcbf48c01079c19fc8c97675a1d0aabfdee5539545f19624ad3fac4ed42029afd53b701dac22f2caa577ee042b1566952e9d5726e27127b25f6c2c6cfb0c2e7adf12c28708efb1053413bb36568c522eb7b56ec070560bc31d7cbb4234fcf1c699c5c9a853a97bc7c35893b61cc601265a6aca6d15304aeca183e92187dff9db91405e6f54a4b1050bb87215234805a77860f7976a6795b826e2d1adf28439eeac5c402f8be7f2c22109149d09a30ef6f69c380863e521592bc632e9842b9d301479054028eb2879a707a168128506655594e1d9efcce68540216d90715cee696aeee088354c5ea5f506b68f5df6a9f6d1ef23f1c35637169511c12f35d942674f2564c99e7c38626b86b2ab94c090f66f7db53f1f09384015a790846aabd087950bdb9cfa722aba62b179d74b6aa594be3ed867d8956c717bacb9cc896e1cc0de810bf71b9db8223b11c866b1d1189ec4d53801ecc2b373dade2b9ede5ec4bc91c158d3784a197da55067921f5e158980b000d21d35421ce374f0d7d5b68de804f377815d1c5793df54eef6e2e9e7ec7a5324bca0db58ede70f7c76a543e7a679b496685c859c8e5470b5d9370736303e18501edb73302a777e955b20d2d0a3b889d8302774aa8583b50a232df074799d8009aadfff590414bfd8f87babbe92c363d8055eae8d016c4af0f52fa1e90d78dbfd2c3ffbed3d85ebb28a93533969cab5b98e49b3cc8cdcd8052e1a6da95340218973cfe3d79a4d68f07e4ab74a091e90fdd7867dd20555d3a9299ef58194018a8ce4ae7121b9002f775e405153baed81f48e316c93e33153d4ebfba4575cf3476d90a9cb68f978038f1d78daad3e1c3470ebabe362af3be0eff3f58e30da9a83e3d19e77ca2f1aad434ceb55bae3ee4f8fb65786458eae2a0ccc6f8cbfc68624b69eb98b66c6d48d9f110890181c75628042d8eca9d5246f3491923387b653d5212b22a882cfe39aef313f1cfaf1bbd4f0baf980f276b75a6fb91a6d685a521b160b70252ad88796f30469a341fedd5aa3fa2b7d8bcad21ccbb7364713a804c20c19ae8257c263629bbe9ebb65a21bfcc218bc047780d3fb28cd38f3ac0a5d5d0199347452c019107ceb7eea174245ac435e3eec9dfa2f3008ca436997b4f9e921aab84a94b3058594c3cf88e170baf2cc33220f9d90617e543b0e360ed73f45d8aa0b98916cf9f1a3024d01c464ad09ccf3b6343ef0322cc60dd4d9278c22dc29ca4010bb56a9e48c1f5a7a45da2129e0857042d7a2dd92d2a23d209e1233d4f7b225a7833e6662e69cc7411984e560078a536525df1c9e0d01b4796a72eb692c692d7165e0cd9ccdc8511f0f4f1e07acad48957a0afade5dd87cb440e7ae01c395e189745d8149f9e4d34692624ae118bf5dd06322c68e782224a521e512c50940f6b381f88e3ffd21e466903e482125bbf6dbf1f36ea2c3eb4b50abb324ba4d8408c8965bf8adfa0f04b1b6fc6e7667deb0ece0cd7cdf7bcb51e6afe6a052d68b6915db5c94efc5ed606fd313c58e9bab3ac37c422ecf8ed7d804d73c7cb5ad2b1565b730445490d069af7779f59a64bad92d2e1a4396a2d8f6b764d2762be4c6bf6482a920220958f33c3490a40457171d3997f54ab2683c35ee86bf9b587e85a5ce5949e9c2e81f34c3b7bf4daade18d26d609f842168b912cc823c8f93f4a692dcffa6ead036e97fa54832cc4aeae49d9362746fb89813a8701731fc05411d259181ac5d8803e3401cc2b4c75a9e5aad6a9b1a41c37f9fd4c408daf7e449eb4a45893b211b16f25b5e2e6fb6637cc6ac8af1f989f0fb6d3b3ab71f285dc0bd6dbebeff485db3d6907c7f51f489bcfbd48fab955ff2c0045bf09c7528fb54d141fa226d93325a281ae2c826451de5cf7ec5934afddf8f6304663d7266f55aa129f35f62b242904fef9f56d7a418d390069e517825f590cc1a6bf3b9f8e6ed6040cb5595fba0bc33957e2e2bbeeaba109273acfbfaaa9bfefce47f82ff24fc4394ef921f724ae098393131a48d695e9f9d672c5b4aff971386f757e9282097365eefd7eda67c7ed284fe72200b9d7a303728d9d9f58f5702b9af76306f13de42a8e99cfc1e05e7aa1f92e6d1222408728e1fe903a175761d5a2d9fb0c9286e0122ed4d87bef7fda54d50e73267c941fda848fafafae76092897efb468c1f1a951064be85a0cdde21b142ba58feea70216a365b75eb3af8478a738a59ef39c8ed3942fb48cbe7ae9edde51fa07b7f2b648054102fef862d13d0f1cf6913f6928c8bf3d03cba8e11093acd3da87184a015c7147f988646526d7bf477ae917545d0ff91df90df5e014a6d22bc44b0702dbc1d371b7a7fbcf1e8d005ead09e26ed2c2e529d4a4a907b76ec29002eabc073149d5167196c1eb184d8bd69ec04d0fe7b79d4a1b13349df5af7cf2e7eedc477be07cc0208fa2fb1042af595c07d6137be06bd486910a6c0c830c505951f7f00066ef2e68586c98863ea49e6d051d33aa70212221346140f75eed5419dbf4be6f7b8f2cff5a9020f3586a06976459cb48623bb8000b338fdbbea055df357fd819ccfbd798595dd4993c6bc2ff6ad1cd39db72ecde779d714efb1d7d008908cacbe7c77ecdb7dd1f8b92313d74c20d7aa071ba91d8d0233adce03686804af31796f9ab36f6737413f6a15273e742b8111509812c15bfbaf64e55f89a13008680fc91a09b4b4e374d2f5c9451ab4858587b87c7bd9819868939f7fe8e5381e068779a817f1ce157704dd6dde490e12f57b3d180a6b50423a2f212ca0d41874e9eae7da9f555c0d3f9db9e215e400ca5c8824e6a054560b2bb5526965fd38ea8add3cf6e25254b3094397bbb9b50307ac6743ab7c2404b77af9aa8220dfe40657a5f25d2c7424658a61929b7406d21af6cd09f5adf2064e76c79784d6d75c8ddfc6ffcc0f93abf75c31c891658a1ddabfe124bfcd5d5bf62b4c7a7a9af2baf0b290a95ab2e9f3bb1f5f64bb2f3b70d37f432bd3ce8b117b86dfa73c593c2078ee87995a0edee8fb07b688be342f55d1fe88545fa489805e3be592d922cc3cee05c7e0c9d8b86e70b033699ba7c6fe56435ef20b571818570524824e30b6f8c90db4a726a587576ced0eebcf19186b931f59095054fb5fbd385d5175ac991ab8608dae3dd2d526642e9faefee0ac74c803d08b886a37b3fa44c7213b462db811090fdfcf86c2fbd98f94d6e49529997b442c7908823cfa4f69177043d0b5a93b81528fa4cedc924eb881c47a4ca99a641fb6e84d14988ee309159264ae3e1a4bb7b5d7cbe4e114d350c44595f037fe0af350f7879691857ff7bad5e26a6b48493c5bc123395801fe1c6a80b9df1be55b5534b5cadfa8f2fda11338daa76f47d745a5395e76bdf83e65902856967ffcd9081a19cf1c2fd1b5b0dba0f3ac1d852ed046a21e28775ea6c7352a6d9b3069033f29c14c5d94cd2cc537574b45ccfcf4e9cd26ee7fe23c401af12147b7494281add91ef1c9cb50b76b75ceb0634e22461e56f3b30bd10c2731ebf819fedf6b69f5b4b01f6a0f029dac27b6d38ae2c6ac658755b89423c0858be20142765aaa4e7595e8bd386356fa98c3be93204199df29f06f7f612b34af7976065428e72191ab75f5349a6e99923204102778a85fc6b3c149d8a48cb4044650a84d081c13b6e6ef523bea9b1c7061bd2a0236308732fc2a8d4119a910b4a6cc6c80f0a98c1ade4ee36678a73bcd872fbd4024c6031178f8278c48c0c012f098524b1e8f01f5834e8759e1c1aeca69d8b3867d52a9bbc32d7e7d4120b020b69caa0c0032e6e1db49ec5c2bc446d20e77aa0dee70563592706ddfc586a21190742091a3cb7b18580db7a94ed587b511d8c132450edeedcf4433f0af0b83be2e355a85ef40cbcdd098c1c03919328feaeaa52f1fca6065c0587772e7ee4741b6db8b7a769584aadfe2f85d7622513bbd2a50b767fb831305fba394a660c75c675448141411756c49f36c557d7361d31d5e2e19b25b7844c4b4a253961de68e385c6ed0b1aab0a8b070e3c22f17130b3fb1df939b7f2596e4abdc6e77e4d68a9e4c972f92ba886ab64a9da5c831ccfbc6eb4a24ebcede2aa8ebb34832ab840c9bacd87b23e6f0e2db2b357d8f96ead811964b212037fae591c44faa51b766fe6b17b256b30444270cff8e5cc4546a607a89c23222d105ef91b8c3fee64f6b081bc16a1b16b51ab91c9e34f0e27b4d0c6280da8f0879f59ecc37fd3f3ae5a82c63e3aba9bf72487678a5f214d773ca664a57fa0ce8cba1a2ada05df35a369436d22ad5655378796c10ab992eb9ff5f67b7a1e4f92a0ad9891711e7b50efff5e835b9ee9bd09c39dca4655db68e1d23f5a9124e2eae5003aa7c092d8fd376eb76ab6c2818307264f9286f36948a13fef1971d90046f0db5120c4b0bbc311ecd75461e179f3319b585f8bb0ff62c857793eba82bfa5569066131f6d719ebd4b272436f0488614b3a0bc91452a1a3d6239b5b83bd509e4ac26e90d2d586df70e8ad7b3d584abd63f17a341db9429d1342a779aac6b4a82d2fbcee73531382e7fb9429c285d55ae724e8a8c259ed7548e654f53f8d63577c553a108e5049f79031bbcc01ef07d8aefbcb3a8017b2c93e249e8a988600b5772153b425842c3ac8edccb398088e25740c0527f1404dc47553969d53408c997ca98e4f0ca15e5de8c0b27c488f697145f3548d11d16c0c05deea080303b03a1a73854d0da1d5cf730372302c07ef5c90cc5c02321427e8c336f8f080b6c493a733ca2723a47ac08c77b7091439ae068a9dde1b5c50b5e928f6a436b8ee8c0de38cf422b55cc5911a8f01a6d2796dde74e699d07c0b4d6a7c45d3d9c6175f7a785edbc6abc7e0e8ea26ace7e1e516dd9cfabcee8391f116e7970f81741d82266bcae40ef8ef856f4e5ac61e93ff2b7b261d51c7f0bd17aae958c69cc0535b01543fae5587f40d76c6d99ff4880c1b969c6d81905a9e5bed427587adacebe49dedd857acc267ba3bc8993fa1edd1b45fb2422127e6f42d89d77468d2dce9a9961f48d3200083d0fe573f18f6abb3835c47b4461ea6162739db3b9474037bb3e3a477865f440b1ff2e6238d62b7621bdf5d2f4406f23e61f7f9e393277af761105ca247ce9f0e39a32584261cdf313c0b13a1c04312e6896b6facd97cbb9cf945306d67c0d83e82a54f9e6795148506cad5b20a6b6f9952f0904cc3f1a0a9d056ecc5891614874ccb8c54b6f7186aff034371a2e1847b882660517d5dcf67335b7f27fce1f7ea8298024cef60313039b808841114dac97cb46000532a810a9e0561d8640eaf9130888bbba3be272c1a0427a79ec03a1b38e1d2ae35e19b077327c40016dbea37858c916130ae255c31a2ff661e02d8220410af62a279ea8f1d9e37c77560671035a14b6e50ffc91b926528d66428733eb93c760425e619e09809f89730c4e341b2bfef62d5d954651556c4b4c5294312384c6f57442068fec20cad8feaa63d62931795a84e8922f518972f27b11c15e3be76905bf2f821230cec4a7857df0eae6ab7509a4981bb0c91c6299096b85e12a500721c36be7599987869548343153859f870fb2ce025683c48c583aa724d297f05dcd758288462f8bdec30f55c4844a3eecf56efac748924009a8ce65386037ff690f38193f5e09a816207cda7cc13844e65e610299528b817a925e111a6cb3f051685f8952e4ae8994e13aa121d40b8a6c13ac67e9cb1ab1957894f8bd419bcee01aa6796c9511bf3df7e25fae3db1a4011b3b44bb1e805a6a52f39fd640c5cd9281a1b5a216471ced12d760f903aa1ad7a4fac0ec441b888455b2209893cffbb609107b8a6621f231d88368438093ac981374c8a5ad693bb4905ba68d77603908183f30bb215d86c994fa88b7f3f9a560ede0837a9ff55e2715d9d80409b434a10603b8a5bf613510d2fc98bc774a1801b2802509a5e06b3c01b8222aaf3bf37ad5d6dbfa8434462e440a306cb57fac9531f52fd7beefdfadb68cb6a26de9c1ca2fba2da472b81e1070a4652c325c76146c65d2d000580600fe085fbfe099e64e73d0447568b1b4374b98b60dc43cff79747c655a7bfe9882f006a0d6b1ce6ac835dfb986b1c7273afa87238f2fb633d2fb64523e8687358194238076bfcaaf804a63f7aafdfccbdb70568e8a789e9a5f7ac03420fee760d6efdfbc389c7fdb1f4ef31a02a39dbd4925af40b37f28cf1753b9080fe605be95a8dfc742589b6f7f34f9bc7d5ee523c3fd09ce49d2bd150f4365f4c0ee47a31701d9db516745bc91b9d93b5fda361dccd788872ad6bed609b8581226f5d1d61f646622a2fa2dc8ceab320df8b45bc1c6320da1db5c244b445e9ba8a08fb599c2742a792b741cd27fc1b26129c593422cafd5e10d31c28e111c29bfa058cc3890bc4852a8833edd99a28e77f600c1cd520b6c8d5ebae97e572cf07eafa09e3f0764766e6886ce42f76e5fc40863af5d6058dfddc472e14739a23238b2f2b34a469d5f6d3f088898666c5d4ac40d94f8ec05b66e83d839e2694767b7bac1e5407ff34d517d2094a31aeec85d543d8eaddf8f601a9a2852ce83b4c49d41ef055b7b4fb90324cef77e71007fb80697b91eaab112c62dc509246f6880f4788e093e3b0d01acccc75b98b3a4a584df958d882def08487e159dc1dcff19272c4d47c710420e5cab9709a73dc26186d5dd3f1370ea686d5b5d731f16b34e9b3f8bbb31c6005cca9f76ee21a682c63fd4a6705562021c3d2cdc9c8ecb304fa713cfff007d2d0f2736673b60d392b2342382a3a2be84ffc79c5aecf466df1c82d9b7402fcad96ca3f5bdb128674edade13b830c195ed9ac08754b56ff09488f7396bdfdd5b3070623ea600eac7d9655aa9b483fe8c701f4feafea1c5f3ab7645e675115a40b797d6ca8782b01224fde8be77bd890099e280686745991bb9948875b70b3afbaa4cb2686202c34eab739c5eee6b3929a7bdee622da5c2177e81affe873f521b40eef27b0ecbd43ed2df209d0221d76a1e1ee8f7a6c5cfeba9ad32079c12fa4c92b1f8da5b2a6f9e3bdc37cc5a2acc7904808276978cd5c8d4b95998a4900e2fe235292c1c7f1b00fdaa8205efe34c72462e74f89e73771e8d4532a7ba9a91fffe04b7a5614298951a42eee8a4b6eeb68b5308d867d2614c1dc2f1310d3f31819fe1bbda5abcca689c0bf34495a071db4de9b058eb6803fcdfaa4cc37ddb871e1a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习知识点汇总</title>
    <link href="/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习知识点汇总"><a href="#深度学习知识点汇总" class="headerlink" title="深度学习知识点汇总"></a>深度学习知识点汇总</h1><p><a href="https://www.cnblogs.com/think90/p/7080251.html">深度学习的57个专业术语</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 定义模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Net, self).__init__()<br>        self.fc1 = nn.Linear(input_size, hidden_units)<br>        self.dropout = nn.Dropout(dropout_rate)<br>        self.fc2 = nn.Linear(hidden_units, num_classes)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = torch.relu(self.fc1(x))<br>        x = self.dropout(x)<br>        x = self.fc2(x)<br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># 创建模型实例</span><br>model = Net()<br><br><span class="hljs-comment"># 定义损失函数和优化器</span><br>criterion = nn.CrossEntropyLoss()<br>optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)<br><br><span class="hljs-comment"># 训练模型</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> i, (images, labels) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        images = images.reshape(-<span class="hljs-number">1</span>, input_size)<br>        <br>        <span class="hljs-comment"># 前向传播</span><br>        outputs = model(images)<br>        loss = criterion(outputs, labels)<br>        <br>        <span class="hljs-comment"># 反向传播和优化</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br>        <br>        <span class="hljs-comment"># 打印训练信息</span><br>        <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % display_step == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;&#x27;</span><br>                  .<span class="hljs-built_in">format</span>(epoch+<span class="hljs-number">1</span>, num_epochs, i+<span class="hljs-number">1</span>, total_steps, loss.item()))<br><br><span class="hljs-comment"># 在测试集上评估模型</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    correct = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> test_loader:<br>        images = images.reshape(-<span class="hljs-number">1</span>, input_size)<br>        outputs = model(images)<br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs.data, <span class="hljs-number">1</span>)<br>        total += labels.size(<span class="hljs-number">0</span>)<br>        correct += (predicted == labels).<span class="hljs-built_in">sum</span>()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test Accuracy: &#123;&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">100</span> * correct / total))<br></code></pre></td></tr></table></figure><h1 id="12-1"><a href="#12-1" class="headerlink" title="12.1"></a>12.1</h1><h2 id="过拟合和欠拟合（Overfitting-and-underfitting）"><a href="#过拟合和欠拟合（Overfitting-and-underfitting）" class="headerlink" title="过拟合和欠拟合（Overfitting and underfitting）"></a>过拟合和欠拟合（Overfitting and underfitting）</h2><p>过拟合和欠拟合是导致模型泛化能力不高的两种常见原因，都是模型学习能力与数据复杂度之间失配的结果。<br><strong>“欠拟合”</strong>常常在模型学习能力较弱，而数据复杂度较高的情况出现，此时模型由于学习能力不足，无法学习到数据集中的“一般规律”，因而导致泛化能力弱。<br><strong>“过拟合”</strong>常常在模型学习能力过强的情况中出现，此时的模型学习能力太强，以至于将训练集单个样本自身的特点都能捕捉到，并将其认为是“一般规律”，同样这种情况也会导致模型泛化能力下降。</p><h3 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h3><p>过拟合（over-fitting）也称为过学习，它的直观表现是算法在训练集上表现好，但在测试集上表现不好，泛化性能差<br><strong>cause</strong></p><blockquote><ul><li>训练集的数据太少或者缺乏代表性；</li><li>训练集样本存在的噪音干扰过大，导致模型拟合了噪音的特征，反而忽略了真实的输入输出间的关系；</li><li>参数太多，模型复杂度过高；</li></ul></blockquote><p><strong>method</strong></p><p>1.增加数据量  </p><ul><li>从数据源头获取更多数据；</li><li>通过数据增强对数据进行扩充：对图像进行翻转、裁剪、缩放、平移、添加噪声等。</li></ul><p>2.正则化<br>在进行目标函数或代价函数（损失函数）优化时，在函数后面加上一个正则项，一般有L1正则、L2正则等。</p><blockquote><ul><li><strong>L1正则化：</strong> L1正则化是通过在目标函数中加入L1范数惩罚项来实现的。<strong>L1范数是指权重向量W中的各个元素绝对值之和</strong>，因此L1正则化的目的是使模型参数尽可能地稀疏。L1正则化可以促使模型参数向零值收缩，进而减少特征的数量。</li><li><strong>L2正则化：</strong> L2正则化是通过在目标函数中加入L2范数惩罚项来实现的。<strong>L2范数是指权重向量W中的各个元素的平方和开根号</strong>，因此L2正则化的目的是通过约束模型参数的平方和，使得它们的值不会过大。L2正则化可以帮助避免模型的权值过拟合，并使得模型更具有鲁棒性和泛化能力。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加L2正则化项</span><br>l2_reg = torch.tensor(<span class="hljs-number">0.</span>) <span class="hljs-comment"># 创建一个初始值为零的 torch.Tensor 对象，用于累加模型参数的 L2 范数。</span><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.parameters():<br>    l2_reg += torch.norm(param, <span class="hljs-number">2</span>)<br>loss += l2_penalty * l2_reg <span class="hljs-comment">#  L2 正则化的惩罚系数（penalty coefficient），用于控制正则化的强度。它是一个超参数，需要根据具体问题进行调整(交叉验证)。</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>区别：</strong> L1正则化减少的是一个常量，L2正则化减少的是权重的固定比例；使用L1可以得到稀疏的权值，使用L2可以得到平滑的权值；实践中L2正则化通常优于L1正则化。</p></blockquote><p>3.Dropout<br>Dropout 是一种常用的正则化技术，用于减少深度神经网络的过拟合现象。Dropout 在训练过程中随机地丢弃一部分神经元的输出，从而强制模型去学习其他特征的表示。</p><blockquote><p><code>self.dropout = nn.Dropout(dropout_rate)</code></p></blockquote><p>具体来说，Dropout 在前向传播的过程中，以一定的概率 p（通常设置为0.5）将某个神经元的输出设为0，即丢弃该神经元。这样做的结果是，每个神经元在训练过程中都有一定概率暂时被“关闭”，从而迫使网络去考虑其他神经元的贡献，减少了对特定神经元的依赖性。同时，在前向传播过程中，通过保留每个神经元输出的比例，可以确保网络的总体期望值不变。</p><h1 id="12-2"><a href="#12-2" class="headerlink" title="12.2"></a>12.2</h1><h2 id="Triplet-Loss-和-Center-Loss"><a href="#Triplet-Loss-和-Center-Loss" class="headerlink" title="Triplet Loss 和 Center Loss"></a>Triplet Loss 和 Center Loss</h2><blockquote><p><code>https://blog.csdn.net/weixin_40671425/article/details/98068190</code></p></blockquote><h1 id="12-2-1"><a href="#12-2-1" class="headerlink" title="12.2"></a>12.2</h1><blockquote><p><code>https://zhuanlan.zhihu.com/p/438085414</code></p></blockquote><h1 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h1><p>Tensor（张量）是一个多维数组，它是深度学习中最基本的数据结构之一，也是基于计算图的深度学习框架的核心组成部分。Tensor 可以存储和表示任意维度的数据，支持各种数值和数据类型，并提供了类似于 numpy 的数据操作接口，例如加、减、乘、除、运算、矩阵乘法、转置等。在深度学习中，我们使用 Tensor 来存储训练样本和模型参数，并对它们进行线性和非线性的运算。</p><p>Tensor 的维度通常被称作“阶”，例如，阶为 0 的 Tensor 又被称作“标量”（scalar），表示一个单独的数值；阶为 1 的 Tensor 又被称作“向量”（vector），表示一列数值；阶为 2 的 Tensor 又被称作“矩阵”（matrix），表示一个二维的表格。在深度学习中，我们通常会使用阶数更高的 Tensor，例如 3 阶、4 阶或更高阶的 Tensor，以表示更复杂的数据结构，如图像、视频或音频数据等。</p><h2 id="1-张量的创建"><a href="#1-张量的创建" class="headerlink" title="1.张量的创建"></a>1.张量的创建</h2><h3 id="1-1-通过列表或者元组"><a href="#1-1-通过列表或者元组" class="headerlink" title="1.1 通过列表或者元组"></a>1.1 通过列表或者元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t = torch([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]) / t = torch((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(t)<br><span class="hljs-comment"># tensor([1, 2])</span><br></code></pre></td></tr></table></figure><h3 id="1-2-通过numpy创建"><a href="#1-2-通过numpy创建" class="headerlink" title="1.2 通过numpy创建"></a>1.2 通过numpy创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>n = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>t = torch.tensor(n)<br><span class="hljs-built_in">print</span>(t)<br><span class="hljs-comment"># tensor([1, 2])</span><br></code></pre></td></tr></table></figure><h3 id="1-3-tensor-type-and-convert"><a href="#1-3-tensor-type-and-convert" class="headerlink" title="1.3 tensor-type and convert"></a>1.3 tensor-type and convert</h3><p>type()不能识别出Tensor内部的数据类型，只能识别出变量的基本类型是Tensor，而dtype方法可以识别出变量具体为哪种类型的Tensor。<br>可以使用.float()、.int()等方法对张量类型进行转化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">i = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>f = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(i), i.dtype, sep = <span class="hljs-string">&#x27; , &#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(f), f.dtype, sep = <span class="hljs-string">&#x27; , &#x27;</span>)<br><span class="hljs-comment"># &lt;class &#x27;torch.Tensor&#x27;&gt; , torch.int64</span><br><span class="hljs-comment"># &lt;class &#x27;torch.Tensor&#x27;&gt; , torch.float32</span><br><br>t = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>f = t.<span class="hljs-built_in">float</span>()<br><span class="hljs-built_in">print</span>(f)<br><span class="hljs-built_in">print</span>(t) <span class="hljs-comment"># 并不会改变原来t的数据类型</span><br><span class="hljs-comment"># tensor([1., 2.])</span><br><span class="hljs-comment"># tensor([1, 2])</span><br></code></pre></td></tr></table></figure><h2 id="tensor—shape"><a href="#tensor—shape" class="headerlink" title="tensor—shape"></a>tensor—shape</h2><p>张量的维度中，我们使用的张量如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一维向量</span><br>t1 = torch.tensor((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-comment"># 二维向量</span><br>t2 = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-comment"># 三维向量</span><br>t3 = torch.tensor([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]],[[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]])<br><br><span class="hljs-comment"># ndim查看张量维度</span><br><span class="hljs-built_in">print</span>(t1.ndim, t2.ndim, t3.ndim, sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># 1, 2, 3</span><br><span class="hljs-comment"># t1为1维向量</span><br><span class="hljs-comment"># t2为2维矩阵</span><br><span class="hljs-comment"># t3为3维张量</span><br><br><span class="hljs-comment"># shape&amp;size查看向量的形状</span><br><span class="hljs-built_in">print</span>(t1.shape, t2.shape, t3.shape, sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># torch.Size([2]), torch.Size([2, 3]), torch.Size([2, 2, 2])</span><br><br><span class="hljs-built_in">print</span>(t1.size(), t2.size(), t3.size(), sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># torch.Size([2]), torch.Size([2, 3]), torch.Size([2, 2, 2])</span><br><br><span class="hljs-comment"># numel查看张量中的元素个数</span><br><span class="hljs-built_in">print</span>(t1.numel(), t2.numel(), t3.numel(), sep = <span class="hljs-string">&#x27;, &#x27;</span>)<br><span class="hljs-comment"># 2, 6, 8</span><br><span class="hljs-comment"># t1向量中共有2个元素</span><br><span class="hljs-comment"># t2矩阵中共有6个元素</span><br><span class="hljs-comment"># t3张量中共有8个元素</span><br><br><span class="hljs-comment"># flatten将任意维度张量转为一维张量</span><br>t2.flatten()<br><span class="hljs-comment"># tensor([1, 2, 3, 4, 5, 6])</span><br><br>t3.flatten()<br><span class="hljs-comment"># tensor([1, 2, 3, 4, 5, 6, 7, 8])</span><br><br><br></code></pre></td></tr></table></figure><blockquote><ul><li>t1向量torch.Size([2])的理解：向量的形状是1行2列。</li><li>t2矩阵torch.Size([2, 3])的理解：二维矩阵的形状是2行3列。</li><li>t3矩阵torch.Size([2, 2, 2])的理解：包含两个二维矩阵，每个二维矩阵的形状是2行2列。</li></ul></blockquote><h3 id="reshape任意变形"><a href="#reshape任意变形" class="headerlink" title="reshape任意变形"></a>reshape任意变形</h3><p><strong>形变维度的乘积需要等于张量元素的个数。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将`t3`变成2×4的矩阵</span><br>t3.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment">#tensor([[1, 2, 3, 4],[5, 6, 7, 8]])</span><br><br><span class="hljs-comment"># 将`t3`变成1×4×2的矩阵</span><br>t3.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># tensor([[[1, 2], [3, 4], [5, 6], [7, 8]]])</span><br></code></pre></td></tr></table></figure><h3 id="squeeze-unsqueeze"><a href="#squeeze-unsqueeze" class="headerlink" title="squeeze&amp;unsqueeze"></a>squeeze&amp;unsqueeze</h3><ul><li>squeeze的作用是压缩张量，去掉维数为1位置的维度</li><li>unsqueeze的作用是解压张量，给<strong>指定位置</strong>加上维数为一的维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将t3的维度变为2×1×4</span><br>t_214 = t3.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(t_214)<br><span class="hljs-comment"># tensor([[[1, 2, 3, 4]], [[5, 6, 7, 8]]])</span><br><br><span class="hljs-comment"># 使用squeeze将其变成2×4，去掉维度为1位置的维度</span><br>t_24 = t_214.squeeze(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t_24)<br><span class="hljs-comment"># tensor([[1, 2, 3, 4], [5, 6, 7, 8]])</span><br><br><span class="hljs-comment"># 将2×4的维度再转换成2×1×4，在第二个维度上加一维</span><br><span class="hljs-comment"># 索引是从0开始的。参数0代表第一维，参数1代表第二维，以此类推</span><br><span class="hljs-built_in">print</span>(t_24.unsqueeze(<span class="hljs-number">1</span>))<br>tensor([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]], [[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]])<br></code></pre></td></tr></table></figure><h3 id="tensor-——-value"><a href="#tensor-——-value" class="headerlink" title="tensor ——&gt; value"></a>tensor ——&gt; value</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n = torch.tensor(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(n) <span class="hljs-comment"># tensor(1)</span><br><br><span class="hljs-comment"># 使用.item()方法将张量转为python中的数值</span><br>n.item() <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><h2 id="张量的索引"><a href="#张量的索引" class="headerlink" title="张量的索引"></a>张量的索引</h2><p>张量是有序序列，我们可以根据每个元素在系统内的顺序位置，来找出特定的元素，也就是索引。</p><p>一维张量索引与Python中的索引一样是是从左到右，从0开始的，遵循格式为[start: end: step]。</p><h2 id="张量的合并与分割"><a href="#张量的合并与分割" class="headerlink" title="张量的合并与分割"></a>张量的合并与分割</h2><blockquote><p>当对一个张量进行切割时，返回的是原始张量的一个视图（view）或子集，而不是创建一个新的张量。这意味着切片返回的是原始张量的一个引用，并与原始张量共享数据存储，<strong>所以在修改切片返回的张量时，会同时修改原始张量中相应的元素。</strong> 需要注意的是，如果我们希望创建一个拷贝而非共享内存的切片，可以使用 .copy() 方法，这样操作切片将不会对原始张量产生影响。</p></blockquote><h3 id="张量的分割-chunk-split"><a href="#张量的分割-chunk-split" class="headerlink" title="张量的分割 chunk &amp; split"></a>张量的分割 chunk &amp; split</h3><p>chunk(tensor, chunks, dim)能够按照某个维度(dim)对张量进行均匀切分(chunks)，并且返回结果是原张量的视图。</p><h3 id="张量的合并-cat"><a href="#张量的合并-cat" class="headerlink" title="张量的合并 cat"></a>张量的合并 cat</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.zeros(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[0., 0., 0.],</span><br><span class="hljs-comment">#         [0., 0., 0.]])</span><br><br>b = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]])</span><br><br><br>因为在张量a与b中，shape的第一个位置是代表向量维度，所以当dim取<span class="hljs-number">0</span>时，就是将向量进行合并，向量中的标量数不变：<br>torch.cat([a, b], dim = <span class="hljs-number">0</span>) <br><span class="hljs-comment"># tensor([[0., 0., 0.],</span><br><span class="hljs-comment">#         [0., 0., 0.],</span><br><span class="hljs-comment">#         [1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]])</span><br><br>当dim取<span class="hljs-number">1</span>时，shape的第二个位置是代表列，即标量数，就是在列上（标量维度）进行拼接，行数（向量数）不变：<br>torch.cat([a, b], dim = <span class="hljs-number">1</span>)<br><span class="hljs-comment"># tensor([[0., 0., 0., 1., 1., 1.],</span><br><span class="hljs-comment">##        [0., 0., 0., 1., 1., 1.]])</span><br></code></pre></td></tr></table></figure><h3 id="张量的堆叠-stack"><a href="#张量的堆叠-stack" class="headerlink" title="张量的堆叠 stack"></a>张量的堆叠 stack</h3><p>和拼接不同，堆叠不是将元素拆分重装，而是将各参与堆叠的对象分装到一个更高维度的张量里。<br>和 cat 的区别：拼接之后维度不变，堆叠之后维度升高。拼接是把一个个元素单独提取出来之后再放到二维张量里，而堆叠则是直接将两个二维向量封装到一个三维张量中。因此，堆叠的要求更高，参与堆叠的张量必须形状完全相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.zeros(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[0., 0., 0.],</span><br><span class="hljs-comment">#         [0., 0., 0.]])</span><br><br>b = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># tensor([[1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]])</span><br><br>torch.stack([a, b], dim = <span class="hljs-number">0</span>)<br><span class="hljs-comment"># tensor([[[0., 0., 0.],</span><br><span class="hljs-comment">#          [0., 0., 0.]],</span><br><span class="hljs-comment">#         [[1., 1., 1.],</span><br><span class="hljs-comment">#          [1., 1., 1.]]])</span><br><br>torch.stack([a, b], dim = <span class="hljs-number">0</span>).shape<br><span class="hljs-comment"># torch.Size([2, 2, 3])</span><br></code></pre></td></tr></table></figure><h1 id="12-3"><a href="#12-3" class="headerlink" title="12.3"></a>12.3</h1><h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><blockquote><p>通道注意力（Channel Attention），空间注意力（Spatial Attention），分支注意力（Branch Attention），自注意力（Self Attention）和交叉注意力（Cross Attention）</p></blockquote><h1 id="12-8"><a href="#12-8" class="headerlink" title="12.8"></a>12.8</h1><h1 id="vision-transformer"><a href="#vision-transformer" class="headerlink" title="vision transformer"></a>vision transformer</h1><h1 id="grad-cam"><a href="#grad-cam" class="headerlink" title="grad-cam"></a>grad-cam</h1><h1 id="Vit-Grad-Cam"><a href="#Vit-Grad-Cam" class="headerlink" title="Vit + Grad-Cam"></a>Vit + Grad-Cam</h1><blockquote><p><code>https://zhuanlan.zhihu.com/p/640450435</code><br>Grad-CAM 对 ViT 的输出进行可视化的原理是利用 ViT 的最后一个注意力块的输出和梯度，计算出每个 token 对分类结果的贡献度，然后将这些贡献度映射回原始图像的空间位置，形成一张热力图。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>损失函数</title>
    <link href="/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p><strong>用来量化模型预测值和真实标签之间的差异</strong></p><h2 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h2><blockquote><p>一般用于分类任务<br>计算：比如三分类问题，一个样本标签的one-hot向量为 $y &#x3D; [0,0,1]^T$ , 模型预测的标签分布为 $[0.3,0.3,0.4]^T$ , 则它们的交叉熵为 $-(0 * log(0.3) + 0 * log(0.3) + 1 * log(0.4)) &#x3D; -log(0.4)$</p></blockquote><p>在机器学习和深度学习中，softmax 函数和交叉熵损失函数是两个常用的概念，它们通常一起使用在分类问题中。</p><h3 id="Softmax-函数"><a href="#Softmax-函数" class="headerlink" title="Softmax 函数"></a>Softmax 函数</h3><p>Softmax 函数是一种将一个向量或一组实数转换成概率分布的函数。给定一个向量 ( z )，其中 ( z ) 的每个元素 ( z_i ) 都是实数，softmax 函数定义如下：</p><p>[<br>\text{softmax}(z_i) &#x3D; \frac{e^{z_i}}{\sum_{j&#x3D;1}^{K} e^{z_j}}<br>]</p><p>其中，( K ) 是类别的数量，( e ) 是自然对数的底数。Softmax 函数的输出是一个概率分布，每个类别都有一个概率值，这些概率值的和为 1。</p><h3 id="交叉熵损失函数（Cross-Entropy-Loss）"><a href="#交叉熵损失函数（Cross-Entropy-Loss）" class="headerlink" title="交叉熵损失函数（Cross-Entropy Loss）"></a>交叉熵损失函数（Cross-Entropy Loss）</h3><p>交叉熵损失函数是衡量模型预测的概率分布与真实标签的概率分布之间的差异的一种方法。在分类问题中，如果 ( y ) 是一个 one-hot 编码的标签向量，( \hat{y} ) 是模型预测的概率分布，交叉熵损失函数定义如下：</p><p>[<br>\text{Cross-Entropy Loss} &#x3D; -\sum_{c&#x3D;1}^{K} y_{o,c} \log(\hat{y}_c)<br>]</p><p>其中，( y_{o,c} ) 是 one-hot 编码中第 ( c ) 个类别的标签值（0 或 1），( \hat{y}_c ) 是模型预测的第 ( c ) 个类别的概率。</p><h2 id="损失函数分类"><a href="#损失函数分类" class="headerlink" title="损失函数分类"></a>损失函数分类</h2><p>在机器学习中，损失函数（Loss Function）是衡量模型预测值与实际值差异的函数，用于指导模型训练过程中的参数更新。以下是一些常见的损失函数：</p><ol><li><p><strong>均方误差（Mean Squared Error, MSE）</strong>：</p><ul><li>用于回归问题，计算预测值与实际值之差的平方的平均值。</li><li>公式：[ \text{MSE} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} (y_i - \hat{y}_i)^2 ]</li><li>其中，( y_i ) 是真实值，( \hat{y}_i ) 是预测值，( n ) 是样本数量。</li></ul></li><li><p><strong>交叉熵损失（Cross-Entropy Loss）</strong>：</p><ul><li>用于分类问题，特别是二分类或多分类问题。</li><li>公式：[ \text{Cross-Entropy} &#x3D; -\sum_{c&#x3D;1}^{M} y_{o,c} \log(p_{o,c}) ]</li><li>其中，( M ) 是类别数，( y_{o,c} ) 是真实标签的独热编码，( p_{o,c} ) 是模型预测为第 ( c ) 类的概率。</li></ul></li><li><p><strong>对数损失（Logarithmic Loss）</strong>：</p><ul><li>与交叉熵损失类似，常用于二分类问题。</li><li>公式：[ \text{Log Loss} &#x3D; -\frac{1}{n} \sum_{i&#x3D;1}^{n} [y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i)] ]</li><li>其中，( y_i ) 是二分类的真实标签（0或1），( \hat{y}_i ) 是模型预测的概率。</li></ul></li><li><p><strong>绝对值误差（Mean Absolute Error, MAE）</strong>：</p><ul><li>用于回归问题，计算预测值与实际值之差的绝对值的平均值。</li><li>公式：[ \text{MAE} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} |y_i - \hat{y}_i| ]</li></ul></li><li><p><strong>Hinge损失（Hinge Loss）</strong>：</p><ul><li>常用于支持向量机（SVM）中，用于最大化决策边界的宽度。</li><li>公式：[ \text{Hinge Loss} &#x3D; \max(0, 1 - y_i \cdot \hat{y}_i) ]</li><li>其中，( y_i ) 是真实标签，( \hat{y}_i ) 是模型的预测值。</li></ul></li><li><p><strong>平方Hinge损失（Squared Hinge Loss）</strong>：</p><ul><li>Hinge损失的变体，对较大的误差给予更大的惩罚。</li><li>公式：[ \text{Squared Hinge Loss} &#x3D; \max(0, 1 - y_i \cdot \hat{y}_i)^2 ]</li></ul></li><li><p><strong>Huber损失（Huber Loss）</strong>：</p><ul><li>结合了MSE和MAE的优点，对小误差使用平方损失，对大误差使用线性损失。</li><li>公式：[ \text{Huber Loss} &#x3D; \begin{cases}<br> \frac{1}{2} (y_i - \hat{y}_i)^2 &amp; \text{for } |y_i - \hat{y}_i| \le \delta, \<br> \delta (|y_i - \hat{y}_i| - \frac{1}{2} \delta) &amp; \text{otherwise}<br> \end{cases} ]</li><li>其中，( \delta ) 是一个超参数，控制损失函数从平方项到线性项的过渡。</li></ul></li><li><p><strong>三元损失（Triplet Loss）</strong>：</p><ul><li>常用于深度学习中的度量学习，特别是在人脸识别等任务中。</li><li>目标是使相似样本的距离比不相似样本的距离小。</li></ul></li><li><p><strong>IoU损失（Intersection over Union Loss）</strong>：</p><ul><li>用于目标检测和分割问题，衡量预测的边界框与真实边界框的重叠程度。</li></ul></li><li><p><strong>Focal损失（Focal Loss）</strong>：</p><ul><li>用于解决类别不平衡问题，特别是对于容易分类的样本减少其权重，而对难以分类的样本增加其权重。</li></ul></li></ol><p>这些损失函数各有其特点和适用场景，选择合适的损失函数可以帮助提高模型的性能和泛化能力。</p><h1 id="过-欠拟合"><a href="#过-欠拟合" class="headerlink" title="过&#x2F;欠拟合"></a>过&#x2F;欠拟合</h1><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>梯度下降法就是一种<strong>通过求目标函数的导数来寻找目标函数最小化的方法</strong></p><ol><li>批量梯度下降法（BGD）在每次迭代时要计算每个样本上损失函数的梯度并求和</li><li>随机梯度下降法（SGD）为了减少每次迭代的</li></ol><h2 id="损失函数、代价函数、目标函数"><a href="#损失函数、代价函数、目标函数" class="headerlink" title="损失函数、代价函数、目标函数"></a>损失函数、代价函数、目标函数</h2><ul><li><strong>损失函数</strong> Loss Function 通常是<strong>针对单个训练样本而言</strong>，给定一个模型输出 $\hat{y}$ 和一个真实 $y$ ，损失函数输出一个实值损失 $L&#x3D;f(y_i, \hat{y_i})$</li><li><strong>代价函数</strong> Cost Function 通常是<strong>针对整个训练集</strong>（或者在使用 mini-batch gradient descent 时一个 mini-batch）的总损失 $J&#x3D;\sum_{i&#x3D;1}^{N} f(y_i,\hat{y_i})$</li><li><strong>目标函数</strong> Objective Function 是一个更通用的术语，表示任意<strong>希望被优化的函数</strong>，用于机器学习领域和非机器学习领域（比如运筹优化）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>表示学习</title>
    <link href="/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h1><blockquote><p>在深度学习中，前面的层为表示学习，最后一层为预测学习</p></blockquote><ol><li><strong>自动地学习出有效的特征</strong>，并最终提高机器学习模型的性能的算法就叫做表示学习。</li><li>表示学习关键是解决语义鸿沟问题————是指输入数据的底层特征表示和高层的抽象语义特征不一致性。（对于一些不同颜色和形状的车来说，它们在像素级别的表示（底层特征表示）上相差很大，但我们认为它们都是车是建立在高层语义特征上的）</li><li>表示学习的两个核心问题：<br><strong>什么是一个好的表示</strong><br><strong>如何学习到好的表示</strong></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="局部表示"><a href="#局部表示" class="headerlink" title="局部表示"></a>局部表示</h3><p>也叫离散表示或符号表示，通常用<strong>one-hot向量</strong>表示，假设所有颜色构成一个词表，词表长度为|V|,可以用一个v维的向量来表示特征，在第i种颜色所对应的one-hot向量中的第 i 维为1，其他维为0</p><p><strong>优点：</strong></p><ol><li>离散的表示方式具有好的解释性</li><li>这种特征表示通常是稀疏的二值向量，计算效率高</li></ol><p><strong>缺点：</strong></p><ol><li>维数高，不易扩展</li><li>不同特征之间的相似度都为0（按理来说红色与粉红色的相似度肯定比 红色和黑色高）</li></ol><h3 id="分布式表示"><a href="#分布式表示" class="headerlink" title="分布式表示"></a>分布式表示</h3><p>用RGB三个数值来表示颜色</p><p>优点：</p><ol><li>向量维度要低，更容易扩展</li><li>不同颜色的相似度也容易计算</li></ol><p><strong>嵌入</strong></p><blockquote><p>使用神经网络将高维的局部表示空间映射到一个低维的分布式表示空间，这个过程被称为嵌入</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>浅层学习，不涉及特征学习，特征来源于人工提取</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li><p><code>Sklearn</code> python的机器学习库</p></li><li><p>鸢尾花数据集（iris dataset）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br><span class="hljs-comment"># 加载数据集</span><br><span class="hljs-comment"># 鸢尾花数据集（iris dataset）是一个经典的机器学习数据集，其中包含了150个样本，</span><br><span class="hljs-comment"># 每个样本有四个特征：花萼长度、花萼宽度、花瓣长度、花瓣宽度。</span><br><span class="hljs-comment"># 这些样本被分为三个类别：山鸢尾（setosa）、变色鸢尾（versicolor）和维吉尼亚鸢尾（virginica）。</span><br><span class="hljs-comment"># 鸢尾花数据集通常被用来进行分类问题的训练和评估，是机器学习领域常用的基准数据集之一。您可以使用sklearn库中的datasets.load_iris()函数加载这个数据集。</span><br>iris = datasets.load_iris()<br>X = iris.data<br>y = iris.target<br><span class="hljs-built_in">print</span>(X)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-comment"># 划分训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 创建线性分类器模型</span><br>model = LogisticRegression(max_iter=<span class="hljs-number">1</span>) <span class="hljs-comment"># 迭代次数</span><br><br><span class="hljs-comment"># 拟合模型</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 预测</span><br>y_pred = model.predict(X_test)<br><br><span class="hljs-comment"># 评估性能</span><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(accuracy))<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol><li><strong>数据预处理</strong>（去掉一些有缺失特征的样本；去掉一些冗余的数据特征；对数值特征进行缩放和归一化；）</li><li><strong>特征提取：</strong>从数据的原始特征中提取一些对特定机器学习任务有用的高质量特征（比如在图像分类中提取边缘）</li><li><strong>特征转换：</strong>对特征进行进一步的加工，比如降维和升维，降维包括特征抽取和特征选择。常用特征转换方法有主成分分析（PCA）和线性判别（LDA）</li><li><strong>预测：</strong>学习一个函数并进行预测</li></ol><h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><blockquote><p>线性模型是机器学习中应用最广泛的模型，指通过样本特征的线性组合来进行预测的模型，给定一个D维样本 $x &#x3D; [x_1,…,x_D]^T$ , 其<strong>线性组合(判别)函数</strong>为 </p></blockquote><p>$$<br>f(x;w) &#x3D; w_1x_1 + w_2x_2 + … + w_Dx_D + b<br>       &#x3D; w^Tx + b<br>$$</p><p>其中 $w &#x3D; [w_1,…,w_D]$ 为 D维的权重向量，b为偏置<br>对于分类问题，要在线性组合函数的基础上引入<strong>非线性的决策函数</strong> $g()$ 来预测输出目标<br>$$<br>y &#x3D; g(f(x;w))<br>$$</p><ol><li><p><strong>一个 线性分类模型 主要由 一个或多个线性的判别函数 和 非线性的决策函数 组成</strong></p></li><li><p>接下来介绍四种不同的线性分类模型（线性分类器）：Logistic回归、Softmax回归、感知机、支持向量机。主要区别在于<strong>使用了不同的损失函数</strong></p></li></ol><p><strong>训练数据集是线性可分</strong></p><p>当说训练数据集是线性可分的时，意味着在数据集中存在一个能够清晰划分两个或多个类别的线性决策边界。<br>换句话说，存在一个线性函数或平面，可以将不同类别的样本有效地分开。这意味着在特征空间中，不同类别的样本在一定程度上能够被一条直线、平面或超平面等线性边界分开。</p><p>如果训练数据集是线性可分的，则意味着使用线性分类器（例如线性回归、逻辑回归、支持向量机等）能够很好地对数据进行分类或预测<br>如果数据集不是线性可分的，就需要使用更复杂的模型或非线性技术来处理数据。</p><h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><p>机器学习算法分类：监督学习、无监督学习、强化学习<br><strong>监督学习算法</strong> (Supervised Algorithms) 在监督学习训练过程中，可以由训练数据集学到或建立一个模式（函数 &#x2F; learning model），并依此模式推测新的实例。该算法要求特定的输入&#x2F;输出，首先需要决定使用哪种数据作为范例。例如，文字识别应用中一个手写的字符，或一行手写文字。主要算法包括神经网络、支持向量机、最近邻居法、朴素贝叶斯法、决策树等。</p><p><strong>无监督学习算法</strong> (Unsupervised Algorithms) 这类算法没有特定的目标输出，算法将数据集分为不同的组。</p><p><strong>强化学习算法</strong> (Reinforcement Algorithms) 强化学习普适性强，主要基于决策进行训练，算法根据输出结果（决策）的成功或错误来训练自己，通过大量经验训练优化后的算法将能够给出较好的预测。类似有机体在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。在运筹学和控制论的语境下，强化学习被称作“近似动态规划”</p><p>基本的机器学习算法：线性回归、支持向量机(SVM)、最近邻居(KNN)、逻辑回归、决策树、k平均、随机森林、朴素贝叶斯、降维、梯度增强</p><ol><li><p>分类：K近邻、决策树、随机森林、朴素贝叶斯、GBDT、支持向量机等；</p></li><li><p>聚类：k均值聚类算法(K-Means)、基于密度聚类(DBSCAN)等；</p></li><li><p>回归：逻辑回归、线性回归；</p></li><li><p>降维：主成分分析算法(PCA)、LDA、局部线性嵌入(LLE)等</p></li></ol><h3 id="线性回归（Linear-Regression）"><a href="#线性回归（Linear-Regression）" class="headerlink" title="线性回归（Linear Regression）"></a>线性回归（Linear Regression）</h3><p><strong>什么是回归问题</strong></p><p>线性回归算法（Linear Regression）的建模过程就是使用数据点来寻找最佳拟合线</p><ol><li>多元线性回归<br>多元线性回归是回归分析中的一种复杂模型，它考虑了多个输入变量对输出变量的影响。与一元线性回归不同，多元线性回归通过引入多个因素，更全面地建模了系统关系。</li></ol><p>多元线性回归模型的表达式为：$f ( x ) &#x3D;\mathbf{k^T}\mathbf{x}+b$<br>其中，$\mathbf{x}$为输入向量，包含多个特征（自变量）；$f(\mathbf{x})$为模型的输出或响应（预测的目标变量）；$\mathbf{k^T}$ 为特征权重；$b$为是模型的截距或偏置；我们的目标是通过学习$\mathbf{k^T}$ 和 $b$ 使得 $f(\mathbf{x})$ 尽可能的接近真实观测值 $\mathbf{y}$</p><p><img src="/../../img/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.png"></p><p>直白点说：首先求出当前模型的 所有采样点上的预测值𝑤𝑥(𝑖) +𝑏与真实值𝑦(𝑖)之间的差的平方和作为总误差ℒ，然后搜索一组参数𝑤∗,𝑏∗使得ℒ最小，对应的直线就是我们要寻找的最优直线</p><ol start="2"><li>实现方式</li></ol><p><strong>全局梯度下降</strong><br>梯度下降法是一种迭代算法。选取适当的初值x(0)，不断迭代，更新x的值，进行<strong>目标函数(也是线性回归的损失函数)的极小化</strong>，直到收敛。（它从一个初始点开始，反复使用某种规则从移动到下一个点，构造这样一个数列，直到<strong>收敛到梯度为0的点处</strong>，即梯度下降算法）</p><p>由于负梯度方向时使函数值下降最快的方向，在迭代的每一步，<strong>以负梯度方向更新x的值</strong>，从而达到减少函数值的目的</p><p>线性回归一般选择的是MSE（均方误差）<br><strong>均方误差</strong>是预测值与真实值之间差值的平方的平均值</p><p><strong>学习率在梯度下降法中的作用</strong><br>我们可以通过 𝜼 来控制每一步走的距离</p><ol><li>以保证不要走的太快，错过了最低点</li><li>同时也要保证收敛速度不要太慢</li></ol><h3 id="逻辑回归（Logistic-regression）"><a href="#逻辑回归（Logistic-regression）" class="headerlink" title="逻辑回归（Logistic regression）"></a>逻辑回归（Logistic regression）</h3><p><strong>逻辑回归和线性回归区别：</strong></p><p>逻辑回归：</p><ol><li>逻辑回归是一种用于分类问题的模型，而不是回归问题。它用于预测二元分类或多元分类的概率。</li><li>损失函数通常是对数损失函数（log loss），也称为交叉熵损失函数（cross-entropy loss）。</li><li>目标是最大化似然函数或最小化损失函数，通常通过梯度下降等方法实现。</li><li>相比较线性回归的连续值直接求解，在逻辑回归中，还需要<strong>使用Sigmoid函数将回归方程映射成概率进行分类</strong></li><li><strong>它通过使用逻辑函数（如Sigmoid函数）将线性回归的输出值映射到0和1之间，从而表示概率。</strong></li></ol><p><img src="/../../img/sigmid.png"></p><p>线性回归：</p><ol><li>线性回归用于预测连续型变量的值，是一种回归模型。</li><li>损失函数通常是均方误差（Mean Squared Error，MSE）。</li><li>目标是最小化损失函数，通过梯度下降等方法实现。</li></ol><h3 id="KNN算法（最近邻居-k-近邻算法，K-Nearest-Neighbors）"><a href="#KNN算法（最近邻居-k-近邻算法，K-Nearest-Neighbors）" class="headerlink" title="KNN算法（最近邻居&#x2F;k-近邻算法，K-Nearest Neighbors）"></a>KNN算法（最近邻居&#x2F;k-近邻算法，K-Nearest Neighbors）</h3><p>口诀：近朱者赤，近墨者黑</p><p><img src="/../../img/KNN.png"></p><p>KNN算法是一种基于实例的学习，或者是局部近似和将所有计算推迟到分类之后的惰性学习。KNN主要用于<strong>分类</strong>问题</p><p>用最近的邻居（k）来预测未知数据点。k 值是预测精度的一个关键因素，无论是分类还是回归，衡量邻居的权重都非常有用，较近邻居的权重比较远邻居的权重大</p><p>ex. 假设k &#x3D; 5，代表用周围5个点来估计未知数据点的类别，这5个点中比例最高的类别即为该预测类别</p><ol><li><p>需要想办法来计算两个样本之间的距离或者相似度，之后才能选出最相近的样本。<strong>欧氏距离</strong>是一个最简单常用的方法</p></li><li><p>怎么确定K值<br>确定KNN算法的K值通常需要通过<strong>交叉验证</strong></p></li></ol><ul><li>将数据集分成K份（通常K取5或10），每次选择其中一份作为验证集，剩下的K-1份作为训练集。</li><li>对于每个K值，重复K次交叉验证，计算模型在验证集上的性能指标（如准确率、F1分数等）的平均值。</li><li>根据性能指标的表现选择最优的K值。</li></ul><h3 id="决策树（Decision-Tress）"><a href="#决策树（Decision-Tress）" class="headerlink" title="决策树（Decision Tress）"></a>决策树（Decision Tress）</h3><ol><li>决策树（Decision tree）是一种特殊的树结构，由一个决策图和可能的结果（例如成本和风险）组成，用来辅助决策。</li><li>机器学习中，<strong>决策树是一个预测模型，树中每个节点表示某个对象，而每个分叉路径则代表某个可能的属性值，而每个叶节点(也是类别)则对应从根节点到该叶节点所经历的路径所表示的对象的值</strong>。</li><li>决策树仅有单一输出，通常该算法用于解决<strong>分类</strong>问题。</li></ol><p><img src="/../../img/%E5%86%B3%E7%AD%96%E6%A0%91.png"></p><p><strong>决策树节点的划分</strong><br>熵：代表一个系统的混乱程度，越混乱熵越高</p><p>划分依据：<strong>最大化信息增益（熵）</strong><br>比较多个特征的信息增益，选择信息增益最大的特征作为根节点进行划分。然后，重复这个过程，对每个子节点进行划分，直到满足停止条件（如节点包含的样本数小于预定义阈值）为止</p><p>信息增益的计算步骤：</p><ol><li>计算每个类别的信息熵</li><li>求离散的特征属性值 a 对数据集 D 的条件信息熵</li><li>计算信息增益</li></ol><p><img src="/../../img/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A.png"></p><h3 id="k-平均算法（K-Means）"><a href="#k-平均算法（K-Means）" class="headerlink" title="k-平均算法（K-Means）"></a>k-平均算法（K-Means）</h3><p>口诀：物以类聚，人以群分</p><p><img src="/../../img/K-Means.png"></p><p>k-平均算法(K-Means)是一种<strong>无监督学习算法</strong>，为<strong>聚类问题</strong>提供了一种解决方案。<br>K-Means 算法把 n 个点（可以是样本的一次观察或一个实例）划分到 k 个集群（cluster），使得每个点都属于离他最近的均值（即聚类中心，centroid）对应的集群。重复上述过程一直持续到重心不改变。</p><p>计算过程如下：</p><ol><li><p>分配阶段：对每个数据点，计算其与每个类中心的距离，然后将其分配到距离最近的类中心所对应的类里。</p></li><li><p>更新阶段：对于每个类，根据该类中所有数据点的均值计算新的类中心。假设某个类包含的数据点集合为 𝑆, 其中包含 𝑛 个数据点，则该类的新的类中心 $𝐶_𝑗$ 可以通过以下公式计算得到, $𝑥_𝑖$ 是数据点集合 $S$ 中的第 $i$ 个数据点到类中心的距离</p></li></ol><p>$$<br>[ C_j &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} x_i ]<br>$$</p><ol start="3"><li>重复迭代：重复执行分配和更新阶段，直至达到停止条件为止。停止条件可以是类中心不再发生变化，即算法收敛；或者是达到最大迭代次数。</li></ol><p>总结：<strong>通过迭代地移动簇中心（质心）来最小化每个点到其簇中心的距离之和。</strong></p><p>预测新的未知数据点：迭代每类的聚类（簇）中心，计算该样本点距离每个中心的距离，距离最近的点即为该样本的类别</p><h3 id="聚类和分类问题的区别"><a href="#聚类和分类问题的区别" class="headerlink" title="聚类和分类问题的区别"></a>聚类和分类问题的区别</h3><ul><li>聚类是一种<strong>无监督</strong>学习，而分类是一种有<strong>监督</strong>的学习。</li><li>聚类<strong>只需要人工指定相似度的标准和类别数</strong>就可以，而分类需要从训练集学习分类的方法</li></ul><p><img src="/../../img/%E8%81%9A%E7%B1%BB%E5%88%86%E7%B1%BB.png"></p><h3 id="SVM-支持向量机，Support-Vector-Machine"><a href="#SVM-支持向量机，Support-Vector-Machine" class="headerlink" title="SVM (支持向量机，Support Vector Machine)"></a>SVM (支持向量机，Support Vector Machine)</h3><p><strong>基本想法</strong> 是求解能够正确划分训练数据集并且几何间隔最大的分离超平面<br>最大化类别间隔实现分类</p><p><strong>支持向量</strong> 是指训练样本中，与分类超平面最近的数据点。其是训练数据的子集同时也是最难分类的点</p><p><img src="/../../img/SVM.png"></p><p>SVM 模型将实例表示为空间中的点，将使用一条直线分隔数据点。需要注意的是，支持向量机需要对输入数据进行<strong>完全标记</strong>，仅直接适用于两类任务，如果是多类任务需要减少到几个二元问题 或者 修改损失函数比如使用softmax</p><p><strong>支持向量机包含几种模型</strong></p><p>主要是根据<strong>训练数据集是否线性可分</strong>以及<strong>是否允许出现分类错误</strong>进行划分的。主要包含以下三种模型：</p><p>硬间隔支持向量机：当训练数据线性可分时，硬间隔最大化不允许出现分类错误，此时超平面将所有训练数据集都分类正确，所以叫硬间隔支持向量机</p><p>软间隔支持向量机：当训练数据近似线性可分时，软间隔最大化允许出现分类错误，此时超平面不能将所有训练数据点都分类正确，所以叫软间隔支持向量机</p><p>非线性支持向量机：当训练数据线性不可分时，通过使用核函数和软间隔最大化对数据进行分类</p><p><strong>硬间隔软间隔</strong></p><p>间隔(margin)就是指决策面(y&#x3D;0)与任意训练数据点之间的最小距离。</p><p>硬间隔是指SVM在分类中不允许出现分类错误。通俗点，硬间隔就是训练集中的任何数据点不允许出现在间隔内，即两条蓝线之间，但数据点可以出现在蓝色线上，这些点叫支持向量。</p><p>软间隔是指SVM在分类中允许出现分类错误的点，如下图所示。这些圈出的数据点都是支持向量，但是其中两个点不在蓝线上，一个在间隔内，另一个被分类错误(黑色直线所指的两个点)。软间隔允许这种情况存在，硬间隔则不允许。</p><p><img src="/../../img/svm%E9%97%B4%E9%9A%94.png"></p><p><strong>SVM的优化</strong><br>更好得找出混在正类中的负类 以及 混在负类中的正类 </p><ol><li><p>增加惩罚项</p></li><li><p>使用核函数<br>通俗解释：如果想把混在一起的沙子和黄豆分开，可以用力一拍，用于弹起后的高度不同，因此可以据此将其分开</p></li></ol><h3 id="集成算法"><a href="#集成算法" class="headerlink" title="集成算法"></a>集成算法</h3><p>构建多个学习器，然后通过一定策略结合把它们来完成学习任务的，常常可以获得比单一学习显著优越的学习器。</p><p><img src="/../../img/%E9%9B%86%E6%88%90%E7%AE%97%E6%B3%95.png"></p><p>集成学习通过训练学习出多个估计器<br>预测时通过结合器将多个估计器的结果整合起来当作最后的结果输出。<br>即训练时用多种分类器一起完成同一份任务，测试时对待测试样本分别通过不同的分类器，汇总最后的结果。</p><p><strong>集成学习的优势:</strong> 是提升了单个估计器的通用性与鲁棒性，比单个估计器拥有更好的预测性能并且能更好得防止过拟合。集成学习的另一个特点是能方便的进行并行化操作</p><p>集成算法一般分为三类：Bagging，Boosting，Stacking（我们可以把它简单地看成并行，串行和树型）</p><h4 id="Bagging-并行"><a href="#Bagging-并行" class="headerlink" title="Bagging 并行"></a>Bagging 并行</h4><p>Bagging的全称是bootstrap averaging，它把各个基模型的结果组织起来</p><h5 id="随机森林（Random-Forest）"><a href="#随机森林（Random-Forest）" class="headerlink" title="随机森林（Random Forest）"></a>随机森林（Random Forest）</h5><p>随机：数据采样随机，特征选择随机（每次数据集是随机有放回的选出，同时随机选出部分特征作为输入）</p><p>森林：很多个决策树并行放在一起</p><p><img src="/../../img/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.png"></p><p><strong>随机森林可以看作一个决策树的集合</strong>，随机森林中每棵决策树估计一个分类，这个过程称为 “<strong>投票</strong>（vote）”。理想情况下，我们根据每棵决策树的每个投票，选择最多投票的分类</p><p>投票策略：软投票与硬投票<br><strong>硬投票</strong>：直接用类别值，少数服从多数。<br><strong>软投票</strong>：各自分类器的概率值进行加权平均</p><p>用随机的方式建立一个决策树的森林。当有一个新的输入样本进入的时候，就<strong>让森林中的每一棵决策树分别进行判断</strong>，预测时使用投票结果最多的分类，也是少数服从多数的算法。</p><p>随机森林优势：</p><ol><li>它能够处理很高维度（feature很多）的数据，并且不用做特征选择。</li><li>在训练完后，它能够给出哪些feature比较重要。</li><li>容易做成并行化方法，速度比较快。</li><li>可以进行可视化展示，便于分析。</li></ol><p><strong>和决策树区别</strong></p><h5 id="BaggingClassifier-BaggingRegressor"><a href="#BaggingClassifier-BaggingRegressor" class="headerlink" title="BaggingClassifier&#x2F;BaggingRegressor"></a>BaggingClassifier&#x2F;BaggingRegressor</h5><p>是从原始数据集抽选Ｓ次（抽取实例，抽取属性），得到S个新数据集（有的值可能重复，有的值可能不出现）。使用同一模型，训练得到S个分类器，预测时使用投票结果最多的分类</p><h5 id="VotingClassifier"><a href="#VotingClassifier" class="headerlink" title="VotingClassifier"></a>VotingClassifier</h5><p>可选择多个不同的基模型，分别进行预测，以投票方式决定最终结果。</p><h4 id="Boosting-串行"><a href="#Boosting-串行" class="headerlink" title="Boosting 串行"></a>Boosting 串行</h4><p>从弱学习器开始加强，通过加权来进行训练。新模型是在旧模型的基本上建立的</p><p><img src="/../../img/Boosting.png"></p><p>Boosting相当于串联电路，先需要做好第一个模型，再做第二个，再做第三个，按照顺序一步一步做。</p><h5 id="AdaBoost自适应提升算法"><a href="#AdaBoost自适应提升算法" class="headerlink" title="AdaBoost自适应提升算法"></a>AdaBoost自适应提升算法</h5><p>它对分类错误属性的给予更大权重，再做下次迭代，直到收敛</p><h5 id="Gradient-Boosting-Machine（简称GBM）梯度提升算法"><a href="#Gradient-Boosting-Machine（简称GBM）梯度提升算法" class="headerlink" title="Gradient Boosting Machine（简称GBM）梯度提升算法"></a>Gradient Boosting Machine（简称GBM）梯度提升算法</h5><p>它通过求损失函数在梯度方向下降的方法，层层改进，sklearn中也实现了该算法GradientBoostingClassifier&#x2F;GradientBoostingRegressor。GBM是目前非常流行的一类算法。</p><h3 id="降维算法（Dimensional-Reduction）"><a href="#降维算法（Dimensional-Reduction）" class="headerlink" title="降维算法（Dimensional Reduction）"></a>降维算法（Dimensional Reduction）</h3><p>降维其更深层次的意义在于<strong>有效信息的提取综合及无用信息的摈弃</strong>。</p><p>数据降维算法是机器学习算法中的大家族，与分类、回归、聚类等算法不同，它的<strong>目标</strong>是将向量投影到低维空间，以达到某种目的如可视化，或是做分类。</p><p>数据降维就是寻找一个映射函数f，将高维向量x映射成低维向量y<br>$$<br>f : (x)  -&gt; (y)<br>$$</p><p>如何确定这个映射函数，是降维算法核心，它们往往根据不同的准则进行构造。</p><p><strong>降维算法分类</strong></p><p>目前已经存在大量的数据降维算法，可以从另个不同的维度对它们进行分类。</p><p>按照是否有使用样本的标签值，可以将降维算法分为有监督降维和无监督降维；</p><p>按照降维算法使用的映射函数，可以将算法分为线性降维与非线性降维；</p><p>无监督降维算法不使用样本标签值，因此是一种无监督学习算法，其典型代表是<strong>PCA</strong>；</p><p>有监督的降维算法则使用了样本标签值，是一种有监督学习算法，其典型代表是<strong>LDA</strong>；</p><p>线性降维算根据样本集构造出线性函数完成向低维空间的映射。一般通过对向量x进行线性变换即左乘一个投影矩阵W而得到结果向量y</p><p>$$<br> y &#x3D; W x<br>$$</p><p>非线性降维算法则构造一个非线性映射完成数据的降维。很多时候数据是非线性的，因此需要使用非线性降维算法以取得更好的效果。</p><h4 id="LAD算法（线性判别分析法）"><a href="#LAD算法（线性判别分析法）" class="headerlink" title="LAD算法（线性判别分析法）"></a>LAD算法（线性判别分析法）</h4><p>Linear Discriminant Analysis<br><strong>线性、有监督降维算法</strong></p><p>LDA降维的<strong>目标</strong>：将带有标签的数据降维，投影到低维空间同时满足三个条件：</p><ul><li>尽可能多地保留数据样本的信息（即选择最大的特征是对应的特征向量所代表的的方向）。</li><li>寻找使样本尽可能好分的最佳投影方向。</li><li>投影后使得同类样本尽可能近，不同类样本尽可能远。</li></ul><p><strong>思想：</strong> 投影之后同类的样本尽量集中，不同类的样本尽量分开</p><p><strong>衡量指标：</strong> 类间散度&#x2F;类内散度最大</p><h4 id="PCA算法（主成分分析法）"><a href="#PCA算法（主成分分析法）" class="headerlink" title="PCA算法（主成分分析法）"></a>PCA算法（主成分分析法）</h4><p><a href="https://zhuanlan.zhihu.com/p/391531132">从线性代数几何角度看降维（上）：主成分分析(PCA)应用于降维</a></p><p><strong>线性、无监督降维算法</strong></p><p>主成分分析（Principal Component Analysis，PCA）是一种常用的降维技术，用于将高维数据转换为低维数据，同时保留数据集中的最大方差。PCA通过找到数据中的<strong>主成分（即数据最大方差方向）</strong> 来实现这一目标<br>从而可以减少数据集的特征数量，减少数据的维度，降低计算和存储开销，并帮助提高模型的泛化能力</p><p><strong>PCA算法思想：</strong> 是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征</p><p><strong>实现方法：</strong><br>PCA算法有两种实现方法：</p><ul><li>基于特征值分解 协方差矩阵 实现PCA算法</li><li>基于SVD分解 协方差矩阵 实现PCA算法</li></ul><p><strong>步骤</strong></p><ol><li>因为要提高计算效率和去除冗余特征，所以我们要做降维</li><li>由于特征之间存在相关性，所以不能直接通过扔掉部分特征来做降维</li><li>因此要先做特征转换，转换后的特征要满足彼此不相关</li><li>要令转换后的新特征不相关，体现在新特征的协方差矩阵要为对角矩阵（reason：协方差矩阵的对角线元素表示各个特征自身的方差，而非对角线元素表示特征之间的协方差。如果新特征不相关，那么它们的协方差应该为零，因此协方差矩阵的非对角线元素都为零，整个矩阵成为对角矩阵。）</li><li>接下来要开始扔特征（主成分），达到降维的目标  <strong>通常认为方差越大的特征含有的信息量越大，方差小的特征往往是噪声或无用信息</strong></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和和差分</title>
    <link href="/2024/04/12/algorithm_know/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2024/04/12/algorithm_know/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h1><p><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">前缀和和差分</a></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>一个数组 a[n] &#x3D; b[1] + b[2] + … + b[n]<br>数组b 即为 a的差分数组 （a为b的前缀和数组）</p><p>当 <code>b[3] += c</code> 时意味着 从a[3] 到 a[n] 都会加上c</p><p>如果想要对原数组 a 中的某段区间[l,r]都加上一个数<br>操作分为两步：</p><ol><li><p>对其差分数组进行 <code>b[l] += c;  b[r+1] -= c;</code></p></li><li><p><strong>再对差分数组求和</strong>即可得到想要的数组</p></li></ol><blockquote><p>给定两个序列，要求将其中一个序列变成另一个序列，我们都可以将其转化到差分数组上，让两个序列的差分数组相同 <code>A ——&gt; B 相当于从 A-B ——&gt; 0</code></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dfs/bfs练习题</title>
    <link href="/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-bfs%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-bfs%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs-bfs练习题"><a href="#dfs-bfs练习题" class="headerlink" title="dfs&#x2F;bfs练习题"></a>dfs&#x2F;bfs练习题</h1><h2 id="母亲的牛奶"><a href="#母亲的牛奶" class="headerlink" title="母亲的牛奶"></a>母亲的牛奶</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/1357/">母亲的牛奶</a></p><p><img src="/../../img/%E6%AF%8D%E4%BA%B2%E7%9A%84%E7%89%9B%E5%A5%B6.png"></p><p><strong>步骤：</strong></p><ol><li>分析题目，找出总共有多少种状态，从而得出队列数组的内存空间</li><li>每种状态相当于一个点，状态与状态之间的转变相当于一条边</li><li>bfs遍历，将每种状态都存在队列中。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//A，B，C最大为20升</span><br><span class="hljs-comment">//状态个数为20^3</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>;<br><span class="hljs-type">int</span> A,B,C;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>&#125;q[N*N*N]; <span class="hljs-comment">//关键点，队列数组q有N^3个状态</span><br> <br><span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br><br><span class="hljs-type">bool</span> st[N][N][N];<br><span class="hljs-type">int</span> s[N]; <span class="hljs-comment">//记录当 A桶是空的时候，C桶中可能包含多少升牛奶</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!st[a][b][c])&#123;<br>        q[++tt] = &#123;a,b,c&#125;;<br>        st[a][b][c] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    q[++tt] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,C&#125;;<br>    st[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][C] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        node t = q[hh];<br>        hh++;<br>        <span class="hljs-type">int</span> a = t.a; <span class="hljs-type">int</span> b = t.b; <span class="hljs-type">int</span> c = t.c;<br>        <span class="hljs-comment">//由当前状态可以得到2*3 = 6 种状态</span><br>        <span class="hljs-comment">//从A开始转移</span><br>        <span class="hljs-built_in">insert</span>(a-<span class="hljs-built_in">min</span>(a,B-b), <span class="hljs-built_in">min</span>(a+b,B), c);<br>        <span class="hljs-built_in">insert</span>(a-<span class="hljs-built_in">min</span>(a,C-c), b, <span class="hljs-built_in">min</span>(a+c,C));<br>        <span class="hljs-comment">//从B开始转移</span><br>        <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">min</span>(a+b,A), b-<span class="hljs-built_in">min</span>(b,A-a), c);<br>        <span class="hljs-built_in">insert</span>(a, b-<span class="hljs-built_in">min</span>(b,C-c), <span class="hljs-built_in">min</span>(b+c,C));<br>        <span class="hljs-comment">//从C开始转移</span><br>        <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">min</span>(a+c,A), b, c-<span class="hljs-built_in">min</span>(c,A-a));<br>        <span class="hljs-built_in">insert</span>(a, <span class="hljs-built_in">min</span>(b+c,B), c-<span class="hljs-built_in">min</span>(c,B-b));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;<br>    <span class="hljs-built_in">bfs</span>();<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;hh;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q[i].a == <span class="hljs-number">0</span>)&#123;<br>            s[cnt] = q[i].c;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(s,s+cnt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小红走矩阵-bfs"><a href="#小红走矩阵-bfs" class="headerlink" title="小红走矩阵(bfs)"></a>小红走矩阵(bfs)</h2><p><a href="https://ac.nowcoder.com/acm/problem/269999">小红走矩阵</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> dist[N][N];<br><br><span class="hljs-type">int</span> ax[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> ay[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><br>queue&lt;PII&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>    dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        PII t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//该处永远是循环4次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> x = t.first + ax[i]; <span class="hljs-type">int</span> y = t.second + ay[i];<br>            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;m &amp;&amp; g[x][y] != g[t.first][t.second] &amp;&amp; dist[x][y] == <span class="hljs-number">-1</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>                dist[x][y] = dist[t.first][t.second] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// for(int i=0;i&lt;n;i++)&#123;</span><br>    <span class="hljs-comment">//     for(int j=0;j&lt;m;j++)&#123;</span><br>    <span class="hljs-comment">//         cout &lt;&lt; dist[i][j] &lt;&lt; &quot; &quot;;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> dist[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(dist));<br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a href="https://ac.nowcoder.com/acm/contest/76652/B">老师的签到</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连通图的遍历</title>
    <link href="/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2024/04/11/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="连通图的遍历"><a href="#连通图的遍历" class="headerlink" title="连通图的遍历"></a>连通图的遍历</h1><blockquote><p>“连通块问题”，是基础搜索。用DFS或BFS都行：遍历一个连通块（找到这个连通块中所有的’#‘，并标记已经搜过，不用再搜）；再遍历下一个连通块…；遍历完所有连通块，统计有多少个连通块。</p></blockquote><h2 id="全球变暖"><a href="#全球变暖" class="headerlink" title="全球变暖"></a>全球变暖</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/1235/">全球变暖</a></p><p><img src="/../../img/%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96.png"></p><p><strong>步骤：</strong></p><ol><li>对图g[N][N]进行循环，每次从是陆地并且没有遍历过的点开始搜索</li><li>进入dfs函数，将当前搜到的点置为true</li><li>然后以此点为中心向四个方向遍历，直到周围没有满足条件（即是陆地又没遍历过的）的点</li><li>便会开始向上回溯直到一步步回溯到退出dfs函数</li><li>如果本次找到的连通块中有一个点其四个方向都是陆地，则这个岛屿不会被完全淹没，否则会被完全淹没。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> st[N][N];<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> d[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">//四个方向</span><br><span class="hljs-type">int</span> flag,ans=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    st[i][j] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;ij:&quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-keyword">if</span>(g[i+<span class="hljs-number">1</span>][j]==<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//继续DFS周围的陆地</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;<span class="hljs-number">4</span>;a++)&#123;<br>        <span class="hljs-type">int</span> x = i+dx[a]; <span class="hljs-type">int</span> y = j+dy[a];<br>        <span class="hljs-comment">//继续DFS未搜过的陆地，目的是标记它们   </span><br>        <span class="hljs-comment">//if(nx&gt;=1 &amp;&amp; nx&lt;=n &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=n &amp;&amp; vis[nx][ny]==0 &amp;&amp; a[nx][ny]==&#x27;#&#x27;) //题目说边上都是水，所以不用这么写了</span><br>        <span class="hljs-keyword">if</span>(!st[x][y] &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(x,y);<br>            <span class="hljs-comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; !st[i][j])&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(i,j);<br>                <span class="hljs-comment">// cout &lt;&lt; &quot;本次连通图查找完毕&quot; &lt;&lt; &quot;\n&quot;;</span><br>                <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//这个岛全部被淹</span><br>                    ans++; <span class="hljs-comment">//统计被淹的岛的数量</span><br>                    <br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈和单调队列</title>
    <link href="/2024/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h1><p><strong>单调栈和优先队列</strong><br>单调栈能保证全部元素的单调性，会直接舍去不合的元素，因此没有额外维护成本<br>小根堆只能保证堆顶是最小值，不会直接舍去元素，但需要O(logn)的decreaseKey成本</p><p>有些题目答案一定是当前最大最小值，直接用单调栈维护即可，不是答案直接舍去，时间复杂度为O(n)<br>当然使用优先队列也正确，因为堆顶一定是极值，但时间复杂度为O(nlogn)</p><p>另外，单调队列是双端版的单调栈，元素可以从两端排除，不等于优先队列</p><ol><li>先想暴力怎么做，再考虑把没有用的元素删掉，再看有没有单调性，有单调性的话再看怎么优化 </li><li>直接看逆序有没有用，若逆序没用，就有单调性！（在一个从小到大排列的数列中，若左边的数比右边的数大，就称作逆序数）</li></ol><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><blockquote><p>一段本不具有单调性的区间，用一个栈去维护使得其具有单调性（将元素入栈，如果其是逆序的，就让它出栈）</p></blockquote><p><img src="/../../img/%E5%8D%95%E8%B0%83%E6%A0%88.png"></p><p><strong>步骤：</strong></p><ol><li><strong>while循环</strong>判断栈顶元素是否大于 a[i]，如果大于则出栈</li><li>如果<strong>此时栈不空</strong>则将新的元素 a[i] 赋给答案数组ans</li><li>如果<strong>此时栈空</strong>则将 -1 赋给答案数组ans</li><li>将当前元素 a[i] 入栈</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,a[N];<br><span class="hljs-type">int</span> stk[N],tt; <span class="hljs-comment">//tt为0代表栈空</span><br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//这个地方是while</span><br>        <span class="hljs-comment">//直到队列为空或者新的元素小于队尾的元素才进行下一步</span><br>        <span class="hljs-keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= a[i]) tt--; <span class="hljs-comment">//出栈</span><br>        <span class="hljs-keyword">if</span>(tt) ans[i] = stk[tt];<br>        <span class="hljs-keyword">else</span> ans[i] = <span class="hljs-number">-1</span>;<br>        stk[++tt] = a[i]; <span class="hljs-comment">//入栈</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/156/">滑动窗口</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,k,a[N];<br><span class="hljs-type">int</span> q[N],hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//判断队头是否已经不在滑动窗口内了</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; i-k+<span class="hljs-number">1</span> &gt; q[hh]) hh++;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; <span class="hljs-comment">//不满足条件出队</span><br>        q[++tt] = i; <span class="hljs-comment">//新元素入队</span><br>        <br>        <span class="hljs-comment">//i指针到达滑动窗口末端,可以开始输出队头值</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出单调地址队列的队头，即最小值</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <br>    <span class="hljs-comment">//队列清空</span><br>    hh = <span class="hljs-number">0</span>; tt=<span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//判断队头是否已经不在滑动窗口内了</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; i-k+<span class="hljs-number">1</span> &gt; q[hh]) hh++;<br>        <span class="hljs-comment">//两个for循环只有 这里从 &gt;= 变成了 &lt;=</span><br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; <span class="hljs-comment">//不满足条件出队</span><br>        q[++tt] = i; <span class="hljs-comment">//新元素入队</span><br>        <br>        <span class="hljs-comment">//i指针到达滑动窗口末端,可以开始输出队头值</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出单调地址队列的队头，即最小值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="滑动窗口（双端队列）"><a href="#滑动窗口（双端队列）" class="headerlink" title="滑动窗口（双端队列）"></a>滑动窗口（双端队列）</h2><p><strong>维护一个固定长度窗口内的最大最小值</strong></p><p><strong>tips</strong></p><ol><li>要先判断 <code>//要先判断 q.size() &gt; 0</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//维护最小值（踢掉目前窗口中 比 要加入窗口值 小的数）</span><br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; a[i] &lt; q.<span class="hljs-built_in">back</span>())&#123; <span class="hljs-comment">//要先判断 q.size() &gt; 0</span><br>    q.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-comment">// int q[N],hh=0,tt=-1; //队列中元素下标从0开始</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <br>    deque&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//双端队列</span><br>    <span class="hljs-comment">//求最小值(构造单调递减队列)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//新元素和队尾元素 循环 比较 （注意这里是while，会一直循环比较）</span><br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>() &amp;&amp; q.<span class="hljs-built_in">back</span>() &gt; a[i]) q.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//队尾出队</span><br>        q.<span class="hljs-built_in">push_back</span>(a[i]); <span class="hljs-comment">//新元素入队</span><br>        <br>        <span class="hljs-comment">//判断目前的队头是否已经滑出了窗口 （这里要取 i-k &gt;= 1）</span><br>        <br>        <span class="hljs-keyword">if</span>(i-k &gt;= <span class="hljs-number">1</span> &amp;&amp; q.<span class="hljs-built_in">front</span>() == a[i-k])&#123; <span class="hljs-comment">//如果q.front != a[i-k] 就代表窗口左边界的值早就出队了，不会参与比较了</span><br>            q.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-comment">//窗口大小满足条件后，开始输出答案</span><br>        <span class="hljs-keyword">if</span>(i &gt;= k)&#123;<br>            cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    q.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-comment">//求最大值(构造单调递减队列)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>() &amp;&amp; q.<span class="hljs-built_in">back</span>() &lt; a[i]) q.<span class="hljs-built_in">pop_back</span>();<br>        q.<span class="hljs-built_in">push_back</span>(a[i]);<br>        <span class="hljs-keyword">if</span>(i - k &gt;= <span class="hljs-number">1</span> &amp;&amp; a[i - k] == q.<span class="hljs-built_in">front</span>()) q.<span class="hljs-built_in">pop_front</span>(); <br>        <span class="hljs-keyword">if</span>(i &gt;= k) cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>滑动窗口的最大值问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMaxInWindows</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> windowSize)</span> </span>&#123;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; window;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-comment">// 移除窗口外的元素</span><br>        <span class="hljs-keyword">while</span> (!window.<span class="hljs-built_in">empty</span>() &amp;&amp; window.<span class="hljs-built_in">front</span>() &lt;= i - windowSize) &#123; <span class="hljs-comment">//window.front() &lt;= i - windowSize 符合这个条件才代表窗口的左边界还在队列中</span><br>            window.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-comment">// 移除小于当前元素的元素</span><br>        <span class="hljs-keyword">while</span> (!window.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[window.<span class="hljs-built_in">back</span>()] &lt; nums[i]) &#123;<br>            window.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        window.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-comment">// 输出窗口内的最大值</span><br>        <span class="hljs-keyword">if</span> (i &gt;= windowSize - <span class="hljs-number">1</span>) &#123;<br>            std::cout &lt;&lt; nums[window.<span class="hljs-built_in">front</span>()] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> windowSize = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">printMaxInWindows</span>(nums, windowSize);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="完美区间"><a href="#完美区间" class="headerlink" title="完美区间"></a>完美区间</h3><p><strong>给出一个长度为N(1 ≤ N ≤ 50000)的数字队列，定义完美区间为数字队列中连续的一段，并且其中最大与最小数字之差不得超过M(1 ≤ M ≤ 50000)。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPerfectIntervals</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> M)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    deque&lt;<span class="hljs-type">int</span>&gt; minDeque; <span class="hljs-comment">// 用于存储最小值索引的双端队列</span><br>    deque&lt;<span class="hljs-type">int</span>&gt; maxDeque; <span class="hljs-comment">// 用于存储最大值索引的双端队列</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-comment">// 维护最小值队列</span><br>        <span class="hljs-keyword">while</span> (!minDeque.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; nums[minDeque.<span class="hljs-built_in">back</span>()]) &#123;<br>            minDeque.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        minDeque.<span class="hljs-built_in">push_back</span>(i);<br><br>        <span class="hljs-comment">// 维护最大值队列</span><br>        <span class="hljs-keyword">while</span> (!maxDeque.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[maxDeque.<span class="hljs-built_in">back</span>()]) &#123;<br>            maxDeque.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        maxDeque.<span class="hljs-built_in">push_back</span>(i);<br><br>        <span class="hljs-comment">// 当窗口大小超过n时，移动窗口</span><br>        <span class="hljs-keyword">while</span> (nums[i] - nums[minDeque.<span class="hljs-built_in">front</span>()] &gt; M) &#123;<br>            <span class="hljs-keyword">if</span> (minDeque.<span class="hljs-built_in">front</span>() == i - minDeque.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>                minDeque.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (nums[maxDeque.<span class="hljs-built_in">front</span>()] - nums[i] &gt; M) &#123;<br>            <span class="hljs-keyword">if</span> (maxDeque.<span class="hljs-built_in">front</span>() == i - maxDeque.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>                maxDeque.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算完美区间的数量</span><br>        count += (i - minDeque.<span class="hljs-built_in">front</span>() + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-type">int</span> M = <span class="hljs-number">3</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Number of perfect intervals: &quot;</span> &lt;&lt; <span class="hljs-built_in">countPerfectIntervals</span>(nums, M) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="每个字母恰好出现两次的最长子串"><a href="#每个字母恰好出现两次的最长子串" class="headerlink" title="每个字母恰好出现两次的最长子串"></a>每个字母恰好出现两次的最长子串</h3><p><strong>给一个只包含小写字母且长度不超过100000的字符串，找出每个字母恰好出现两次的最长子串。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">string <span class="hljs-title">longestSubstringWithEqualFrequency</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; count;<br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    string result;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; n; ++right) &#123;<br>        <span class="hljs-type">char</span> c = s[right];<br>        count[c]++;<br>        <br>        <span class="hljs-comment">// 检查当前窗口是否有效</span><br>        <span class="hljs-keyword">while</span> (count[c] &gt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">char</span> leftChar = s[left];<br>            count[leftChar]--;<br>            left++;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查当前窗口是否包含所有字符恰好两次</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">all_of</span>(count.<span class="hljs-built_in">begin</span>(), count.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&amp; p) &#123; <span class="hljs-keyword">return</span> p.second == <span class="hljs-number">2</span>; &#125;)) &#123;<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                maxLen = right - left + <span class="hljs-number">1</span>;<br>                result = s.<span class="hljs-built_in">substr</span>(left, maxLen);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s = <span class="hljs-string">&quot;aabbcc&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Longest substring with equal frequency: &quot;</span> &lt;&lt; <span class="hljs-built_in">longestSubstringWithEqualFrequency</span>(s) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的直径</title>
    <link href="/2024/04/10/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2024/04/10/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><blockquote><p>定义：树上任意两节点之间最长的简单路径即为树的「直径」<br>显然，一棵树可以有多条直径，他们的长度相等。<br>可以用两次 DFS 或者树形 DP 的方法在 O(n) 时间求出树的直径。</p></blockquote><p><strong>求树的直径的方法：</strong></p><ol><li><p>任取一点作为起始点k，找到距离该点最远的一个点v。</p></li><li><p>从点v开始搜，找到距离点v最远的一点u，则uv间的距离是树的直径。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//1KB=1024B（字节），1MB=1024KB，所以1MB大约等于100w字节（1e6）64MB = 6400w字节 （6*1e7）</span><br><span class="hljs-comment">//int 占四字节</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2</span>*N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx=<span class="hljs-number">1</span>,w[M]; <span class="hljs-comment">//</span><br><span class="hljs-type">bool</span> st[N];<br>LL s[<span class="hljs-number">10100</span>];<br>LL maxu,maxd;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    e[idx] = b; ne[idx] = h[a]; h[a] = idx; w[idx] = d; idx++; <span class="hljs-comment">//idx要最后再++</span><br>&#125;<br><br><span class="hljs-comment">//求距离某个点u最远的点maxu,以及距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])&#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(maxd &lt; d+w[i])&#123;<br>                <span class="hljs-comment">//maxu是距离u最远的点，maxd是 u和maxu 的距离</span><br>                maxd = d+w[i];<br>                maxu = j;<br>            &#125;<br>            <span class="hljs-built_in">dfs</span>(j,d+w[i]);<br>            st[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-comment">//这里是到n-1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,d;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;<br>        <span class="hljs-built_in">add</span>(a,b,d); <span class="hljs-built_in">add</span>(b,a,d);<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; s[4] &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">// int ans,max=0,pos;</span><br>    <span class="hljs-comment">// for(int i=2;i&lt;=n;i++)&#123;</span><br>    <span class="hljs-comment">//     memset(st,0,sizeof(st));</span><br>    <span class="hljs-comment">//     ans = dfs(1,i,0);</span><br>    <span class="hljs-comment">//     if(ans &gt; max)&#123;</span><br>    <span class="hljs-comment">//         max = ans;</span><br>    <span class="hljs-comment">//         pos = i;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>    <span class="hljs-built_in">dfs</span>(maxu,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; u &lt;&lt; pos;</span><br>    <span class="hljs-comment">// memset(st,0,sizeof(st));</span><br>    <span class="hljs-comment">// cout &lt;&lt; maxd; </span><br>    <span class="hljs-comment">//n(a1+an)/2</span><br>    cout &lt;&lt; ( <span class="hljs-number">11</span> + (<span class="hljs-number">11</span>+maxd<span class="hljs-number">-1</span>) )*maxd/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; s[maxd];</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2024/04/10/algorithm_know/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2024/04/10/algorithm_know/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p>步骤：</p><ol><li>将区间按照左端点进行排序</li><li>循环判断，如果下一个区间的左端点小于（等于）当前区间的右端点时则可以合并，并更新右端点的最大值</li><li>如果下一个区间的左端点大于当前区间的右端点时则不可以合并，则更新右端点的最大值为下一个区间的右端点</li></ol><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//t代表有人挤奶牛的区间的集合，f代表没有挤奶牛的区间的集合</span><br><span class="hljs-comment">//初始化</span><br>    LL maxr = a[<span class="hljs-number">1</span>].r;<br>    t[++<span class="hljs-type">num_t</span>] = a[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//循环遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>].l &lt;= maxr)&#123;<br>            maxr = <span class="hljs-built_in">max</span>(maxr,a[i+<span class="hljs-number">1</span>].r);<br>            t[<span class="hljs-type">num_t</span>].r = maxr;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            f[++num_f] = &#123;t[<span class="hljs-type">num_t</span>].r , a[i+<span class="hljs-number">1</span>].l&#125;; <span class="hljs-comment">//老区间的r和新区间的l</span><br>            t[++<span class="hljs-type">num_t</span>] = a[i+<span class="hljs-number">1</span>];<br>            maxr = a[i+<span class="hljs-number">1</span>].r;<br>            <span class="hljs-comment">// cnt++; 区间个数</span><br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>求区间合并之后区间的总个数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">int</span> n,cnt=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    LL l,r;<br>&#125;a[N],ans[N];<br><span class="hljs-comment">//左端点从小到大排列</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmd</span><span class="hljs-params">(node a, node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.l &lt; b.l;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        a[i] = &#123;l,r&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmd);<br>    <span class="hljs-comment">//从第二个区间开始判断</span><br>    LL maxr = a[<span class="hljs-number">1</span>].r;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>].l &lt;= maxr)&#123;<br>            maxr = <span class="hljs-built_in">max</span>(maxr,a[i+<span class="hljs-number">1</span>].r);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cnt++;<br>            maxr = a[i+<span class="hljs-number">1</span>].r;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="挤奶牛"><a href="#挤奶牛" class="headerlink" title="挤奶牛"></a>挤奶牛</h3><blockquote><p>求区间合并后各个区间的范围</p></blockquote><p><img src="/../../img/%E6%8C%A4%E5%A5%B6%E7%89%9B.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">int</span> n;<br>LL <span class="hljs-type">num_t</span>,num_f,<span class="hljs-type">max_t</span>,max_f;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    LL l,r;<br>&#125;a[N],t[N],f[N]; <span class="hljs-comment">//t代表有人挤奶牛的区间的集合，f代表没有挤奶牛的区间的集合</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmd</span><span class="hljs-params">(node a,node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.l &lt; b.l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmd);<br>    LL maxr = a[<span class="hljs-number">1</span>].r;<br>    t[++<span class="hljs-type">num_t</span>] = a[<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>].l &lt;= maxr)&#123;<br>            maxr = <span class="hljs-built_in">max</span>(maxr,a[i+<span class="hljs-number">1</span>].r);<br>            t[<span class="hljs-type">num_t</span>].r = maxr;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            f[++num_f] = &#123;t[<span class="hljs-type">num_t</span>].r , a[i+<span class="hljs-number">1</span>].l&#125;; <span class="hljs-comment">//老区间的r和新区间的l</span><br>            t[++<span class="hljs-type">num_t</span>] = a[i+<span class="hljs-number">1</span>];<br>            maxr = a[i+<span class="hljs-number">1</span>].r;<br>            <span class="hljs-comment">// cnt++; 区间个数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-type">num_t</span>;i++)&#123;<br>        <span class="hljs-comment">// cout &lt;&lt; t[i].l &lt;&lt; &quot; &quot; &lt;&lt; t[i].r &lt;&lt; &quot;\n&quot;;</span><br>        <span class="hljs-type">max_t</span> = <span class="hljs-built_in">max</span>(<span class="hljs-type">max_t</span>,t[i].r-t[i].l);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num_f;i++)&#123;<br>        <span class="hljs-comment">// cout &lt;&lt; f[i].l &lt;&lt; &quot; &quot; &lt;&lt; f[i].r &lt;&lt; &quot;\n&quot;;</span><br>        max_f = <span class="hljs-built_in">max</span>(max_f,f[i].r-f[i].l);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-type">max_t</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; max_f;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>区间合并</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>区间合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA408/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="cd001eedacaf17440b842860afe731a49ba4a94ca031a94c15f6682e52ad8788">9ef5e081b4fe98a32076e025047ca199b8697f81cb35d436f11001bf982a82df66d1dc61cb3aa440c9bcb55c7090e2a6554f69058e089e9ccbdf034cfd1f3dda12db3f829c591e0da5ca01e3917f75b5d03b529ad01fdfa95cce4e3734b55505cf0cef78ab352d4257ddf7583aa11efdb23a1ca345e68a2d6df74ea7dd001701fb398f039ce3fa015724738b8509f6919d5fb07ad9c668de5775b4be2764474dedc0c4aaa4a855738d4f7dfa6c5ac174a3fddf5fdf0912915e3606f365de96e03930a9ece8fc80be66be66511d940ceaab7740b53f1f635c056738e697746138cf32cd7845bf4de31ac326aad8d64245e4c98347f878afdcde2d321c533f98f521e7c058a60d33ed28056fcda1073023690e4a85ee22a2c947ce95fec0fffc1f1cf4f1ed54f8db115a81e45b9cd4aeb12f1cca56fd27ceab5e92917cd6db63e863eb181c73b0ceee4f529936e1a389bae4a84893cb9220167767aef873830b4d1301c02e900cfb8f7357141da4e7f873cf41d3e7ea616af87f4d744814048daef2954a66b739be6ae879b03fb14fcd9ef2c9d791c8aee6194dde1acc0b8576b08cbd4ded8affc539fed13033b46689e20f20db3551fbf7eb3773731146eccb7a30d2e675c552e3ebbd9239cc61117f9f37bc0439a0a408a5db4c1bae6ce013dc1f47a9b6e9e449a27e6bc97081338014afe64ce52b7206197e3cad81bb05cf2b538d4a38449d3fe99f3ff8c11b0717f2b4938348bb9c81d33cac5678fbcce6c963684804ea11a8973c914e7bc4ad125897250491b8df3f5b3f05d5748c31ba6f7273c6f42e29e65736a467a130aed14adeed10f24501a3fdcb862e1f489bd7d30a450ba9257295ebfd8fede620350daad5def172bcc700eeda905669b6e6cef190a2f4cd6cd2bf178466c3c32e2d4b47bbaf8d1e9cf7335b87e6fca237114ef3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>期末复习</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>期末复习</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日期问题</title>
    <link href="/2024/04/10/algorithm_know/%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/10/algorithm_know/%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h1><h2 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h2><ol><li>是否是闰年来确定二月的天数</li><li>日期是否合理（month在1<del>12 day在1</del>28&#x2F;29&#x2F;30&#x2F;31（根据月份来判断））</li><li>日期的输出顺序是否合理</li><li>日期相同时只需要输出一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string c;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    string yy,mm,dd;<br>&#125;d[<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmd</span><span class="hljs-params">(<span class="hljs-type">const</span> node&amp; a, <span class="hljs-type">const</span> node&amp; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.yy != b.yy) <span class="hljs-keyword">return</span> a.yy &lt; b.yy;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.mm != b.mm) <span class="hljs-keyword">return</span> a.mm &lt; b.mm;<br>    <span class="hljs-keyword">else</span>&#123;<br>        a.dd &lt; b.dd;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; c;<br>    string yy,mm,dd;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> day[<span class="hljs-number">12</span>] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        string str = c;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>            yy = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>); mm = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); dd = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>            yy = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>); mm = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>); dd = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            yy = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>); mm = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); dd = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(yy &lt;= <span class="hljs-string">&quot;59&quot;</span>)&#123;<br>            yy = <span class="hljs-string">&quot;20&quot;</span> + yy;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            yy = <span class="hljs-string">&quot;19&quot;</span> + yy;<br>        &#125;<br>        <br>        string t = yy;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">stoi</span>(t);<br>        <br>        <span class="hljs-keyword">if</span>(mm &lt;= <span class="hljs-string">&quot;00&quot;</span> || mm &gt; <span class="hljs-string">&quot;12&quot;</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mm == <span class="hljs-string">&quot;02&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || (a % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; a % <span class="hljs-number">100</span> !=<span class="hljs-number">0</span> ))&#123;<br>                <span class="hljs-keyword">if</span>(dd &gt; <span class="hljs-string">&quot;29&quot;</span> || dd &lt;= <span class="hljs-string">&quot;00&quot;</span> ) <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(dd &gt; <span class="hljs-string">&quot;28&quot;</span> || dd &lt;= <span class="hljs-string">&quot;00&quot;</span> ) <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mm == <span class="hljs-string">&quot;01&quot;</span> || mm == <span class="hljs-string">&quot;03&quot;</span> || mm == <span class="hljs-string">&quot;05&quot;</span> || mm == <span class="hljs-string">&quot;07&quot;</span> || mm == <span class="hljs-string">&quot;08&quot;</span> || mm == <span class="hljs-string">&quot;10&quot;</span> || mm == <span class="hljs-string">&quot;12&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(dd &lt;= <span class="hljs-string">&quot;00&quot;</span> || dd &gt; <span class="hljs-string">&quot;31&quot;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(dd &lt;= <span class="hljs-string">&quot;00&quot;</span> || dd &gt; <span class="hljs-string">&quot;30&quot;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>            <span class="hljs-keyword">if</span>(yy == d[i].yy &amp;&amp; mm == d[i].mm &amp;&amp; dd == d[i].dd) flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//这个地方要用cnt，不能用i，因为i一直在循环中增加，但放入结构体数组中的数只有满足条件才会放入</span><br>        d[cnt] = &#123;yy,mm,dd&#125;;<br>        cnt ++;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(d,d+cnt,cmd);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        cout &lt;&lt; d[i].yy &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; d[i].mm &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; d[i].dd &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找练习题</title>
    <link href="/2024/04/08/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/08/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找练习题"><a href="#二分查找练习题" class="headerlink" title="二分查找练习题"></a>二分查找练习题</h1><h2 id="卡牌"><a href="#卡牌" class="headerlink" title="卡牌"></a>卡牌</h2><p>题目链接：<a href="https://www.lanqiao.cn/problems/2191/learning/?subject_code=1&group_code=4&match_num=13&match_flow=2&origin=cup">卡牌</a></p><p><img src="/../../img/%E5%8D%A1%E7%89%8C%E4%BA%8C%E5%88%86.png"></p><p><strong>tips:</strong></p><ol><li>记得开long long （最好把<strong>所有的数据都从 int 变成 long long</strong>）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e11</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL n,m,a[N],b[N];<br><br><span class="hljs-comment">//mid为能凑出的牌的套数</span><br><span class="hljs-comment">//m是全局变量，而每次判断 mid 是否满足条件时都要用到总空白牌数m这个值，因此 要用一个变量去代替 m 去操作 </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span>&#123;<br>  LL sum = m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(a[i] &gt;= mid) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(b[i]+a[i] &lt; mid || sum+a[i] &lt; mid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    sum = sum - (mid - a[i]); <br>  &#125;<br>  <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; b[i];<br>  &#125;<br>  LL l = <span class="hljs-number">0</span>, r = INT_MAX; <br>  <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    LL mid = (l+r+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>      l = mid;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      r = mid<span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; l;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp背包问题练习题</title>
    <link href="/2024/04/07/dp/dp%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/07/dp/dp%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="dp背包问题练习题"><a href="#dp背包问题练习题" class="headerlink" title="dp背包问题练习题"></a>dp背包问题练习题</h1><h2 id="货币系统（完全背包）"><a href="#货币系统（完全背包）" class="headerlink" title="货币系统（完全背包）"></a>货币系统（完全背包）</h2><p><strong>tips：</strong></p><ol><li>要将$f[0][0]$ 等特殊的点进行初始化操作</li><li>要将$f[N][N] $设置为 $long long$</li></ol><p><img src="/../../img/1371_%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//从前v种货币中选，凑出N元钱的方案的集合的长度</span><br><span class="hljs-comment">//第v种货币不选或者选一个/两个/...</span><br><span class="hljs-comment">//如果第v种货币选一个的方案数相当于从前v-1种货币中选凑出N-v[i]的方案数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL n,m;<br>LL v[N];<br>LL f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i];<br>    &#125;<br>    <span class="hljs-comment">//注意边界值要记得初始化</span><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-comment">// f[i][j] = f[i-1][j];</span><br>            <span class="hljs-comment">// for(int k=1;k*v[i]&lt;=j;k++)</span><br>            <span class="hljs-comment">//     f[i][j] += f[i-1][j-k*v[i]];</span><br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) f[i][j] += f[i][j - v[i]];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n][m];<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="包子凑数"><a href="#包子凑数" class="headerlink" title="包子凑数"></a>包子凑数</h2><blockquote><p>问题简化为：输入n个数，求整数域内共有多少个数无法被这n个数通过加法来表示；</p></blockquote><p><strong>tips：</strong></p><ol><li>要将$f[0][0]$ 等特殊的点进行初始化操作</li><li>输入n个数，求整数域内共有多少个数无法被这n个数通过加法来表示；</li><li>当这n个数<strong>最大公因数等于 1 的时候，个数有限</strong></li><li><strong>最大公因数大于 1 的时候，个数无限</strong></li><li>最大不能表示出来的数必定有个上界; 当两个数a,b（当gcd&#x3D;1时），最大不能表示的数为(a-1)(b-1)-1 ; 当数字更多的时候，这个上界必然更小（可选的数字变多了）; 而99和98是100内最大的互质的数，所以这个上界选择10000</li></ol><p><img src="/../../img/%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//f[i][j]: 从前 i 种蒸笼种选，使得这若干笼中恰好一共有 j 个包子的方案集合</span><br><span class="hljs-comment">//属性：集合是否非空</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,a[<span class="hljs-number">110</span>],f[N][N];<br><span class="hljs-type">int</span> d; <span class="hljs-comment">//所给的几个数的最大公因数</span><br><span class="hljs-comment">//输入n个数，求整数域内共有多少个数无法被这n个数通过加法来表示；</span><br><span class="hljs-comment">//最大公因数等于 1 的时候，个数有限</span><br><span class="hljs-comment">//最大公因数大于 1 的时候，个数无限</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>        d = <span class="hljs-built_in">gcd</span>(d,a[i]); <span class="hljs-comment">//0和a[i]的最大公因数为 a[i]</span><br>    &#125;<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1e4</span>;j++)&#123;<br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= a[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i][j-a[i]]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//最大不能表示出来的数必定有个上界</span><br>    <span class="hljs-comment">//当两个数a,b（当gcd=1时），最大不能表示的数为(a-1)(b-1)-1</span><br>    <span class="hljs-comment">//当数字更多的时候，这个上界必然更小（可选的数字变多了）</span><br>    <span class="hljs-comment">//而99和98是100内最大的互质的数，所以这个上界选择10000</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">1e4</span>;i++)&#123;<br>        <span class="hljs-comment">//方案数为0 代表其不可表示</span><br>        <span class="hljs-keyword">if</span>(f[n][i] == <span class="hljs-number">0</span>) cnt++;<br>    &#125;<br>    <span class="hljs-comment">//最大公因数大于 1 的时候，个数无限</span><br>    <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;INF&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h2><blockquote><p>从2022个物品中选择10个物品，并且物品总体积为2022的方案数</p></blockquote><p><img src="/../../img/2022.png"></p><p><strong>tips:</strong></p><ol><li>从 0到N 初始化 $f[i][0][0]$<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)&#123;<br>    f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2030</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-comment">//从2022个物品中选择10个物品，并且物品总体积为2022</span><br>LL f[N][<span class="hljs-number">15</span>][N]; <span class="hljs-comment">//f[i][j][k]表示从前i个物品中选择j个物品，物体的总体积为k </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a[N];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)&#123;<br>    a[i] = i;<br>    f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2022</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;j++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2022</span>;k++)&#123;<br>        <span class="hljs-comment">//如果没有选择第i个物品，那么当前的方案数就是前i-1个物品中选j </span><br>        f[i][j][k] =  f[i<span class="hljs-number">-1</span>][j][k];<br>        <span class="hljs-keyword">if</span>(k &gt;= a[i]) f[i][j][k] += f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>][k-a[i]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; f[<span class="hljs-number">2022</span>][<span class="hljs-number">10</span>][<span class="hljs-number">2022</span>];<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="砝码称重（0-1背包）"><a href="#砝码称重（0-1背包）" class="headerlink" title="砝码称重（0-1背包）"></a>砝码称重（0-1背包）</h2><blockquote><p>从前i个砝码中选，重量为 j 的方案数</p></blockquote><p><img src="/../../img/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//0-1背包</span><br><span class="hljs-comment">//从前i个砝码中选，重量为 j 的方案数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> w[N];<br><span class="hljs-type">int</span> n,sum;<br><span class="hljs-comment">//如果数据只有一个砝码，重量是1e5，那么当j=1e5，转移时的f[i][j+w[i]]就越界了，所以开了两倍</span><br><span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>*M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; w[i];<br>        sum+=w[i];<br>    &#125;<br>    <span class="hljs-comment">//初始化</span><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sum;j++)&#123;<br>            <span class="hljs-comment">// bool f[N][2*M]</span><br>            <span class="hljs-comment">// f[i][j]=f[i-1][j]||f[i-1][j+w[i]]||f[i-1][abs(j-w[i])];</span><br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            f[i][j] += f[i<span class="hljs-number">-1</span>][<span class="hljs-built_in">abs</span>(j-w[i])]; <span class="hljs-comment">//由于这里加了abs，所以不需要再判断j&gt;=w[i]了</span><br>            f[i][j] += f[i<span class="hljs-number">-1</span>][j+w[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sum;i++)&#123;<br>        <span class="hljs-keyword">if</span>(f[n][i]) cnt++;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/description/?envType=problem-list-v2&envId=2cktkvj">279. 完全平方数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> f[<span class="hljs-number">110</span>][<span class="hljs-number">10010</span>]; <span class="hljs-comment">//d[i][j] 从前i个中选，数量不限制，背包容量等于j的情况下，选择的数量的最小值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f)); <span class="hljs-comment">//由于求最小值min，因此要将所有值初始化为最大值</span><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 由于循环里有f[i-1]，因此i要从1开始循环，所以f[0][0]单独放到循环外面初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=n;i++)&#123;<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)&#123;<br>                f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>                <span class="hljs-keyword">if</span>(j &gt;= i*i) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j],f[i][j-i*i]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> m = <span class="hljs-built_in">pow</span>(n,<span class="hljs-number">1.0</span>/<span class="hljs-number">2</span>);  <span class="hljs-comment">//m为背包数量</span><br>        <span class="hljs-keyword">return</span> f[m][n]; <br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="0-1背包练习题"><a href="#0-1背包练习题" class="headerlink" title="0-1背包练习题"></a>0-1背包练习题</h2><p>一个大集合中要分出 两个集合</p><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h3><ul><li>背包的体积为sum &#x2F; 2</li><li><strong>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</strong></li><li>背包如何正好装满，说明找到了总和为 sum &#x2F; 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><h3 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h3><p>尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题了。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>背包问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性dp练习题</title>
    <link href="/2024/04/07/dp/%E7%BA%BF%E6%80%A7dp%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2024/04/07/dp/%E7%BA%BF%E6%80%A7dp%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="线性dp练习题"><a href="#线性dp练习题" class="headerlink" title="线性dp练习题"></a>线性dp练习题</h1><h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/900/">数字三角形</a></p><p><img src="/../../img/900_%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2.png"></p><p><strong>tips</strong></p><ol><li>因为有些值为负数，因此要将所有$f[i][j]$初始为负无穷<br>如果初始化为0会导致部分$f[i][j]$的值大于 本不应该大于 的f$f[i-1][j-1]$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N][N],f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin &gt;&gt; a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 因为有些值为负数，因此要将所有f[i][j]初始为负无穷</span><br>    <span class="hljs-comment">//如果初始化为0会导致部分f[i][j]的值大于 本不应该大于 的f[i-1][j-1]</span><br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));<br>    <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j] + a[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> max_v = INT_MIN;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        max_v = <span class="hljs-built_in">max</span>(max_v,f[n][j]);<br>    &#125;<br>    cout &lt;&lt; max_v;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="松散子序列"><a href="#松散子序列" class="headerlink" title="松散子序列"></a>松散子序列</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/5409/">松散子序列</a></p><p><img src="/../../img/%E6%9D%BE%E6%95%A3%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><p><strong>dp 思路：</strong><br>以下标 $i$ (从1开始)结尾的松散子序列长度的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">char</span> s[N];<br>string str;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; str;<br>    <span class="hljs-type">int</span> n = str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        s[i] = str[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    f[<span class="hljs-number">1</span>] = s[<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) f[i] = <span class="hljs-built_in">max</span>(f[i],f[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">if</span>(i<span class="hljs-number">-2</span>&gt;=<span class="hljs-number">0</span>) f[i] = <span class="hljs-built_in">max</span>(f[i],f[i<span class="hljs-number">-2</span>] + s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;i++)&#123;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; f[i] &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    cout &lt;&lt; f[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>线性dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的最短路问题</title>
    <link href="/2024/04/07/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/07/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="图的最短路问题"><a href="#图的最短路问题" class="headerlink" title="图的最短路问题"></a>图的最短路问题</h1><p><img src="/../../img/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF.png"></p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><h3 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h3><p><strong>核心思想：</strong></p><ol><li><strong>先确定最短距离点</strong></li><li><strong>然后用该点去更新其他点的最短距离</strong></li></ol><blockquote><p>适合稠密图<br>变量：dist[N] （距离源点的距离数组） , st[N]（某个点是否已经被更新为距离最短的点的集合中的状态数组）<br>重边与自环：在min中会循环找出最短距离的边<br>算法步骤：</p></blockquote><ol><li>初始化：dist 初始化为正无穷（0x3f）<code>memset(dist,0x3f,sizeof(dist));</code> st 初始化为0</li><li>更新已经得到最短距离的所有点所在集合；更新方法：遍历距离数组的所有点，将其中最小距离的点放入集合。</li><li>根据第二步最新得到那个点 t ，去更新其他点的最短距离<br><code>d[j] = min(d[j],d[t] + t-&gt;j的距离)</code></li></ol><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/1906644/">Dijkstra求最短路图解 </a></p><p><strong>邻接矩阵版</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>; <span class="hljs-comment">//数据范围（最大输入节点数）</span><br><br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// 节点/边数</span><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 图的邻接矩阵（稠密图用这个） ，算法复杂度为n^2</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">//用于记录每一个点距离第一个点的距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">//已经确定了最短路径的点为true</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist)); <span class="hljs-comment">//将距离矩阵初始化为正无穷</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 题目要求 求出 1号点到 n号点的最短距离，第一个点到自身的距离为0</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;   <span class="hljs-comment">//有n个点所以要进行n次 迭代</span><br>    <br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;         <span class="hljs-comment">//t存储着下方某轮次循环中找出的距离源点距离最近的点</span><br>        <br>        <span class="hljs-comment">//找到路径最短的点：</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;  <span class="hljs-comment">//此时的j代表从1号点开始,该处循环是找出此时距离源点距离最近的点</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t==<span class="hljs-number">-1</span> || dist[t]&gt;dist[j]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//t的最短路径确定好了</span><br>        <br>        <span class="hljs-comment">//对每个点的最短路径更新：</span><br>        <span class="hljs-comment">//当有新的被确定最短路径的点加入到集合中时，</span><br>        <span class="hljs-comment">//要对所有点（但实际只有剩余未被确定最短路径的点会被更新，因为最短路径的确定是由短到长的）距离源点的最短距离进行更新。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;    <span class="hljs-comment">//此处j&lt;=n 必须要有等于号 //依次更新每个点所到相邻的点路径值</span><br>            <span class="hljs-keyword">if</span>(!st[j])&#123;     <span class="hljs-comment">//跳过已经确定为最短路径的点</span><br>                dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<span class="hljs-comment">//初始化图（邻接矩阵）</span><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c); <span class="hljs-comment">//建图（邻接矩阵） ；当有重边时更新邻接矩阵中的权重为较小的那个权重。</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">dijkstra</span>();<br>    <br>    cout &lt;&lt; t &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],w[M],idx;<br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//堆里存储距离和节点编号</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    e[idx] = b;<br>    w[idx] = v;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="hljs-comment">//小根堆</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//插入距离和节点编号</span><br>    <span class="hljs-comment">//遍历n次，每次找出一个点的最短距离</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>; <span class="hljs-comment">//需要被放入集合的点t</span><br><br>        <span class="hljs-comment">//此时的j代表从1号点开始,该处循环是找出此时距离源点距离最近的点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[j] &lt; d[t]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        st[t] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//更新未确定点的最短距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=h[t];k!=<span class="hljs-number">-1</span>;k=ne[k])&#123;<br>            <span class="hljs-type">int</span> j = e[k];<br>            <span class="hljs-keyword">if</span>(st[j]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//如果该点已经被确定为了最短点集合中了就没必要再去更新它了</span><br>            d[j] = <span class="hljs-built_in">min</span>(d[j],d[t] + w[k]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(a,b,v);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(); <span class="hljs-comment">//找出所有点到源点的距离</span><br>    <span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; d[n];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化Dijkstra算法"><a href="#堆优化Dijkstra算法" class="headerlink" title="堆优化Dijkstra算法"></a>堆优化Dijkstra算法</h3><blockquote><p>适合稀疏图<br>使用小根堆：<code>priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap</code></p></blockquote><p>tips:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2</span>*<span class="hljs-number">1e5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">3</span>*<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],w[M],idx;<br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//堆里存储距离和节点编号</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    e[idx] = b;<br>    w[idx] = v;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="hljs-comment">//小根堆</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//插入距离和节点编号</span><br>    <span class="hljs-comment">//此处有while循环</span><br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br>        PII t = heap.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-comment">//距离源点的距离dist，其节点编号为index</span><br>        <span class="hljs-type">int</span> dist = t.first; <span class="hljs-type">int</span> index = t.second;<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//如果该点已经被放入到最短路径集合中了的话就可以continue</span><br>        <span class="hljs-keyword">if</span>(st[index]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//必不可少的剪枝，防止超时</span><br>        st[index] = <span class="hljs-literal">true</span>;<br>            <br>        <span class="hljs-comment">//更新index所指向的节点距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=h[index];k!=<span class="hljs-number">-1</span>;k=ne[k])&#123;<br>            <span class="hljs-type">int</span> j = e[k];<br>            d[j] = <span class="hljs-built_in">min</span>(d[j],dist + w[k]);<br>            heap.<span class="hljs-built_in">push</span>(&#123;d[j],j&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(a,b,v);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(); <span class="hljs-comment">//找出所有点到源点的距离</span><br>    <span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; d[n];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h2><p>思路：对 所有边 进行 n-1次松弛 操作</p><p><strong>松弛：</strong><br>遍历所有边，更新 边的终节点 到 起点 的最短距离<br><code>if (minDist[B] &gt; minDist[A] + value) minDist[B] = minDist[A] + value</code></p><p><strong>为什么是n-1次操作：</strong></p><p>第一次松弛 能得到与起点 一条边相连的节点的最短路径<br>第二次松弛 能得到与起点 两条边相连的节点的最短路径<br>……<br>第n-1次松弛  能得到与起点 n-1条边相连的节点的最短路径(n个节点，n-1条边即可相连)</p><h3 id="判断是否有负权回路"><a href="#判断是否有负权回路" class="headerlink" title="判断是否有负权回路"></a>判断是否有负权回路</h3><p>在n-1次松弛的基础上，再多松弛一次，看minDist数组 是否发生变化。如果变化了就有负权回路</p><h3 id="有边数限制的bellman-ford算法"><a href="#有边数限制的bellman-ford算法" class="headerlink" title="有边数限制的bellman-ford算法"></a>有边数限制的bellman-ford算法</h3><p>要算从 1 号点到 n 号点的<strong>最多经过 k 条边</strong>的最短距离</p><p>bellman_ford 标准写法是松弛 n-1 次，此时就<strong>松弛 k 次</strong>就好</p><p>在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。此时是<strong>松弛 k+1 次</strong>（因为经过k个城市意味着会经过k+1条边）</p><p><strong>要使用复制数组的关键在于两个因素：</strong></p><ol><li>图中可以有负权回路，说明只要多做松弛，结果是会变的。</li><li>要求最多经过k个节点，对松弛次数是有限制的。</li></ol><p>以上两种情况需要使用复制数组</p><p>acwing流程:</p><ol><li>初始化（结构体数组，d数组设置为无穷大）</li><li>循环k次（边数限制为k）</li><li>每次循环时，对所有的边进行更新操作（要先进行<strong>数组备份</strong>，使用备份的数组进行更新，防止出现串联操作从而<strong>导致实际最短路走过的长度大于k</strong>）</li><li>判断是否有路径（大于 0x3f3f3f3f &#x2F; 2）即为无路径（起点和终点不连通，但终点和别的点连通）</li></ol><p><a href="https://www.acwing.com/solution/content/17551/">有边数限制的最短路</a></p><blockquote><p>适用于有负权边的最短路（有边数限制的最短路）</p></blockquote><p><strong>注意事项</strong></p><ol><li>有边数限制时，要注意防止一次松弛前进多步</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//防止一次松弛前进多条边</span><br><span class="hljs-built_in">memcpy</span>(cpy,d,<span class="hljs-built_in">sizeof</span>(d));<br><br><span class="hljs-comment">//遍历m条边</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>    <span class="hljs-type">int</span> a = u[i].a; <span class="hljs-type">int</span> b = u[i].b; <span class="hljs-type">int</span> w = u[i].w;<br>    <span class="hljs-keyword">if</span>(cpy[a] + w &lt; d[b])&#123;<br>        d[b] = cpy[a] + w; <span class="hljs-comment">//比较的时候用复制的数组，更新的时候才用原数组</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>由于存在负权边，返回值长度可能恰好是 -1 的情况下会报错<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span>(d[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//不能这么写，因为有可能路径长度恰好是 -1</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> d[n];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ...<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;    <br>&#125;u[M];<br><br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> d[N],cpy[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//起点为节点1， 起点到起点的距离为0，所以 minDist[1] 初始化为0</span><br>    <br>    <span class="hljs-comment">//k次松弛</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        <br>        <span class="hljs-comment">//防止一次松弛前进多条边</span><br>        <span class="hljs-built_in">memcpy</span>(cpy,d,<span class="hljs-built_in">sizeof</span>(d));<br>        <br>        <span class="hljs-comment">//遍历m条边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;i++)&#123;<br>            <span class="hljs-type">int</span> a = u[j].a; <span class="hljs-type">int</span> b = u[j].b; <span class="hljs-type">int</span> w = u[j].w;<br>            <span class="hljs-keyword">if</span>(cpy[a] + w &lt; d[b])&#123;<br>                d[b] = cpy[a] + w; <span class="hljs-comment">//比较的时候用复制的数组，更新的时候才用原数组</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><br>    <span class="hljs-comment">//先存储要进行遍历的边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        u[i] = &#123;a,b,v&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">bellman</span>();<br>    <span class="hljs-keyword">if</span>(d[n] &gt; <span class="hljs-number">1e9</span>) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>; <span class="hljs-comment">//d[n]没被更新 代表 没有路径</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; d[n];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h2><p><strong>dijkstra 和 spfa算法的区别</strong><br>dijkstra是基于贪心的思想，每次选择最近的点去更新其它点，过后就不再访问。<br>而在spfa算法中，只要有某个点的距离被更新了，就把它加到队列中，去更新其它点，所有每个点有被重复加入队列的可能。</p><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p><strong>动态规划思想</strong></p><p><code>g[i][j] = min(g[i][j],g[i][k] + g[k][j]);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> n,m,k;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                g[i][j] = <span class="hljs-built_in">min</span>(g[i][j],g[i][k] + g[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> x,y,z;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        <br>        <span class="hljs-comment">//因为有重边，所以要用min取最小值</span><br>        g[x][y] = <span class="hljs-built_in">min</span>(g[x][y],z);    <br>    &#125;<br><span class="hljs-comment">/* 这三条边就是重边</span><br><span class="hljs-comment">3 4 5</span><br><span class="hljs-comment">3 4 6</span><br><span class="hljs-comment">3 4 7</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-built_in">floyd</span>();<br>    <br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        <br>        <span class="hljs-keyword">if</span>(x == y)&#123; <span class="hljs-comment">//起点和终点相同是距离为0</span><br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;    <br>        <span class="hljs-keyword">else</span>&#123;<br>        <br>            <span class="hljs-keyword">if</span>(g[x][y] &gt; <span class="hljs-number">1e9</span>)&#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cout &lt;&lt; g[x][y] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>多源最短路算法</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map</title>
    <link href="/2024/04/06/stl/map/"/>
    <url>/2024/04/06/stl/map/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>拓扑序列</title>
    <link href="/2024/04/05/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
    <url>/2024/04/05/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><blockquote><p>定义：拓扑序列是图中的顶点的线性排序，使得从顶点u到顶点v的每个有向边u-&gt;v ,在拓扑序列中u都在v前面</p></blockquote><ol><li><p>不是所有的有向图都是有拓扑序的，只有<strong>有向无环图才有拓扑序</strong>，所以有向无环图又被称为拓扑图</p></li><li><p>有向无环图的<strong>拓扑序不是唯一的</strong></p></li></ol><h2 id="拓扑序列的求法"><a href="#拓扑序列的求法" class="headerlink" title="拓扑序列的求法"></a>拓扑序列的求法</h2><blockquote><p>对于拓扑序列而言，入度为0的点一定是排在前面的<br>对一个图BFS一遍，BFS过程中更新每个点的入度，如果一个点的入度为0，那么就将其加入拓扑序，并且删除其与后继结点的所有边。</p></blockquote><p>1.入度的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">在建立邻接表时计算每个节点的入度<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    d[b] ++; <span class="hljs-comment">//节点b的入度加1</span><br>    <br>    ne[idx] = h[a];<br>    h[a] = idx;<br>    idx ++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>得到拓扑序列<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//先将目前入度为0的节点入队</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)&#123;<br>            q[++tt] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh];<br>        hh++;<br>        <span class="hljs-comment">//删除由节点t所指出的边（并不是真的删除，而是将节点入度减1）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            d[j] --; <span class="hljs-comment">//该边的终点入度减1</span><br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">0</span>)&#123;<br>                q[++tt] = j; <span class="hljs-comment">//让入度为0的节点入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是不是拓扑序列</span><br>    <span class="hljs-comment">//如果所有点都入队了（所有点的入度都为0）就是拓扑序列，反之就不是</span><br>    <span class="hljs-keyword">return</span> tt == n<span class="hljs-number">-1</span>; <span class="hljs-comment">//tt初始化时为-1，tt代表节点下标从0开始，因此是与n-1对比</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>判断是不是拓扑序列</strong><br>看队尾指针tt的值 加1 （下标从0开始）是不是等于节点个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//判断是不是拓扑序列</span><br><span class="hljs-comment">//如果所有点都入队了（所有点的入度都为0）就是拓扑序列，反之就不是</span><br><span class="hljs-keyword">return</span> tt == n<span class="hljs-number">-1</span>; <span class="hljs-comment">//tt初始化时为-1，tt代表节点下标从0开始，因此是与n-1对比</span><br><br></code></pre></td></tr></table></figure></li><li><strong>输出拓扑序列</strong><br>由于出队只是将指针向后移动，但前面入队的元素还在队列数组中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h2><ol><li>所需变量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> e[N],ne[N],idx<br><span class="hljs-comment">// head 代表头指针</span><br><span class="hljs-comment">// e[N] 代表节点元素的值</span><br><span class="hljs-comment">// ne[N] 代表节点元素的next指针，即其所指向的下一个节点的下标</span><br><span class="hljs-comment">// idx 代表目前已经已经用到哪个节点了</span><br><br></code></pre></td></tr></table></figure></li><li>初始化操作</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">head = <span class="hljs-number">-1</span>; <span class="hljs-comment">//初始时头指针指向NULL</span><br>idx = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>将x插到头节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">e[idx] = x;<br>ne[idx] = head;<br>head = idx;<br>idx++;<br></code></pre></td></tr></table></figure><ol start="4"><li>将x插到下标是k的点后面</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">e[idx] = x;<br>ne[idx] = ne[k];<br>ne[k] = idx;<br>idx++;<br></code></pre></td></tr></table></figure><ol start="5"><li>删除<strong>下标为k</strong>的数（即为第k-1个插入的数）后面的那一个节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">ne[k] = ne[ne[k]];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树和图的存储和遍历</title>
    <link href="/2024/04/04/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"/>
    <url>/2024/04/04/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="树和图的存储和遍历"><a href="#树和图的存储和遍历" class="headerlink" title="树和图的存储和遍历"></a>树和图的存储和遍历</h1><h2 id="树和图的存储"><a href="#树和图的存储" class="headerlink" title="树和图的存储"></a>树和图的存储</h2><ol><li>树是一种特殊的图（无环连通图），因此可以把树当作图来处理</li><li>图分为有向图(a-&gt;b)和无向图(a-b),但我们在算法题中如果<strong>遇到无向图，就直接（a-&gt;b）和（b-&gt;a）都建立</strong>，因此无向图就是特殊的有向图。</li><li>存储方式</li></ol><p>（1）邻接矩阵 g[N][N]</p><ul><li>g[a][b] &#x3D; 0 代表 节点a-&gt;b没有边 </li><li>g[a][b] &#x3D; 1 代表 a-&gt;b有边 </li><li>g[b][a] &#x3D; 1 代表 b-&gt;a有边</li><li>g[a][b] &#x3D; w 代表 a-&gt;b 该边的权重或者长度为w</li><li>空间复杂度为O(n²)，适合存储稠密图</li></ul><p>（2）邻接表 </p><blockquote><p>我们可以想一下对于任意一个结点u, 需要记录邻边的哪些信息。</p><p>这些信息应该包括这条邻边的终点，权重，以及下一条邻边的编号。</p></blockquote><ul><li>每个点上都有一个单链表，存的是这个点可以走到哪些点</li><li><strong>h数组的下标为结点的编号，e,ne数组的下标为边的编号，e数组的值为该边的终点，idx为边的编号</strong></li><li>邻接表初始化(<strong>先将h数组都置为-1再插入节点</strong>)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// N代表点的个数，M代表边的条数</span><br>  <span class="hljs-comment">// n个结点的树最多有n - 1条边，如果考虑无向边需要开两倍的n - 1来存储</span><br><span class="hljs-type">int</span> h[N],e[<span class="hljs-number">2</span>*N],ne[<span class="hljs-number">2</span>*N],idx; <span class="hljs-comment">//有n个单链表就有n个头节点</span><br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h)); <span class="hljs-comment">//所有头节点都指向-1</span><br>  <span class="hljs-comment">// h[i]：第 i 个节点的第一条邻边的 idx</span><br>  <span class="hljs-comment">// e[idx]：存储 idx 这条边的终点，也就是与第 i 个节点相连的某一个点</span><br>  <span class="hljs-comment">// ne[idx]：存储 与第 idx 条边 同起点的 下一条边的 idx，也就是邻接表中的下一个节点</span><br>  <span class="hljs-comment">// idx：用于标识每条边的下标，存的是边的编号</span><br></code></pre></td></tr></table></figure></li><li>邻接表插入元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//有一条a-&gt;b的边 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a]; <span class="hljs-comment">// 新插入的边是插到链表头（头插法）</span><br>    h[a] = idx; <span class="hljs-comment">//更新链表头</span><br>    idx++;<br>&#125;<br><span class="hljs-comment">//树的边数等于节点数减1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-built_in">add</span>(a,b); <span class="hljs-built_in">add</span>(b,a); <span class="hljs-comment">//无向图</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="树和图的遍历"><a href="#树和图的遍历" class="headerlink" title="树和图的遍历"></a>树和图的遍历</h2><p><strong>遍历前要记得将头指针数组设置为 -1</strong></p><blockquote><p>对于树和图的遍历，不管是DFS还是BFS，因为每个点只会被遍历一次，所以时间复杂度与点和边的数量成线性关系，为<strong>O(n + m)</strong></p></blockquote><p><strong>dfs 和 bfs 的不同</strong><br><strong>不同：</strong></p><ol><li><p>参数上：</p><ul><li>void dfs(int u) &#x2F;&#x2F;u代表层数  调用: dfs(1);</li><li>int bfs() &#x2F;&#x2F;没有参数  调用：cout &lt;&lt; bfs(); &#x2F;&#x2F;在函数里面会返回需要的答案</li></ul></li><li><p>变量上<br>bfs 多了一个距离数组，初始时要将其置为-1 <code>memset(d,-1,sizeof(d))</code><br>dfs 用st[N] 当作状态数组 ，bfs可以使用距离数组 d 来充当状态数组 ; </p></li><li><p>代码结构<br>dfs: 递归结构<br>bfs: <strong>初始化 + while(队列非空)的循环</strong></p></li></ol><p><strong>相同：</strong></p><ol><li>初始化上<br>要在开始时将当前正在访问的点设置为true</li></ol><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><p>从节点编号1开始遍历，沿着节点的邻接表一路深搜</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> st[N]; <span class="hljs-comment">//状态数组,标记某个点是否被遍历到</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//遍历点u的所有出边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> b = e[i]; <span class="hljs-comment">//b是该边终点</span><br>        <span class="hljs-keyword">if</span>(!st[b])&#123;<br>            <span class="hljs-built_in">dfs</span>(b);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.acwing.com/problem/content/description/4965/">景区导游</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//https://www.acwing.com/file_system/file/content/whole/index/content/11514015/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,k,a[N];<br><span class="hljs-type">int</span> h[N],e[<span class="hljs-number">2</span>*N],ne[<span class="hljs-number">2</span>*N],idx;<br><span class="hljs-type">int</span> w[<span class="hljs-number">2</span>*N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> s[N]; <span class="hljs-comment">//前缀和数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> t)</span><span class="hljs-comment">//表示u-&gt;v 距离是t 把v添加到u里去</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u]; i!=<span class="hljs-number">-1</span>; i=ne[i]) &#123;<span class="hljs-comment">//这里要判断一下有没有边重复加</span><br>        <span class="hljs-keyword">if</span>(e[i]==v) <span class="hljs-keyword">return</span>; <br>    &#125;<br>    e[idx]=v;ne[idx]=h[u];h[u]=idx;w[idx]=t;idx++;<span class="hljs-comment">//idx是v的下标 w[idx]表示u-&gt;v的距离</span><br>&#125;<br><span class="hljs-comment">//求u-&gt;v的距离 u起点 v终点 d是起点到当前点的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> d)</span></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//先将起点设置为访问过了</span><br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span> d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])&#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//不能d += w[i] 再dfs(j,v,j,d)</span><br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">dfs</span>(j,v,d+w[i]); <span class="hljs-comment">//更新起点</span><br>            <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ret;<br>            st[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,v;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(a,b,v); <span class="hljs-built_in">add</span>(b,a,v);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> st);<span class="hljs-comment">//每次dfs前都要清空一下st数组</span><br>        s[i] = s[i<span class="hljs-number">-1</span>] + <span class="hljs-built_in">dfs</span>(a[i],a[i+<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>        cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><p>距离从小到大来遍历，取第一次遍历到的结果（每个点只遍历一次）。<br>遍历框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">队列初始化<br><span class="hljs-keyword">while</span>(queue 不空)<br>&#123;<br>    取出队头<br>    拓展队头所有邻点<span class="hljs-function">x</span><br><span class="hljs-function">    <span class="hljs-title">if</span><span class="hljs-params">(x未遍历)</span></span><br><span class="hljs-function">    </span>&#123;<br>        x入队<br>        d[x]=d[队头]+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[n];<br></code></pre></td></tr></table></figure><p>数组模拟队列常见操作 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">300</span> <span class="hljs-comment">//这个地方要设置得大一点才行，因为队列在不断出队入队</span><br>PII q[N];  <span class="hljs-comment">//这个地方要设置得大一点才行，因为队列在不断出队入队</span><br><br><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//入队</span><br>q[++tt] = &#123;&#125; ; q.<span class="hljs-built_in">push</span>()<br><span class="hljs-comment">//取队头</span><br>t = q[hh] ; q.<span class="hljs-built_in">top</span>()<br><span class="hljs-comment">//出队</span><br>hh++ ; q.<span class="hljs-built_in">pop</span>()<br><span class="hljs-comment">//判断是否非空</span><br><span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;&#125; ; q.<span class="hljs-built_in">empty</span>()<br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.acwing.com/problem/content/description/849/">图中点的层次</a><br>每条边长度都为1的最短路问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//要把距离 数组初始为-1</span><br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    <span class="hljs-comment">//队列初始化</span><br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    q[++tt] = <span class="hljs-number">1</span>;<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh];<br>        hh++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">//编号为i的边 的终点</span><br><br>            <span class="hljs-comment">//一旦某个点被访问了就不会再访问了，确保该点的最短距离不会被之前较长路径的距离所覆盖</span><br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">-1</span>)&#123;<br><br>                q[++tt] = j;<br>                <span class="hljs-comment">// pre[j] = t;</span><br>                d[j] = d[t] + <span class="hljs-number">1</span>; <span class="hljs-comment">//此处是d[t] + 1 ,不是d[i] + 1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// int x = n;</span><br>    <span class="hljs-comment">// while(x!=1)&#123;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; x &lt;&lt; &quot;\n&quot;;</span><br>    <span class="hljs-comment">//     x = pre[x];</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><blockquote><p>定义：在有根树上，两点的祖先有公共部分，这些点叫做他们的公共祖先，而其中深度最深的点，叫作它们的最近公共祖先（LCA ，Lowest Common Ancestors）</p></blockquote><p>求树上两个点距离的时候，可以预处理出每个点到根节点的距离，然后两点间最短距离公式为：dist[a-&gt;b] &#x3D; dist[a]+dist[b]-2*dist[p]</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
    <url>/2024/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote><p>元素先进先出，<strong>从队尾入队，从队首出队</strong>。只允许在最后面添加元素，只允许在最前面删除元素。</p></blockquote><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><ol><li>初始化队列<br><code>queue&lt;int&gt; q</code></li><li>返回队首和队尾元素<br><code>q.front()</code> <code>q.back()</code></li><li>尾部增加和删除一个元素<br> <code>q.push()</code> <code>q.pop()</code></li><li>队列长度和是否为空<br><code>q.size()</code> <code>q.empty</code></li></ol><h2 id="队列模拟"><a href="#队列模拟" class="headerlink" title="队列模拟"></a>队列模拟</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> q[N]; <span class="hljs-comment">//队列数组</span><br><span class="hljs-comment">//队列区间为[hh,tt]</span><br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>; tt = <span class="hljs-number">-1</span>; <span class="hljs-comment">//队头和队尾指针</span><br><br>初始时tt = <span class="hljs-number">-1</span>,队列为空，当 ++tt 之后 tt = hh = <span class="hljs-number">0</span>,给q[<span class="hljs-number">0</span>]赋值，hh指向该队头元素<br><br>之后新元素入队，++tt往后移，元素出队，hh++,队头指针往后移。队列区间为[hh,tt]<br><br>q[++tt] = &#123;&#125; <span class="hljs-comment">//入队 </span><br><br>hh ++ <span class="hljs-comment">//出队，队首向后移动一格（本来指向队头元素，）</span><br><br>q[hh] <span class="hljs-comment">//取队头元素</span><br><br><span class="hljs-comment">//是否为空的判断，因为队列区间为[hh,tt],当hh &lt;= tt 时代表队列中有元素为非空</span><br><span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="priority-queue（优先队列）"><a href="#priority-queue（优先队列）" class="headerlink" title="priority_queue（优先队列）"></a>priority_queue（优先队列）</h2><blockquote><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。底层是通过堆（小根堆、大根堆）来实现的。</p></blockquote><ol><li>初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//默认是大根堆，每次取出的元素是队列中的最大值</span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,great&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><br>第一个参数：就是优先队列中存储的数据类型<br>第二个参数：vector&lt;<span class="hljs-type">int</span>&gt; 是用来承载底层数据结构堆的容器，若优先队列中存放的是<span class="hljs-type">double</span>型数据，就要填vector&lt; <span class="hljs-type">double</span> &gt;，总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。<br><br>less&lt;<span class="hljs-type">int</span>&gt; 表示数字大的优先级大，堆顶为最大的数字<br>greater&lt;<span class="hljs-type">int</span>&gt;表示数字小的优先级大，堆顶为最小的数字<br><br>如果存储pair<br>默认先对pair的first进行降序排序，然后再对second降序排序<br></code></pre></td></tr></table></figure><ol start="2"><li>访问队头元素 ： <code>q.top()</code><br>优先队列只能通过top()访问队首元素（优先级最高的元素）</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
      <category>队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dfs(爆搜)</title>
    <link href="/2024/04/03/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-%E7%88%86%E6%90%9C/"/>
    <url>/2024/04/03/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/dfs-%E7%88%86%E6%90%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs-爆搜-和-全排列"><a href="#dfs-爆搜-和-全排列" class="headerlink" title="dfs(爆搜) 和 全排列"></a>dfs(爆搜) 和 全排列</h1><h2 id="dfs递归"><a href="#dfs递归" class="headerlink" title="dfs递归"></a>dfs递归</h2><p><a href="https://www.acwing.com/solution/content/87387/" title="图解">图解</a></p><ol><li>递归就是把一个大问题变成中问题再变成一个很小的问题进行解决</li><li>如果在分解问题时，可能出现一个大问题包括很多个中问题的情况，此时就要在递归外面加上for循环</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> path[N];<br><span class="hljs-type">int</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(u&gt;n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//空位上可以选择的数字为:1 ~ n</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            path[u] = i; <span class="hljs-comment">//此处为u，代表第u个位置需要填</span><br>            st[i] = <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">/*dfs(u+1)展开： </span><br><span class="hljs-comment">            if(u==n)&#123;&#125; </span><br><span class="hljs-comment">            for(int i=1;i&lt;=n;++)&#123;</span><br><span class="hljs-comment">            //由于这里有个状态数组，i=1已经被访问过了，所以会把没访问过的 i=2 填入path数组中（真妙！） </span><br><span class="hljs-comment">        if(!state[i])&#123;</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">dfs(u+1)</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">            */</span><br>            st[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="next-permutation-函数"><a href="#next-permutation-函数" class="headerlink" title="next_permutation() 函数"></a>next_permutation() 函数</h2><blockquote><p>全排列函数 next_permutation(num,num+n) 是对数组num中的前n个元素进行全排列，同时并改变num数组的值。</p></blockquote><ol><li><p>另外，需要强调的是，next_permutation（）在<strong>使用前需要对欲排列数组按升序排序</strong>(此时才能找全)，否则只能找出该序列之后的全排列数</p></li><li><p>next_permutation（node,node+n,cmp）可以对结构体num按照自定义的排序方式cmp进行排序</p></li><li><p>常用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span>&#123;<br><br>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a,a+n));<br><br></code></pre></td></tr></table></figure></li></ol><p><strong>dfs例题：</strong><br><a href="https://www.acwing.com/problem/content/description/4960/" title="飞机降落问题">飞机降落问题</a></p><p>使用全排列函数对所有情况进行枚举，判断在所有的情况下是否能够满足条件。<br>使用方式：</p><ol><li>初始化一个全排列数组 a[n] ，通过a[i] &#x3D; i对其赋值（初始时其为1，2，…,n）</li><li>下面每种情况其循环时的下标应当为 a[i]</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> flag;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> t,d,l;<br>&#125;p[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin &gt;&gt; m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> a[n]; <span class="hljs-comment">//全排列数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i] = i; <span class="hljs-comment">//初始排列数组为 1,2,3</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; p[i].t &gt;&gt; p[i].d &gt;&gt; p[i].l;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-comment">//初始化操作</span><br>          flag = <span class="hljs-literal">true</span>;<br>          <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上一架飞机的降落时间，在此事件后开始降落的飞机都是合法的</span><br>          <br>          <span class="hljs-comment">//循环某个排序</span><br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> j = a[i]; <span class="hljs-comment">//代表此次排列顺序的下标</span><br><br>            start = <span class="hljs-built_in">max</span>(start , p[j].t) ; <span class="hljs-comment">// 和飞机到达时间取max,因为有可能上个飞机已经降落完成但下个飞机还没到</span><br>            <span class="hljs-keyword">if</span>(p[j].t + p[j].d &gt;= start)&#123;<br>              start += p[j].l;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>              flag = <span class="hljs-literal">false</span>;<br>              <span class="hljs-keyword">break</span>;<br>            &#125;<br>          &#125;<br>          <br>          <span class="hljs-keyword">if</span>(flag)&#123;<br>              <span class="hljs-comment">//只要有一组排列满足条件即可判定为yes</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>));<br>             <br>        <span class="hljs-comment">//只有所有排列都不满足条件才判定为no</span><br>        <span class="hljs-keyword">if</span>(!flag) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。<br>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>    [2,4],<br>    [3,4],<br>    [2,3],<br>    [1,2],<br>    [1,3],<br>    [1,4],<br>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startIndex;i&lt;=n;i++)&#123;<br>                path.<span class="hljs-built_in">push_back</span>(i);<br>                <span class="hljs-built_in">dfs</span>(n,k,i+<span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p><strong>和普通组合问题的区别</strong></p><ol><li>组合中的元素个数没有数量要求</li><li>元素可无限重复选取</li></ol><p><strong>startIndex 不需要在 ++</strong><br>原始组合问题：<code>backtracking(candidates, target, sum, i+1);</code><br>本题的递归回溯：<code>backtracking(candidates, target, sum, i);</code></p><p><strong>在求和问题中，排序之后加剪枝是常见的套路！</strong></p><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><p><strong>和组合问题的区别</strong></p><ul><li>每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素了</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2024/04/02/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/04/02/algorithm_know/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="二分算法解析"><a href="#二分算法解析" class="headerlink" title="二分算法解析"></a>二分算法解析</h2><p>二分的判断条件通常是通过列出有关要二分的量和其他变量之间的关系方程：</p><ol><li>暴力解放要循环所有可能的边长值</li><li>通过二分来一步步得缩小查找的区间</li><li>二分的核心就是通过某些性质使得可以缩小查找区间来减少时间复杂度</li></ol><p><strong>二分步骤：</strong></p><ol><li>先写一个check函数(判断条件要具有二段性，并且答案一定是二段性的分界点)</li><li>判定在check的情况下（true和false的情况下），如何更新区间。</li><li>在check(m) &#x3D;&#x3D; true的分支下是:<ul><li>l &#x3D; mid的情况，中间点的更新方式是m &#x3D; (l+r+1)&#x2F;2</li><li>r &#x3D; mid的情况，中间点的更新方式是m &#x3D; (l+r)&#x2F;2</li></ul></li></ol><p>这种方法保证了：</p><ol><li>最后的 l &#x3D;&#x3D; r</li><li>搜索到达的答案是闭区间的，即 a[l] 是满足check()条件的。</li></ol><p><strong>二分模板</strong><br>模板1就是在满足chek()的区间内找到左边界，模板2在满足check()的区间内找到右边界。然后无论是左边界还是右边界，都应该是整个区间中某一段满足某性质（如单调不降）与另一段不满足该性质的分界点</p><p><strong>口诀：左加右减</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//查找左边界 SearchLeft 简写SL</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SL</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid; <br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>; <br>    &#125;   <br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">//查找右边界 SearchRight 简写SR </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SR</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;                   <br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//需要+1 防止死循环</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> r; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><ol><li>浮点数二分不需要判断边界</li><li>题目要求保留6位小数的时候，就要求l和r的差值小于10的负8次方比较保险<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 浮点数二分</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;n);<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-10000</span>,r=<span class="hljs-number">10000</span>;<br>    <span class="hljs-comment">//保留6位小数的时候，就要求l和r的差值小于10的负8次方比较保险</span><br>    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-8</span>)&#123;<br>        <span class="hljs-type">double</span> mid = (l+r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid*mid &gt;= n)&#123;<br>            r = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            l = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="STL中的有关二分的函数"><a href="#STL中的有关二分的函数" class="headerlink" title="STL中的有关二分的函数"></a>STL中的有关二分的函数</h2><p>tip:这些关于二分的stl函数，都<strong>只会查找指定元素后面的值</strong>，所以要在排好序的数组中进行查找</p><ol><li><code>binary_search()</code>函数，作用：对一个<strong>不降序列</strong>进行二分查找，如果所查找的值在序列中出现了，返回true，没有出现，返回false。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-type">bool</span> flag = <span class="hljs-built_in">binary_search</span>(a,a+<span class="hljs-number">5</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//返回的是布尔值</span><br>cout &lt;&lt; flag;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>lower_bound()</code>函数，作用：对一个<strong>不降序列</strong>进行二分查找，返回第一个<strong>大于等于</strong>所查找的值的元素下标，<strong>注意返回的是指针变量！！！</strong> 如果所有元素都小于val，则返回last的位置，且last的位置是越界的</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>upper_bound()</code>函数，作用：对一个不降序列进行二分查找，返回第一个<strong>大于</strong>所查找的值的元素下标，注意返回的是指针变量！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-keyword">auto</span> pos = <span class="hljs-built_in">upper_bound</span>(a,a+<span class="hljs-number">5</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//返回的是指针变量</span><br><span class="hljs-keyword">auto</span> index =  pos-a; <span class="hljs-comment">//对应元素下标(从0开始)</span><br>cout &lt;&lt; index &lt;&lt; endl &lt;&lt; *pos &lt;&lt; endl &lt;&lt; a[index];<br></code></pre></td></tr></table></figure></li><li><p>如果查找第一个小于某个元素的下标，则加上<code>greater&lt;int&gt;()</code></p></li></ol><p><strong>例题：数的范围</strong></p><blockquote><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。<br>如果数组中不存在该元素，则返回 -1 -1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,q;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> k;<br>        cin &gt;&gt; k;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">binary_search</span>(a,a+n,k))&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">lower_bound</span>(a,a+n,k) - a;<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">upper_bound</span>(a,a+n,k) - a;<br>        cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r<span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/2024/04/02/stl/String/"/>
    <url>/2024/04/02/stl/String/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><h2 id="stl函数方法"><a href="#stl函数方法" class="headerlink" title="stl函数方法"></a>stl函数方法</h2><ol><li><p>获取字符串长度<br><code>s.size()</code> 和 <code>s.length()</code></p></li><li><p>插入<br><code>s.push_back()</code> 在末尾插入<br><code>s.insert(pos,&#39;c&#39;)</code> 在指定位置插入<br><code>s.append(str)</code> 在s字符串结尾添加str字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>(),<span class="hljs-string">&#x27;1&#x27;</span>)<br>s.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;abc&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>删除<br><code>erase(iterator first, iterator last)</code><br>删除字符串中迭代器区间[first,last)上所有字符</p><p><code>erase(pos, len)</code><br>删除字符串中从索引位置pos开始的len个字符</p></li><li><p>字符替换<br><code>s.replace(pos,n,str)</code> 把当前字符串从索引pos开始的n个字符替换为str<br><code>s.replace(it1,it2,str)</code> 把当前字符串[it1,it2)区间替换为str it1 ,it2为迭代器哦<br><code>tolower(s[i]) \ toupper(s[i])</code>  转换为小写 \ 大写</p></li><li><p>分割<br><code>s.substr(pos,n)</code> 截取从pos索引开始的n个字符</p></li><li><p>查找</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;<br><span class="hljs-comment">//字符串查找-----找到后返回首字母在字符串中的下标</span><br><span class="hljs-comment">// 1. 查找一个字符串</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">6</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：11</span><br>    <br><span class="hljs-comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 4. 从字符串的末尾开始查找字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&#x27;i&#x27;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符</span><br>    <br><span class="hljs-comment">// 5. 在该字符串中查找第一个属于字符串s的字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;13br98&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：4---b</span><br>    <br><span class="hljs-comment">// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_not_of</span>(<span class="hljs-string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl; <span class="hljs-comment">// 结果是：4</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_not_of</span>(<span class="hljs-string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;  <span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 7. 在该字符串最后中查找第一个属于字符串s的字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&quot;13r98&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：19</span><br><br><span class="hljs-comment">// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&quot;teac&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：21</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符比较"><a href="#字符比较" class="headerlink" title="字符比较"></a>字符比较</h2><p>使用 <strong>单引号</strong> 包括单个字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;s&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符串变字符数组"><a href="#字符串变字符数组" class="headerlink" title="字符串变字符数组"></a>字符串变字符数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">string s = <span class="hljs-string">&quot;xing ma qi&quot;</span>;<br><span class="hljs-type">char</span> s2[] = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure><h2 id="将数字转换成字符串"><a href="#将数字转换成字符串" class="headerlink" title="将数字转换成字符串"></a>将数字转换成字符串</h2><blockquote><p><code>to_string(num)</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">12345678</span>;<br>cout &lt;&lt; <span class="hljs-built_in">to_string</span>(a) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="将字符串变成数字"><a href="#将字符串变成数字" class="headerlink" title="将字符串变成数字"></a>将字符串变成数字</h2><blockquote><p><code>atoi(const char *)</code> 将<strong>字符数组</strong>转换为int类型<br><code>stoi(const string*)</code> 将<strong>字符串</strong>转换为int类型</p></blockquote><p>关于输出数字的范围：<br>atoi不做范围检查，如果超出上界，输出上界，超出下界，输出下界。<br>stoi会做范围检查，默认必须在int范围内，如果超出范围，会出现RE（Runtime Error）错误。</p><h2 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h2><p><a href="https://www.xdull.cn/kmp.html">彻底搞懂 KMP 算法原理</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>字符串操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索</title>
    <link href="/2024/04/02/dp/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2024/04/02/dp/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="记忆化数组"><a href="#记忆化数组" class="headerlink" title="记忆化数组"></a>记忆化数组</h1><blockquote><p>核心思想：设置一个记忆化数组f[N][N]，保存每种情况的（最优）解<br>并且如果这个点 f[i][j] 已经计算过了，直接返回即可，这就是记忆化搜索</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,m,g[N][N]; <span class="hljs-comment">//数组g存储每个点高度</span><br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">//记忆化数组，保存每个(i,j)为起点的最优解</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">//以i，j为起点的滑雪长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个点已经计算过了，直接返回即可，这就是记忆化搜索</span><br>    <span class="hljs-keyword">if</span>(f[i][j] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[i][j]; <br>    f[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">//长度最短至少为1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;<span class="hljs-number">4</span>;a++)&#123;<br>        <span class="hljs-type">int</span> x = i + dx[a]; <span class="hljs-type">int</span> y = j + dy[a];<br>        <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="hljs-number">1</span> &amp;&amp; y&lt;= m &amp;&amp; g[i][j] &gt; g[x][y])&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">dp</span>(x,y)+<span class="hljs-number">1</span>); <span class="hljs-comment">//(i,j) 为当前位置，(x,y)为下一个要访问的位置</span><br>        &#125;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> f[i][j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(f));<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//循环枚举起始位置(i,j)的所有可能，找出最大值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dp</span>(i,j)); <span class="hljs-comment">//dp(x,y)返回以位置(i,j)为起点能延申的最长长度</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>记忆化搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2024/04/02/dp/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2024/04/02/dp/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>树形dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>树形dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector</title>
    <link href="/2024/04/01/stl/vector/"/>
    <url>/2024/04/01/stl/vector/</url>
    
    <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="vector索引"><a href="#vector索引" class="headerlink" title="vector索引"></a>vector索引</h2><p><strong>vector只有在指定长度时,才能用下标索引的方法修改元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = a.<span class="hljs-built_in">begin</span>();p != a.<span class="hljs-built_in">end</span>(); p++)&#123;<br>cout &lt;&lt; *p;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>下标访问</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>cout &lt;&lt; vi[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>迭代器访问</strong><br>迭代器类似指针，迭代器在vector中就是充当指针的作用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it = vi.<span class="hljs-built_in">begin</span>(); it != vi.<span class="hljs-built_in">end</span>();it ++)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>返回首尾部的元素</strong></p><ol><li><code>front()</code> 返回第一个元素</li><li><code>back()</code>  返回最后一个元素</li></ol><h2 id="vector-插入-删除-元素"><a href="#vector-插入-删除-元素" class="headerlink" title="vector 插入&#x2F;删除 元素"></a>vector 插入&#x2F;删除 元素</h2><ol><li>在尾部进行插入&#x2F;删除<ul><li><code>push_back()</code></li><li><code>pop_back()</code></li></ul></li><li>指定位置的插入&#x2F;删除<ul><li><code>insert()</code>  c.insert(it, x) : 向任意迭代器it插入一个元素x ，O(N)</li><li><code>erase()</code>  c.erase(first,last) 删除[first,last)的所有元素，first,last都为迭代器指针 ，O(N)</li></ul></li></ol><h2 id="vector去重"><a href="#vector去重" class="headerlink" title="vector去重"></a>vector去重</h2><ol><li>先进行 sort() 排序，这样重复元素就会堆一起了</li><li>调用 unique() 函数将<strong>相邻且重复</strong> （因此要先排序） 的元素放到vector的尾部 然后返回指向第一个重复元素的迭代器</li><li>再用erase函数擦除从迭代器所指元素到最后元素的所有的元素</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()), vec.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h2 id="vector截取"><a href="#vector截取" class="headerlink" title="vector截取"></a>vector截取</h2><p>void assign(const_iterator first,const_iterator last); &#x2F;&#x2F;两个指针，分别指向开始和结束的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//通过vector的迭代器截取数组</span><br><span class="hljs-keyword">auto</span> first = a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> end = a.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>;<br>a.<span class="hljs-built_in">assign</span>(first,end);<br></code></pre></td></tr></table></figure><h2 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a>第k小数</h2><blockquote><p>寻找序列第k小的值 <code>nth_element(beg, nth, end)</code><br><code>nth_element(a,a+k,a+n)</code>，函数只是把下标为k的元素放在了正确位置<br>求第k大时,我们可以转化成求第n+1-k小，此时下标应该是n - k,所以为 <code>nth_element(a,a+n-k,a+n)</code> 也可以用cmp自定义比较函数，<code>greater&lt;int&gt;()</code></p></blockquote><p>nth为一个迭代器，指向序列中的一个元素。第n小的值恰好在nth位置上</p><p>执行nth_element()之后，序列中的元素会围绕nth进行划分：<strong>nth之前的元素都小于等于它，而之后的元素都大于等于它</strong></p><h2 id="哈希表-vector"><a href="#哈希表-vector" class="headerlink" title="哈希表 + vector"></a>哈希表 + vector</h2><p><img src="/../../img/347.png"></p><ol><li><code>unordered_map&lt;int,int&gt; st;</code> <strong>哈希表统计数据</strong></li><li><code>vector&lt;pair&lt;int,int&gt;&gt; a;</code>   <strong>vector的sort来排序</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">//哈希表统计数据</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; a; <span class="hljs-comment">//vector的sort来排序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            st[nums[i]] ++;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> it = st.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it != st.<span class="hljs-built_in">end</span>()) &#123;<br>            a.<span class="hljs-built_in">push_back</span>(&#123;it-&gt;second,it-&gt;first&#125;);<br>            it ++;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            res.<span class="hljs-built_in">push_back</span>(a[i].second);<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>stl</category>
      
      <category>vector</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>stl</tag>
      
      <tag>vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性dp</title>
    <link href="/2024/04/01/dp/%E7%BA%BF%E6%80%A7dp/"/>
    <url>/2024/04/01/dp/%E7%BA%BF%E6%80%A7dp/</url>
    
    <content type="html"><![CDATA[<h1 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h1><blockquote><p>线性DP，是较常见的一类动态规划问题，其是在线性结构上进行状态转移，这类问题不像背包问题、区间DP等有固定的模板</p><p>线性动态规划的目标函数为特定变量的线性函数，约束是这些变量的线性不等式或等式，目的是求目标函数的最大值或最小值</p></blockquote><h2 id="LCS问题——最长公共子序列"><a href="#LCS问题——最长公共子序列" class="headerlink" title="LCS问题——最长公共子序列"></a>LCS问题——最长公共子序列</h2><blockquote><p><code>子序列</code> : 指的是字符串中<strong>不一定连续</strong>但先后顺序一致的n个字符<br><code>字符子串</code>：指的是字符串中连续的n个字符<br><code>最长公共子序列</code>，英文缩写为LCS（Longest Common Subsequence）。其定义是: 一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。</p></blockquote><blockquote><p>问题描述：给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p></blockquote><p><strong>状态表示</strong></p><ol><li>集合表示：所有 $ A[1,n] $和 $ B[1,m] $ 的公共子序列的集合</li><li><strong>dp[i][j]代表以s1[i]，s2[j]结尾的LCS的长度</strong></li><li>属性：公共子序列长度的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>找集合中所有情况的共同点和不同点来划分集合</li><li>该公共子序列分为四种情况：包括a[n] , b[m] ，不包括a[n] ,包括b[m] ，不包括a[n] , b[m] ，包括a[n] ,不包括b[m] （可以用二进制0 1来表示）</li><li>$ f[i][j] $：A前i个字符，B前j个字符的公共子序列 的集合<br>属性：maxlen</li><li>集合划分情况（假定）<ul><li>(1) $ f[i-1][j-1] + 1 $  同时包括 a[n] 和 b[m] （前提是a[n] &#x3D;&#x3D; a[m]）</li><li>(2) $ f[i-1][j] $  不包括a[n] ,包括b[m]</li><li>(3) $ f[i][j-1] $  包括a[n] ,不包括b[m]</li><li>(4) $ f[i-1][j-1] $ a[n] 和 b[m] 都不包括</li></ul></li><li>集合划分情况（实际）<ul><li>f[i-1][j-1]+1 可以表示情况1    –&gt; a</li><li>f[i][j-1]&#x3D;max(情况2,情况4)    –&gt; b</li><li>f[i-1][j]&#x3D;max(情况3,情况4)    –&gt; c<br>所以我们最终只需要 求 max(a,b,c) 即可</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++">\\最长公共子序列<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-comment">//注意题目中是字符</span><br><span class="hljs-type">char</span> a[N],b[N];  <br><br><span class="hljs-type">int</span> n,m,f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    cin &gt;&gt; b[i];<br>&#125;<br><span class="hljs-comment">//状态计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-1</span>][j]);<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br>    cout &lt;&lt; f[n][m];<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="LIS问题——最长上升子序列"><a href="#LIS问题——最长上升子序列" class="headerlink" title="LIS问题——最长上升子序列"></a>LIS问题——最长上升子序列</h2><blockquote><p><code>最长上升子序列</code>（Longest  Increasing Subsequence），简称LIS，也有些情况求的是最长非降序子序列，二者区别就是序列中是否可以有相等的数，对于固定的数组，虽然LIS序列不一定唯一，但LIS的<strong>长度是唯一的</strong></p></blockquote><ol><li><p>状态设计：$dp[i]$ 代表以 $a[i]$ 结尾的LIS的长度</p></li><li><p>状态转移：$dp[i]&#x3D;max{dp[j]+1，dp[i]} (1&lt;&#x3D;j&lt; i，a[j]&lt;a[i])$</p></li><li><p>边界处理：$dp[i]&#x3D;1(1&lt;&#x3D;i&lt;&#x3D;n)$</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> a[N],n;<br><span class="hljs-type">int</span> f[N]; <span class="hljs-comment">//f[i]: 以 a[i] 为结尾的上升子序列的最大长度</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>        f[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">//用1去初始化dp数组，因为最短的递增子序列的长度为1</span><br>    &#125;<br>    <span class="hljs-comment">//循环整个数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//从前往后循环比那里之前的元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="hljs-built_in">max</span>(f[i],f[j]+<span class="hljs-number">1</span>);<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans,f[i]);<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求最长子序列的路径"><a href="#求最长子序列的路径" class="headerlink" title="求最长子序列的路径"></a>求最长子序列的路径</h3><p>核心思想：使用g数组存储序列中每个元素下标的上一个元素的下标<br><code>g[i] = j;</code> : 最长子序列中下标为 i 的元素 的 上一个元素下标为 j</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,a[N],g[N],f[N]; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        g[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123;<br>                f[i] = <span class="hljs-built_in">max</span>(f[i],f[j]+<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//如果f[i]更新了，则说明最长子序列中 下标为i的元素的上一个元素下标为j</span><br>                <span class="hljs-keyword">if</span>(f[i] == f[j]+<span class="hljs-number">1</span>)&#123;<br>                    g[i] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> k; <span class="hljs-comment">//最长子序列的最后一个元素的下标</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(f[i] &gt; res)&#123;<br>            res = f[i];<br>            k = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//res为最长子序列的长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;res;t++)&#123;<br>        cout &lt;&lt; a[k] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        k = g[k]; <span class="hljs-comment">//g[k]存储着 下标为k的元素 的上一个元素下标</span><br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; res;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p><img src="/../../img/%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><p>题目链接：<a href="https://www.acwing.com/problem/content/description/1224/">密码脱落</a></p><p><img src="/../../img/%E6%98%9F%E7%90%83%E8%84%B1%E8%90%BD.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// f[i][j] 区间[i，j] 之间的最长 回文 子序列 长度</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">状态划分：</span><br><span class="hljs-comment">1. 字符 s[i]和s[j] 都在子序列中</span><br><span class="hljs-comment">2. 字符 s[i]在，s[j]不在</span><br><span class="hljs-comment">3. 字符 s[i]不在，s[j]在</span><br><span class="hljs-comment">4. 字符 s[i]和s[j] 都不在子序列中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">char</span> s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)&#123;<br>        <span class="hljs-comment">//r-l+1 = len</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>; len+l<span class="hljs-number">-1</span> &lt; n; l++)&#123;<br>            <span class="hljs-type">int</span> r = len+l<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>                f[l][r] = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// continue;</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                f[l][r] = <span class="hljs-built_in">max</span>(f[l][r<span class="hljs-number">-1</span>],f[l+<span class="hljs-number">1</span>][r]);<br>                <span class="hljs-keyword">if</span>(s[l] == s[r]) f[l][r] = <span class="hljs-built_in">max</span>(f[l][r],f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; n - f[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>得到具体的回文字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        <span class="hljs-comment">// 初始化二维动态规划表</span><br>        <span class="hljs-type">bool</span> f[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 填充对角线为true，因为单个字符总是回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            f[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最长回文串的起始位置和长度</span><br><br>        <span class="hljs-comment">// 填充动态规划表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; ++len) &#123; <span class="hljs-comment">// 长度从2开始</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + len - <span class="hljs-number">1</span> &lt; n; ++i) &#123; <span class="hljs-comment">// i是子串的起始位置,j是右端点小于n</span><br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>; <span class="hljs-comment">// j是子串的结束位置</span><br>                <span class="hljs-comment">// 如果首尾字符相同，并且中间部分也是回文，则整个序列是回文</span><br>                <span class="hljs-keyword">if</span> (s[i] == s[j] &amp;&amp; (len &lt; <span class="hljs-number">3</span> || f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>                    f[i][j] = <span class="hljs-literal">true</span>;<br>                    maxLen = len;<br>                    start = i;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最长的回文子串</span><br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start, maxLen);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>线性dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间dp</title>
    <link href="/2024/04/01/dp/%E5%8C%BA%E9%97%B4dp/"/>
    <url>/2024/04/01/dp/%E5%8C%BA%E9%97%B4dp/</url>
    
    <content type="html"><![CDATA[<h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><blockquote><p>定义：区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。</p><p>令状态 $f(i,j) $表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 $f(i,j)&#x3D;\max{f(i,k)+f(k+1,j)+cost}$，$cost $为将这两组元素合并起来的价值</p></blockquote><p><strong>性质</strong></p><ol><li><strong>合并：</strong> 即将两个或多个部分进行整合，当然也可以反过来</li><li><strong>特征</strong> 能将问题分解为能两两合并的形式</li><li><strong>求解</strong> 对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值</li></ol><p><strong>解题模板</strong><br>区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len &#x3D; 1 时用来初始化，枚举从 len &#x3D; 2 开始；第二维枚举起点 i （右端点 j 自动获得，j &#x3D; i + len - 1）</p><p>模板代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len++) &#123;         <span class="hljs-comment">// 区间长度</span><br>    <span class="hljs-comment">//终止条件代表右端点要小于n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) &#123; <span class="hljs-comment">// 枚举起点</span><br>        <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 区间终点</span><br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            dp[i][j] = 初始值<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//或者在下方加上else</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) &#123;        <span class="hljs-comment">// 枚举分割点，构造状态转移方程</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + w[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h2><blockquote><p>问题描述：设有 N 堆石子排成一排，其编号为 1,2,3,…,N。每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。<br>每次<strong>只能合并相邻的两堆</strong>，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。<br>找出一种合理的方法，使总的代价最小，输出最小代价</p></blockquote><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示将 [i,j] 这段区间的物品合并在一起的方案集合</li><li>属性：最小代价</li><li>集合划分，最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并，将集合划分成某一堆是由区间 $ [i,i] ，[i,i+1] ，[i,i+2] ，… ， [i,i + j-1] $ 这些情况中之一所合并而成（即所有方案中，最后一次合并时，其中的某一堆一定是由上述某个区间所合并而成，满足不重不漏的原则）</li><li>除了最后一次以外前面每次合并的和即为该次合并所产生的代价，因此最小总代价 &#x3D; $ f(i,k) + f(k+1,j) + s[j] - s[i-1] $</li><li>$ f(i,j) $</li></ol><p><strong>状态计算</strong></p><p>1.<br>2. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> f[N][N],s[N],n,w[N]; <span class="hljs-comment">//dp数组；前缀和数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        s[i] = s[i<span class="hljs-number">-1</span>] + w[i];<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f); <span class="hljs-comment">//由于是求最小值，因此先把dp数组设置成最大值</span><br>    <span class="hljs-comment">// 区间 DP 枚举套路：长度+左端点 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)&#123; <span class="hljs-comment">//len表示[i, j]的元素个数</span><br>        <span class="hljs-comment">// 右端点j小于0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=n;i++)&#123; <br>            <span class="hljs-type">int</span> j = i+len<span class="hljs-number">-1</span>; <span class="hljs-comment">// 自动得到右端点</span><br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>                f[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 边界初始化</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;k++)&#123;<br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i][j],f[i][k] + f[k+<span class="hljs-number">1</span>][j] + s[j] - s[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for(int len=2;len&lt;=n;len++)&#123;</span><br><span class="hljs-comment">        //右端点j小于0</span><br><span class="hljs-comment">        for(int i=1;len+i-1 &lt;= n;i++)&#123;</span><br><span class="hljs-comment">            //j-i+1 = len</span><br><span class="hljs-comment">            int j = len+i-1;</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">            //初始化f[i][j]为一个较大值（题目要求最小代价）</span><br><span class="hljs-comment">            f[i][j] = 1e9;</span><br><span class="hljs-comment">            //枚举合并点</span><br><span class="hljs-comment">            for(int k=i;k&lt;=j-1;k++)&#123;</span><br><span class="hljs-comment">                f[i][j] = min( f[i][j] , f[i][k] + f[k+1][j] + s[j] - s[i-1]);</span><br><span class="hljs-comment">                // cout &lt;&lt; f[i][j] &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;    </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>区间dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>区间dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划（背包问题）</title>
    <link href="/2024/03/30/dp/dp/"/>
    <url>/2024/03/30/dp/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="dp问题分类"><a href="#dp问题分类" class="headerlink" title="dp问题分类"></a>dp问题分类</h1><h2 id="求最值"><a href="#求最值" class="headerlink" title="求最值"></a>求最值</h2><p><strong>求max&#x2F;min值</strong></p><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">最后一块石头的重量 II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;stones.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>        <span class="hljs-keyword">if</span>(j&gt;=stones[i]) f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-stones[i]]+stones[i]);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br><span class="hljs-comment">//要使最后一块石头的重量尽可能地小，f[target] 需要在不超过 ⌊sum/2⌋ 的前提下尽可能地大</span><br><span class="hljs-keyword">return</span> (sum-f[target]) - f[target]; <span class="hljs-comment">// 最后剩下的一块石头的重量</span><br></code></pre></td></tr></table></figure><h2 id="求数目"><a href="#求数目" class="headerlink" title="求数目"></a>求数目</h2><p><strong>累加</strong></p><p><a href="https://leetcode.cn/problems/target-sum/">目标和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//动态规划数组初始化</span><br><br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0</span><br><br><span class="hljs-comment">//dp公式</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = x ; j &gt;= <span class="hljs-number">0</span>; j--)&#123; <span class="hljs-comment">//最小值可以取0，因此此时这里要取0</span><br><br>        <span class="hljs-comment">//凑整f[j]有多少方法呢，也就是把 所有的 f[j - nums[i]] 累加起来</span><br>        <span class="hljs-keyword">if</span>(j &gt;= nums[i]) f[j] += f[j-nums[i]]; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="背包问题的排列数和组合数"><a href="#背包问题的排列数和组合数" class="headerlink" title="背包问题的排列数和组合数"></a>背包问题的排列数和组合数</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/description/">零钱兑换 II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//组合数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=coins[i];j&lt;=amount;j++)&#123;<br>                f[j] += f[j-coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//排列数</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        for(int j=0;j&lt;=amount;j++)&#123;</span><br><span class="hljs-comment">            for(int i=0;i&lt;coins.size();i++)&#123;</span><br><span class="hljs-comment">                if(j&gt;=coins[i]) f[j] += f[j-coins[i]];</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        for(int j=0;j&lt;=amount;j++)&#123;</span><br><span class="hljs-comment">            cout &lt;&lt; f[j] &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">return</span> f[amount];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="dp问题"><a href="#dp问题" class="headerlink" title="dp问题"></a>dp问题</h1><ol><li>要将$f[0][0]$ 等特殊的点进行初始化操作</li><li></li></ol><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><blockquote><p>问题描述：有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i件物品的体积是$ v_i $，价值是$ w_i $ 。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大</p></blockquote><p>针对0-1背包问题，每个物品有选与不选两种选择，则暴力枚举的时间复杂度为 $ O(2^n) $</p><p><strong>状态表示</strong> </p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品只能<strong>选一次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>将状态集合将所有选法划分成第 i 个物品 选 或者 不选 的方案（该划分方式不重不漏）</li><li>第 i 个物品不选时：$ f(i,j) &#x3D; f(i-1,j) $</li><li>第 i 个物品被选择时，为了方便计算，则先假设不选第 i 个物品，则此时 $ f(i,j) &#x3D; f(i-1,j-v[i]) + w[i] $ ,此时前提条件是 $ j &gt; v[i] $</li><li>状态属性是求最大值，则用max函数求出上述情况下的价值最大值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,m,ans;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-comment">//动态计算</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j], d[i<span class="hljs-number">-1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一维优化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> d[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) d[j] = <span class="hljs-built_in">max</span>(d[j], d[j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品能选<strong>无数次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>该集合的所有选法可以划分成第 i 个物品被选了0次,1次, … , n次（不重不漏）</li><li>划分依据:找最后一个不同点；最后一个物品选几个</li><li>$ f(i-1,j) $ 和 $ f(i-1,j-n*v_i) $ 这些方案的最大值</li><li>$ f(i,j) &#x3D; max( f(i-1,j), f(i-1,j-1<em>v[i])+1</em>w[i], f(i-1,j-2<em>v[i])+2</em>w[i], … , f(i-1,j-n<em>v[i])+n</em>w[i] ) $</li><li>$ f(i,j-v) &#x3D; max( f(i-1,j-v), f(i-1,j-2<em>v[i])+1</em>w[i], f(i-1,j-3<em>v[i])+2</em>w[i], … , f(i-1,j-(n+1)<em>v[i])+n</em>w[i] ) $</li><li>$ f(i,v) &#x3D; f(i,j-v) + w $</li></ol><p><strong>未优化版本，会超时</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;(k*v[i])&lt;=j;k++)&#123;<br>                <span class="hljs-keyword">if</span>(j&gt;=k*v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j],d[i][j-k*v[i]]+k*w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; d[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二维优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span>(j&gt;=v[i]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j],d[i][j-v[i]] + w[i]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>一维优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[j] = d[j];<br>        <span class="hljs-keyword">if</span>(j&gt;=v[i]) d[j] = <span class="hljs-built_in">max</span>(d[j],d[j-v[i]] + w[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p><strong>状态表示</strong></p><ol><li>集合：$ f(i,j) $ 表示从前 i 个物品中选择（每个物品能选<strong>有限n次</strong>），总价值不超过 j 的选法集合</li><li>属性：所有选法中物品价值的最大值</li></ol><p><strong>状态计算</strong></p><ol><li>集合的选法包括第i个物品不被选，或者选1个，2个…n个.</li><li>多重背包可以转换成0-1背包</li><li>将s个物品的体积看成一个个单独的物品</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将s个物品看成一个个单独的物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>    <span class="hljs-keyword">while</span>(s--)&#123;<br>        t++; <span class="hljs-comment">//t从1开始</span><br>        v[t] = a;<br>        w[t] = b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拆分后直接套用0-1背包板子</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>        f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二进制优化版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-keyword">while</span>(k&lt;=s)&#123;<br>            t++;<br>            v[t] = k*a;<br>            w[t] = k*b;<br>            s -= k; <span class="hljs-comment">//s代表目前还未分配的，每次要减去已经分配</span><br>            k*=<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果还有没分配的，再进行最后一次分配</span><br>        <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>)&#123;<br>            t++;<br>            v[t] = a*s;<br>            w[t] = b*s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>            f[j] = f[j];<br>            <span class="hljs-keyword">if</span>(v[i] &lt;= j) f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[m]; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><blockquote><p>问题描述：有 N 组物品和一个容量是 V 的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是$ v_{ij} $，价值是$ w_{ij} $，其中$ i $是组号，$ j $ 是组内编号。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p></blockquote><p><strong>状态计算</strong></p><ol><li>体积和价值表示为$ v[i][k] w[i][k] $ $ i $代表物品组，k 代表物品组里的第k个物品<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> d[S][M]; <span class="hljs-comment">//从前s组选，体积不超过m</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; s[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=s[i];j++)&#123;<br>            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>对每个物品组进行循环，将其转换成0-1背包<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        d[i][j] = d[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=s[i];k++)<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i][k]) d[i][j] = <span class="hljs-built_in">max</span>(d[i][j], d[i<span class="hljs-number">-1</span>][j-v[i][k]] + w[i][k]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>背包问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2024/03/29/algorithm_know/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/29/algorithm_know/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><blockquote><p>定义：贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解</p></blockquote><ol><li>类似于二分，将大集合进行划分，得出最优解所在的小集合</li><li>与动态规划的不同: 在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能</li></ol><h2 id="贪心算法步骤"><a href="#贪心算法步骤" class="headerlink" title="贪心算法步骤"></a>贪心算法步骤</h2><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><blockquote><p>给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)</p></blockquote><p><strong>实现手段：</strong><br>通过一个小根堆<code>(priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;)</code>，每次取出队列顶部的两个元素进行合并，同时将这两个元素出队，将合并之后得到的新元素入队<br>直到队列中只剩下一个元素为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">// 优先队列头文件</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// 大根堆 + 大于号 = 小根堆</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        q.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">// 加入节点</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// res: 结果</span><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// 模拟哈夫曼树生成过程</span><br>    &#123;<br>        <span class="hljs-comment">// 挑两个最小的数</span><br>        <span class="hljs-type">int</span> a = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> b = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        res += a + b; <span class="hljs-comment">// 把他们之和加到答案里</span><br>        q.<span class="hljs-built_in">push</span>(a + b); <span class="hljs-comment">// 合并节点</span><br>    &#125;<br><br>    cout &lt;&lt; res;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>math</title>
    <link href="/2024/03/29/algorithm_know/math/"/>
    <url>/2024/03/29/algorithm_know/math/</url>
    
    <content type="html"><![CDATA[<h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><h2 id="约数-因数-个数"><a href="#约数-因数-个数" class="headerlink" title="约数(因数)个数"></a>约数(因数)个数</h2><ol><li>因数总是成对出现的,一个在开根号左边，一个在右边，此时因数个数加二</li><li>特殊情况：有可能刚好等于开根号之后的数字，此时因数个数只加一<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*j&lt;=a[i];j++)&#123;<br>            <span class="hljs-comment">//因数总是成对出现的,一个在开根号左边，一个在右边，此时因数个数加二</span><br>            <span class="hljs-comment">//特殊情况：有可能刚好等于开根号之后的数字，此时因数个数只加一</span><br>            <span class="hljs-keyword">if</span>(a[i] % j == <span class="hljs-number">0</span> &amp;&amp; j*j != a[i]) cnt+=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(a[i] % j == <span class="hljs-number">0</span> &amp;&amp; j*j == a[i]) cnt+=<span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/869/">分解质因数</a></p><p><img src="/../../img/%E8%B4%A8%E5%9B%A0%E6%95%B0.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n,a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-type">int</span> m = x;<br>        <span class="hljs-comment">//循环到平方根</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;i++)&#123;<br>            <span class="hljs-keyword">if</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>                    x /= i;<br>                    cnt++;<br>                &#125;<br>                cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; 1&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>$ gcd(a, b) &#x3D; gcd(b, a mod b) $</p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p><strong>互质数：</strong></p><blockquote><p>两个数的公因数只有1的两个非零自然数,叫做互质数<br>1与任何数都互斥，自身与自身不互斥（公约数包括1和自身）</p></blockquote><p>性质一：两个不同的质数是互质的。<br>性质二：一个质数，另一个不为它的倍数，这两个数为互质数。（较大数是质数的两个数是互质数）<br>性质三：相邻的两个自然数是互质数。<br>性质四：相邻的两个奇数是互质数。<br>性质五：最大公约数是1，两个数互质。</p><p><strong>欧拉函数</strong></p><blockquote><p>定义：对于一个正整数n，n的欧拉函数ϕ(n)表示<strong>小于等于</strong>n中，与n互质的<strong>正整数</strong>的个数</p></blockquote><p>分解质因数：N &#x3D; $ p_1^{a_1} * p_2^{a_2} * …*p_n^{a_n} $</p><p>$ ϕ(N) &#x3D; N(1- \frac{1}{p_1})(1- \frac{1}{p_2})…(1- \frac{1}{p_n}) $</p><p>用代码表示该公式时为了防止出现小数，用以下方式表示：<br>$ ϕ(N) &#x3D; (\frac{N}{p_1})*(p_1 - 1) $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=t/i;i++)&#123;<br>    <span class="hljs-comment">//判断i是不是t的质因子</span><br>    <span class="hljs-keyword">if</span>(t%i == <span class="hljs-number">0</span>)&#123;<br>        res = (res/i)*(i<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span>(t%i == <span class="hljs-number">0</span>)&#123;<br>            t /= i;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//有没除尽的</span><br><span class="hljs-keyword">if</span>(t &gt; <span class="hljs-number">1</span>) res = (res/t)*(t<span class="hljs-number">-1</span>);<br>cout &lt;&lt; res &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>性质1：如果<strong>n是质数</strong>，那么<strong>ϕ(n) &#x3D; n−1</strong>,因为只有n本身与它不互质。</p><p>性质2：如果p，q都是质数，那么$ ϕ ( p ∗ q ) &#x3D; ϕ ( p ) ∗ ϕ ( q ) &#x3D; ( p − 1 ) ∗ ( q − 1 ) $.</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂，二进制取幂，在O(logn)下求$ a^n $的方法</p><blockquote><p>求 $ {a^b} % {p} $ 的值</p></blockquote><p>做这个题前首先我们需要了解一下关于取余的公式<br>(a + b) % p &#x3D; (a % p + b % p) % p<br>(a - b) % p &#x3D; (a % p - b % p ) % p<br>(a * b) % p &#x3D; (a % p * b % p) % p</p><p><strong>$ a^b &#x3D; a^{2^0+2^1+…+2^n(中的某几项)} $</strong><br>ex. $ a^{10} &#x3D; a^{(1010)_2} &#x3D; a^{2^1+2^3} $</p><p><strong>注意下述式子</strong></p><blockquote><p>$ a^{2^3} &#x3D; (a^{2^2})^2 \ a^{2^0} &#x3D; a   $</p></blockquote><p>第二个式子即可解释代码中的  <code>a = a*a % p;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL a,b;<br><span class="hljs-type">int</span> p,n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;p);<br>        LL res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// cout &lt;&lt; b;</span><br>            <span class="hljs-comment">//求数末尾为1还是0</span><br>            <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)&#123;<br>                res = res * a % p;<br>            &#125;<br>            a = a*a % p;<br>            b = b &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//注意这里要把移位后的值赋给b</span><br>        &#125;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p><a href="https://blog.csdn.net/gwk1234567/article/details/106444071">矩阵快速幂算法详细解析</a></p><p><img src="/../../img/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.png"></p><p>矩阵快速幂主要是解决n很大的递推式问题</p><p>ex. f(n)&#x3D;4f(n-1)+3f(n-2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> <br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> m[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>&#125;ans,res;<br><br><span class="hljs-comment">//矩阵A * 矩阵B</span><br><span class="hljs-function">node <span class="hljs-title">mul</span><span class="hljs-params">(node A,node B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,j,k;<br>    node temp;<span class="hljs-comment">//定义一个临时矩阵，存放A*B的结果</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<span class="hljs-comment">//先全部定义为0</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;n; j++)<br>        &#123;<br>            temp.m[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<span class="hljs-comment">//矩阵相乘的代码</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;n; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>; k&lt;n; k++)<br>            &#123;<br>                temp.m[i][j] += (A.m[i][k] * B.m[k][j])%<span class="hljs-number">666666</span>;<span class="hljs-comment">//取模</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-comment">//对个相同矩阵a的乘法</span><br><span class="hljs-function">node <span class="hljs-title">quickpower</span><span class="hljs-params">(node a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    node c;<br>    <span class="hljs-built_in">memset</span>(c.m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c.m));<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)  c.m[i][i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//定义一个单位矩阵</span><br>    <span class="hljs-keyword">while</span>(n)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>)<br>        &#123;<br>            c=<span class="hljs-built_in">mul</span>(c,a);<br>        &#125;<br>        a=<span class="hljs-built_in">mul</span>(a,a);<br>        n=n&gt;&gt;<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-built_in">memset</span>(ans.m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ans.m));<br><br>    <span class="hljs-comment">//这是构建常数矩阵，主要是其参数会随着递推式变化</span><br>    ans.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">4</span>;<br>    ans.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">3</span>;<br>    ans.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    ans.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><br>    n=n<span class="hljs-number">-2</span>;<span class="hljs-comment">//前俩个冒险者减去</span><br>    ans=<span class="hljs-built_in">quickpower</span>(ans,n);<span class="hljs-comment">//求出常数矩阵的n-2次方</span><br><br>    <span class="hljs-built_in">memset</span>(res.m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(res.m));<br><br>    <span class="hljs-comment">//构建f[1] 和 f[2]</span><br>    res.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">233</span>;<br>    res.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">//相乘前：ans是常数矩阵的n-2次幂，mul矩阵是f[n-1] 和 f[n-2]</span><br>    <span class="hljs-comment">//相乘后：res矩阵是f[n] 和 f[n-1];</span><br>    res=<span class="hljs-built_in">mul</span>(ans,res);<span class="hljs-comment">//求出最后的结果矩阵</span><br><br>    <span class="hljs-comment">//此时res.m[0][0] 即是 f[n]</span><br>    k=k-res.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">//减去最后的造成的总伤害</span><br><br>    cout&lt;&lt;k&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数学知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pair</title>
    <link href="/2024/03/29/stl/pair/"/>
    <url>/2024/03/29/stl/pair/</url>
    
    <content type="html"><![CDATA[<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><blockquote><p>pair&lt;int,int&gt; p[N];</p></blockquote><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><blockquote><p>和结构体类似，first代表第一个元素，second代表第二个元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="索引元素"><a href="#索引元素" class="headerlink" title="索引元素"></a>索引元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cout &lt;&lt; p[i].first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p[i].second;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>stl</category>
      
      <category>pair</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>stl</tag>
      
      <tag>pair</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手做操作系统</title>
    <link href="/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA408/OS/"/>
    <url>/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA408/OS/</url>
    
    <content type="html"><![CDATA[<h1 id="动手做操作系统"><a href="#动手做操作系统" class="headerlink" title="动手做操作系统"></a>动手做操作系统</h1><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ol><li>在Windows下编写代码，使用vscode、记事本等编辑器。</li><li>使用Linux的虚拟机编译内核和生成操作软盘映像。（img软盘也可以直接在window11环境下使用bximage.exe生成，但需要在虚拟机里进行格式化）</li><li>必要时使用安装了DOS的虚拟机来调试程序以及操作软盘映像。</li><li>安装一个Bochs,必要的时候用它来调试。</li><li>使用其他必要的工具，比如版本控制工具(VSS或者CVS)。</li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>软盘是从A盘启动的</li></ol><h2 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h2><p>在操作系统中，实模式（Real Mode）和保护模式（Protected Mode）是两种不同的工作模式，特别是在x86架构的计算机上常见。</p><p><strong>实模式：</strong></p><ul><li>实模式是早期IBM PC兼容计算机上的一种工作模式。在实模式下，CPU可以访问1MB范围内的内存。</li><li>内存管理采用分段机制，内存地址由一个16位段地址和一个16位偏移地址组成，共20位地址空间。</li><li>实模式下，没有内存保护机制，任何程序都可以访问系统的所有内存和硬件设备，因此容易导致系统的稳定性问题。<br><strong>保护模式：</strong></li><li>保护模式是后来引入的一种工作模式，提供了更为复杂和强大的内存管理和保护机制。</li><li>在保护模式下，CPU可以访问超过1MB的内存，并且支持虚拟内存和分页机制。</li><li>内存管理采用分段和分页结合的方式，可以实现更灵活的内存保护和隔离，不同程序之间不会相互影响。</li><li>保护模式下，操作系统可以对内存和硬件设备进行更精细的控制和管理，提高了系统的稳定性和安全性。</li></ul><p>总的来说，实模式和保护模式是操作系统在x86架构下的两种不同的工作模式，保护模式相比实模式具有更多的功能和优势，是现代操作系统常用的工作模式。</p><h2 id="全局描述符表（GDT）"><a href="#全局描述符表（GDT）" class="headerlink" title="全局描述符表（GDT）"></a>全局描述符表（GDT）</h2><p>全局描述符表（Global Descriptor Table，GDT）是x86架构下一种用于管理内存的数据结构，它在操作系统中扮演着重要的角色。GDT定义了内存分段的策略，包括内存段的起始地址、段的大小、访问权限等信息。</p><p>在x86架构中，内存被分成多个段（segment），每个段都有自己的起始地址和大小。GDT就是用来管理这些段的数据结构。每个段都由一个描述符（descriptor）来描述，而GDT就是存放这些描述符的表格。描述符包含了段的各种属性，比如基地址、段限长、访问权限等。</p><p>通过GDT，操作系统可以实现对内存的灵活管理和保护。例如，操作系统可以将代码、数据、堆栈等不同类型的信息放在不同的段中，并且对每个段设置不同的访问权限，从而提高系统的安全性和稳定性。此外，GDT还支持虚拟内存和分页机制，可以实现更高效的内存管理和地址转换。</p><p>总的来说，全局描述符表（GDT）是x86架构下一种重要的内存管理数据结构，它定义了内存分段的策略，为操作系统提供了灵活的内存管理和保护机制。</p><h2 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h2><p>(1) 准备GDT </p><p>(2) 用 lgdt 加载 gdtr.<br><code>lgdt [GdtPtr]</code></p><p>(3) 关中断<br><code>cli</code></p><p>(4) 打开 A20地址线.<br><code>inal, 92h </code><br><code>oral, 00000010b</code><br><code>out92h, al</code></p><p>(5)置cr0的PE位（第0位）为1.<br><code>moveax, cr0</code><br><code>oreax, 1</code><br><code>movcr0, eax</code></p><p>(6)跳转，进入保护模式.<br><code>jmpdword SelectorCode32:0</code></p><h2 id="运行一个-com程序的步骤"><a href="#运行一个-com程序的步骤" class="headerlink" title="运行一个.com程序的步骤"></a>运行一个.com程序的步骤</h2><ol><li>使用bximage.exe生成一个软盘</li><li>将软盘插入到xp虚拟机中，进行格式化（选择带ms-dos启动盘的格式化）</li><li>将需要运行的.com程序放入软盘中，之后将软盘取出（防止软盘被占用而出错）</li><li>编辑bochsrc.bxrc，将软盘名称改成自己软盘的名称，将启动盘改成A</li><li>运行<code>C:\Bochs-2.6.9\dos</code> 里的 <code>bchsrc.bxrc</code>即可进入到软盘中，之后在窗口中输入test1.com即可运行</li></ol><h2 id="保护模式下的特点"><a href="#保护模式下的特点" class="headerlink" title="保护模式下的特点"></a>保护模式下的特点</h2><ol><li>地址用 SEG:OFFSET 表示 ; 段值仍然由原来16位的cs、ds 等寄存器表示，但此时它仅仅变成了一个索引，这个索引指向一个数据结构的一个表项，表项中详细定义了段的起始地址、界限、属性等内容。这个数据结构，就是GDT（实际上还可能是LDT，这个以后再介绍)。GDT 中的表项也有一个专门的名字，叫做描述符（Descriptor)。</li><li>也就是说，GDT的作用是用来提供段式存储机制，这种机制是通过段寄存器和GDT中的描述符共同提供的。</li><li>GDT中的每一个描述符定义一个段</li><li>不难理解，当TI和RPL都为零时，选择子就变成了对应描述符相对于GDT 基址的偏移</li></ol><h2 id="建立新段的步骤"><a href="#建立新段的步骤" class="headerlink" title="建立新段的步骤"></a>建立新段的步骤</h2><ol><li>建立一个段</li><li>在段表中建立一个条目写进去</li><li>给定一个选择子（指向段表的索引）</li><li>初始化时，把起始地址填入到Desc</li><li>使用该段</li></ol>]]></content>
    
    
    <categories>
      
      <category>408</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举算法</title>
    <link href="/2024/03/28/algorithm_know/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/28/algorithm_know/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举算法"><a href="#枚举算法" class="headerlink" title="枚举算法"></a>枚举算法</h1><h2 id="结题步骤"><a href="#结题步骤" class="headerlink" title="结题步骤"></a>结题步骤</h2><p>采用枚举算法解题的一般思路如下：</p><ol><li>确定枚举对象、枚举范围和判断条件，并判断条件设立的正确性。</li><li>一一枚举可能的情况，并验证是否是问题的解。</li><li>考虑提高枚举算法的效率。</li></ol><p><strong>提高算法效率方法</strong></p><ol><li>抓住问题状态的本质，尽可能缩小问题状态空间的大小。</li><li>加强约束条件，缩小枚举范围。</li><li>根据某些问题特有的性质，例如对称性等，避免对本质相同的状态重复求解。</li></ol><h2 id="递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。"><a href="#递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。" class="headerlink" title="递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。"></a>递归常见的三类枚举方式是：指数型枚举、排列型枚举、组合型枚举。</h2><h3 id="指数型枚举"><a href="#指数型枚举" class="headerlink" title="指数型枚举"></a>指数型枚举</h3><p>从 1∼n 这 n个整数中随机选取任意多个，输出所有可能的选择方案。<br>由于每个数都存在选与不选两种状态，所以总共会有2^n 种情况<br>选与不选可以使用dfs来递归表示<br>因此递归函数中会用到两个dfs()函数分别表示选与不选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> st[<span class="hljs-number">20</span>]; <span class="hljs-comment">//结果数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">1</span>) <br>                cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    st[u] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>    <br>    st[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排列型枚举"><a href="#排列型枚举" class="headerlink" title="排列型枚举"></a>排列型枚举</h3><p>可以使用stl函数 next_permutation </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//时间复杂度 N!</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> a[N],n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="组合型枚举"><a href="#组合型枚举" class="headerlink" title="组合型枚举"></a>组合型枚举</h3><blockquote><p>从 1∼n 这 n 个整数中随机选出 k 个，输出所有可能的选择方案</p></blockquote><p>可以使用stl函数 <strong>prev_permutation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) a[i]=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span>(a[i]) cout&lt;&lt; i &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">prev_permutation</span>(a+<span class="hljs-number">1</span>, a+<span class="hljs-number">1</span>+n));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>枚举算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>枚举算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将数据集分成训练集和测试集</title>
    <link href="/2024/03/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/data-set-spilt/"/>
    <url>/2024/03/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/data-set-spilt/</url>
    
    <content type="html"><![CDATA[<h1 id="将数据集分成训练集和测试集"><a href="#将数据集分成训练集和测试集" class="headerlink" title="将数据集分成训练集和测试集"></a>将数据集分成训练集和测试集</h1><h2 id="具体代码（带详细注释）"><a href="#具体代码（带详细注释）" class="headerlink" title="具体代码（带详细注释）"></a>具体代码（带详细注释）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">假设数据集文件夹中有三类</span><br><span class="hljs-string">class_indices.json</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;0&quot;: &quot;AD&quot;,</span><br><span class="hljs-string">    &quot;1&quot;: &quot;CN&quot;,</span><br><span class="hljs-string">    &quot;2&quot;: &quot;MCI&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_split_data</span>(<span class="hljs-params">root: <span class="hljs-built_in">str</span>, val_rate: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.2</span></span>):<br>    random.seed(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 保证随机结果可复现</span><br>    <span class="hljs-keyword">assert</span> os.path.exists(root), <span class="hljs-string">&quot;dataset root: &#123;&#125; does not exist.&quot;</span>.<span class="hljs-built_in">format</span>(root)<br><br>    <span class="hljs-comment"># 遍历文件夹，一个文件夹对应一个类别</span><br>    data_class = [cla <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> os.listdir(root) <span class="hljs-keyword">if</span> os.path.isdir(os.path.join(root, cla))]<br>    <span class="hljs-comment"># 排序，保证各平台顺序一致</span><br>    data_class.sort()  <span class="hljs-comment"># [&#x27;AD&#x27;, &#x27;CN&#x27;, &#x27;MCI&#x27;]</span><br>    <span class="hljs-comment"># 生成类别名称以及对应的数字索引</span><br>    class_indices = <span class="hljs-built_in">dict</span>((k, v) <span class="hljs-keyword">for</span> v, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_class))<br>    json_str = json.dumps(<span class="hljs-built_in">dict</span>((val, key) <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> class_indices.items()), indent=<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;class_indices.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> json_file:<br>        json_file.write(json_str)<br><br>    train_images_path = []  <span class="hljs-comment"># 存储训练集的所有图片路径</span><br>    train_images_label = []  <span class="hljs-comment"># 存储训练集图片对应索引信息</span><br>    val_images_path = []  <span class="hljs-comment"># 存储验证集的所有图片路径</span><br>    val_images_label = []  <span class="hljs-comment"># 存储验证集图片对应索引信息</span><br>    every_class_num = []  <span class="hljs-comment"># 存储每个类别的样本总数</span><br>    supported = [<span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-string">&quot;.JPG&quot;</span>, <span class="hljs-string">&quot;.png&quot;</span>, <span class="hljs-string">&quot;.PNG&quot;</span>]  <span class="hljs-comment"># 支持的文件后缀类型</span><br>    <span class="hljs-comment"># 遍历每个文件夹下的文件</span><br>    <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> data_class:<br>        cla_path = os.path.join(root, cla) <span class="hljs-comment"># 类别文件夹的具体路径</span><br>        <span class="hljs-comment"># 遍历获取supported支持的所有文件路径</span><br>        images = [os.path.join(root, cla, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> os.listdir(cla_path)<br>                  <span class="hljs-keyword">if</span> os.path.splitext(i)[-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> supported]<br>        <span class="hljs-comment"># 排序，保证各平台顺序一致</span><br>        images.sort() <span class="hljs-comment"># 该类别文件夹下的所有图片 按名称字典顺序排列</span><br>        <span class="hljs-comment"># 获取该类别对应的索引</span><br>        image_class = class_indices[cla]<br>        <span class="hljs-comment"># 记录该类别的样本数量</span><br>        every_class_num.append(<span class="hljs-built_in">len</span>(images))<br>        <span class="hljs-comment"># 按比例随机采样验证样本</span><br>        val_path = random.sample(images, k=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(images) * val_rate))<br><br>        <span class="hljs-keyword">for</span> img_path <span class="hljs-keyword">in</span> images:<br>            <span class="hljs-keyword">if</span> img_path <span class="hljs-keyword">in</span> val_path:  <span class="hljs-comment"># 如果该路径在采样的验证集样本中则存入验证集</span><br>                val_images_path.append(img_path)<br>                val_images_label.append(image_class)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 否则存入训练集</span><br>                train_images_path.append(img_path)<br>                train_images_label.append(image_class)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images were found in the dataset.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">sum</span>(every_class_num)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for training.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(train_images_path)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for validation.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(val_images_path)))<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(train_images_path) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;number of training images must greater than 0.&quot;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(val_images_path) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;number of validation images must greater than 0.&quot;</span><br><br>    plot_image = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> plot_image:<br>        <span class="hljs-comment"># 绘制每种类别个数柱状图</span><br>        plt.bar(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data_class)), every_class_num, align=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 将横坐标0,1,2,3,4替换为相应的类别名称</span><br>        plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data_class)), data_class)<br>        <span class="hljs-comment"># 在柱状图上添加数值标签</span><br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(every_class_num):<br>            plt.text(x=i, y=v + <span class="hljs-number">5</span>, s=<span class="hljs-built_in">str</span>(v), ha=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 设置x坐标</span><br>        plt.xlabel(<span class="hljs-string">&#x27;image class&#x27;</span>)<br>        <span class="hljs-comment"># 设置y坐标</span><br>        plt.ylabel(<span class="hljs-string">&#x27;number of images&#x27;</span>)<br>        <span class="hljs-comment"># 设置柱状图的标题</span><br>        plt.title(<span class="hljs-string">&#x27;data class distribution&#x27;</span>)<br>        plt.show()<br><br>    <span class="hljs-keyword">return</span> train_images_path, train_images_label, val_images_path, val_images_label<br><br>data_path = <span class="hljs-string">&quot;D:\data_set&quot;</span> <span class="hljs-comment"># 数据集所在（绝对/相对）路径</span><br>train_images_path, train_images_label, val_images_path, val_images_label = read_split_data(data_path)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>数据集处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>数据集处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2024/03/25/algorithm_know/tree-arr/"/>
    <url>/2024/03/25/algorithm_know/tree-arr/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>首要用途：维护序列的前缀和</p><blockquote><p>对一个序列a，建立一个数组c，其中c[x]保存序列a的区间(x-lowbit(x)+1,x]中所有数的和(前开后必)。</p></blockquote><h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>1.每一个节点x，有c[x]保存着以x为根节点的所有叶节点的和</p><p>2.每个内部节点c[x]的子节点个数等于lowbit（x）的位数</p><p>3.除了树根以外的每个子节点的父节点都是c[x+lowbit(x)];</p><p>4.数的深度为log(N)  &#x2F;&#x2F;N为序列a的长度</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>O(logN)的时间复杂度去实现单点修改和区间查询</li><li>数组下标一定要从1开始</li><li>一个数的二进制表示中末尾有几个0就在第几层</li></ol><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><blockquote><p><code>x &amp; (-x)</code> : 假设 x的二进制数表示 的从右向左数的第一个1所在位为k，则lowbit(x) &#x3D; 2^(k-1)</p></blockquote><blockquote><p>tip: 求 n 的二进制表示的第 k 位(从0开始)数字：<code>n &gt;&gt; k &amp; 1</code></p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>实现单点修改</li><li>实现求前缀和</li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造树状数组的方法</span><br><span class="hljs-comment">// 可以假设原序列a为全0，依次通过“单点修改”操作把每个数加进去，最后就可以形成树状数组了</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> t[N],tr[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-comment">//在原数组的第x个数加上v</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-comment">//注意这里的i是从x开始得</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123; <br>        tr[i] += v; <span class="hljs-comment">//在树状数组第i个位置上加上一个值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//返回原数组前x个数的前缀和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x; i&gt;<span class="hljs-number">0</span>; i-=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        sum += tr[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin &gt;&gt; t[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">add</span>(i,t[i]); <span class="hljs-comment">//在第i个位置上加上原数组t[i] 构造树状数组</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x<span class="hljs-number">-1</span>) &lt;&lt; endl; <span class="hljs-comment">//求的是[a,b]的必区间</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">add</span>(x,y);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树状数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法 树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>algorithm_know</title>
    <link href="/2024/03/25/algorithm_know/algorithm-know/"/>
    <url>/2024/03/25/algorithm_know/algorithm-know/</url>
    
    <content type="html"><![CDATA[<h1 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h1><p><a href="https://blog.csdn.net/weixin_49486457/article/details/123439229">算法竞赛常用STL万字总结</a></p><h2 id="降低时间复杂度的方法（降低运行时间防止超时）"><a href="#降低时间复杂度的方法（降低运行时间防止超时）" class="headerlink" title="降低时间复杂度的方法（降低运行时间防止超时）"></a>降低时间复杂度的方法（降低运行时间防止超时）</h2><h3 id="使用平方根去约束数的循环范围"><a href="#使用平方根去约束数的循环范围" class="headerlink" title="使用平方根去约束数的循环范围"></a>使用平方根去约束数的循环范围</h3><blockquote><p>应用场景：完全数，质数</p></blockquote><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h2 id="得到某一段数组-l-r-的和，常规循环计算的复杂度为-O-n-，使用前缀和就可以直接使用-S-r-S-l-1-，复杂度为O-1"><a href="#得到某一段数组-l-r-的和，常规循环计算的复杂度为-O-n-，使用前缀和就可以直接使用-S-r-S-l-1-，复杂度为O-1" class="headerlink" title="得到某一段数组 [l,r] 的和，常规循环计算的复杂度为 O(n) ，使用前缀和就可以直接使用 S(r) - S(l-1) ，复杂度为O(1)"></a>得到某一段数组 [l,r] 的和，常规循环计算的复杂度为 O(n) ，使用前缀和就可以直接使用 S(r) - S(l-1) ，复杂度为O(1)</h2><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ol><li>O(log)的时间复杂度去实现单点修改和区间查询</li><li>数组下标一定要从1开始</li><li>一个数的二进制表示中末尾有几个0就在第几层</li></ol><h1 id="2-17"><a href="#2-17" class="headerlink" title="2.17"></a>2.17</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote><p>求 n 的二进制表示的第 k+1 位（计数从1开始）数字：<code>n &gt;&gt; k &amp; 1</code><br><code>n &amp; 1</code> 判断第1位的数字</p></blockquote><p><a href="https://www.acwing.com/problem/content/description/803/">二进制中1的个数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(a[i])&#123;<br>        <span class="hljs-keyword">if</span>((a[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) res++;<br>        a[i] = a[i] &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>返回 n 的最后一位1所对应的值：lowbit(n) &#x3D; n &amp; -n &#x3D; n &amp; (n^(n-1))<br>假设一个数的二进制最低位的1在从右往左数的第k位，那么它的lowbit值就是2^(k-1)<br>树状数组C[x] &#x3D; [x-lowbit(n) , x] 原数组中这段区间的和</p></blockquote><h1 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h1><h2 id="n次方幂"><a href="#n次方幂" class="headerlink" title="n次方幂"></a>n次方幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//负数要先转换成正数去计算n次方根</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-literal">true</span>; <br>        n = -n;<br>    &#125;<br>    <span class="hljs-type">double</span> res = <span class="hljs-built_in">pow</span>(n,(<span class="hljs-type">double</span>)<span class="hljs-number">1</span>/<span class="hljs-number">3</span>); <span class="hljs-comment">//使用求n次幂函数，来求n次方根</span><br></code></pre></td></tr></table></figure><h1 id="3-26"><a href="#3-26" class="headerlink" title="3.26"></a>3.26</h1><h1 id="线段数组"><a href="#线段数组" class="headerlink" title="线段数组"></a>线段数组</h1><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>线段树是一棵平衡二叉树。母结点代表整个区间的和，越往下区间越小</li><li>每个节点p的左右子节点的编号分别为 2p 和 2p+1</li><li>节点p存储区间[l,r]的和，设 mid &#x3D; floor(l+r&#x2F;2) ; 左节点存储[l,mid]的和， 左节点存储[mid+1,r]的和</li></ol><h2 id="建立线段数组"><a href="#建立线段数组" class="headerlink" title="建立线段数组"></a>建立线段数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> sum;<br>&#125;tr[N*<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">//u位节点编号，l和r为区间左右端点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> tr[u] = &#123;l,r,w[l]&#125;; <span class="hljs-comment">//抵达叶子节点，为其赋值</span><br>    <span class="hljs-type">int</span> mid = (l+r) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//向下取整</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u, l, mid); <span class="hljs-comment">//向左子树递归</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//向右子树递归</span><br>    tr[u].sum = tr[<span class="hljs-number">2</span>*u].sum + tr[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].sum <span class="hljs-comment">//递归完左右子树后向上回溯</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><blockquote><p>把区间内的叶子节点相加</p></blockquote><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><blockquote></blockquote><h1 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a>第k小数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> t, n, k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br><span class="hljs-keyword">while</span> (t--) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        list[i] = <span class="hljs-built_in">read</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 将第k小的数放在 k-1 位置，左边的数都比它小，右边的数都比它大，但都是无序的</span><br>    <span class="hljs-built_in">nth_element</span>(list, list + k - <span class="hljs-number">1</span>, list + n);<br>    <span class="hljs-comment">// 由于数据量太大，下面两种方法会超时</span><br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-comment">// sort(list, list + n);</span><br>    <span class="hljs-comment">// 将第k小的数放在 k-1 位置，左边的数都比它小，而且是有序的，右边的数都比它大，但右边是无序的</span><br>    <span class="hljs-comment">// partial_sort(list, list + k - 1, list + n);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, list[k - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>首先，binary_search()函数，作用：对一个不降序列进行二分查找，如果所查找的值在序列中出现了，返回true，没有出现，返回false。</p><p>然后，lower_bound()函数，作用：对一个不降序列进行二分查找，返回第一个大于等于所查找的值的元素下标，注意返回的是指针变量！！！</p><p>最后，upper_bound()函数，作用：对一个不降序列进行二分查找，返回第一个大于所查找的值的元素下标，注意返回的是指针变量！！！</p><h1 id="无穷大和无穷小"><a href="#无穷大和无穷小" class="headerlink" title="无穷大和无穷小"></a>无穷大和无穷小</h1><p>指定一个数为无穷大或无穷小：INT_MIX INT_MAX<br>要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))<br>要把一段内存全部置为无穷小，我们只需要memset(a,0xc0,sizeof(a))</p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map[key] &#x3D; value</p><h2 id="查找map中某个key是否存在-具体位置"><a href="#查找map中某个key是否存在-具体位置" class="headerlink" title="查找map中某个key是否存在&#x2F;具体位置"></a>查找map中某个key是否存在&#x2F;具体位置</h2><blockquote><p>mp.count(key)<br>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0<br>mp.find(key)<br>返回键为key的映射的迭代器 $O(logN) $ 注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()</p></blockquote><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set里面的元素<strong>不重复</strong> 且 <strong>有序</strong></p><h1 id="如何将字符串转换成数字"><a href="#如何将字符串转换成数字" class="headerlink" title="如何将字符串转换成数字"></a>如何将字符串转换成数字</h1><p>String str&#x3D;“2019”;<br>char s[]&#x3D;str.toCharArray();<br>int x&#x3D;0;<br>for(int i&#x3D;0;i&lt;s.length;i++){<br>x&#x3D;x*10+str[i]-‘0’;<br>}</p><h1 id="结构体数组排序"><a href="#结构体数组排序" class="headerlink" title="结构体数组排序"></a>结构体数组排序</h1><p><strong>当数组是从1开始赋值时，sort函数也要加1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin &gt;&gt; a[i].t &gt;&gt; a[i].d &gt;&gt; a[i].l;<br>&#125;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp); <span class="hljs-comment">//由于数组是从1开始赋值的，因此排序函数也要加1 </span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">11</span>];<br>    <span class="hljs-type">int</span> solve;<br>    <span class="hljs-type">int</span> time;<br>&#125;p[<span class="hljs-number">10000</span>];<br><br><span class="hljs-comment">//按照题数，再罚时间，再名字（名字按字典序排列）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; a, <span class="hljs-type">const</span> Student&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.solve != b.solve)<br>     &#123; <br>        <span class="hljs-keyword">if</span> (a.solve &gt; b.solve)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.time != b.time)<br>           <span class="hljs-keyword">return</span> a.time &lt; b.time;<br>    <span class="hljs-keyword">else</span><br>          <span class="hljs-built_in">return</span> (<span class="hljs-built_in">strcmp</span>(a.name, b.name) &lt; <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>      cin&gt;&gt;p[i].name&gt;&gt;p[i].solve&gt;&gt;p[i].time;<br>    <span class="hljs-built_in">sort</span>(p,p+n,cmp);<span class="hljs-comment">//在主函数中调用，结构体排序；</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>      cout&lt;&lt;p[i].name;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="max-element-min-element"><a href="#max-element-min-element" class="headerlink" title="max_element+min_element"></a>max_element+min_element</h2><blockquote><p>返回最大最小值的下标所对应的地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数都是返回地址，需要加*取值</span><br><span class="hljs-type">int</span> indx = <span class="hljs-built_in">max_element</span>(a, a + n) - a;<br><span class="hljs-type">int</span> mx = *<span class="hljs-built_in">max_element</span>(a, a + n);<br><span class="hljs-type">int</span> mn = *<span class="hljs-built_in">min_element</span>(a, a + n);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法小知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>算法小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第三章</title>
    <link href="/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-3/"/>
    <url>/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-3/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第三章"><a href="#计算机网络复习第三章" class="headerlink" title="计算机网络复习第三章"></a>计算机网络复习第三章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>数据链路层的功能是：实现在两个通信实体之间传送数据（以 帧为单位），并通过差错控制方法，使有差错的物理线路变成无差错数据链路。数据链路层使用的信道有2种：广播信道和点对点信道。 数据链路层需要解决的三个基本问题是：封装成帧. 透明传输（如在数据中出现控制字符时加入转义字符）和差错检测（如CRC技术）。</p></li><li><p>10Mbps以太网是基带编码，使用的曼彻斯特编码，是一种自同步的数字信号编码方式，编码效率是50%；通常采用RJ45（非屏蔽双绞线）。</p></li><li><p>虚拟局域网（VLAN）技术是建立在网络交换机之上的，以硬件方式实现逻辑工作组的划分与管理，通常可以根据端口. MAC地址. IP地址等划分VLAN。同一层交换机上不同VLAN之间不能直接通信（需要使用路由器才能通信）</p></li><li><p>网络互联时使用中继器或集线器完成物理层功能，使用网桥或二层交换机完成数据链路层的功能，使用路由器或三层交换机完成网络层的功能。</p></li><li><p>常用的IEEE802协议有802.2—LLC   802.3—10Mbps CSMA&#x2F;CD以太网  802.4—令牌总线 802.5—令牌环，这些协议都属于数据链路层。以太网使用10BASE-T规定从集线器到网卡的最大距离是100米。</p></li><li><p>总线型网络和使用HUB的星型网络，任意时刻只能有一台电脑发送信息；使用SWITCH的星型网络，任意时刻可以有多台电脑发送信息。</p></li><li><p>CSMA&#x2F;CD的中文是多路载波侦听&#x2F;冲突检测，掌握其工作原理并重点掌握：用于在10Mbps以标准太网的信道访问控制，要求数据帧的发送时间是传播时间的2倍，其帧长为64–1518B，其碰撞窗口为51.2us ，总线型以太网可以检测冲突却不能避免冲突，交换型以太网可以避免冲突。发生第K次冲突后，需要等待r*51.2us之后再侦听以决定是否发送，其中r&#x3D;Min（10，x）(x取(0,1,2,3,…2k-1)中任意随机值),最多传送16次。 </p></li><li><p>通常数据在各个层次的名称不同，一般物理层称为比特. 数据链路层称为帧. 网络层称为分组. 传输层称为报文. 余下各层统称为文本。OSI&#x2F;RM协议的层次名称. 上下层次关系，TCP&#x2F;IP协议的层次名称. 上下层关系，以及OSI&#x2F;RM各层次与TCP&#x2F;IP各层次对应关系。VLAN(虚拟局域网)使用的核心设备是二层交换机。</p></li><li><p>教材图3-10的PPP格式（P75）。教材图3-22的以太网格式（P92）</p></li><li><p>CRC计算（教材 图3-8）（P71）</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>数据链路层需要解决的三个基本问题是：封装成帧. 透明传输和差错检测，其中在数据中出现控制字符时加入转义字符属于(   )。<br>2. 完善以太网的MAC帧格式 。</p><ol start="3"><li>以太网中采用的CSMA&#x2F;CD协议是一种能避免冲突的协议。</li><li>在一个二层交换机内划分为3个虚拟网络后，虚拟网络之间不可在本交换机内通信。</li><li>在802.3局域网中，当使用了交换技术后，可避免冲突产生。</li><li>10M以太网的碰撞窗口为51.2us  </li><li>10M以太网的标准是IEEE802.5 。</li><li>10BASE-T标准中使用的电缆为双绞线</li><li>802.3协议中源地址为（）。<br>A. 1字节  B. 4字节    C. 6字节   D. 8字节</li><li>符合OSI参考模型第二层功能的设备，均有一个MAC地址，以太网MAC地址是（）位二进制。<br>A.    64     B. 48     C. 32    D. 8<br>11.交换机是对应OSI参考模型（）的设备。<br>A. 物理层    B. 传输层    C. 网络层  D. 数据链路层<br>12目前局域网中的高端交换机使用双绞线时能适应10M&#x2F;S，100M&#x2F;S，1000M&#x2F;S的速率，依靠（  ）技术。<br>A. 线路交换    B. 令牌控制<br>C. 自动侦测    D. VLAN技术</li><li>以太网交换机不具有的功能是（）。<br>A. 地址学习    B. 数据帧转发<br>C. 路由选择    D. 回路避免</li><li>以下MAC地址哪个是正确的（）<br>A. 004         B.  00DA45<br>C. 210.47.2.34   D. 00AABB0034CC</li><li>虚拟局域网中的核心设备是（）<br>A. 高端交换机   B. 路由器<br>C. 集线器       D. 中继器</li><li>虚拟局域网的技术基础是（）。<br>A. 交换    B. 路由    C.  带宽分配    D. 冲突检测</li><li>在一个数字化的语音系统中，采用256个量化级时，编码时采用（）位。<br>A. 8           B. 7          C. 6        D. 10</li><li>具有冲突检测载波监听多路访问CSMA&#x2F;CD技术，不适用于（）。<br>A. 总线型网络    B. 星型网络<br>C. 树型网络      D. 环型网络</li><li>IEEE802.3标准中，MAC帧的帖起始定界符是（）。<br>A.  01111111（左低右高）  B. 11101011（左低右高）<br>C.  01111110（左低右高）  D. 10101011（左低右高）</li><li>CSMA&#x2F;CD协议只适用于（）。<br>A. 局域网  B. 广域网    C. 城域网    D. 以上全部</li><li>IEEE802.3中10BASE-T规定从集线器到网卡的最大距离是（）。<br>A. 50米     B. 100米      C. 200米     D. 500米</li><li>数据链路层需要解决的三个基本问题是：封装成帧. 透明传输和差错检测，其中CRC技术属于（  ）。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>透明传输</li><li>类型</li><li>T</li><li>T</li><li>T</li><li>T</li><li>F</li><li>T</li><li>C</li><li>B</li><li>D</li><li>C</li><li>C</li><li>D</li><li>A</li><li>A</li><li>A</li><li>C</li><li>D</li><li>A</li><li>B</li><li>差错检测</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第二章</title>
    <link href="/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-2/"/>
    <url>/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-2/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第二章"><a href="#计算机网络复习第二章" class="headerlink" title="计算机网络复习第二章"></a>计算机网络复习第二章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>物理层确定与传输媒体的接口有关的特性是机械特性.电气特性.功能特性和过程特性。</p></li><li><p>根据信号中代表消息的参数的取值方式不同，信号可以分为2大类，模拟信号和数字信号。从通信的双方信息的交互方式来区分，可以有三种基本方式：单工通信（只能有一个方向的通信而没有反方向的交互）.半双工通信（通信的双方都可以发送信息，但不能双方同时发送）和全双工通信（通信的双方都可以发送信息，而且双方能同时发送）。</p></li><li><p>复用方式有：频分复用（FDM）.时分复用(TDM).码分复用(CDM)和波分复用(WDM)多种，在一根光纤上复用多路光载波信号称为波分复用，利用信号频率的不同来实现电路复用的方法是频分复用，利用信号的不同时间发送来实现电路复用的方法是时分复用。</p></li><li><p>10Mbps以太网是基带编码，使用的曼彻斯特编码，是一种自同步的数字信号编码方式，编码效率是50%；通常采用RJ45（非屏蔽双绞线）。</p></li><li><p>在脉码调制PCM过程中要经过采样.量化.编码三个过程。T1和E1技术都是基本的将模拟信号转为数字信号的方法，目前我国使用的是欧洲的E1标准，E1速率是2.048Mbps，T1的速率是1.544Mbps，这两种方法都使用时分复用。</p></li><li><p>传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。一个数据通信系统包括三大部分：源系统（或发送端.发送方）.传输系统（或传输网络）和目的系统（或接收端.接收方）。</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>通常一个通信系统可以划分为三大部分，即源系统（或发送端.发送方）.(   )和目的系统（或接收方.接收端）。</p></li><li><p>从通信的双方信息的交互方式来区分，可以有三种基本方式：单工通信.半双工通信和(   )。</p></li><li><p>传输媒体是数据传输系统中在发送器和接收器之间的物理通道，可以分为导向传输媒体和非导向传输媒体。无线电波属于(   )。</p></li><li><p>多个通信设备共享一个信道进行通信称为信道复用，不同的用户占用不同的带宽资源称为(   )。</p></li><li><p>在PCM调制过程中要经过量化.采样.编码三个过程。</p></li><li><p>在数据传输过程中，差错主要是由通信过程中的噪声引起的。</p></li><li><p>ADSL技术中，上行通道和下行通道的传输速率不对称。</p></li><li><p>在电路交换.分组交换与报文交换方式中，都要经过线路建立.数据传输.线路释放这3个过程。</p></li><li><p>两台计算机通过电话网通信时必须使用的设备是（）。<br>A. 调制解调器  B.网线.C.中继器    D.集线器</p></li><li><p>常用的传输介质中，带宽最大.信号传输衰减最小.抗干扰能力最强的是（）。<br>A.光纤    B.双绞线     C.同轴电缆     D.无线信道</p></li><li><p>利用信号频率的不同来实现电路复用的方法是（）。<br>A.频分多路复用   B.时分多路复用<br>C.码分多路复用   D.以上都不对</p></li><li><p>在物理层中，指明在接口电缆的各条线上出现的电压范围，属于（）。<br>A.机械特性   B.电气特性  C.功能特性   D.过程特性</p></li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>传输系统</li><li>全双工通信</li><li>非导向传输媒体</li><li>频分复用</li><li>F</li><li>T</li><li>T</li><li>F</li><li>A</li><li>A</li><li>A</li><li>B</li></ol>]]></content>
    
    
    <categories>
      
      <category>期末复习</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>期末复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习第一章</title>
    <link href="/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-1/"/>
    <url>/2024/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA408/cs-net-1/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习第一章"><a href="#计算机网络复习第一章" class="headerlink" title="计算机网络复习第一章"></a>计算机网络复习第一章</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>为网络中的数据交换而建立的规则.标准或约定称为网络协议，网络协议由三部分组成：语法（数据与控制信息的结构或格式）.语义（需要发出何种控制信息，完成何种动作以及做出何种响应）.同步（事件实现顺序的详细说明）。</p></li><li><p>Arpanet是Internet的前身，对因特网发展起到很大作用。Internet是通过路由器将多个LAN或WAN相连接形成。</p></li><li><p>计算机网络向用户提供的最重要的功能有2个：连通性和共享</p></li><li><p>所有因特网标准都是以RFC形式在因特网上发表。RFC的意思是“请求评论”</p></li><li><p>因特网从其工作方式上看，可以划分为2大块：边缘部分（由连接在因特网上的主机组成，这部分是用户直接使用的，用来进行通信和资源共享）和核心部分（由大量网络和连接这些网络的路由器组成，这部分为边缘部分提供服务，提供连通性和交换）</p></li><li><p>三网合一是指电信语音 .有线电视网和计算机网络的结合。</p></li><li><p>常用的交换方式有电路.报文和分组。在电路交换方式中要经过线路建立.数据传输.线路释放三个过程。而分组交换和报文交换不需要，因为每个分组都需要被独立进行确定“路由”处理，所以可能存在“后发先至”的现象。计算机网络通常采用分组交换方式。</p></li><li><p>网络通信常用的3种交换方式是电路交换（整个报文的比特流连续地从源点直达终点，好像在一个管道中传送）.报文交换（整个报文先送到相邻节点，全部存储下来后查找转发表，转发到下一节点）和分组交换（单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一节点）。计算机网络采用的交换方式属于分组交换。</p></li><li><p>时延是计算机网络的性能指标之一，指的是数据从网络的一端传输到另一端所需的时间，通常包括发送时延（主机或路由器发送数据帧所需要的时间，也称为传输时延。发送时延&#x3D;数据帧长度&#x2F;发送速率）.传播时延（电磁波在信道中传播一定的距离所需要的时间，在自由空间的传播速率约为3.0<em>105km&#x2F;s，在铜线电缆中的传播速率约为2.3</em>105km&#x2F;s, 在光纤中的传播速率约为2.0*105km&#x2F;s。传播时延&#x3D;信道长度&#x2F;电磁波在信道上传输速率）.处理时延（主机或路由器在收到分组是需要花费一定的时间进行处理）和排队时延（分组在进入路由器后在输入队列中等待处理）。</p></li><li><p>OSI的体系结构由7层组成，从上到下分别是：应用层.表示层.会话层.运输层.网络层.数据链路层.物理层。TCP&#x2F;IP协议由4层组成，从上向下分别为应用层.运输层.网际层（IP）和网络接口层。掌握OSI&#x2F;RM协议的各层次名称.顺序及与TCP&#x2F;IP协议的对应关系。教材图1-18</p></li><li><p>按距离进行分类，可将网络分为广域网.城域网和局域网，掌握其距离范围</p></li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>假定有一个10MB的数据块，在带宽为1Mb&#x2F;s的信道上连续发送，其发送时延是_____s。</li><li>因特网从其工作方式上看，可以划分为2大块：用来进行通信和资源共享属于边缘部分。提供连通性和交换的属于(   )。</li><li>网络通信有3种交换方式。其中【单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一节点】属于(   )（请说明名称，不能说第一种、第二种或第三种）。</li><li>时延是计算机网络的性能指标之一，指的是数据从网络的一端传输到另一端所需的时间。其中的传播时延是指电磁波在信道中传播一定的距离所需要的时间，通常在铜线电缆中其传播速率约为(   )km&#x2F;s。</li><li>所有因特网标准都是以(   )形式在因特网上发表。其意思是“请求评论”。</li><li>网络协议由三部分组成：语法、语义和同步，其中需要发出何种控制信息，完成何种动作以及做出何种响应属于(   )。</li><li>OSI的体系结构由7层组成，从下向上，第六层是(   )。</li><li>TCP&#x2F;IP协议由4层组成，从上向下，UDP是属于(   )。</li><li>电磁波在光纤中传播的速率大约为2.0*105km&#x2F;s,长度为1000km的光纤传播时延是（    ）s。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>83.89</li><li>核心部分</li><li>分组交换</li><li>2.3*105km&#x2F;s</li><li>RFC</li><li>语义</li><li>表示层</li><li>运输层</li><li>0.005</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first-test-blog</title>
    <link href="/2024/03/25/first-test-blog/"/>
    <url>/2024/03/25/first-test-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一个测试博客"><a href="#这是一个测试博客" class="headerlink" title="这是一个测试博客"></a>这是一个测试博客</h1><h1 id="浅浅许个愿：保研上岸"><a href="#浅浅许个愿：保研上岸" class="headerlink" title="浅浅许个愿：保研上岸"></a>浅浅许个愿：保研上岸</h1>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>保研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>保研</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
